

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.jpg">
  <link rel="icon" href="/img/fluid.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ysc">
  <meta name="keywords" content="">
  
    <meta name="description" content="总结Cmake的使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Cmake总结">
<meta property="og:url" content="https://ysc2.github.io/ysc2.github.io/2023/12/06/Cmake%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Ysc Web">
<meta property="og:description" content="总结Cmake的使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/pexels-tommaso-zanini-19342832.jpg">
<meta property="article:published_time" content="2023-12-06T07:47:32.000Z">
<meta property="article:modified_time" content="2024-05-08T12:49:20.913Z">
<meta property="article:author" content="Ysc">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/pexels-tommaso-zanini-19342832.jpg">
  
  
  
  <title>Cmake总结 - Ysc Web</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ysc2.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"c"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ysc博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/pexels-tommaso-zanini-19342832.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Cmake总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-06 15:47" pubdate>
          2023年12月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          137 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Cmake总结</h1>
            
            
              <div class="markdown-body">
                
                <p>总结Cmake的使用</p>
<span id="more"></span>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前我学习了，Linux中autotools工具链的使用，但是在学习的过程中我发现还有比autotools更加方便，更加好用的制作Makefile文件的工具——Cmake</p>
<h1 id="Autotools和Cmake的对比"><a href="#Autotools和Cmake的对比" class="headerlink" title="Autotools和Cmake的对比"></a>Autotools和Cmake的对比</h1><p>首先我们已经知道了Autotools工具链的使用非常繁琐：<br><img src="https://picgo-ysc.oss-cn-shenzhen.aliyuncs.com/web/202312061558984.png" srcset="/img/loading.gif" lazyload></p>
<p>而Cmake的使用只需要编写<code>Cmake.txt</code>文件，将自己的需求告诉Cmake就可以了。其实Cmake就是一种语言，我们通过Cmake的语法编写<code>Cmake.txt</code>文件内容。</p>
<h1 id="安装Cmake"><a href="#安装Cmake" class="headerlink" title="安装Cmake"></a>安装Cmake</h1><div class="note note-warning">
            <p>注意：由于Cmake是一个版本控制工具，所以我们使用的Cmake最好比我们使用的编译器的版本的发行时间要晚，所以我们尽量使用新版本的Cmake。</p>
          </div>


<h1 id="常用的函数以及操作"><a href="#常用的函数以及操作" class="headerlink" title="常用的函数以及操作"></a>常用的函数以及操作</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs Cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 指定运行此配置文件所需的 CMake 的最低版本。</span><br><br><span class="hljs-keyword">project</span>(Hello VERSION <span class="hljs-number">1.0</span>)<br><span class="hljs-comment"># 设置项目的属性，包括（名称、版本等待）。同时会自动生成PROJECT_NAME 变量，使用 $&#123;PROJECT_NAME&#125; 即可访问到 hello_cmake。</span><br><br><span class="hljs-keyword">add_executable</span>(Hello hello.c)<br><span class="hljs-comment"># 第一个参数是可执行文件名，第二个参数是要编译的源文件列表。这里将hello.c文件编译成hello可执行文件，在有源函数的文件夹中的CMakeTlists中使用。</span><br><br><span class="hljs-keyword">install</span>(TARGETS Hello)<br><span class="hljs-comment"># 指定安装的目标</span><br><br><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<br><span class="hljs-comment"># 查询当前目录下的所有源文件，将其存储在DIR_SRCE变量下</span><br><br><span class="hljs-keyword">ADD_LIBRARY</span>(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br><span class="hljs-comment"># add_library：用于从某些源文件创建一个库，默认生成在构建文件夹。第一个参数为库名（不需要 lib 前缀，会自动添加），第二个参数用于指定 SHARED（动态库），STATIC（静态库）（如果不写，则通过全局BUILD_SHARED_LIBS 的 FALSE 或 TRUE 来指定）。第三个参数即为源文件列表。</span><br><br><span class="hljs-comment">#类型有三种:</span><br><span class="hljs-comment">#SHARED，动态库</span><br><span class="hljs-comment">#STATIC，静态库</span><br><span class="hljs-comment">#MODULE，在使用 dyld 的系统有效，如果不支持 dyld，则被当作 SHARED 对待。</span><br><br><span class="hljs-comment"># EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。</span><br><br><span class="hljs-keyword">target_link_libraries</span>(Demo MathFunctions)<br><span class="hljs-comment"># target_link_libraries：该命令用于指明可执行文件 Demo 需要链接 MathFunctions 库。第一个参数为可执行文件名，第二个参数为访问权限（PUBLIC、PRIVATE、INTERFACE，默认为 PUBLIC），第三个参数为库名（这两个参数可以为多个）。</span><br><br><span class="hljs-keyword">MESSAGE</span>([SEND_ERROR | STATUS | FATAL_ERROR] <span class="hljs-string">&quot;message to display&quot;</span><br>...)<br><span class="hljs-comment"># 这个指令用于向终端输出用户定义的信息，包含了三种类型:</span><br><span class="hljs-comment"># SEND_ERROR，产生错误，生成过程被跳过。</span><br><span class="hljs-comment"># SATUS，输出前缀为—的信息。</span><br><span class="hljs-comment"># FATAL_ERROR，立即终止所有 cmake 过程.</span><br><br><span class="hljs-keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br><span class="hljs-comment"># 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可。</span><br><span class="hljs-comment"># 比如我们用到的是 SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：</span><br><span class="hljs-comment"># SET(SRC_LIST main.c t1.c t2.c)。</span><br><br><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span> 指令<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])<br><span class="hljs-comment"># 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除，比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你也可以通过定义依赖来解决此类问题)。在主CMakeLists中使用。</span><br><br><br>通过 <span class="hljs-keyword">SET</span> 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量<br>来指定最终的目标二进制的位置(指最终生成的 hello 或者最终的共享库，不包含编译生成<br>的中间文件)<br><br><span class="hljs-keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)<br><br><span class="hljs-keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)<br><br>&lt;projectname&gt;_BINARY_DIR 和 PROJECT_BINARY_DIR 变量，他们指的编译发生的当前目录，如果是内部编译，就相当于 PROJECT_SOURCE_DIR 也就是<br>工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的build目录。<br><br><span class="hljs-comment"># INSTALL函数，其中大写字母都是固定的，我们只需要更改小写字母的。</span><br><br><span class="hljs-comment"># 安装目标文件</span><br><span class="hljs-keyword">INSTALL</span>(TARGETS myrun mylib mystaticlib<br>RUNTIME DESTINATION bin<br>LIBRARY DESTINATION lib<br>ARCHIVE DESTINATION libstatic<br>)<br>上面的例子会将：<br>可执行二进制 myrun 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/bin 目录<br>动态库 libmylib 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/lib 目录<br>静态库 libmystaticlib 安装到<span class="hljs-variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/libstatic 目录<br><br><span class="hljs-comment"># 安装普通文件</span><br><span class="hljs-keyword">INSTALL</span>(FILES files... DESTINATION &lt;dir&gt;<br> [PERMISSIONS permissions...]  <span class="hljs-comment"># 权限</span><br> [CONFIGURATIONS [Debug|Release|...]]<br> [COMPONENT &lt;component&gt;]<br> [RENAME &lt;name&gt;] [OPTIONAL])<br><span class="hljs-comment"># 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限 PERMISSIONS，安装后的权限为：OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限。</span><br><br><br><span class="hljs-comment"># 安装非目标文件的可执行文件（脚本等等）</span><br><span class="hljs-keyword">INSTALL</span>(PROGRAMS files... DESTINATION &lt;dir&gt;<br> [PERMISSIONS permissions...]<br> [CONFIGURATIONS [Debug|Release|...]]<br> [COMPONENT &lt;component&gt;]<br> [RENAME &lt;name&gt;] [OPTIONAL])<br><span class="hljs-comment"># 跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:</span><br><span class="hljs-comment"># OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限</span><br><br><span class="hljs-comment"># 安装函数的注意点：</span><br><span class="hljs-comment"># 1. 如果没有cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr .. 也就是说没有指定CMAKE_INSTALL_PREFIX，则默认路径是/usr/local</span><br><span class="hljs-comment"># 2. 在安装目录（属于上述的普通文件）时 如果是 x/ 则是安装x目录下的文件，不包括x；如果是 x 则是包括了x。</span><br><br><span class="hljs-comment">#生成一个动态库或者是静态库，也可以使用</span><br><span class="hljs-keyword">ADD_LIBRARY</span><br> <span class="hljs-keyword">ADD_LIBRARY</span>(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br></code></pre></td></tr></table></figure>

<div class="note note-warning">
            <p>在Cmake中使用变量的值的一般方法是<code>%{}</code>，但是在<code>if</code>语句中使用变量只需直接使用变量名即可，无需使用<code>%{}</code></p>
          </div>

<h2 id="语法规则小总结"><a href="#语法规则小总结" class="headerlink" title="语法规则小总结"></a>语法规则小总结</h2><p>最简单的语法规则是：</p>
<ol>
<li>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</li>
<li>指令(参数 1 参数 2…)</li>
</ol>
<p><strong>参数使用括弧括起，参数之间使用空格或分号分开。</strong></p>
<p>以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成：</p>
<p>ADD_EXECUTABLE(hello main.c func.c)或者</p>
<p>ADD_EXECUTABLE(hello main.c;func.c)</p>
<ol start="3">
<li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令。</li>
</ol>
<div class="note note-warning">
            <p>需要注意的是Cmake的语法是比较灵活的，比如说：在包含文件名的时候可以使用””将文件名包裹，但是不使用也是可以的，但如果文件名中有空格的话就必须使用””。同时在函数中分隔参数可以使用空格分隔，也可以使用,分隔。注意这里不是所有的参数都是用,分隔。而是同类型的参数之间，比如说文件名之间。</p>
          </div>

<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Cmake"><span class="hljs-comment"># 将规则写在CMakeList.txt文件中，需要注意大小写。</span><br><br>mkdir build <br><span class="hljs-comment"># 创建一个build文件夹，将Cmake生成的文件放在此文件下</span><br>cd ./build<br><span class="hljs-comment"># 切换到build文件夹下</span><br>cmake ..<br><span class="hljs-comment"># 生成Makefile等文件</span><br>make<br><span class="hljs-comment"># 执行make程序，你可以用 cmake --build . 替换 make 这一行。</span><br><br><span class="hljs-comment"># 上面的步骤也可以使用一下两条命令替代</span><br>cmake -S . -B build<br>cmake --build build<br><br><span class="hljs-comment"># 一下的任意一条指令都可以完成安装</span><br><span class="hljs-comment"># From the build directory (pick one)</span><br>make <span class="hljs-keyword">install</span><br>cmake --build . --<span class="hljs-keyword">target</span> <span class="hljs-keyword">install</span><br>cmake --<span class="hljs-keyword">install</span> . <span class="hljs-comment"># CMake 3.15+ only</span><br><span class="hljs-comment"># From the source directory (pick one)</span><br>make -C build <span class="hljs-keyword">install</span><br>cmake --build build --<span class="hljs-keyword">target</span> <span class="hljs-keyword">install</span><br>cmake --<span class="hljs-keyword">install</span> build <span class="hljs-comment"># CMake 3.15+ only</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="构建动态库和静态库"><a href="#构建动态库和静态库" class="headerlink" title="构建动态库和静态库"></a>构建动态库和静态库</h1><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>我们知道可以直接使用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -fPLC -share -o libtest.so 1.c 2.c 3.c或者是：<br><br>gcc -fPIC -c func.c -o func.o<br>gcc -shared func.o -o libfunc.so<br></code></pre></td></tr></table></figure>
<p><code>Cmake</code>方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先创建一个新的文件夹t3，t3中mkdir lib 。在t3目录中touch CMakeLists.txt中添加：</span><br>ROJECT(HELLOLIB) <span class="hljs-comment">#创建一个新的项目</span><br>ADD_SUBDIRECTORY(lib) <span class="hljs-comment">#引入lib子目录</span><br><br><span class="hljs-comment">#在lib中vim CMakeLists.txt添加:</span><br>SET(LIBHELLO hello.c)<br>ADD_LIBRARY(hello SHARED <span class="hljs-variable">$&#123;LIBHELLO&#125;</span>)<br><br><span class="hljs-comment">#使用外部编译，mkdir Build cd BUild </span><br><br>此时可以在lib中找到HELLOLIB.so<br><br><span class="hljs-comment">#如果你要指定 libhello.so 生成的位置，可以通过在主工程文件 CMakeLists.txt 中修改 ADD_SUBDIRECTORY(lib)指令来指定一个编译输出位置或者在 lib/CMakeLists.txt 中添加SET(LIBRARY_OUTPUT_PATH &lt;路径&gt;)来指定一个新的位置。</span><br><span class="hljs-comment">#这两者的区别我们上一节已经提到了，所以，这里不再赘述，下面，我们解释一下一个新的指令 </span><br><br>ADD_LIBRARY<br> ADD_LIBRARY(libname [SHARED|STATIC|MODULE]<br> [EXCLUDE_FROM_ALL]<br> source1 source2 ... sourceN)<br><span class="hljs-comment">#你不需要写全 libhello.so，只需要填写 hello 即可，cmake 系统会自动为你生成libhello.X</span><br><br><span class="hljs-comment">#设置共享库的版本号：</span><br>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)<br>VERSION 指代动态库版本，SOVERSION 指代 API 版本。<br><br>将上述指令加入 lib/CMakeLists.txt 中，重新构建看看结果。<br>在 build/lib 目录会生成：<br>libhello.so.1.2<br>libhello.so.1-&gt;libhello.so.1.2<br>libhello.so -&gt;libhello.so.1<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h2><p>我们知道可以直接使用<code>gcc</code>命令制作静态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">		gcc -c 1.c 2.c <br>		ar rsc test.a ./1.o ./2.o<br>		<br>		ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。<br>		<br>		对参数的说明：<br>		<br>		参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。<br>		参数 c 表示创建一个库。不管库否存在，都将创建。<br>		参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。<br>		<br>不管是静态库或者是动态库都是由.o文件构成的。<br></code></pre></td></tr></table></figure>

<p>但是当有很多源文件的时候，我们在使用这种方法就很不方便了。于是<code>cmake</code>支持创建静态库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用到的指令：</span><br>使用指令和制作动态库是一致的，只是需要将动态参数换成静态参数。唯一需要注意的是两种库的同名问题，如果我们使用函数ADD_LIBRARY(hello STATIC <span class="hljs-variable">$&#123;LIBHELLO_SRC&#125;</span>)来构建动态库，会造成一个同名的报错（因为函数的target是唯一的）。解决方法有将某一个库的名字改成另一个。如果要求两种库同名的话可以使用函数：<br><br>SET_TARGET_PROPERTIES，其基本语法是：<br> SET_TARGET_PROPERTIES(target1 target2 ...<br> PROPERTIES prop1 value1<br> prop2 value2 ...)<br><br><span class="hljs-comment">#这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。</span><br><br>在本例中，我们需要作的是向 lib/CMakeLists.txt 中添加一条：<br>SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)这样，我们就可以同时得到 libhello.so/libhello.a 两个库了。<br><br>与他对应的指令是：<br>GET_TARGET_PROPERTY(VAR target property)<br>具体用法如下例，我们向 lib/CMakeListst.txt 中添加：<br>GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)<br>MESSAGE(STATUS “This is the hello_static<br>OUTPUT_NAME:”<span class="hljs-variable">$&#123;OUTPUT_VALUE&#125;</span>)<br>如果没有这个属性定义，则返回 NOTFOUND.<br><br></code></pre></td></tr></table></figure>

<h2 id="使用动态库-静态库"><a href="#使用动态库-静态库" class="headerlink" title="使用动态库&amp;静态库"></a>使用动态库&amp;静态库</h2><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#表示注释   </span><br><span class="hljs-comment">#cmake file for project association</span><br><br><span class="hljs-comment">#cmake 最低版本要求，低于2.8 构建过程会被终止。   </span><br><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">2.8</span>)<br><br><span class="hljs-comment">#定义工程名称</span><br><span class="hljs-keyword">PROJECT</span>(association)<br>                     <br><span class="hljs-comment">#打印相关消息消息   </span><br><span class="hljs-comment">#MESSAGE(STATUS &quot;Project: $&#123;PROJECT_NAME&#125;&quot;)</span><br><span class="hljs-comment">#MESSAGE(STATUS &quot;Project Directory: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)  </span><br><br><span class="hljs-comment">#指定编译类型debug版</span><br><span class="hljs-keyword">SET</span>(CMAKE_BUILE_TYPE DEBUG)<br><span class="hljs-comment">#发行版</span><br><span class="hljs-comment">#SET(CMAKE_BUILE_TYPE RELEASE)</span><br><br><span class="hljs-comment">#SET(CMAKE_C_FLAGS_DEBUG &quot;-g -Wall&quot;)          #C</span><br><span class="hljs-comment">#SET(CMAKE_CXX_FLAGS_DEBUG &quot;-g -Wall&quot;)           #C++</span><br><br><span class="hljs-comment">#设置C++ 编译</span><br><span class="hljs-keyword">SET</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -s -Wall -W -O3&quot;</span>)   <br> <br><span class="hljs-comment">#添加子目录   </span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment">#设置变量，表示所有的源文件  </span><br><span class="hljs-keyword">SET</span>(SOURCE_FILES<br>    src/main.cpp    <br>    )<br><br><br><span class="hljs-comment">#配置相关库文件的目录，  </span><br><span class="hljs-keyword">LINK_DIRECTORIES</span>(                                  <br>    /usr/local/lib<br>    )  <br><br><span class="hljs-comment">#找BZip2</span><br><span class="hljs-keyword">FIND_PACKAGE</span>(BZip2)<br><span class="hljs-keyword">if</span> (BZIP2_FOUND)<br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;$&#123;BZIP_INCLUDE_DIRS&#125;&quot;</span>)  <br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot; $&#123;BZIP2_LIBRARIES&#125;&quot;</span>)  <br><span class="hljs-keyword">endif</span> (BZIP2_FOUND)<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> BZIP2_FOUND)<br>    <span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;NOT  BZIP2_FOUND&quot;</span>)  <br><span class="hljs-keyword">endif</span> (<span class="hljs-keyword">NOT</span>  BZIP2_FOUND)<br><br><br><span class="hljs-comment">#相关头文件的目录</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(  <br>     /usr/local/<span class="hljs-keyword">include</span>  <br>     <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/utility_inc<br>     <span class="hljs-variable">$&#123;BZIP_INCLUDE_DIRS&#125;</span><br>    )<br><br><span class="hljs-comment">#链接库</span><br><span class="hljs-keyword">LINK_LIBRARIES</span>(<br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/static_libs/libSentinelKeys64.a<br>    <span class="hljs-variable">$&#123;BZIP2_LIBRARIES&#125;</span><br>    )<br><br><span class="hljs-comment">#生成可执行文件</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SOURCE_FILES&#125;</span>)<br><br><span class="hljs-comment">#依赖的库文件  </span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> eventloop)<br></code></pre></td></tr></table></figure>




<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><p><strong>注意，Cmake本身就制定了一些变量，这里变量都是大写的。</strong></p>
<p><a target="_blank" rel="noopener" href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/chapters/basics/variables.html#fn_1">https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/chapters/basics/variables.html#fn_1</a></p>
<p>小总结：</p>
<ol>
<li>CMake具有作用域的概念</li>
</ol>
<h2 id="内部编译和外部编译"><a href="#内部编译和外部编译" class="headerlink" title="内部编译和外部编译"></a>内部编译和外部编译</h2><p>这两者的区别就是，内部编译是在源文件目录中直接<code>make</code>，而外部编译是在其他目录中（一般是Build）目录下 <code>Cmake</code>的。这两者的主要区别就是在内部编译中，编译所生成的中间文件都会留在源文件中，而外部编译不会。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CMake中的安装需要使用一个函数：<code>INSTALL</code>。安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。这个函数一般和<code>CMAKE_INSTALL_PREFIX</code>变量一起使用。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">GNU Make</a>用于控制如何从程序的源代码文件编译并链接为可执行文件，通过<code>make</code>命令从名称为<code>makefile</code>的文件中获取构建信息，该文件定义了一系列规则来指定源文件的编译先后顺序、是否需要重新编译、甚至于进行更为复杂的操作。通过<code>makefile</code>文件可以方便的实现工程的自动化编译，只需要执行<code>make</code>命令即可完成编译动作，从而极大的提高了开发人员的工作效率。</p>
<p><a target="_blank" rel="noopener" href="http://www.uinio.com/Linux/CMake/logo.png"><img src="http://www.uinio.com/Linux/CMake/logo.png" srcset="/img/loading.gif" lazyload></a></p>
<p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/v3.17/">CMake 3.17</a>是一款源代码构建管理工具，最初作为各种 <strong>Makefile</strong> 方言的生成器，后来逐步发展为现代化的构建系统，广泛用于 C 和 C++ 工程源代码的构建。官方提供的<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">《CMake Tutorial》</a> 为开发人员提供了一个循序渐进的指南，涵盖了 CMake 构建过程中常见问题的解决方案。如果需要构建从第三方发布的源代码包，则可以参考<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/v3.17/guide/user-interaction/index.html">《User Interaction Guide》</a>。而<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/v3.17/guide/using-dependencies/index.html#guide:Using%20Dependencies%20Guide">《Using Dependencies Guide》</a>则主要针对需要使用第三方库的开发人员。</p>
<h2 id="GNU-Make"><a href="#GNU-Make" class="headerlink" title="GNU Make"></a>GNU Make</h2><p><code>make</code>是一款用于解释<code>makefile</code>文件当中命令的工具，而<code>makefile</code>关系到整个工程的编译规则。许多 IDE 集成开发环境都整合了该命令，例如：Visual C++ 里的<strong>nmake</strong>，Linux 里的 <strong>GNU make</strong>，本章节主要讲解 <strong>GNU make</strong> 相关的内容。开始进一步讲解之前，需要先了解一下 C&#x2F;C++ 源代码的编译过程，具体内容可参见笔者的<a target="_blank" rel="noopener" href="http://www.uinio.com/Linux/GCC.html#%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4">《基于 Linux 的 GCC 与 GDB 应用调试》 - 编译步骤</a>一文：</p>
<p><a target="_blank" rel="noopener" href="http://www.uinio.com/Linux/CMake/GNU-Make/0.png"><img src="http://www.uinio.com/Linux/CMake/GNU-Make/0.png" srcset="/img/loading.gif" lazyload></a></p>
<ol>
<li><strong>预处理 Preprocessing</strong>：解析各种预处理命令，包括头文件包含、宏定义的扩展、条件编译的选择等；</li>
<li><strong>编译 Compiling</strong>：对预处理之后的源文件进行翻译转换，产生由机器语言描述的汇编文件；</li>
<li><strong>汇编 Assembly</strong>：将汇编代码转译成为机器码；</li>
<li><strong>链接 Link</strong>：将机器码中的各种符号引用与定义转换为可执行文件内的相应信息（例如虚拟地址）；</li>
</ol>
<h3 id="makefile-文件"><a href="#makefile-文件" class="headerlink" title="makefile 文件"></a>makefile 文件</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>执行<code>make</code>命令时，实际会解析当前目录下的<code>makefile</code>文件，该文件用于告知<code>make</code>命令如何对源代码进行编译与链接，一个 makefile 的基本编写规则如下所示：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span>target ... : prerequisites ...</span><br><span>    command</span><br><span>    ...</span><br><span>    ...</span><br></pre></td></tr></tbody></table>

<ul>
<li><code>target</code>：即可以是 1 个目标文件，也可以是 1 个执行文件，甚至还可以是 1 个标签；</li>
<li><code>prerequisites</code>：生成该<code>target</code> 所依赖的文件或者其它<code>target</code>；</li>
<li><code>command</code>：该<code>target</code>所要执行的 Shell 命令，需要保持 1 个【Tab】的缩进；</li>
</ul>
<p>上述的基本编写规则最终会形成一套依赖关系，其中**<code>target</code>依赖于<code>prerequisites</code>，而生成规则定义在<code>command</code>；如果<code>prerequisites</code>中的文件比<code>target</code>上的文件要新，则<code>command</code>所定义的命令就会被执行**。</p>
<p>观察下面的例子，其中的反斜杠<code>\</code>表示换行，将其保存为一个<code>makefile</code>或者<code>Makefile</code>文件，然后在当前目录执行<code>make</code>命令，就可以生成可执行文件<code>app</code>。如果需要删除可执行文件以及中间生成的目标文件，则执行<code>make clean</code>命令即可。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></pre></td><td><pre><span>app : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span>    gcc -o app main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>main.o : main.c defs.h</span><br><span>    gcc -c main.c</span><br><span>kbd.o : kbd.c defs.h command.h</span><br><span>    gcc -c kbd.c</span><br><span>command.o : command.c defs.h command.h</span><br><span>    gcc -c command.c</span><br><span>display.o : display.c defs.h buffer.h</span><br><span>    gcc -c display.c</span><br><span>insert.o : insert.c defs.h buffer.h</span><br><span>    gcc -c insert.c</span><br><span>search.o : search.c defs.h buffer.h</span><br><span>    gcc -c search.c</span><br><span>files.o : files.c defs.h buffer.h command.h</span><br><span>    gcc -c files.c</span><br><span>utils.o : utils.c defs.h</span><br><span>    gcc -c utils.c</span><br><span>clean :</span><br><span>    rm app main.o kbd.o command.o display.o \</span><br><span>       insert.o search.o files.o utils.o</span><br></pre></td></tr></tbody></table>

<p>输入<code>make</code>命令之后，就会开始执行上述的<code>makefile</code>文件，具体执行流程如下所示：</p>
<ol>
<li><code>make</code>会在当前目录下查找<code>Makefile</code>或者<code>makefile</code>文件；</li>
<li>找到后将当中定义的第 1 个<code>target</code>作为最终的目标文件；</li>
<li>如果<code>app</code>文件不存在，或者其依赖的<code>.o</code>文件修改时间要比<code>app</code>执行文件更新。那么，他就会执行<code>command</code>定义的命令来生成<code>app</code>文件；</li>
<li>如果<code>app</code>依赖的<code>.o</code>文件也不存在，那么查找<code>.o</code>文件对应的依赖规则生成<code>.o</code>文件；</li>
<li>最后，基于工程中<code>.c</code>和<code>.h</code>源文件生成<code>.o</code>依赖文件，然后再基于这些<code>.o</code>文件生成<code>app</code>执行文件；</li>
</ol>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>上面示例中<code>app</code>生成规则中的一系列<code>.o</code>文件反复出现，这里我们可以将其声明为一个变量：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span>main.o : main.c defs.h</span><br><span>    cc -c main.c</span><br><span>kbd.o : kbd.c defs.h command.h</span><br><span>    cc -c kbd.c</span><br><span>command.o : command.c defs.h command.h</span><br><span>    cc -c command.c</span><br><span>display.o : display.c defs.h buffer.h</span><br><span>    cc -c display.c</span><br><span>insert.o : insert.c defs.h buffer.h</span><br><span>    cc -c insert.c</span><br><span>search.o : search.c defs.h buffer.h</span><br><span>    cc -c search.c</span><br><span>files.o : files.c defs.h buffer.h command.h</span><br><span>    cc -c files.c</span><br><span>utils.o : utils.c defs.h</span><br><span>    cc -c utils.c</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table>

<h4 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h4><p>GNU Make 可以自动识别并推导目标与依赖关系之后的<code>command</code>命令，只要<code>make</code>发现 1 个<code>.o</code>文件，就会自动将对应的<code>.c</code>文件添加至依赖关系当中，同时也会将对应的<code>gcc -c</code>命令推导出来。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o \</span><br><span>    insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span></span><br><span>main.o : defs.h</span><br><span>kbd.o : defs.h command.h</span><br><span>command.o : defs.h command.h</span><br><span>display.o : defs.h buffer.h</span><br><span>insert.o : defs.h buffer.h</span><br><span>search.o : defs.h buffer.h</span><br><span>files.o : defs.h buffer.h command.h</span><br><span>utils.o : defs.h</span><br><span></span><br><span>.PHONY : clean</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table>

<p>这种方法被称为<code>make</code>的<strong>隐含规则</strong>，上述代码中<code>.PHONY</code>表示<code>clean</code>是一个<strong>伪目标文件</strong>，关于隐晦规则和伪目标文件的内容后续将会进行更为详细的介绍。</p>
<p>通过<strong>隐含规则</strong>可以进一步简化上面的<code>makefile</code>，这样虽然可以最大幅度减少代码，但是文件的依赖关系显得较为凌乱，所以这种风格较少被采用。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></pre></td><td><pre><span>objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span></span><br><span>app : <span>$(objects)</span></span><br><span>    cc -o app <span>$(objects)</span></span><br><span></span><br><span><span>$(objects)</span> : defs.h</span><br><span>kbd.o command.o files.o : command.h</span><br><span>display.o insert.o search.o files.o : buffer.h</span><br><span></span><br><span>.PHONY : clean</span><br><span>clean :</span><br><span>    rm app <span>$(objects)</span></span><br></pre></td></tr></tbody></table>

<h4 id="清理中间文件"><a href="#清理中间文件" class="headerlink" title="清理中间文件"></a>清理中间文件</h4><p>习惯上，每个<code>makefile</code>文件都应该编写一个用于清理中间文件的规则，这样不仅便于重新编译，也有利于保持工程的整洁。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br></pre></td><td><pre><span><span>clean:</span></span><br><span>    rm edit <span>$(objects)</span></span><br></pre></td></tr></tbody></table>

<p>之前代码采用了上面较为简单粗暴的方式，但是更为稳健的方法是采用下面这样的风格：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>.PHONY : clean</span><br><span>clean :</span><br><span>    -rm edit <span>$(objects)</span></span><br></pre></td></tr></tbody></table>

<p><code>.PHONY</code>关键字用于表标识<code>clean</code>是一个<strong>伪目标</strong>，<code>rm</code>命令前的小减号<code>-</code>表示忽略操作出现问题的文件，习惯上会将<code>clean</code>放置在<code>makefile</code>的最后。</p>
<h4 id="Makefile-组成"><a href="#Makefile-组成" class="headerlink" title="Makefile 组成"></a>Makefile 组成</h4><p>Makefile 文件主要包含<strong>显式规则</strong>、<strong>隐式规则</strong>、<strong>变量定义</strong>、<strong>文件指示</strong>、<strong>注释</strong>。</p>
<ul>
<li><strong>显式规则</strong>：由<code>Makefile</code>编写者明确指定，用于描述如何生成<code>target</code>；</li>
<li><strong>隐式规则</strong>：利用<code>make</code>命令的自动推导功能，简略书写<code>Makefile</code>；</li>
<li><strong>变量的定义</strong>：通常为字符串，当<code>Makefile</code>被执行时，其中的变量会扩散到相应的引用位置；</li>
<li><strong>文件指示</strong>：在<code>Makefile</code>当中引用另外的<code>Makefile</code>，类似于 C 语言里的<code>#include</code>。或者根据条件指定<code>Makefile</code>的有效部分，类似于 C 语言中的<code>#if</code>。除此之外，还可以用于定义一条拥有多行的命令；</li>
<li><strong>注释</strong>：注释采用<code>#</code>字符，需要时可以采用反斜杠进行转义<code>\#</code>；</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<code>Makefile</code>中的命令<code>command</code>必须以【Tab】键开始。</p>
</blockquote>
<h4 id="引用其它-Makefile"><a href="#引用其它-Makefile" class="headerlink" title="引用其它 Makefile"></a>引用其它 Makefile</h4><p>使用<code>include</code>关键字可以将其它<code>Makefile</code>包含进来，类似于 C 语言中的<code>#include</code>预处理语句，被包含的文件会自动替换至包含位置。</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>include &lt;filename&gt;</span><br></pre></td></tr></tbody></table>

<p><code>filename</code>可以是当前操作系统 Shell 命令或者文件（可以包含路径和通配符），<code>include</code>关键字之前可以存在空字符，但是绝不允许出现【Tab】键。</p>
<p>例如：存在 4 个 Makefile<code>a.mk</code>、<code>b.mk</code>、<code>c.mk</code>、<code>foo.make</code>以及 1 个变量<code>$(bar)</code>（包含<code>e.mk</code>和<code>f.mk</code>） ，那么下面 2 条语句就是等价的：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>include</span> foo.make *.mk <span>$(bar)</span></span><br><span>                ⇓</span><br><span><span>include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></tbody></table>

<p><code>make</code>命令开始执行时，会查找<code>include</code>的其它<code>Makefile</code>，如果没有指定绝对或者相对路径的话，<code>make</code>会首先在当前目录下查找，如果没有查询到则会进入如下目录：</p>
<ul>
<li>如果<code>make</code>命令执行时，带有<code>-I</code>或者<code>--include-dir</code>参数，那么<code>make</code>就会在该参数指定的目录下查找；</li>
<li>此外，<code>make</code>还会去查找<code>&lt;prefix&gt;/include</code>目录（通常为<code>/usr/local/bin</code>或者<code>/usr/include</code>）；</li>
</ul>
<p>最后，如果文件未能找到，<code>make</code>将会生成警告信息，然后继续载入其它文件，一旦<code>makefile</code>读取完成，<code>make</code>会再次进行查询，如果依然未能找到，则报出一条致命错误信息。如果想让<code>make</code>忽略读取错误，则可以在<code>include</code>前添加减号<code>-</code>。</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>-include</span> &lt;filename&gt;</span><br></pre></td></tr></tbody></table>

<blockquote>
<p><strong>注意</strong>：其它版本<code>make</code>采用的兼容命令是<code>sinclude</code>，其作用与<code>-include</code>相同。</p>
</blockquote>
<p>这里，重新再来总结一下 GNU Make 的工作步骤：</p>
<ol>
<li>读取所有<code>Makefile</code>文件；</li>
<li>查找被<code>include</code>的其它<code>Makefile</code>；</li>
<li>初始化<code>Makefile</code>文件当中定义的变量；</li>
<li>分析并且推导隐式规则；</li>
<li>创建<code>target</code>目标文件的依赖关系；</li>
<li>根据依赖关系，决定哪些<code>target</code>需要重新生成；</li>
</ol>
<h4 id="MAKEFILES-环境变量"><a href="#MAKEFILES-环境变量" class="headerlink" title="MAKEFILES 环境变量"></a>MAKEFILES 环境变量</h4><p>如果当前定义了<code>MAKEFILES</code>环境变量，其值为采用<strong>空格</strong>分隔的其它<code>Makefile</code>，执行<code>make</code>时会将这个该环境变量的值<code>include</code>进来。但是与<code>include</code>所不同的是，该环境变量引入的<code>Makefile</code>的<code>target</code>不会生效，其定义的文件如果发现错误，<code>make</code>也会不理会。</p>
<p>日常开发环境，不建议使用<code>MAKEFILES</code>环境变量，因为定义后会影响到所有<code>make</code>命令的执行。反而是在<code>makefile</code>文件出现一些莫名其妙错误的时候，需要检查当前是否定义了这个环境变量。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><strong>规则</strong>描述了<code>Makefile</code>文件的依赖关系以及如何生成目标文件。定义在 Makefile 中的<code>target</code>可以有很多，但是第 1 条规则中的<code>target</code>会被确立为最终的目标。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td><td><pre><span></span><br><span>targets : prerequisites</span><br><span>    command</span><br><span>    ...</span><br><span></span><br><span></span><br><span>targets : prerequisites ; command</span><br><span>    command</span><br><span>    ...</span><br></pre></td></tr></tbody></table>

<ul>
<li><code>targets</code>：<strong>目标文件名称</strong>，以空格分隔，可以使用通配符；</li>
<li><code>prerequisites</code>：<strong>目标文件的依赖</strong>，如果某个依赖文件比目标文件要新，那么就会重新进行生成；</li>
<li><code>command</code>：<strong>Shell 命令行</strong>，如果不与<code>target : prerequisites</code>在一行，那么必须以【Tab】开头；如果保持在一行，则可以采用分号<code>;</code>进行分隔；</li>
</ul>
<blockquote>
<p><strong>注意</strong>：如果<code>prerequisites</code>和<code>command</code>过长，可以使用反斜杠<code>\</code>进行换行。通常<code>make</code>会以 Bash Shell 也就是<code>/bin/sh</code>来执行命令。</p>
</blockquote>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p><code>make</code>支持<code>*</code>、<code>?</code>、<code>~</code>三个通配符。<code>~</code>字符在 Linux 下表示当前用户的<code>$HOME</code>目录，在 Windows 下则根据环境变量<code>HOME</code>设置而定。</p>
<p>通配符可以应用在<code>command</code>当中，下面代码会在清除所有<code>.o</code>文件之前，查看一下<code>main.c</code>文件。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>clean:</span></span><br><span>    cat main.c</span><br><span>    rm -f *.o</span><br></pre></td></tr></tbody></table>

<p>通配符还可以应用于<code>prerequisites</code>，下面代码中的<code>print</code>目标依赖于所有<code>.c</code>文件，其中的<code>$?</code>是后续将会讲到的<strong>自动化变量</strong>。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>print: *.c</span></span><br><span>    lpr -p <span>$?</span></span><br><span>    touch print</span><br></pre></td></tr></tbody></table>

<p>通配符同样可以应用在变量中，但是并不会因此而自动展开，下面代码里变量<code>objects</code>的值就是<code>*.o</code>。</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>objects = *.o</span><br></pre></td></tr></tbody></table>

<p>如果需要让通配符在变量当中展开，即让<code>objects</code>的值是所有<code>.o</code>文件名的集合。</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span>objects := <span>$(<span>wildcard</span> *.o)</span></span><br></pre></td></tr></tbody></table>

<hr>
<h2 id="Autoconf"><a href="#Autoconf" class="headerlink" title="Autoconf"></a>Autoconf</h2><p><a target="_blank" rel="noopener" href="http://www.gnu.org/software/autoconf/">autoconf</a></p>
<h2 id="Automake"><a href="#Automake" class="headerlink" title="Automake"></a>Automake</h2><p><a target="_blank" rel="noopener" href="http://www.gnu.org/software/automake/">automake</a></p>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake 教程提供了一个循序渐进的指南，涵盖了常见的构建系统问题。本文涉及的示例代码可以在 <a target="_blank" rel="noopener" href="https://cmake.org/download/">CMake 源码树</a>的<code>Help/guide/tutorial</code>目录下找到，每个步骤都拥有其相应的子目录，循序渐进直至提供完整的解决方案。</p>
<h3 id="基本出发点"><a href="#基本出发点" class="headerlink" title="基本出发点"></a>基本出发点</h3><p>最为基础的项目是从源代码构建可执行文件，这样只需要一个 3 行的<code>CMakeLists.txt</code>文件，这将是整个教程的起点。在【Step1】目录当中创建如下<code>CMakeLists.txt</code>文件：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span></span><br><span><span>project</span>(Tutorial)</span><br><span></span><br><span></span><br><span><span>add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></tbody></table>

<p>CMake 支持<strong>大写</strong>、<strong>小写</strong>、<strong>混合大小写</strong>的命令，上面的<code>CMakeLists.txt</code>文件使用了小写命令。教程源代码<code>Step1</code>目录中提供了用于执行数字平方根计算的<code>cxx</code>文件。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></pre></td><td><pre><span></span><br><span><span>#<span>include</span> <span>&lt;cmath&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;cstdlib&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;iostream&gt;</span></span></span><br><span><span>#<span>include</span> <span>&lt;string&gt;</span></span></span><br><span></span><br><span><span><span>int</span> <span>main</span><span>(<span>int</span> argc, <span>char</span>* argv[])</span> </span>{</span><br><span>  <span>if</span> (argc &lt; <span>2</span>) {</span><br><span>    std::cout &lt;&lt; <span>"Usage: "</span> &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" number"</span> &lt;&lt; std::endl;</span><br><span>    <span>return</span> <span>1</span>;</span><br><span>  }</span><br><span></span><br><span>  <span>const</span> <span>double</span> inputValue = <span>atof</span>(argv[<span>1</span>]);       </span><br><span>  <span>const</span> <span>double</span> outputValue = <span>sqrt</span>(inputValue);   </span><br><span>  std::cout &lt;&lt; <span>"The square root of "</span> &lt;&lt; inputValue &lt;&lt; <span>" is "</span> &lt;&lt; outputValue</span><br><span>            &lt;&lt; std::endl;</span><br><span>  <span>return</span> <span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table>

<h4 id="添加版本号和配置头文件"><a href="#添加版本号和配置头文件" class="headerlink" title="添加版本号和配置头文件"></a>添加版本号和配置头文件</h4><p>我们要添加的第一个特性是为项目提供 1 个版本号。虽然源代码中也可以完成这件事，但是使用<code>CMakeLists.txt</code>可以提供更好的灵活性。首先，修改<code>CMakeLists.txt</code>文件，使用<code>project()</code>命令设置项目名称和版本号。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span></span><br><span><span>project</span>(Tutorial VERSION <span>1.0</span>)</span><br></pre></td></tr></tbody></table>

<p>然后，继续编写配置，把一个头文件上保存的版本号传递到源代码：</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></tbody></table>

<p>由于配置文件将会被写入到二叉树，所以必须将该目录添加至搜索包含文件的路径列表当中，在<code>CMakeLists.txt</code>文件的末尾添加以下行：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>target_include_directories</span>(Tutorial PUBLIC</span><br><span>                           <span>"${PROJECT_BINARY_DIR}"</span></span><br><span>                          )</span><br></pre></td></tr></tbody></table>

<p>在当前目录下创建<code>TutorialConfig.h</code>文件，并且包含如下内容：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>/* 配置主、副版本号 */</span><br><span></span><br><span></span><br></pre></td></tr></tbody></table>

<p>当 CMake 配置该头文件以后，上述的<code>@Tutorial_VERSION_MAJOR@</code>和<code>@Tutorial_VERSION_MINOR@</code>的值将会被替换。</p>
<p>接下来修改<code>tutorial.cxx</code>来包含上面的<code>TutorialConfig.h</code>头文件，并最终通过修改后的<code>tutorial.cxx</code>打印版本号。</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td><td><pre><span><span>#<span>include</span> <span>"TutorialConfig.h"</span></span></span><br><span></span><br><span><span>if</span> (argc &lt; <span>2</span>) {</span><br><span>   </span><br><span>   std::cout &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" Version "</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span>"."</span></span><br><span>             &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span>   std::cout &lt;&lt; <span>"Usage: "</span> &lt;&lt; argv[<span>0</span>] &lt;&lt; <span>" number"</span> &lt;&lt; std::endl;</span><br><span>   <span>return</span> <span>1</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table>

<h4 id="指定-C-标准"><a href="#指定-C-标准" class="headerlink" title="指定 C++ 标准"></a>指定 C++ 标准</h4><p>接下来，将<code>tutorial.cxx</code>文件中的<code>atof</code>替换为<code>std::stod</code>，从而为项目添加一些 C++11 特性。同时，删除<code>#include &lt;cstdlib&gt;</code>。</p>
<table><tbody><tr><td><pre><span>1</span><br></pre></td><td><pre><span><span>const</span> <span>double</span> inputValue = std::<span>stod</span>(argv[<span>1</span>]);</span><br></pre></td></tr></tbody></table>

<p>CMake 中启用特定 C++ 标准支持的最简单方法是使用<code>CMAKE_CXX_STANDARD</code>变量，这里将<code>CMakeLists.txt</code>文件里的<code>CMAKE_CXX_STANDARD</code>变量设置为<code>11</code>，并将<code>CMAKE_CXX_STANDARD_REQUIRED</code>设置为<code>True</code>：</p>
<table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></pre></td><td><pre><span><span>cmake_minimum_required</span>(VERSION <span>3.10</span>)</span><br><span></span><br><span># 设置项目名称与版本</span><br><span><span>project</span>(Tutorial VERSION <span>1.0</span>)</span><br><span></span><br><span># 指定 C++ 标准</span><br><span><span>set</span>(CMAKE_CXX_STANDARD <span>11</span>)</span><br><span><span>set</span>(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></tbody></table>

<h4 id="编译与测试"><a href="#编译与测试" class="headerlink" title="编译与测试"></a>编译与测试</h4><p>从命令行导航到 CMake 源代码树的 Help&#x2F;guide&#x2F;tutorial 目录，并运行以下命令:</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/README_GitBook.html">中文翻译教程</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/shendeguize/CMakeTutorialCN">中文教程</a></p>
<p><a target="_blank" rel="noopener" href="http://file.ncnynl.com/ros/CMake%20Practice.pdf">http://file.ncnynl.com/ros/CMake%20Practice.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">官方教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.arg.pub/2022/05/13/cmake/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1CMake%E3%80%8C%E4%B8%80%E3%80%81%E8%B5%B7%E6%AD%A5%E3%80%8D/">优秀博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.worldhello.net/2010/04/07/954.html">自动生成Makefile</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cmake/CMake-primer/?highlight=cmake">Cmake保姆级教程上</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cmake/CMake-advanced/?spm=a2c6h.12873639.article-detail.8.55bf57adxN9G4M">Cmake保姆级教程上</a></p>
<p><a target="_blank" rel="noopener" href="https://www.owalle.com/2023/02/16/autotools-cmake/">Autotool和Cmake对比</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/shendeguize/CMakeTutorialCN">Github上的个人教程</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9D%82%E9%A1%B9/" class="category-chain-item">杂项</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/" class="print-no-link">#原创</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Cmake总结</div>
      <div>https://ysc2.github.io/ysc2.github.io/2023/12/06/Cmake总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ysc</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93-CRT/" title="运行时库(CRT)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">运行时库(CRT)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/05/Linux%E4%B8%AD%E7%9A%84autotools%E5%B7%A5%E5%85%B7%E9%9B%86/" title="Linux中的autotools工具集">
                        <span class="hidden-mobile">Linux中的autotools工具集</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
